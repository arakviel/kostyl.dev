---
title: LINQ (Language Integrated Query)
description: –ü–æ–≤–Ω–∏–π –≥—ñ–¥ –ø–æ LINQ –≤ C# ‚Äî –≤—ñ–¥ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å—É –∑–∞–ø–∏—Ç—ñ–≤ –¥–æ –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–∏—Ö –æ–ø–µ—Ä–∞—Ç–æ—Ä—ñ–≤ —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ñ—ó, –ø—Ä–æ–µ–∫—Ü—ñ—ó, –≥—Ä—É–ø—É–≤–∞–Ω–Ω—è —Ç–∞ –∞–≥—Ä–µ–≥–∞—Ü—ñ—ó –¥–∞–Ω–∏—Ö.
---

# LINQ (Language Integrated Query)

## –í—Å—Ç—É–ø —Ç–∞ –ö–æ–Ω—Ç–µ–∫—Å—Ç

### –ü—Ä–æ–±–ª–µ–º–∞—Ç–∏–∫–∞: –Ü–º–ø–µ—Ä–∞—Ç–∏–≤–Ω–∏–π –ö–æ–¥ vs –î–µ–∫–ª–∞—Ä–∞—Ç–∏–≤–Ω—ñ –ó–∞–ø–∏—Ç–∏

–£—è–≤—ñ—Ç—å, —â–æ –≤–∏ —Ä–æ–∑—Ä–æ–±–ª—è—î—Ç–µ —Å–∏—Å—Ç–µ–º—É –∞–Ω–∞–ª—ñ—Ç–∏–∫–∏ –¥–ª—è —ñ–Ω—Ç–µ—Ä–Ω–µ—Ç-–º–∞–≥–∞–∑–∏–Ω—É. –ü–æ—Ç—Ä—ñ–±–Ω–æ –∑–Ω–∞–π—Ç–∏ –≤—Å—ñ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è –∑–∞ –æ—Å—Ç–∞–Ω–Ω—ñ–π –º—ñ—Å—è—Ü—å, –∑–≥—Ä—É–ø—É–≤–∞—Ç–∏ —ó—Ö –∑–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ—è–º–∏ —Ç–æ–≤–∞—Ä—ñ–≤, –≤—ñ–¥—Å–æ—Ä—Ç—É–≤–∞—Ç–∏ –∑–∞ –∑–∞–≥–∞–ª—å–Ω–æ—é —Å—É–º–æ—é —Ç–∞ –ø–æ—Ä–∞—Ö—É–≤–∞—Ç–∏ —Å–µ—Ä–µ–¥–Ω—ñ–π —á–µ–∫ –¥–ª—è –∫–æ–∂–Ω–æ—ó –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó.

**–¢—Ä–∞–¥–∏—Ü—ñ–π–Ω–∏–π —ñ–º–ø–µ—Ä–∞—Ç–∏–≤–Ω–∏–π –ø—ñ–¥—Ö—ñ–¥** –≤–∏–≥–ª—è–¥–∞—î —Ç–∞–∫:

```csharp {showLineNumbers}
class Order
{
    public DateTime Date { get; set; }
    public string Category { get; set; } = string.Empty;
    public decimal Amount { get; set; }
}

class CategoryStats
{
    public string Category { get; set; } = string.Empty;
    public decimal TotalAmount { get; set; }
    public decimal AverageCheck { get; set; }
    public int OrderCount { get; set; }
}

static List<Order> GetAllOrders()
{
    return
    [
        new Order { Date = DateTime.Now.AddDays(-5), Category = "Electronics", Amount = 299.99m },
        new Order { Date = DateTime.Now.AddDays(-10), Category = "Books", Amount = 45.50m },
        new Order { Date = DateTime.Now.AddDays(-2), Category = "Electronics", Amount = 1200m },
        new Order { Date = DateTime.Now.AddDays(-20), Category = "Clothing", Amount = 89.99m },
        new Order { Date = DateTime.Now.AddDays(-8), Category = "Books", Amount = 23.00m },
        new Order { Date = DateTime.Now.AddDays(-15), Category = "Electronics", Amount = 599.99m },
    ];
}

List<Order> allOrders = GetAllOrders();

// –ö—Ä–æ–∫ 1: –§—ñ–ª—å—Ç—Ä–∞—Ü—ñ—è –∑–∞ –æ—Å—Ç–∞–Ω–Ω—ñ–π –º—ñ—Å—è—Ü—å
List<Order> lastMonthOrders = new List<Order>();
DateTime oneMonthAgo = DateTime.Now.AddMonths(-1);

foreach (var order in allOrders)
{
    if (order.Date >= oneMonthAgo)
    {
        lastMonthOrders.Add(order);
    }
}

// –ö—Ä–æ–∫ 2: –ì—Ä—É–ø—É–≤–∞–Ω–Ω—è –∑–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ—è–º–∏
Dictionary<string, List<Order>> groupedByCategory = new Dictionary<string, List<Order>>();

foreach (var order in lastMonthOrders)
{
    if (!groupedByCategory.ContainsKey(order.Category))
    {
        groupedByCategory[order.Category] = new List<Order>();
    }
    groupedByCategory[order.Category].Add(order);
}

// –ö—Ä–æ–∫ 3: –û–±—á–∏—Å–ª–µ–Ω–Ω—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
List<CategoryStats> stats = new List<CategoryStats>();

foreach (var kvp in groupedByCategory)
{
    decimal total = 0;
    int count = 0;

    foreach (var order in kvp.Value)
    {
        total += order.Amount;
        count++;
    }

    stats.Add(new CategoryStats
    {
        Category = kvp.Key,
        TotalAmount = total,
        AverageCheck = total / count,
        OrderCount = count
    });
}

// –ö—Ä–æ–∫ 4: –°–æ—Ä—Ç—É–≤–∞–Ω–Ω—è –∑–∞ –∑–∞–≥–∞–ª—å–Ω–æ—é —Å—É–º–æ—é
stats.Sort((a, b) => b.TotalAmount.CompareTo(a.TotalAmount));
```

**–ü—Ä–æ–±–ª–µ–º–∏ —Ü—å–æ–≥–æ –ø—ñ–¥—Ö–æ–¥—É:**

-   üìù **50+ —Ä—è–¥–∫—ñ–≤ –∫–æ–¥—É** –¥–ª—è –≤—ñ–¥–Ω–æ—Å–Ω–æ –ø—Ä–æ—Å—Ç–æ—ó –æ–ø–µ—Ä–∞—Ü—ñ—ó
-   üîÑ **–ú–Ω–æ–∂–∏–Ω–Ω—ñ loops** —Ç–∞ —Ç–∏–º—á–∞—Å–æ–≤—ñ –∑–º—ñ–Ω–Ω—ñ
-   üêõ **–°—Ö–∏–ª—å–Ω—ñ—Å—Ç—å –¥–æ –ø–æ–º–∏–ª–æ–∫** (–∑–∞–±—É–ª–∏ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ dictionary, –ø–æ–º–∏–ª–∫–∞ –≤ –æ–±—á–∏—Å–ª–µ–Ω–Ω—è—Ö)
-   üìñ **–í–∞–∂–∫–æ —á–∏—Ç–∞—Ç–∏** - –ø–æ—Ç—Ä—ñ–±–µ–Ω —á–∞—Å —â–æ–± –∑—Ä–æ–∑—É–º—ñ—Ç–∏ "—â–æ" –∫–æ–¥ —Ä–æ–±–∏—Ç—å
-   üîß **–í–∞–∂–∫–æ –ø—ñ–¥—Ç—Ä–∏–º—É–≤–∞—Ç–∏** - –∑–º—ñ–Ω–∞ –ª–æ–≥—ñ–∫–∏ –≤–∏–º–∞–≥–∞—î —Ä–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è –±–∞–≥–∞—Ç—å–æ—Ö –º—ñ—Å—Ü—å

---

**LINQ (Language Integrated Query)** —Ä–µ–≤–æ–ª—é—Ü—ñ–æ–Ω—ñ–∑—É—î —Ü–µ–π –ø—ñ–¥—Ö—ñ–¥:

```csharp {1,2,11-16} showLineNumbers
List<Order> allOrders = GetAllOrders();

// –í–µ—Å—å –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ–π –∫–æ–¥ –∑–∞–º—ñ–Ω—é—î—Ç—å—Å—è –Ω–∞:
var categoryStats = allOrders
    .Where(o => o.Date >= DateTime.Now.AddMonths(-1))
    .GroupBy(o => o.Category)
    .Select(g => new CategoryStats
    {
        Category = g.Key,
        TotalAmount = g.Sum(o => o.Amount),
        AverageCheck = g.Average(o => o.Amount),
        OrderCount = g.Count()
    })
    .OrderByDescending(s => s.TotalAmount);
```

**10 —Ä—è–¥–∫—ñ–≤ –∑–∞–º—ñ—Å—Ç—å 50+!** –ö–æ–¥ —Å—Ç–∞–≤:

-   ‚úÖ **–ß–∏—Ç–∞–±–µ–ª—å–Ω–∏–º** - –æ–¥—Ä–∞–∑—É –∑—Ä–æ–∑—É–º—ñ–ª–æ –©–û —Ä–æ–±–∏–º–æ
-   ‚úÖ **–î–µ–∫–ª–∞—Ä–∞—Ç–∏–≤–Ω–∏–º** - –æ–ø–∏—Å—É—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç, –∞ –Ω–µ –ø—Ä–æ—Ü–µ—Å
-   ‚úÖ **–ë–µ–∑–ø–µ—á–Ω–∏–º** - –º–µ–Ω—à–µ –º—ñ—Å—Ü—å –¥–ª—è –ø–æ–º–∏–ª–æ–∫
-   ‚úÖ **–ü—ñ–¥—Ç—Ä–∏–º—É–≤–∞–Ω–∏–º** - –∑–º—ñ–Ω–∏ –ª–æ–∫–∞–ª—å–Ω—ñ —Ç–∞ –æ—á–µ–≤–∏–¥–Ω—ñ

---

### –©–æ —Ç–∞–∫–µ LINQ?

**LINQ (Language Integrated Query)** - —Ü–µ –Ω–∞–±—ñ—Ä —Ç–µ—Ö–Ω–æ–ª–æ–≥—ñ–π —É .NET, —è–∫—ñ –Ω–∞–¥–∞—é—Ç—å **—É–Ω—ñ—Ñ—ñ–∫–æ–≤–∞–Ω–∏–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –∑–∞–ø–∏—Ç—ñ–≤** –¥–ª—è —Ä–æ–±–æ—Ç–∏ –∑ –¥–∞–Ω–∏–º–∏ –Ω–µ–∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ –¥–∂–µ—Ä–µ–ª–∞.

::mermaid

```mermaid
graph TB
    LINQ[LINQ Query Syntax]

    LINQ --> Objects[LINQ to Objects<br/>IEnumerable&lt;T&gt;]
    LINQ --> SQL[LINQ to SQL/EF<br/>IQueryable&lt;T&gt;]
    LINQ --> XML[LINQ to XML<br/>XDocument/XElement]
    LINQ --> JSON[LINQ to JSON<br/>JToken via libraries]

    Objects --> Memory[Collections in Memory<br/>List, Array, Dictionary]
    SQL --> DB[(Databases<br/>SQL Server, PostgreSQL)]
    XML --> XmlDocs[XML Documents]
    JSON --> JsonData[JSON Data]

    style LINQ fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style Objects fill:#10b981,stroke:#047857,color:#ffffff
    style SQL fill:#8b5cf6,stroke:#6d28d9,color:#ffffff
    style XML fill:#f59e0b,stroke:#b45309,color:#ffffff
    style JSON fill:#ec4899,stroke:#be185d,color:#ffffff
```

::

**–û—Å–Ω–æ–≤–Ω—ñ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∏ LINQ:**

::field-group
::field{name="LINQ to Objects" type="IEnumerable<T>"}
–ó–∞–ø–∏—Ç–∏ –¥–æ **–∫–æ–ª–µ–∫—Ü—ñ–π —É –ø–∞–º'—è—Ç—ñ**: `List<T>`, –º–∞—Å–∏–≤–∏, `HashSet<T>`, `Dictionary<TKey, TValue>`. –í–∏–∫–æ–Ω—É—î—Ç—å—Å—è **client-side** –±–µ–∑–ø–æ—Å–µ—Ä–µ–¥–Ω—å–æ –≤ C# runtime.
::

::field{name="LINQ to SQL / Entity Framework" type="IQueryable<T>"}
–ó–∞–ø–∏—Ç–∏ –¥–æ **–±–∞–∑ –¥–∞–Ω–∏—Ö**. Expression trees (–¥–µ—Ä–µ–≤–∞ –≤–∏—Ä–∞–∑—ñ–≤) –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—é—Ç—å—Å—è –Ω–∞ SQL –∑–∞–ø–∏—Ç–∏ —Ç–∞ –≤–∏–∫–æ–Ω—É—é—Ç—å—Å—è **server-side** –Ω–∞ database engine.
::

::field{name="LINQ to XML" type="XDocument, XElement"}
–ó–∞–ø–∏—Ç–∏ –¥–æ **XML –¥–æ–∫—É–º–µ–Ω—Ç—ñ–≤**. –°–ø—Ä–æ—â—É—î –Ω–∞–≤—ñ–≥–∞—Ü—ñ—é, —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ñ—é —Ç–∞ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü—ñ—é XML —á–µ—Ä–µ–∑ LINQ operators.
::

::field{name="LINQ to JSON" type="—á–µ—Ä–µ–∑ –±—ñ–±–ª—ñ–æ—Ç–µ–∫–∏"}
–†–æ–±–æ—Ç–∞ –∑ **JSON –¥–∞–Ω–∏–º–∏** (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, Newtonsoft.Json `JToken`, System.Text.Json). –ü–∞—Ä—Å–∏–Ω–≥ —Ç–∞ querying JSON structures.
::
::

**–£ —Ü—å–æ–º—É –º–∞—Ç–µ—Ä—ñ–∞–ª—ñ —Ñ–æ–∫—É—Å –Ω–∞ LINQ to Objects** - –Ω–∞–π–ø–æ—à–∏—Ä–µ–Ω—ñ—à–æ–º—É —Ç–∞ —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω–æ–º—É —Å—Ü–µ–Ω–∞—Ä—ñ—ó.

---

### –ß–æ–º—É LINQ –†–µ–≤–æ–ª—é—Ü—ñ–π–Ω–∏–π?

**1. Language Integration (–Ü–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—è –∑ –ú–æ–≤–æ—é)**

LINQ - –Ω–µ –∑–æ–≤–Ω—ñ—à–Ω—è –±—ñ–±–ª—ñ–æ—Ç–µ–∫–∞, –∞ **—á–∞—Å—Ç–∏–Ω–∞ C# —Å–∏–Ω—Ç–∞–∫—Å–∏—Å—É**:

-   Compile-time type checking
-   IntelliSense –ø—ñ–¥—Ç—Ä–∏–º–∫–∞
-   Refactoring –±–µ–∑–ø–µ—á–Ω—ñ—Å—Ç—å

**2. –£–Ω—ñ—Ñ—ñ–∫–∞—Ü—ñ—è –ü—ñ–¥—Ö–æ–¥—ñ–≤**

–î–æ LINQ –∫–æ–∂–Ω–µ –¥–∂–µ—Ä–µ–ª–æ –¥–∞–Ω–∏—Ö –º–∞–ª–æ —Å–≤—ñ–π API:

-   Collections: `foreach`, `List.Sort()`, custom loops
-   Databases: SQL —Å—Ç—Ä–æ–∫–∏, ADO.NET
-   XML: `XmlDocument` DOM navigation

LINQ –Ω–∞–¥–∞—î **—î–¥–∏–Ω–∏–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å** –¥–ª—è –≤—Å—ñ—Ö.

**3. Composability (–ö–æ–º–ø–æ–∑–∏—Ü—ñ–π–Ω—ñ—Å—Ç—å)**

–û–ø–µ—Ä–∞—Ü—ñ—ó easily chain-—è—Ç—å—Å—è:

```csharp
var result = data
    .Where(filters)
    .Select(transformation)
    .OrderBy(sorting)
    .GroupBy(grouping)
    .Take(pagination);
```

**4. Deferred Execution (–í—ñ–¥–∫–ª–∞–¥–µ–Ω–µ –í–∏–∫–æ–Ω–∞–Ω–Ω—è)**

Queries –≤–∏–∫–æ–Ω—É—é—Ç—å—Å—è **–ª–∏—à–µ –ø—Ä–∏ –ø–æ—Ç—Ä–µ–±—ñ** ‚Üí –µ—Ñ–µ–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å —Ç–∞ lazy evaluation.

---

### –©–æ –í–∏ –í–∏–≤—á–∏—Ç–µ

–£ —Ü—å–æ–º—É –º–∞—Ç–µ—Ä—ñ–∞–ª—ñ –≤–∏ –≥–ª–∏–±–æ–∫–æ –æ—Å–≤–æ—ó—Ç–µ:

::steps

### Query Syntax vs Method Syntax

–î–≤–∞ —Å–ø–æ—Å–æ–±–∏ –Ω–∞–ø–∏—Å–∞–Ω–Ω—è LINQ –∑–∞–ø–∏—Ç—ñ–≤ - SQL-–ø–æ–¥—ñ–±–Ω–∏–π —Ç–∞ fluent API. –ö–æ–ª–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ —è–∫–∏–π.

### Deferred vs Immediate Execution

–Ø–∫ –ø—Ä–∞—Ü—é—î –≤—ñ–¥–∫–ª–∞–¥–µ–Ω–µ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è, iterator pattern, performance implications, caching strategies.

### Filtering & Projection

`Where`, `OfType`, `Select`, `SelectMany` - —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ñ—è —Ç–∞ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü—ñ—è –¥–∞–Ω–∏—Ö.

### Sorting & Grouping

`OrderBy`, `ThenBy`, `GroupBy` - —Å–∫–ª–∞–¥–Ω–µ —Å–æ—Ä—Ç—É–≤–∞–Ω–Ω—è —Ç–∞ –≥—Ä—É–ø—É–≤–∞–Ω–Ω—è –∑ –∞–≥—Ä–µ–≥–∞—Ü—ñ—è–º–∏.

### Joins

Inner join, group join, left outer join patterns –¥–ª—è –∫–æ–º–±—ñ–Ω—É–≤–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö.

### Aggregation

`Sum`, `Count`, `Average`, `Max`, `Min`, `MaxBy`, `MinBy`, `Aggregate` - –æ–±—á–∏—Å–ª–µ–Ω–Ω—è over collections.

### Set Operations

`Distinct`, `Union`, `Intersect`, `Except` - –æ–ø–µ—Ä–∞—Ü—ñ—ó –Ω–∞–¥ –º–Ω–æ–∂–∏–Ω–∞–º–∏.

### Element Operations

`First`, `Single`, `ElementAt`, `Any`, `All` - –≤–∏—Ç—è–≥—É–≤–∞–Ω–Ω—è —Ç–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –µ–ª–µ–º–µ–Ω—Ç—ñ–≤.

### Performance & Best Practices

–û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è queries, —É–Ω–∏–∫–Ω–µ–Ω–Ω—è –ø–∞—Å—Ç–æ–∫, –∫–æ–ª–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ `ToList()`.
::

---

### Prerequisites

–î–ª—è –ø–æ–≤–Ω–æ–≥–æ —Ä–æ–∑—É–º—ñ–Ω–Ω—è –º–∞—Ç–µ—Ä—ñ–∞–ª—É –Ω–µ–æ–±—Ö—ñ–¥–Ω–æ –∑–Ω–∞—Ç–∏:

-   ‚úÖ **Generic Collections**: `List<T>`, `Dictionary<TKey, TValue>`, `IEnumerable<T>`
-   ‚úÖ **Delegates —Ç–∞ Lambda Expressions**: `Func<T>`, `Action<T>`, `x => x.Property`
-   ‚úÖ **Anonymous Types**: `new { Name = "John", Age = 30 }`
-   ‚úÖ **Extension Methods**: —Ä–æ–∑—É–º—ñ–Ω–Ω—è —è–∫ –ø—Ä–∞—Ü—é—é—Ç—å `this` parameter methods
-   ‚úÖ **–ë–∞–∑–æ–≤–µ –û–û–ü**: classes, properties, interfaces

::tip
–Ø–∫—â–æ —â–æ—Å—å –∑ prerequisites –Ω–µ–∑—Ä–æ–∑—É–º—ñ–ª–æ - –ø–æ–≤–µ—Ä–Ω—ñ—Ç—å—Å—è –¥–æ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–∏—Ö —Ä–æ–∑–¥—ñ–ª—ñ–≤ roadmap –ø–µ—Ä–µ–¥ –ø—Ä–æ–¥–æ–≤–∂–µ–Ω–Ω—è–º.
::

---

## Query Syntax vs Method Syntax

LINQ –Ω–∞–¥–∞—î **–¥–≤–∞ –µ–∫–≤—ñ–≤–∞–ª–µ–Ω—Ç–Ω—ñ —Å–ø–æ—Å–æ–±–∏** –Ω–∞–ø–∏—Å–∞–Ω–Ω—è –∑–∞–ø–∏—Ç—ñ–≤. –†–æ–∑–±–µ—Ä–µ–º–æ –æ–±–∏–¥–≤–∞ –¥–µ—Ç–∞–ª—å–Ω–æ.

### Query Syntax (Comprehension Syntax)

**Query syntax** –Ω–∞–≥–∞–¥—É—î SQL —Ç–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î —Å–ø–µ—Ü—ñ–∞–ª—å–Ω—ñ –∫–ª—é—á–æ–≤—ñ —Å–ª–æ–≤–∞ C#:

```csharp {showLineNumbers}
List<int> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Query syntax - SQL-–ø–æ–¥—ñ–±–Ω–∏–π
IEnumerable<int> evenNumbers =
    from num in numbers
    where num % 2 == 0
    orderby num
    select num;

foreach (int n in evenNumbers)
{
    Console.Write($"{n} ");
}
// Output: 2 4 6 8 10
```

**–°—Ç—Ä—É–∫—Ç—É—Ä–∞ query syntax:**

```csharp
from [identifier] in [source]
[where —É—Å–ª–æ–≤–∏–µ]
[orderby –ø–æ–ª–µ [ascending|descending]]
[group ... by ... into ...]
[join ... in ... on ... equals ...]
select [projection]
```

**–ö–ª—é—á–æ–≤—ñ –∫–ª—é—á–æ–≤—ñ —Å–ª–æ–≤–∞:**

-   `from` - –≤–∏–∑–Ω–∞—á–∞—î –¥–∂–µ—Ä–µ–ª–æ –¥–∞–Ω–∏—Ö —Ç–∞ range variable
-   `where` - —Ñ—ñ–ª—å—Ç—Ä—É—î –µ–ª–µ–º–µ–Ω—Ç–∏
-   `orderby` - —Å–æ—Ä—Ç—É—î —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏
-   `select` - –ø—Ä–æ–µ–∫—Ç—É—î (—Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º—É—î) —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏
-   `group by` - –≥—Ä—É–ø—É—î –µ–ª–µ–º–µ–Ω—Ç–∏
-   `join` - –∑'—î–¥–Ω—É—î –¥–≤–∞ –¥–∂–µ—Ä–µ–ª–∞

---

### Method Syntax (Fluent API)

**Method syntax** –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î extension methods –Ω–∞ `IEnumerable<T>`:

```csharp {showLineNumbers}
List<int> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Method syntax - fluent API
IEnumerable<int> evenNumbers = numbers
    .Where(num => num % 2 == 0)
    .OrderBy(num => num);

foreach (int n in evenNumbers)
{
    Console.Write($"{n} ");
}
// Output: 2 4 6 8 10
```

**Extension methods chain:**

-   –ö–æ–∂–µ–Ω –º–µ—Ç–æ–¥ –ø—Ä–∏–π–º–∞—î `IEnumerable<T>`
-   –ü–æ–≤–µ—Ä—Ç–∞—î `IEnumerable<TResult>`
-   –î–æ–∑–≤–æ–ª—è—î **fluent chaining**

**Lambda expressions:**

```csharp
num => num % 2 == 0
// ‚Üë      ‚Üë
// –ø–∞—Ä–∞–º–µ—Ç—Ä  —Ç—ñ–ª–æ (–≤–∏—Ä–∞–∑ –∞–±–æ –±–ª–æ–∫)
```

---

### –©–æ –í—ñ–¥–±—É–≤–∞—î—Ç—å—Å—è "–ü—ñ–¥ –ö–∞–ø–æ—Ç–æ–º"?

**Query syntax - —Ü–µ syntactic sugar!** –ö–æ–º–ø—ñ–ª—è—Ç–æ—Ä C# **–ø–µ—Ä–µ—Ç–≤–æ—Ä—é—î** –π–æ–≥–æ –Ω–∞ method syntax.

::code-group

```csharp [–í–∏ –ü–∏—à–µ—Ç–µ (Query)]
int[] numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

var query = from n in numbers
            where n > 5
            select n * 2;
```

```csharp [–ö–æ–º–ø—ñ–ª—è—Ç–æ—Ä –ì–µ–Ω–µ—Ä—É—î (Method)]
int[] numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

var query = numbers
    .Where(n => n > 5)
    .Select(n => n * 2);
```

::

**Verification —á–µ—Ä–µ–∑ IL:**

```csharp
class Student { public string Name { get; set; } = ""; public int Age { get; set; } }
var students = new List<Student> { new() { Name = "Alice", Age = 20 }, new() { Name = "Bob", Age = 17 } };

// Original query syntax
var result = from s in students
             where s.Age >= 18
             select s.Name;
```

**IL Code (simplified):**

```il
.method private hidebysig instance void Main()
{
    // ...
    call class [System.Linq]System.Linq.Enumerable::Where<...>(...)
    call class [System.Linq]System.Linq.Enumerable::Select<...>(...)
    // ...
}
```

‚Üí Query syntax –∫–æ–º–ø—ñ–ª—é—î—Ç—å—Å—è —É –≤–∏–∫–ª–∏–∫–∏ `Enumerable.Where()` —Ç–∞ `Enumerable.Select()`!

---

### –î–µ—Ç–∞–ª—å–Ω–µ –ü–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è

::code-group

```csharp [Query Syntax] {1-20} showLineNumbers
class Student
{
    public string Name { get; set; } = string.Empty;
    public int Grade { get; set; }
    public bool IsActive { get; set; }
    public int Age { get; set; }
    public string Department { get; set; } = string.Empty;
}

static List<Student> GetStudents()
{
    return
    [
        new Student { Name = "Alice", Grade = 95, IsActive = true, Age = 22, Department = "Engineering" },
        new Student { Name = "Bob", Grade = 88, IsActive = true, Age = 23, Department = "Marketing" },
        new Student { Name = "Charlie", Grade = 92, IsActive = false, Age = 21, Department = "Engineering" },
        new Student { Name = "Diana", Grade = 87, IsActive = true, Age = 20, Department = "Arts" },
    ];
}

List<Student> students = GetStudents();

var topStudents =
    from s in students
    where s.Grade >= 90 && s.IsActive
    orderby s.Name
    select new { s.Name, s.Grade };

foreach (var student in topStudents)
{
    Console.WriteLine($"{student.Name}: {student.Grade}");
}
```

```csharp [Method Syntax] {1,3-6} showLineNumbers
List<Student> students = GetStudents(); // Using the same GetStudents() from above

var topStudents = students
    .Where(s => s.Grade >= 90 && s.IsActive)
    .OrderBy(s => s.Name)
    .Select(s => new { s.Name, s.Grade });

foreach (var student in topStudents)
{
    Console.WriteLine($"{student.Name}: {student.Grade}");
}
```

::

**–û–±–∏–¥–≤–∞ –≤–∞—Ä—ñ–∞–Ω—Ç–∏:**

-   ‚úÖ –¢–∏–ø–æ-–±–µ–∑–ø–µ—á–Ω—ñ
-   ‚úÖ Compile-time –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞
-   ‚úÖ –û–¥–Ω–∞–∫–æ–≤–∞ performance (identical IL)
-   ‚úÖ Deferred execution

---

### –ü–æ—Ä—ñ–≤–Ω—è–ª—å–Ω–∞ –¢–∞–±–ª–∏—Ü—è

| –ê—Å–ø–µ–∫—Ç                     | Query Syntax                                           | Method Syntax                           |
| :------------------------- | :----------------------------------------------------- | :-------------------------------------- |
| **–ß–∏—Ç–∞–±–µ–ª—å–Ω—ñ—Å—Ç—å**          | SQL-familiar, –ø—Ä–∏—Ä–æ–¥–Ω–∏–π –¥–ª—è queries                    | C# idiomatic, fluent                    |
| **–î–æ—Å—Ç—É–ø–Ω—ñ—Å—Ç—å –æ–ø–µ—Ä–∞—Ç–æ—Ä—ñ–≤** | –û–±–º–µ–∂–µ–Ω–æ –∫–ª—é—á–æ–≤–∏–º–∏ —Å–ª–æ–≤–∞–º–∏ (`from`, `where`, `select`) | –í—Å—ñ `IEnumerable<T>` extension methods  |
| **Join Syntax**            | ‚úÖ –ü—Ä–æ—Å—Ç—ñ—à–∏–π —Ç–∞ —á–∏—Ç–∞–±–µ–ª—å–Ω—ñ—à–∏–π                          | –ë—ñ–ª—å—à verbose                           |
| **GroupBy**                | ‚úÖ `group ... by ... into ...` —ñ–Ω—Ç—É—ó—Ç–∏–≤–Ω–∏–π             | –ü–æ—Ç—Ä–µ–±—É—î —Ä–æ–∑—É–º—ñ–Ω–Ω—è `IGrouping<TKey, T>` |
| **Pagination**             | ‚ùå –ù–µ–º–∞—î `Take`, `Skip`                                | ‚úÖ –í—Å—ñ operators –¥–æ—Å—Ç—É–ø–Ω—ñ               |
| **Custom Extensions**      | ‚ùå –ù–µ –ø—ñ–¥—Ç—Ä–∏–º—É—î—Ç—å—Å—è                                    | ‚úÖ –õ–µ–≥–∫–æ –¥–æ–¥–∞—Ç–∏ –≤–ª–∞—Å–Ω—ñ methods          |
| **Debugging**              | –°–∫–ª–∞–¥–Ω—ñ—à–µ (–æ–¥–∏–Ω –≤–∏—Ä–∞–∑)                                 | ‚úÖ –õ–µ–≥—à–µ breakpoint-–∏—Ç–∏ –∫–æ–∂–µ–Ω –º–µ—Ç–æ–¥     |
| **–ú—ñ–∫—Å—É–≤–∞–Ω–Ω—è**             | –ú–æ–∂–Ω–∞ –ø–æ—î–¥–Ω—É–≤–∞—Ç–∏ –∑ method syntax                       | –ü–æ–≤–Ω—ñ—Å—Ç—é —Å–∞–º–æ–¥–æ—Å—Ç–∞—Ç–Ω—ñ–π                  |

---

### –ö–æ–ª–∏ –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ –©–æ?

::tip
**Method Syntax** - **—Ä–µ–∫–æ–º–µ–Ω–¥—É—î—Ç—å—Å—è –¥–ª—è –±—ñ–ª—å—à–æ—Å—Ç—ñ –≤–∏–ø–∞–¥–∫—ñ–≤**:

-   ‚úÖ –£–Ω—ñ–≤–µ—Ä—Å–∞–ª—å–Ω–∏–π (–≤—Å—ñ operators)
-   ‚úÖ –õ–µ–≥—à–µ chain-–∏—Ç–∏ —Ç–∞ —Ç–µ—Å—Ç—É–≤–∞—Ç–∏
-   ‚úÖ –ó–≤–∏—á–Ω–∏–π –¥–ª—è —Å—É—á–∞—Å–Ω–æ–≥–æ C# –∫–æ–¥—É
-   ‚úÖ –ü—ñ–¥—Ç—Ä–∏–º—É—î custom extensions

**Query Syntax** - –∫–æ—Ä–∏—Å–Ω–∏–π –¥–ª—è:

-   ‚úÖ –°–∫–ª–∞–¥–Ω–∏—Ö **joins** (–±—ñ–ª—å—à —á–∏—Ç–∞–±–µ–ª—å–Ω–∏–π)
-   ‚úÖ **GroupBy** –∑ –º–Ω–æ–∂–∏–Ω–Ω–∏–º–∏ –æ–ø–µ—Ä–∞—Ü—ñ—è–º–∏
-   ‚úÖ SQL-background developers (—à–≤–∏–¥—à–µ –æ—Å–≤–æ—î–Ω–Ω—è)

::

**–ü—Ä–∞–∫—Ç–∏—á–Ω–∏–π –ø—Ä–∏–∫–ª–∞–¥ (Join):**

::code-group

```csharp [Query - –ß–∏—Ç–∞–±–µ–ª—å–Ω—ñ—à–∏–π Join]
class Customer { public int Id { get; set; } public string Name { get; set; } = ""; }
class Order { public int CustomerId { get; set; } public DateTime Date { get; set; } }
var customers = new List<Customer> { new() { Id = 1, Name = "John" } };
var orders = new List<Order> { new() { CustomerId = 1, Date = DateTime.Now } };

var customerOrders =
    from c in customers
    join o in orders on c.Id equals o.CustomerId
    select new { Customer = c.Name, Order = o.Date };
```

```csharp [Method - –ú–µ–Ω—à —á–∏—Ç–∞–±–µ–ª—å–Ω–∏–π]
// Using the same customers and orders from above
var customerOrders = customers.Join(
    orders,
    c => c.Id,
    o => o.CustomerId,
    (c, o) => new { Customer = c.Name, Order = o.Date }
);
```

::

**–ü—Ä–∞–∫—Ç–∏—á–Ω–∏–π –ø—Ä–∏–∫–ª–∞–¥ (Pagination):**

```csharp
class Product { public string Category { get; set; } = ""; }
var products = new List<Product> { new() { Category = "Electronics" } };

// Query syntax –ù–ï –ø—ñ–¥—Ç—Ä–∏–º—É—î Take/Skip –Ω–∞–ø—Ä—è–º—É
var page2 = (from p in products
             where p.Category == "Electronics"
             select p)
            .Skip(20)  // –ü–æ—Ç—Ä—ñ–±–Ω–æ –ø–µ—Ä–µ–º–∏–∫–∞—Ç–∏—Å—å –Ω–∞ method syntax!
            .Take(10);

// Method syntax - –ø—Ä–∏—Ä–æ–¥–Ω–æ
var page2 = products
    .Where(p => p.Category == "Electronics")
    .Skip(20)
    .Take(10);
```

---

### –ú–æ–∂–Ω–∞ –ú—ñ–∫—Å—É–≤–∞—Ç–∏!

```csharp {5-6} showLineNumbers
// Query syntax –∑ method syntax extension
var result =
    (from p in products
     where p.InStock
     select p)
    .OrderByDescending(p => p.Price)  // Method syntax
    .Take(5);                         // Method syntax
```

::note
**Best Practice**: –ü–æ—á–∏–Ω–∞–π—Ç–µ –∑ method syntax. –Ø–∫—â–æ join –∞–±–æ group by —Å—Ç–∞—é—Ç—å –Ω–µ–∑—Ä–æ–∑—É–º—ñ–ª–∏–º–∏ - –ø–µ—Ä–µ–∫–ª—é—á–∞–π—Ç–µ—Å—å –Ω–∞ query syntax –¥–ª—è —Ç—ñ—î—ó —á–∞—Å—Ç–∏–Ω–∏.
::

---

## Deferred Execution (–í—ñ–¥–∫–ª–∞–¥–µ–Ω–µ –í–∏–∫–æ–Ω–∞–Ω–Ω—è)

–¶–µ **–Ω–∞–π–≤–∞–∂–ª–∏–≤—ñ—à–∞ –∫–æ–Ω—Ü–µ–ø—Ü—ñ—è** LINQ, —è–∫—É –Ω–µ–æ–±—Ö—ñ–¥–Ω–æ –≥–ª–∏–±–æ–∫–æ —Ä–æ–∑—É–º—ñ—Ç–∏ –¥–ª—è –µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–≥–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è.

### Lazy Evaluation - –Ø–∫ –¶–µ –ü—Ä–∞—Ü—é—î?

–ö–æ–ª–∏ –≤–∏ –ø–∏—à–µ—Ç–µ LINQ query, **–≤—ñ–Ω –ù–ï –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è –Ω–µ–≥–∞–π–Ω–æ**. –ù–∞—Ç–æ–º—ñ—Å—Ç—å —Å—Ç–≤–æ—Ä—é—î—Ç—å—Å—è **query definition** (–≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è –∑–∞–ø–∏—Ç—É), —è–∫–∏–π –≤–∏–∫–æ–Ω–∞—î—Ç—å—Å—è –ª–∏—à–µ –∫–æ–ª–∏ –≤–∏ –ø–æ—á–Ω–µ—Ç–µ **—ñ—Ç–µ—Ä—É–≤–∞—Ç–∏** —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏.

```csharp {4-8,12} showLineNumbers
List<int> numbers = [1, 2, 3, 4, 5];

Console.WriteLine("=== –î–æ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è query ===");

// –ó–∞–ø–∏—Ç —Å—Ç–≤–æ—Ä–µ–Ω–æ, –∞–ª–µ –ù–ï –≤–∏–∫–æ–Ω–∞–Ω–æ!
var query = numbers.Where(n => {
    Console.WriteLine($"  Filtering: {n}");
    return n % 2 == 0;
});

Console.WriteLine("=== –ü—ñ—Å–ª—è —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è, –¥–æ —ñ—Ç–µ—Ä–∞—Ü—ñ—ó ===");

// –¢–Ü–õ–¨–ö–ò –¢–ï–ü–ï–† –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è!
foreach (int n in query)
{
    Console.WriteLine($"Result: {n}");
}
```

**Output:**

```
=== –î–æ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è query ===
=== –ü—ñ—Å–ª—è —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è, –¥–æ —ñ—Ç–µ—Ä–∞—Ü—ñ—ó ===
  Filtering: 1
  Filtering: 2
Result: 2
  Filtering: 3
  Filtering: 4
Result: 4
  Filtering: 5
```

**–©–æ –≤—ñ–¥–±—É–ª–æ—Å—å:**

1. –†—è–¥–æ–∫ 6-8: Query **—Å—Ç–≤–æ—Ä–µ–Ω–æ**, but `Where` predicate –ù–ï –≤–∏–∫–ª–∏–∫–∞—î—Ç—å—Å—è!
2. –†—è–¥–æ–∫ 14: `foreach` –ø–æ—á–∏–Ω–∞—î enumeration ‚Üí **–¢–ï–ü–ï–†** query –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è
3. –§—ñ–ª—å—Ç—Ä–∞—Ü—ñ—è –≤—ñ–¥–±—É–≤–∞—î—Ç—å—Å—è **–µ–ª–µ–º–µ–Ω—Ç –∑–∞ –µ–ª–µ–º–µ–Ω—Ç–æ–º** –ø—ñ–¥ —á–∞—Å —ñ—Ç–µ—Ä–∞—Ü—ñ—ó

---

### "Under the Hood": Iterator Pattern

LINQ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î **iterator pattern** (—á–µ—Ä–µ–∑ `yield return`):

```csharp {showLineNumbers}
// –°–ø—Ä–æ—â–µ–Ω–∞ —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—è Where
public static IEnumerable<T> Where<T>(
    this IEnumerable<T> source,
    Func<T, bool> predicate)
{
    foreach (T item in source)
    {
        if (predicate(item))
        {
            yield return item;  // –ü–æ–≤–µ—Ä–Ω—É—Ç–∏ element –ø—Ä–∏ –∑–∞–ø–∏—Ç—ñ
        }
    }
}

// –ö–æ–ª–∏ –≤–∏ –ø–∏—à–µ—Ç–µ:
var query = numbers.Where(n => n > 5);

// –°—Ç–≤–æ—Ä—é—î—Ç—å—Å—è —ñ—Ç–µ—Ä–∞—Ç–æ—Ä (state machine), —è–∫–∏–π:
// 1. –ó–±–µ—Ä—ñ–≥–∞—î source (numbers) —Ç–∞ predicate (n => n > 5)
// 2. –ß–µ–∫–∞—î –Ω–∞ enumeration
//  3. –ü—Ä–∏ foreach - –≤–∏–∫–æ–Ω—É—î –ª–æ–≥—ñ–∫—É –±–ª–æ–∫—É –∑–∞ –±–ª–æ–∫–æ–º
```

::mermaid

```mermaid
sequenceDiagram
    participant Code as Application Code
    participant Query as LINQ Query Object
    participant Iterator as Iterator State Machine
    participant Source as Source Collection

    Code->>Query: var q = numbers.Where(...)
    Note over Query: Query object created<br/>NO execution yet

    Code->>Code: ... other work ...

    Code->>Query: foreach (var x in q)
    Query->>Iterator: GetEnumerator()
    Iterator->>Iterator: Initialize state

    loop For each element
        Iterator->>Source: Request next element
        Source-->>Iterator: Element
        Iterator->>Iterator: Apply predicate
        alt Matches
            Iterator-->>Code: yield return element
            Code->>Code: Process element
        else Doesn't match
            Note over Iterator: Skip, continue
        end
    end

    Iterator-->>Code: Enumeration complete
```

::

---

### Multiple Enumeration Problem

**–ö–æ–∂–Ω–∞ —ñ—Ç–µ—Ä–∞—Ü—ñ—è –ø–æ–≤—Ç–æ—Ä–Ω–æ –≤–∏–∫–æ–Ω—É—î** –≤–µ—Å—å query!

```csharp {6-9,12-13} showLineNumbers
var query = numbers.Where(n => {
    Console.WriteLine($"Checking {n}");
    return n > 3;
});

// –ü–µ—Ä—à–∞ —ñ—Ç–µ—Ä–∞—Ü—ñ—è
Console.WriteLine("=== First Enumeration ===");
foreach (var n in query)
    Console.Write($"{n} ");

// –î—Ä—É–≥–∞ —ñ—Ç–µ—Ä–∞—Ü—ñ—è - QUERY –í–ò–ö–û–ù–£–Ñ–¢–¨–°–Ø –ó–ù–û–í–£!
Console.WriteLine("\n=== Second Enumeration ===");
foreach (var n in query)
    Console.Write($"{n} ");
```

**Output:**

```
=== First Enumeration ===
Checking 1
Checking 2
Checking 3
Checking 4
4 Checking 5
5
=== Second Enumeration ===
Checking 1  ‚Üê –ó–Ω–æ–≤—É –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è!
Checking 2
Checking 3
Checking 4
4 Checking 5
5
```

::warning
**Performance Trap**: –Ø–∫—â–æ query **–¥–æ—Ä–æ–≥–∏–π** (—á–∏—Ç–∞—î —Ñ–∞–π–ª–∏, —Ä–æ–±–∏—Ç—å HTTP –∑–∞–ø–∏—Ç–∏, –≤–∏–∫–æ–Ω—É—î —Å–∫–ª–∞–¥–Ω—ñ –æ–±—á–∏—Å–ª–µ–Ω–Ω—è), –ø–æ–≤—Ç–æ—Ä–Ω–∞ enumeration –º–æ–∂–µ –±—É—Ç–∏ **–∫–∞—Ç–∞—Å—Ç—Ä–æ—Ñ—ñ—á–Ω–æ—é** –¥–ª—è performance!

**–ü—Ä–∏–∫–ª–∞–¥ –ø—Ä–æ–±–ª–µ–º–∏:**

```csharp
// –î–æ—Ä–æ–≥–∏–π query (—á–∏—Ç–∞—î –∑ database –∞–±–æ API)
var expensiveQuery = GetUsersFromDatabase()
    .Where(u => u.IsActive)
    .Select(u => TransformUser(u));  // –î–æ—Ä–æ–≥–∞ –æ–ø–µ—Ä–∞—Ü—ñ—è

// –ü–µ—Ä—à–∞ —ñ—Ç–µ—Ä–∞—Ü—ñ—è - –≤–∏–∫–æ–Ω–∞–Ω–æ
int count = expensiveQuery.Count();  // Database query #1

// –î—Ä—É–≥–∞ —ñ—Ç–µ—Ä–∞—Ü—ñ—è - –ó–ù–û–í–£ database query!
var first10 = expensiveQuery.Take(10).ToList();  // Database query #2

// –¶–µ –≤–∏–∫–æ–Ω–∞–ª–æ –î–í–ê –ø–æ–≤–Ω–∏—Ö database queries!
```

::

---

### Immediate Execution

–©–æ–± **–≤–∏–∫–æ–Ω–∞—Ç–∏ query –æ–¥—Ä–∞–∑—É** —ñ –∑–∞–∫–µ—à—É–≤–∞—Ç–∏ results, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ **materializing operators**:

**–û–ø–µ—Ä–∞—Ç–æ—Ä–∏ –∑ immediate execution:**

::field-group
::field{name="ToList()" type="List<T>"}
–í–∏–∫–æ–Ω—É—î query —Ç–∞ –∑–±–µ—Ä—ñ–≥–∞—î —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ —É `List<T>`. –ù–∞–π—á–∞—Å—Ç—ñ—à–∏–π –≤–∏–±—ñ—Ä –¥–ª—è caching.
::

::field{name="ToArray()" type="T[]"}
–í–∏–∫–æ–Ω—É—î query —Ç–∞ –ø–æ–≤–µ—Ä—Ç–∞—î –º–∞—Å–∏–≤. –ö–æ—Ä–∏—Å–Ω–æ –¥–ª—è fixed-size collections.
::

::field{name="ToDictionary()" type="Dictionary<TKey, TValue>"}
–°—Ç–≤–æ—Ä—é—î dictionary –∑ key selector. Immediate execution + fast lookup.
::

::field{name="Count()" type="int"}
–ü—ñ–¥—Ä–∞—Ö–æ–≤—É—î –µ–ª–µ–º–µ–Ω—Ç–∏. –í–∏–∫–æ–Ω—É—î –≤–µ—Å—å query –¥–ª—è –ø—ñ–¥—Ä–∞—Ö—É–Ω–∫—É.
::

::field{name="Sum(), Average(), Max(), Min()" type="numeric"}
Aggregation operators - –∑–∞–≤–∂–¥–∏ immediate execution.
::

::field{name="First(), FirstOrDefault(), Single()" type="T"}
–í–∏—Ç—è–≥—É—é—Ç—å element(s) - immediate execution –¥–ª—è —Ç–æ–≥–æ –µ–ª–µ–º–µ–Ω—Ç–∞.
::
::

**–ü—Ä–∏–∫–ª–∞–¥ –∑ –∫–µ—à—É–≤–∞–Ω–Ω—è–º:**

```csharp {6,9,14,17} showLineNumbers
List<int> numbers = [1, 2, 3, 4, 5];

// Deferred - query definition
IEnumerable<int> deferredQuery = numbers.Where(n => n > 2);

// Immediate - –≤–∏–∫–æ–Ω–∞–Ω–æ –û–î–†–ê–ó–£, —Ä–µ–∑—É–ª—å—Ç–∞—Ç —É List
List<int> cachedQuery = numbers.Where(n => n > 2).ToList();

// –ú–æ–¥–∏—Ñ—ñ–∫—É—î–º–æ –¥–∂–µ—Ä–µ–ª–æ
numbers.Add(6);

// Deferred query –ø–æ–±–∞—á–∏—Ç—å –∑–º—ñ–Ω–∏ (–≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è –∑–Ω–æ–≤—É)
Console.WriteLine(string.Join(", ", deferredQuery));
// Output: 3, 4, 5, 6  ‚Üê –ë–∞—á–∏—Ç—å 6!

// Cached query –ù–ï –ø–æ–±–∞—á–∏—Ç—å –∑–º—ñ–Ω (–≤–∂–µ –≤–∏–∫–æ–Ω–∞–Ω–æ —Ä–∞–Ω—ñ—à–µ)
Console.WriteLine(string.Join(", ", cachedQuery));
// Output: 3, 4, 5  ‚Üê –ù–ï –±–∞—á–∏—Ç—å 6

// Proof: –ø–æ–≤—Ç–æ—Ä–Ω–∞ enumeration deferred
Console.WriteLine(string.Join(", ", deferredQuery));
// Output: 3, 4, 5, 6  ‚Üê –ó–Ω–æ–≤—É –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è, –±–∞—á–∏—Ç—å 6
```

::tip
**–ö–æ–ª–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ `ToList()`:**

-   ‚úÖ –ü–æ—Ç—Ä—ñ–±–Ω–æ **–∫—ñ–ª—å–∫–∞ —Ä–∞–∑—ñ–≤** —ñ—Ç–µ—Ä—É–≤–∞—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏
-   ‚úÖ Query **–¥–æ—Ä–æ–≥–∏–π** (database, file I/O, network)
-   ‚úÖ –•–æ—á–µ—Ç–µ **snapshot** –¥–∞–Ω–∏—Ö —É –ø–µ–≤–Ω–∏–π moment
-   ‚úÖ –ü–æ—Ç—Ä—ñ–±–Ω–∞ **–º–æ–¥–∏—Ñ—ñ–∫–∞—Ü—ñ—è** collection (Add/Remove)

**–ö–æ–ª–∏ –∑–∞–ª–∏—à–∏—Ç–∏ deferred:**

-   ‚úÖ –û–¥–Ω–æ—Ä–∞–∑–æ–≤–∞ —ñ—Ç–µ—Ä–∞—Ü—ñ—è
-   ‚úÖ –ü–∞–π–ø–ª–∞–π–Ω transformations (chain –∫—ñ–ª—å–∫–∞ operations)
-   ‚úÖ –ü–æ—Ç—Ä—ñ–±–Ω–∞ **–∞–∫—Ç—É–∞–ª—å–Ω—ñ—Å—Ç—å** –¥–∞–Ω–∏—Ö (–∑–∞–≤–∂–¥–∏ fresh data)

::

---

## Filtering (–§—ñ–ª—å—Ç—Ä–∞—Ü—ñ—è)

### Where - –û—Å–Ω–æ–≤–Ω–∏–π –§—ñ–ª—å—Ç—Ä

**–°–∏–≥–Ω–∞—Ç—É—Ä–∞:**

```csharp
IEnumerable<T> Where<T>(this IEnumerable<T> source, Func<T, bool> predicate)
IEnumerable<T> Where<T>(this IEnumerable<T> source, Func<T, int, bool> predicate)
```

**–ë–∞–∑–æ–≤–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è:**

```csharp {showLineNumbers}
class Product
{
    public string Name { get; set; } = string.Empty;
    public decimal Price { get; set; }
    public string Category { get; set; } = string.Empty;
    public bool InStock { get; set; }
    public bool IsActive { get; set; }
    public bool IsOnSale { get; set; }
    public double Rating { get; set; }
}

static List<Product> GetProducts()
{
    return
    [
        new Product { Name = "Laptop", Price = 1200m, Category = "Electronics", InStock = true, IsActive = true, IsOnSale = false, Rating = 4.5 },
        new Product { Name = "Mouse", Price = 25m, Category = "Electronics", InStock = true, IsActive = true, IsOnSale = true, Rating = 4.2 },
        new Product { Name = "Keyboard", Price = 75m, Category = "Electronics", InStock = false, IsActive = true, IsOnSale = false, Rating = 4.7 },
        new Product { Name = "C# Guide", Price = 45m, Category = "Books", InStock = true, IsActive = true, IsOnSale = false, Rating = 4.8 },
        new Product { Name = "LINQ Mastery", Price = 38m, Category = "Books", InStock = true, IsActive = true, IsOnSale = true, Rating = 4.9 },
        new Product { Name = "Monitor", Price = 350m, Category = "Electronics", InStock = true, IsActive = true, IsOnSale = false, Rating = 4.6 },
        new Product { Name = "Desk Chair", Price = 199m, Category = "Furniture", InStock = true, IsActive = true, IsOnSale = true, Rating = 4.3 },
    ];
}

List<Product> products = GetProducts();

// –ü—Ä–æ—Å—Ç—ñ —É–º–æ–≤–∏
var expensiveProducts = products.Where(p => p.Price > 100);

// –ú–Ω–æ–∂–∏–Ω–Ω—ñ —É–º–æ–≤–∏ –∑ &&
var specificProducts = products.Where(p =>
    p.Price >= 50 &&
    p.Price <= 200 &&
    p.Category == "Electronics" &&
    p.InStock
);

// –ó predicate method
bool IsActiveAndCheap(Product p) => p.IsActive && p.Price < 50;
var cheapActive = products.Where(IsActiveAndCheap);
```

**Index overload:**

```csharp {showLineNumbers}
// –ó —ñ–Ω–¥–µ–∫—Å–æ–º (index overload)
var evenIndexProducts = products.Where((p, index) => index % 2 == 0);

// –í–∑—è—Ç–∏ –∫–æ–∂–µ–Ω 3-–π –µ–ª–µ–º–µ–Ω—Ç
var everyThird = products.Where((p, i) => i % 3 == 0);

// –ü–µ—Ä—à—ñ 10 –≤—ñ–¥—Ñ—ñ–ª—å—Ç—Ä–æ–≤–∞–Ω—ñ
var firstTenExpensive = products
    .Where((p, i) => p.Price > 100 && i < 10);
```

---

### OfType\<T\> - –§—ñ–ª—å—Ç—Ä –ó–∞ –¢–∏–ø–æ–º

–í–∏—Ç—è–≥—É—î –µ–ª–µ–º–µ–Ω—Ç–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç–∏–ø—É –∑ heterogeneous collection:

```csharp {showLineNumbers}
object[] mixed = [1, "text", 3.14, "hello", 42, null, true];

// –¢—ñ–ª—å–∫–∏ int
IEnumerable<int> numbers = mixed.OfType<int>();
Console.WriteLine(string.Join(", ", numbers));
// Output: 1, 42

// –¢—ñ–ª—å–∫–∏ string
IEnumerable<string> strings = mixed.OfType<string>();
Console.WriteLine(string.Join(", ", strings));
// Output: text, hello

// –ó inheritance
class Animal
{
    public string Name { get; set; } = string.Empty;
}

class Dog : Animal
{
    public Dog(string name) { Name = name; }
    public void Bark() => Console.WriteLine($"{Name} says: Woof!");
}

class Cat : Animal
{
    public Cat(string name) { Name = name; }
    public void Meow() => Console.WriteLine($"{Name} says: Meow!");
}

class Bird : Animal
{
    public Bird(string name) { Name = name; }
    public void Chirp() => Console.WriteLine($"{Name} says: Chirp!");
}

List<Animal> animals = [
    new Dog("Rex"),
    new Cat("Whiskers"),
    new Dog("Buddy"),
    new Bird("Tweety")
];

// –¢—ñ–ª—å–∫–∏ Dogs
IEnumerable<Dog> dogs = animals.OfType<Dog>();
foreach (var dog in dogs)
{
    dog.Bark();  // Type-safe!
}
```

**–†—ñ–∑–Ω–∏—Ü—è –≤—ñ–¥ `Where`:**

```csharp
// Where –ø–æ—Ç—Ä–µ–±—É—î manual casting —Ç–∞ null check
var dogsWhere = animals
    .Where(a => a is Dog)
    .Select(a => (Dog)a);  // Manual cast!

// OfType - type-safety built-in
var dogsOfType = animals.OfType<Dog>();  // –ß–∏—Å—Ç–æ —Ç–∞ –±–µ–∑–ø–µ—á–Ω–æ
```

---

## Projection (–ü—Ä–æ–µ–∫—Ü—ñ—è)

### Select - –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü—ñ—è –ï–ª–µ–º–µ–Ω—Ç—ñ–≤

**–°–∏–≥–Ω–∞—Ç—É—Ä–∞:**

```csharp
IEnumerable<TResult> Select<T, TResult>(
    this IEnumerable<T> source,
    Func<T, TResult> selector)
```

**–ü—Ä–æ—Å—Ç—ñ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü—ñ—ó:**

```csharp {showLineNumbers}
List<Product> products = GetProducts();

// Extraction –æ–¥–Ω–æ–≥–æ –ø–æ–ª—è
IEnumerable<string> names = products.Select(p => p.Name);

// –û–±—á–∏—Å–ª–µ–Ω–Ω—è
IEnumerable<decimal> pricesWithTax = products
    .Select(p => p.Price * 1.2m);

// Anonymous type
var summary = products.Select(p => new {
    p.Name,
    p.Price,
    TaxIncluded = p.Price * 1.2m,
    Discount = p.IsOnSale ? p.Price * 0.1m : 0
});

foreach (var item in summary)
{
    Console.WriteLine($"{item.Name}: ${item.TaxIncluded} (discount: ${item.Discount})");
}
```

**Index overload:**

```csharp {showLineNumbers}
var indexedNames = products.Select((p, index) =>
    $"{index + 1}. {p.Name}"
);

// Output:
// 1. Laptop
// 2. Mouse
// 3. Keyboard
```

---

### SelectMany - Flattening Collections

**–ü—Ä–æ–±–ª–µ–º–∞**: –ú–∞—î–º–æ collection of collections, –ø–æ—Ç—Ä—ñ–±–Ω–∞ flat collection.

```csharp {showLineNumbers}
class Employee
{
    public string Name { get; set; } = string.Empty;
    public Employee(string name) { Name = name; }
}

class Department
{
    public string Name { get; set; } = string.Empty;
    public List<Employee> Employees { get; set; } = new();
}

List<Department> departments = [
    new() { Name = "IT", Employees = [new("Alice"), new("Bob")] },
    new() { Name = "HR", Employees = [new("Charlie")] },
    new() { Name = "Sales", Employees = [new("Dave"), new("Eve"), new("Frank")] }
];

// –ë–µ–∑ SelectMany - –≤–ª–æ–∂–µ–Ω–∞ collection!
IEnumerable<IEnumerable<Employee>> nested = departments
    .Select(d => d.Employees);
// Type: IEnumerable<IEnumerable<Employee>> - not flat!

// –ó SelectMany - –ø–ª–æ—Å–∫–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
IEnumerable<Employee> allEmployees = departments
    .SelectMany(d => d.Employees);

foreach (var emp in allEmployees)
{
    Console.WriteLine(emp.Name);
}
// Output:
// Alice
// Bob
// Charlie
// Dave
// Eve
// Frank
```

**Query syntax equivalent:**

::code-group

```csharp [Method Syntax]
var allEmployees = departments
    .SelectMany(d => d.Employees);
```

```csharp [Query Syntax - Multiple from]
var allEmployees =
    from dept in departments
    from emp in dept.Employees  // Flattening!
    select emp;
```

::

**Cartesian Product (Combinations):**

```csharp {showLineNumbers}
int[] numbers = [1, 2, 3];
char[] letters = ['a', 'b'];

// –í—Å—ñ –∫–æ–º–±—ñ–Ω–∞—Ü—ñ—ó
var combinations = numbers.SelectMany(
    num => letters,              // –î–ª—è –∫–æ–∂–Ω–æ–≥–æ num - –≤—Å—ñ letters
    (num, letter) => $"{num}{letter}"  // Result selector
);

Console.WriteLine(string.Join(", ", combinations));
// Output: 1a, 1b, 2a, 2b, 3a, 3b
```

---

## Sorting (–°–æ—Ä—Ç—É–≤–∞–Ω–Ω—è)

### OrderBy / OrderByDescending

```csharp {showLineNumbers}
List<Product> products = GetProducts();

// Ascending (–∑–∞ –∑—Ä–æ—Å—Ç–∞–Ω–Ω—è–º)
var byPriceAsc = products.OrderBy(p => p.Price);

// Descending (–∑–∞ —Å–ø–∞–¥–∞–Ω–Ω—è–º)
var byPriceDesc = products.OrderByDescending(p => p.Price);

// Query syntax
var querySorted = from p in products
                  orderby p.Price descending
                  select p;

// –í–∏–≤–µ–¥–µ–º–æ –ø–µ—Ä—à—ñ 5
foreach (var p in byPriceDesc.Take(5))
{
    Console.WriteLine($"{p.Name}: ${p.Price}");
}
```

---

### ThenBy / ThenByDescending - –í—Ç–æ—Ä–∏–Ω–Ω–µ Sorting

**Use case**: –ö–æ–ª–∏ primary keys –æ–¥–Ω–∞–∫–æ–≤—ñ, —Å–æ—Ä—Ç—É–≤–∞—Ç–∏ –∑–∞ secondary key.

```csharp {showLineNumbers}
List<Student> students = GetStudents();

// Primary: Grade (descending), Secondary: Name (ascending)
var sorted = students
    .OrderByDescending(s => s.Grade)  // –°–ø–æ—á–∞—Ç–∫—É –∑–∞ –æ—Ü—ñ–Ω–∫–æ—é
    .ThenBy(s => s.Name);              // –ü–æ—Ç—ñ–º –∑–∞ —ñ–º'—è–º

// Query syntax
var querySorted = from s in students
                  orderby s.Grade descending, s.Name
                  select s;

// –ú–Ω–æ–∂–∏–Ω–Ω—ñ —Ä—ñ–≤–Ω—ñ
var complex = students
    .OrderBy(s => s.Department)         // 1-–π —Ä—ñ–≤–µ–Ω—å
    .ThenByDescending(s => s.Grade)     // 2-–π —Ä—ñ–≤–µ–Ω—å
    .ThenBy(s => s.Age)                 // 3-–π —Ä—ñ–≤–µ–Ω—å
    .ThenBy(s => s.Name);               // 4-–π —Ä—ñ–≤–µ–Ω—å
```

**–ü—Ä–∏–∫–ª–∞–¥ output:**

```
Department: Engineering
  - Name: Alice, Grade: 95, Age: 22
  - Name: Bob, Grade: 95, Age: 23
  - Name: Charlie, Grade: 88, Age: 21

Department: Marketing
  - Name: Dave, Grade: 92, Age: 24
  ...
```

---

## Grouping (–ì—Ä—É–ø—É–≤–∞–Ω–Ω—è)

### GroupBy - –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –ì—Ä—É–ø

**–°–∏–≥–Ω–∞—Ç—É—Ä–∞:**

```csharp
IEnumerable<IGrouping<TKey, TElement>> GroupBy<T, TKey>(
    this IEnumerable<T> source,
    Func<T, TKey> keySelector)
```

**`IGrouping<TKey, TElement>`** - —Ü–µ —Å–ø–µ—Ü—ñ–∞–ª—å–Ω–∏–π —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å:

```csharp
interface IGrouping<out TKey, out TElement> : IEnumerable<TElement>
{
    TKey Key { get; }  // –ö–ª—é—á –≥—Ä—É–ø–∏
}
```

**–ë–∞–∑–æ–≤–µ –≥—Ä—É–ø—É–≤–∞–Ω–Ω—è:**

```csharp {showLineNumbers}
List<Product> products = GetProducts();

// –ì—Ä—É–ø—É–≤–∞–Ω–Ω—è –∑–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ—î—é
IEnumerable<IGrouping<string, Product>> byCategory =
    products.GroupBy(p => p.Category);

foreach (var group in byCategory)
{
    Console.WriteLine($"\nCategory: {group.Key}");

    foreach (var product in group)
    {
        Console.WriteLine($"  - {product.Name}: ${product.Price}");
    }
}

// Output:
// Category: Electronics
//   - Laptop: $1200
//   - Mouse: $25
// Category: Books
//   - C# Guide: $45
//   - LINQ Mastery: $38
```

**–ì—Ä—É–ø—É–≤–∞–Ω–Ω—è –∑ –∞–≥—Ä–µ–≥–∞—Ü—ñ—î—é:**

```csharp {showLineNumbers}
var categoryStats = products
    .GroupBy(p => p.Category)
    .Select(g => new {
        Category = g.Key,
        Count = g.Count(),
        TotalValue = g.Sum(p => p.Price),
        AveragePrice = g.Average(p => p.Price),
        MostExpensive = g.Max(p => p.Price),
        CheapestName = g.OrderBy(p => p.Price).First().Name
    });

foreach (var stat in categoryStats)
{
    Console.WriteLine($"{stat.Category}:");
    Console.WriteLine($"  Products: {stat.Count}");
    Console.WriteLine($"  Total: ${stat.TotalValue}");
    Console.WriteLine($"  Avg: ${stat.AveragePrice:F2}");
}
```

**Query syntax:**

```csharp {showLineNumbers}
var queryGrouped =
    from p in products
    group p by p.Category into g  // 'into' creates IGrouping
    select new {
        Category = g.Key,
        Products = g.ToList(),
        TotalValue = g.Sum(p => p.Price)
    };
```

**Nested queries –Ω–∞ groups:**

```csharp {showLineNumbers}
// –¢–æ–ø-3 products —É –∫–æ–∂–Ω—ñ–π –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
var topPerCategory = products
    .GroupBy(p => p.Category)
    .Select(g => new {
        Category = g.Key,
        TopProducts = g.OrderByDescending(p => p.Price)
                       .Take(3)
                       .Select(p => p.Name)
                       .ToList()
    });
```

---

## Joins (–ó'—î–¥–Ω–∞–Ω–Ω—è)

### Inner Join

–ü–æ—î–¥–Ω—É—î –¥–≤–∞ sequences –∑–∞ shared key:

::code-group

```csharp [Method Syntax] {showLineNumbers}
class Customer
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
}

class Order
{
    public int CustomerId { get; set; }
    public DateTime Date { get; set; }
    public decimal TotalAmount { get; set; }
}

static List<Customer> GetCustomers()
{
    return
    [
        new Customer { Id = 1, Name = "John Doe" },
        new Customer { Id = 2, Name = "Jane Smith" },
        new Customer { Id = 3, Name = "Bob Johnson" },
    ];
}

static List<Order> GetOrders()
{
    return
    [
        new Order { CustomerId = 1, Date = DateTime.Parse("2024-01-15"), TotalAmount = 299.99m },
        new Order { CustomerId = 1, Date = DateTime.Parse("2024-02-20"), TotalAmount = 150.00m },
        new Order { CustomerId = 2, Date = DateTime.Parse("2024-01-10"), TotalAmount = 450.50m },
        new Order { CustomerId = 3, Date = DateTime.Parse("2024-03-05"), TotalAmount = 89.99m },
    ];
}

List<Customer> customers = GetCustomers();
List<Order> orders = GetOrders();

var customerOrders = customers.Join(
    orders,                      // Inner sequence
    c => c.Id,                   // Outer key selector
    o => o.CustomerId,           // Inner key selector
    (c, o) => new {              // Result selector
        CustomerName = c.Name,
        OrderDate = o.Date,
        Amount = o.TotalAmount
    }
);

foreach (var item in customerOrders)
{
    Console.WriteLine($"{item.CustomerName}: {item.Amount} on {item.OrderDate}");
}
```

```csharp [Query Syntax] {showLineNumbers}
var customerOrders =
    from c in customers
    join o in orders on c.Id equals o.CustomerId
    select new {
        CustomerName = c.Name,
        OrderDate = o.Date,
        Amount = o.TotalAmount
    };
```

::

---

### Group Join

–ó–≤'—è–∑—É—î –∫–æ–∂–µ–Ω outer element –∑ **–≥—Ä—É–ø–æ—é** matching inner elements:

```csharp {showLineNumbers}
var customersWithOrders = customers.GroupJoin(
    orders,
    c => c.Id,
    o => o.CustomerId,
    (customer, customerOrders) => new {
        Customer = customer.Name,
        OrdersCount = customerOrders.Count(),
        Orders = customerOrders.ToList()
    }
);

foreach (var item in customersWithOrders)
{
    Console.WriteLine($"{item.Customer}: {item.OrdersCount} orders");
    foreach (var order in item.Orders)
    {
        Console.WriteLine($"  - {order.Date}: ${order.TotalAmount}");
    }
}

// Query syntax
var queryGroupJoin =
    from c in customers
    join o in orders on c.Id equals o.CustomerId into customerOrders
    select new {
        Customer = c.Name,
        Orders = customerOrders.ToList()
    };
```

---

### Left Outer Join Pattern

LINQ –Ω–µ–º–∞—î –≤–±—É–¥–æ–≤–∞–Ω–æ–≥–æ left join, –∞–ª–µ –π–æ–≥–æ –º–æ–∂–Ω–∞ –µ–º—É–ª—é–≤–∞—Ç–∏ —á–µ—Ä–µ–∑ **`DefaultIfEmpty()`**:

```csharp {showLineNumbers}
// Left join: –≤—Å—ñ customers, –Ω–∞–≤—ñ—Ç—å –±–µ–∑ orders
var leftJoin =
    from c in customers
    join o in orders on c.Id equals o.CustomerId into customerOrders
    from order in customerOrders.DefaultIfEmpty()  // Key part!
    select new {
        CustomerName = c.Name,
        OrderDate = order?.Date,         // Nullable!
        Amount = order?.TotalAmount ?? 0  // Handle null
    };

// Method syntax
var leftJoinMethod = customers
    .GroupJoin(orders, c => c.Id, o => o.CustomerId,
        (c, orders) => new { Customer = c, Orders = orders })
    .SelectMany(
        x => x.Orders.DefaultIfEmpty(),
        (x, order) => new {
            CustomerName = x.Customer.Name,
            OrderDate = order?.Date,
            Amount = order?.TotalAmount ?? 0
        }
    );
```

| Join Type           | –†–µ–∑—É–ª—å—Ç–∞—Ç                         | Use Case                          |
| :------------------ | :-------------------------------- | :-------------------------------- |
| **Inner Join**      | –¢—ñ–ª—å–∫–∏ matching pairs             | Orders –∑ customers                |
| **Group Join**      | Outer + grouped inner             | Customers –∑ —ó—Ö orders lists       |
| **Left Outer Join** | All outer + matched inner (nulls) | All customers (–Ω–∞–≤—ñ—Ç—å –±–µ–∑ orders) |

---

## Aggregation (–ê–≥—Ä–µ–≥–∞—Ü—ñ—è)

### Standard Aggregates

```csharp {showLineNumbers}
List<int> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// –ë–∞–∑–æ–≤—ñ aggregates
int sum = numbers.Sum();                    // 55
int count = numbers.Count();                // 10
int max = numbers.Max();                    // 10
int min = numbers.Min();                    // 1
double average = numbers.Average();         // 5.5

// –ó predicate
int evenCount = numbers.Count(n => n % 2 == 0);   // 5
int evenSum = numbers.Where(n => n % 2 == 0).Sum(); // 30

// LongCount –¥–ª—è –≤–µ–ª–∏–∫–∏—Ö –∫–æ–ª–µ–∫—Ü—ñ–π
long bigCount = veryLargeCollection.LongCount();

// –ù–∞ –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—è—Ö
List<Product> products = GetProducts();
decimal totalValue = products.Sum(p => p.Price);
decimal avgPrice = products.Average(p => p.Price);
```

---

### MaxBy / MinBy (.NET 6+)

–ó–Ω–∞—Ö–æ–¥–∏—Ç—å **–µ–ª–µ–º–µ–Ω—Ç** –∑ max/min –∑–Ω–∞—á–µ–Ω–Ω—è–º –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—ñ (–æ–¥–∏–Ω –ø—Ä–æ—Ö—ñ–¥!):

```csharp {showLineNumbers}
List<Product> products = GetProducts();

// –°—Ç–∞—Ä–∏–π —Å–ø–æ—Å—ñ–± (–Ω–µ–µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ - –¥–≤–∞ –ø—Ä–æ—Ö–æ–¥–∏)
decimal maxPrice = products.Max(p => p.Price);
var mostExpensiveOld = products.First(p => p.Price == maxPrice);

// –ù–æ–≤–∏–π —Å–ø–æ—Å—ñ–± (.NET 6+, –æ–¥–∏–Ω –ø—Ä–æ—Ö—ñ–¥)
Product? mostExpensive = products.MaxBy(p => p.Price);
Product? cheapest = products.MinBy(p => p.Price);

Console.WriteLine($"Most expensive: {mostExpensive?.Name} (${mostExpensive?.Price})");

// –ó —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ñ—î—é
var bestElectronics = products
    .Where(p => p.Category == "Electronics")
    .MaxBy(p => p.Rating);
```

---

### Aggregate - Custom Accumulator

–£–Ω—ñ–≤–µ—Ä—Å–∞–ª—å–Ω–∏–π –æ–ø–µ—Ä–∞—Ç–æ—Ä –¥–ª—è custom aggregation:

```csharp {showLineNumbers}
List<int> numbers = [1, 2, 3, 4, 5];

// –î–æ–±—É—Ç–æ–∫ –≤—Å—ñ—Ö —á–∏—Å–µ–ª
int product = numbers.Aggregate((acc, n) => acc * n);
// 1 * 2 = 2, 2 * 3 = 6, 6 * 4 = 24, 24 * 5 = 120

// –ó seed (–ø–æ—á–∞—Ç–∫–æ–≤–∏–º –∑–Ω–∞—á–µ–Ω–Ω—è–º)
int productWithSeed = numbers.Aggregate(1, (acc, n) => acc * n);

// –ó result selector
string concatenated = numbers.Aggregate(
    "",                              // Seed
    (acc, n) => acc + n.ToString(),  // Accumulator
    result => $"Numbers: {result}"   // Result selector
);
// Output: "Numbers: 12345"

// –ü—Ä–∞–∫—Ç–∏—á–Ω–∏–π –ø—Ä–∏–∫–ª–∞–¥: –ø–æ—Å—Ç—Ä–æ—Ü—ñ—è —Å–∫–ª–∞–¥–Ω–æ–≥–æ –æ–±'—î–∫—Ç–∞
List<string> words = ["Hello", "World", "From", "LINQ"];
string sentence = words.Aggregate((acc, word) => $"{acc} {word}");
// "Hello World From LINQ"

// –°–∫–ª–∞–¥–Ω–∞ –∞–≥—Ä–µ–≥–∞—Ü—ñ—è
var stats = numbers.Aggregate(
    new { Sum = 0, Count = 0 },
    (acc, n) => new {
        Sum = acc.Sum + n,
        Count = acc.Count + 1
    },
    acc => new {
        acc.Sum,
        acc.Count,
        Average = (double)acc.Sum / acc.Count
    }
);
```

---

## Set Operations (–ú–Ω–æ–∂–∏–Ω–Ω—ñ –û–ø–µ—Ä–∞—Ü—ñ—ó)

### Distinct / DistinctBy

```csharp {showLineNumbers}
int[] numbers = [1, 2, 2, 3, 3, 3, 4, 5, 5];

var unique = numbers.Distinct();
Console.WriteLine(string.Join(", ", unique));
// Output: 1, 2, 3, 4, 5

// –ù–∞ –æ–±'—î–∫—Ç–∞—Ö (–ø–æ—Ç—Ä–µ–±—É—î Equals/GetHashCode override –∞–±–æ comparer)
List<Product> products = GetProducts();

// .NET 6+: DistinctBy –∑ key selector
var uniqueByCategory = products.DistinctBy(p => p.Category);
var uniqueByPrice = products.DistinctBy(p => p.Price);
```

---

### Union, Intersect, Except

```csharp {showLineNumbers}
int[] setA = [1, 2, 3, 4, 5];
int[] setB = [4, 5, 6, 7, 8];

// Union - –æ–±'—î–¥–Ω–∞–Ω–Ω—è (–±–µ–∑ –¥—É–±–ª—ñ–∫–∞—Ç—ñ–≤)
var union = setA.Union(setB);
Console.WriteLine(string.Join(", ", union));
// Output: 1, 2, 3, 4, 5, 6, 7, 8

// Intersect - –ø–µ—Ä–µ—Ç–∏–Ω (—Å–ø—ñ–ª—å–Ω—ñ –µ–ª–µ–º–µ–Ω—Ç–∏)
var intersect = setA.Intersect(setB);
Console.WriteLine(string.Join(", ", intersect));
// Output: 4, 5

// Except - —Ä—ñ–∑–Ω–∏—Ü—è (A \ B)
var except = setA.Except(setB);
Console.WriteLine(string.Join(", ", except));
// Output: 1, 2, 3

// .NET 6+: By variants
static List<Product> GetProductsA()
{
    return
    [
        new Product { Name = "Laptop", Category = "Electronics" },
        new Product { Name = "Mouse", Category = "Electronics" },
        new Product { Name = "Book", Category = "Books" },
    ];
}

static List<Product> GetProductsB()
{
    return
    [
        new Product { Name = "Mouse", Category = "Electronics" },
        new Product { Name = "Keyboard", Category = "Electronics" },
        new Product { Name = "Novel", Category = "Books" },
    ];
}

List<Product> productsA = GetProductsA();
List<Product> productsB = GetProductsB();

var unionByName = productsA.UnionBy(productsB, p => p.Name);
var intersectByCategory = productsA.IntersectBy(
    productsB.Select(p => p.Category),
    p => p.Category
);
```

::mermaid

```mermaid
graph LR
    subgraph "Set A"
        A1[1]
        A2[2]
        A3[3]
        A4[4]
        A5[5]
    end

    subgraph "Set B"
        B4[4]
        B5[5]
        B6[6]
        B7[7]
        B8[8]
    end

    subgraph "Union A ‚à™ B"
        U[1,2,3,4,5,6,7,8]
    end

    subgraph "Intersect A ‚à© B"
        I[4,5]
    end

    subgraph "Except A \ B"
        E[1,2,3]
    end

    style A4 fill:#f59e0b
    style A5 fill:#f59e0b
    style B4 fill:#f59e0b
    style B5 fill:#f59e0b
```

::

---

## Element Operations

### First / FirstOrDefault

```csharp {showLineNumbers}
List<int> numbers = [1, 2, 3, 4, 5];
List<int> empty = [];

// First - –≤–∏–∫–∏–¥–∞—î exception —è–∫—â–æ empty
int first = numbers.First();  // 1
// int bad = empty.First();   // InvalidOperationException!

// FirstOrDefault - –ø–æ–≤–µ—Ä—Ç–∞—î default —è–∫—â–æ empty
int firstOrDefault = empty.FirstOrDefault();  // 0 (default –¥–ª—è int)

// –ó predicate
int firstEven = numbers.First(n => n % 2 == 0);  // 2
int firstBig = numbers.FirstOrDefault(n => n > 100);  // 0 (–Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ)

// Nullable reference types (.NET 6+)
List<string?> strings = ["a", "b", null];
string? firstString = strings.FirstOrDefault();  // "a"
```

::tip
**Best Practice**: –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ `FirstOrDefault()` –¥–ª—è –±–µ–∑–ø–µ–∫–∏, —è–∫—â–æ –Ω–µ –≤–ø–µ–≤–Ω–µ–Ω—ñ —â–æ collection –Ω–µ –ø–æ—Ä–æ–∂–Ω—è. –ü–µ—Ä–µ–≤—ñ—Ä—è–π—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø–µ—Ä–µ–¥ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è–º.

```csharp
class User { public int Id { get; set; } }
var users = new List<User> { new() { Id = 1 }, new() { Id = 2 } };
int id = 1;
void ProcessUser(User u) { Console.WriteLine($"Processing user {u.Id}"); }

// ‚úÖ –ë–µ–∑–ø–µ—á–Ω–æ
var user = users.FirstOrDefault(u => u.Id == id);
if (user != null)
{
    ProcessUser(user);
}

// ‚ùå –†–∏–∑–∏–∫–æ–≤–∞–Ω–æ
var user = users.First(u => u.Id == id);  // –ú–æ–∂–µ exception!
```

::

---

### Single / SingleOrDefault

–ì–∞—Ä–∞–Ω—Ç—É—î **—Ä—ñ–≤ –Ω–æ –æ–¥–∏–Ω** –µ–ª–µ–º–µ–Ω—Ç:

```csharp {showLineNumbers}
List<int> oneElement = [42];
List<int> multiple = [1, 2, 3];
List<int> empty = [];

// Single - exception —è–∫—â–æ 0 –∞–±–æ >1
int single = oneElement.Single();  // 42
// int bad1 = multiple.Single();   // InvalidOperationException: More than one!
// int bad2 = empty.Single();      // InvalidOperationException: No elements!

// SingleOrDefault
int singleOrDefault = empty.SingleOrDefault();  // 0

// Use case: —É–Ω—ñ–∫–∞–ª—å–Ω–∏–π –∫–ª—é—á lookup
class User { public string Username { get; set; } = ""; }
var users = new List<User> { new() { Username = "admin" }, new() { Username = "guest" } };

User? admin = users.SingleOrDefault(u => u.Username == "admin");
if (admin == null)
{
    throw new Exception("Admin user not found!");
}
```

---

### ElementAt / ElementAtOrDefault

–î–æ—Å—Ç—É–ø –∑–∞ —ñ–Ω–¥–µ–∫—Å–æ–º –¥–ª—è `IEnumerable<T>`:

```csharp {showLineNumbers}
IEnumerable<int> numbers = GetNumbers();  // –ù–µ –æ–±–æ–≤'—è–∑–∫–æ–≤–æ IList!

int third = numbers.ElementAt(2);  // –¢—Ä–µ—Ç—ñ–π –µ–ª–µ–º–µ–Ω—Ç (zero-based)
// int bad = numbers.ElementAt(100);  // ArgumentOutOfRangeException

int safe = numbers.ElementAtOrDefault(100);  // 0
```

---

### Any / All

```csharp {showLineNumbers}
List<int> numbers = [1, 3, 5, 7, 9];

// Any - —á–∏ —î —Ö–æ—á –æ–¥–∏–Ω
bool hasElements = numbers.Any();  // true
bool hasEven = numbers.Any(n => n % 2 == 0);  // false

// All - —á–∏ –≤—Å—ñ –∑–∞–¥–æ–≤–æ–ª—å–Ω—è—é—Ç—å
bool allOdd = numbers.All(n => n % 2 != 0);  // true
bool allPositive = numbers.All(n => n > 0);  // true
bool allLessThan5 = numbers.All(n => n < 5);  // false

// Practical use
var products = GetProducts(); // Using GetProducts() defined earlier
void ShowPremiumProductsSection() { Console.WriteLine("Showing premium products"); }

if (products.Any(p => p.Price > 1000))
{
    ShowPremiumProductsSection();
}

class User { public bool IsVerified { get; set; } }
var users = new List<User> { new() { IsVerified = true }, new() { IsVerified = true } };
void ApproveTransaction() { Console.WriteLine("Transaction approved"); }

if (users.All(u => u.IsVerified))
{
    ApproveTransaction();
}
```

::tip
**Performance**: `Any()` —à–≤–∏–¥—à–∏–π –∑–∞ `Count() > 0`. `Any()` –∑—É–ø–∏–Ω—è—î—Ç—å—Å—è –ø—ñ—Å–ª—è –ø–µ—Ä—à–æ–≥–æ matching –µ–ª–µ–º–µ–Ω—Ç–∞.

```csharp
// ‚úÖ –ï—Ñ–µ–∫—Ç–∏–≤–Ω–æ (short-circuit)
if (expensiveQuery.Any()) { ... }

// ‚ùå –ù–µ–µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ (–ø—ñ–¥—Ä–∞—Ö–æ–≤—É—î –≤—Å—ñ)
if (expensiveQuery.Count() > 0) { ... }
```

::

---

## Pagination —Ç–∞ –Ü–Ω—à—ñ –ö–æ—Ä–∏—Å–Ω—ñ –û–ø–µ—Ä–∞—Ç–æ—Ä–∏

### Take / Skip

```csharp {showLineNumbers}
List<int> numbers = Enumerable.Range(1, 100).ToList();

// –ü–µ—Ä—à—ñ 10
var first10 = numbers.Take(10);

// –ü—Ä–æ–ø—É—Å—Ç–∏—Ç–∏ –ø–µ—Ä—à—ñ 20, –≤–∑—è—Ç–∏ –Ω–∞—Å—Ç—É–ø–Ω—ñ 10 (page 3, size 10)
var page3 = numbers.Skip(20).Take(10);

// TakeLast / SkipLast (.NET Core 2.0+)
var last5 = numbers.TakeLast(5);      // [96, 97, 98, 99, 100]
var exceptLast10 = numbers.SkipLast(10);  // [1..90]

// Pagination helper pattern
int pageNumber = 2;  // 0-based: page 2 = 3rd page
int pageSize = 10;
var products = GetProducts(); // Using GetProducts() defined earlier

var pageData = products
    .OrderBy(p => p.Name)
    .Skip(pageNumber * pageSize)
    .Take(pageSize)
    .ToList();
```

---

### TakeWhile / SkipWhile

```csharp {showLineNumbers}
List<int> numbers = [1, 3, 5, 10, 12, 4, 6];

// TakeWhile - –±–µ—Ä–µ –¥–æ–∫–∏ —É–º–æ–≤–∞ true
var takeWhile = numbers.TakeWhile(n => n < 10);
Console.WriteLine(string.Join(", ", takeWhile));
// Output: 1, 3, 5  (–∑—É–ø–∏–Ω–∏–≤—Å—è –Ω–∞ 10)

// SkipWhile - –ø—Ä–æ–ø—É—Å–∫–∞—î –¥–æ–∫–∏ —É–º–æ–≤–∞ true
var skipWhile = numbers.SkipWhile(n => n < 10);
Console.WriteLine(string.Join(", ", skipWhile));
// Output: 10, 12, 4, 6  (–ø–æ—á–∞–≤ –∑ –ø–µ—Ä—à–æ–≥–æ false)
```

---

### Chunk (.NET 6+)

–†–æ–∑–±–∏–≤–∞—î collection –Ω–∞ batches:

```csharp {showLineNumbers}
int[] numbers = Enumerable.Range(1, 10).ToArray();

// –†–æ–∑–±–∏—Ç–∏ –ø–æ 3
IEnumerable<int[]> chunks = numbers.Chunk(3);

foreach (var chunk in chunks)
{
    Console.WriteLine(string.Join(", ", chunk));
}
// Output:
// 1, 2, 3
// 4, 5, 6
// 7, 8, 9
// 10

// Practical use: batch processing
var products = GetProducts(); // Using GetProducts() defined earlier
Task ProcessBatchAsync(Product[] batch) { Console.WriteLine($"Processing {batch.Length} products"); return Task.CompletedTask; }

var productBatches = products.Chunk(100);
foreach (var batch in productBatches)
{
    await ProcessBatchAsync(batch);
}
```

---

## Best Practices

**1. Use `ToList()` –¥–ª—è Caching**

```csharp
// Query –±—É–¥–µ –≤–∏–∫–æ–Ω—É–≤–∞—Ç–∏—Å—å –æ–¥–∏–Ω —Ä–∞–∑
var numbers = Enumerable.Range(1, 100);
var expensiveQuery = numbers.Where(n => n % 2 == 0);
void ProcessData(List<int> data) { Console.WriteLine($"Processing {data.Count} items"); }
void DisplayData(List<int> data) { Console.WriteLine($"Displaying {data.Count} items"); }

var cached = expensiveQuery.ToList();
ProcessData(cached);
DisplayData(cached);  // –ù–µ –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è –∑–Ω–æ–≤—É
```

**2. Method Syntax - –°—Ç–∞–Ω–¥–∞—Ä—Ç**

```csharp
// –ß–∏—Ç–∞–±–µ–ª—å–Ω–æ —Ç–∞ –ø—ñ–¥—Ç—Ä–∏–º—É–≤–∞–Ω–æ
var products = GetProducts(); // Using GetProducts() defined earlier

var result = products
    .Where(p => p.InStock)
    .OrderByDescending(p => p.Price)
    .Take(10);
```

**3. `FirstOrDefault` –ë–µ–∑–ø–µ—á–Ω—ñ—à–∏–π**

```csharp
class User { public int Id { get; set; } }
var users = new List<User> { new() { Id = 1 } };
int id = 1;

var user = users.FirstOrDefault(u => u.Id == id);
if (user != null) { /* safe */ }
```

**4. `Any()` –ó–∞–º—ñ—Å—Ç—å `Count() > 0`**

```csharp
var products = GetProducts(); // Using GetProducts() defined earlier

// ‚úÖ Short-circuit, –µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ
if (products.Any(p => p.Price > 1000)) { ... }

// ‚ùå –ü—ñ–¥—Ä–∞—Ö–æ–≤—É—î –≤—Å—ñ
if (products.Count(p => p.Price > 1000) > 0) { ... }
```

**5. –ù–µ –ú–æ–¥–∏—Ñ—ñ–∫—É–π—Ç–µ Collection –ø—ñ–¥ —á–∞—Å LINQ**

```csharp
// ‚ùå –ü–û–ì–ê–ù–û
foreach (var item in list.Where(x => x.IsOld))
{
    list.Remove(item);  // InvalidOperationException!
}

// ‚úÖ –î–û–ë–†–ï
var toRemove = list.Where(x => x.IsOld).ToList();
foreach (var item in toRemove)
{
    list.Remove(item);
}
```

**6. Deferred vs Immediate Decision**

```text
Deferred –∫–æ–ª–∏:
- –û–¥–Ω–æ—Ä–∞–∑–æ–≤–∞ —ñ—Ç–µ—Ä–∞—Ü—ñ—è
- Pipeline transformations
- –ü–æ—Ç—Ä—ñ–±–Ω—ñ –∞–∫—Ç—É–∞–ª—å–Ω—ñ –¥–∞–Ω—ñ

Immediate (ToList()) –∫–æ–ª–∏:
- –ú–Ω–æ–∂–∏–Ω–Ω—ñ —ñ—Ç–µ—Ä–∞—Ü—ñ—ó
- –î–æ—Ä–æ–≥–∏–π query
- Snapshot –¥–∞–Ω–∏—Ö
```

---

## Troubleshooting

_InvalidOperationException: Sequence contains no elements_
::collapsible
**–ü—Ä–∏—á–∏–Ω–∞:** `First()` –∞–±–æ `Single()` –Ω–∞ empty sequence.

**–†—ñ—à–µ–Ω–Ω—è:**

```csharp
class User { public int Id { get; set; } }
var users = new List<User>();
int id = 1;

// –ó–∞–º—ñ—Å—Ç—å First() ‚Üí FirstOrDefault()
var user = users.FirstOrDefault(u => u.Id == id);
if (user == null)
{
    // Handle not found
}
```

::
_InvalidOperationException: Sequence contains more than one element_
::collapsible
**–ü—Ä–∏—á–∏–Ω–∞:** `Single()` –∑–Ω–∞–π—à–æ–≤ >1 matching elements.

**–†—ñ—à–µ–Ω–Ω—è:**

```csharp
class User { public string Role { get; set; } = ""; }
var users = new List<User> { new() { Role = "Admin" }, new() { Role = "User" } };

// –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ —É–º–æ–≤—É –∞–±–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ First()
var admin = users.FirstOrDefault(u => u.Role == "Admin");
// –∞–±–æ –ø–µ—Ä–µ–∫–æ–Ω–∞–π—Ç–µ—Å—å —â–æ —Ç—ñ–ª—å–∫–∏ –æ–¥–∏–Ω admin
```

::

_NullReferenceException –≤ projection_
::collapsible
**–ü—Ä–∏—á–∏–Ω–∞:** –î–æ—Å—Ç—É–ø –¥–æ `null` –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç–µ–π.

**–†—ñ—à–µ–Ω–Ω—è:**

```csharp
class Address { public string City { get; set; } = ""; }
class User { public Address? Address { get; set; } }
var users = new List<User> { new() { Address = new() { City = "Kyiv" } }, new() { Address = null } };

// Null-conditional operator
var cities = users.Select(u => u.Address?.City ?? "Unknown");
```

::

_Collection was modified; enumeration operation may not execute_
::collapsible
**–ü—Ä–∏—á–∏–Ω–∞:** –ú–æ–¥–∏—Ñ—ñ–∫–∞—Ü—ñ—è collection –ø—ñ–¥ —á–∞—Å foreach.

**–†—ñ—à–µ–Ω–Ω—è:**

```csharp
var list = new List<int> { 1, 2, 3, 4, 5 };
Bool predicate(int x) => x > 2;

// Materialize –ø–µ—Ä–µ–¥ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ü—ñ—î—é
var itemsToRemove = list.Where(predicate).ToList();
foreach (var item in itemsToRemove)
{
    list.Remove(item);
}
```

::

---

## –ü—Ä–∞–∫—Ç–∏—á–Ω—ñ –ó–∞–≤–¥–∞–Ω–Ω—è

::badge
Beginner
::

### –ó–∞–≤–¥–∞–Ω–Ω—è 1: Top Products

–ó–Ω–∞–π–¥—ñ—Ç—å —Ç–æ–ø-5 –Ω–∞–π–¥–æ—Ä–æ–∂—á–∏—Ö –ø—Ä–æ–¥—É–∫—Ç—ñ–≤ –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó "Electronics", –≤—ñ–¥—Å–æ—Ä—Ç–æ–≤–∞–Ω–∏—Ö –∑–∞ —Ü—ñ–Ω–æ—é (descending).

```csharp
List<Product> products = GetProducts();

// Your solution here
```

**–û—á—ñ–∫ —É–≤–∞–Ω–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç:** `IEnumerable<Product>` –∑ 5 –µ–ª–µ–º–µ–Ω—Ç–∞–º–∏.

---

::badge
Intermediate
::

### –ó–∞–≤–¥–∞–Ω–Ω—è 2: Pagination Extension

–°—Ç–≤–æ—Ä—ñ—Ç—å extension method `Paginate<T>()`:

```csharp
public static class LinqExtensions
{
    public static IEnumerable<T> Paginate<T>(
        this IEnumerable<T> source,
        int pageNumber,
        int pageSize)
    {
        // Your implementation
    }
}

// Usage:
var page2 = products.Paginate(pageNumber: 2, pageSize: 10);
```

---

::badge
Advanced
::

### –ó–∞–≤–¥–∞–Ω–Ω—è 3: Custom DistinctBy

–†–µ–∞–ª—ñ–∑—É–π—Ç–µ `DistinctBy<T, TKey>()` —Å–∞–º–æ—Å—Ç—ñ–π–Ω–æ (–±–µ–∑ .NET 6 API):

```csharp
public static IEnumerable<T> DistinctBy<T, TKey>(
    this IEnumerable<T> source,
    Func<T, TKey> keySelector)
{
    // Use yield return and HashSet for tracking
}

// Usage:
var uniqueByCategory = products.DistinctBy(p => p.Category);
```

---

::badge
Expert
::

### –ó–∞–≤–¥–∞–Ω–Ω—è 4: Complex Analytics

–°—Ç–≤–æ—Ä—ñ—Ç—å query, —è–∫–∏–π –¥–ª—è –∫–æ–∂–Ω–æ—ó –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó –ø—Ä–æ–¥—É–∫—Ç—ñ–≤:

-   –ó–Ω–∞—Ö–æ–¥–∏—Ç—å —Ç–æ–ø-3 –∑–∞ —Ü—ñ–Ω–æ—é
-   –†–∞—Ö—É—î —Å–µ—Ä–µ–¥–Ω—é —Ü—ñ–Ω—É
-   –í–∏–∑–Ω–∞—á–∞—î % –≤—ñ–¥ –∑–∞–≥–∞–ª—å–Ω–æ—ó –≤–∞—Ä—Ç–æ—Å—Ç—ñ –≤—Å—ñ—Ö –ø—Ä–æ–¥—É–∫—Ç—ñ–≤
-   –°–æ—Ä—Ç—É—î –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó –∑–∞ –∑–∞–≥–∞–ª—å–Ω–æ—é –≤–∞—Ä—Ç—ñ—Å—Ç—é

**–†–µ–∑—É–ª—å—Ç–∞—Ç:** Nested structure –∑ calculations.

---

## –†–µ–∑—é–º–µ

::note
**–ö–ª—é—á–æ–≤—ñ –∫–æ–Ω—Ü–µ–ø—Ü—ñ—ó LINQ:**

‚úÖ **–î–≤–∞ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∏**: Query (SQL-like) —Ç–∞ Method (Fluent API)  
‚úÖ **Deferred Execution**: Queries –≤–∏–∫–æ–Ω—É—é—Ç—å—Å—è –ø—Ä–∏ enumeration, not creation  
‚úÖ **Iterator Pattern**: `yield return` –ø—ñ–¥ –∫–∞–ø–æ—Ç–æ–º –¥–ª—è lazy evaluation  
‚úÖ **Materializing**: `ToList()`, `ToArray()` –¥–ª—è immediate execution —Ç–∞ caching

**–û—Å–Ω–æ–≤–Ω—ñ –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó –æ–ø–µ—Ä–∞—Ç–æ—Ä—ñ–≤:**

-   **Filtering**: `Where`, `OfType`
-   **Projection**: `Select`, `SelectMany`
-   **Sorting**: `OrderBy`, `ThenBy`
-   **Grouping**: `GroupBy` –∑ `IGrouping<TKey, T>`
-   **Joins**: Inner, Group, Left Outer patterns
-   **Aggregation**: `Sum`, `Count`, `Average`, `MaxBy`, `MinBy`, `Aggregate`
-   **Set Operations**: `Distinct`, `Union`, `Intersect`, `Except`
-   **Element**: `First`, `Single`, `Any`, `All`, `ElementAt`
-   **Pagination**: `Take`, `Skip`, `Chunk`

**Performance Tips:**

-   Use `ToList()` –¥–ª—è multiple enumerations
-   `Any()` > `Count() > 0`
-   `FirstOrDefault()` –±–µ–∑–ø–µ—á–Ω—ñ—à–∏–π –∑–∞ `First()`
-   Method syntax —É–Ω—ñ–≤–µ—Ä—Å–∞–ª—å–Ω—ñ—à–∏–π

::

**–ù–∞—Å—Ç—É–ø–Ω—ñ —Ç–µ–º–∏:**

-   üìñ [Async Programming](/csharp/advanced-core/async-await) - –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ñ—Å—Ç—å –∑ LINQ
-   üìñ [Expression Trees](/csharp/advanced-core/expression-trees) - –Ø–∫ –ø—Ä–∞—Ü—é—î IQueryable
-   üìñ [System Internals](/csharp/system-internals-concurrency/memory-management) - Performance deep dive

–í–∏ –æ–ø–∞–Ω—É–≤–∞–ª–∏ LINQ - –æ–¥–∏–Ω –∑ –Ω–∞–π–ø–æ—Ç—É–∂–Ω—ñ—à–∏—Ö —ñ–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ñ–≤ C# –¥–ª—è —Ä–æ–±–æ—Ç–∏ –∑ –¥–∞–Ω–∏–º–∏! üéâ
