---
title: Synchronization Primitives
description: –ì–ª–∏–±–æ–∫–∏–π —Ä–æ–∑–±—ñ—Ä –ø—Ä–∏–º—ñ—Ç–∏–≤—ñ–≤ —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—ó –≤ .NET - lock, Monitor, Mutex, Semaphore, AutoResetEvent, Interlocked —Ç–∞ Volatile
---

# Synchronization Primitives (–ü—Ä–∏–º—ñ—Ç–∏–≤–∏ –°–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—ó)

## –í—Å—Ç—É–ø —Ç–∞ –ö–æ–Ω—Ç–µ–∫—Å—Ç

### –ü—Ä–æ–±–ª–µ–º–∞: –ß–æ–º—É –ü–æ—Ç—Ä—ñ–±–Ω–∞ –°–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—è?

–£—è–≤—ñ—Ç—å, —â–æ –≤–∏ —Ä–æ–∑—Ä–æ–±–ª—è—î—Ç–µ –±–∞–Ω–∫—ñ–≤—Å—å–∫—É —Å–∏—Å—Ç–µ–º—É. –î–≤–∞ –ø–æ—Ç–æ–∫–∏ –æ–¥–Ω–æ—á–∞—Å–Ω–æ –æ–±—Ä–æ–±–ª—è—é—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—ó –¥–ª—è –æ–¥–Ω–æ–≥–æ —Ä–∞—Ö—É–Ω–∫—É:

```csharp
// ‚ùå –ù–ï–ë–ï–ó–ü–ï–ß–ù–ò–ô –ö–û–î: Race Condition
public class BankAccount
{
    private decimal _balance = 1000;

    public void Withdraw(decimal amount)
    {
        if (_balance >= amount)           // Thread A: 1000 >= 500? –¢–∞–∫!
        {                                  // Thread B: 1000 >= 600? –¢–∞–∫!
            Thread.Sleep(1);               // –°–∏–º—É–ª—è—Ü—ñ—è –∑–∞—Ç—Ä–∏–º–∫–∏
            _balance -= amount;            // Thread A: 1000 - 500 = 500
        }                                  // Thread B: 500 - 600 = -100 ‚ùå
    }
}
```

**–©–æ —Å—Ç–∞–ª–æ—Å—å?**

1. **Thread A** –ø–µ—Ä–µ–≤—ñ—Ä—è—î –±–∞–ª–∞–Ω—Å: 1000 >= 500 ‚úì
2. **Thread B** –ø–µ—Ä–µ–≤—ñ—Ä—è—î –±–∞–ª–∞–Ω—Å: 1000 >= 600 ‚úì (—â–µ –Ω–µ –∑–º—ñ–Ω–µ–Ω–∏–π!)
3. Thread A –∑–Ω—ñ–º–∞—î 500: –±–∞–ª–∞–Ω—Å = 500
4. Thread B –∑–Ω—ñ–º–∞—î 600: –±–∞–ª–∞–Ω—Å = **-100** üò±

–¶–µ –∫–ª–∞—Å–∏—á–Ω–∏–π –ø—Ä–∏–∫–ª–∞–¥ **Race Condition (—Å—Ç–∞–Ω –≥–æ–Ω–∫–∏)** ‚Äî —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ –ø–æ—Ä—è–¥–∫—É –≤–∏–∫–æ–Ω–∞–Ω–Ω—è –ø–æ—Ç–æ–∫—ñ–≤, —è–∫–∏–π –Ω–µ–¥–µ—Ç–µ—Ä–º—ñ–Ω–æ–≤–∞–Ω–∏–π.

::warning
**–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞**: –ó–∞ –¥–æ—Å–ª—ñ–¥–∂–µ–Ω–Ω—è–º–∏ Microsoft, race conditions ‚Äî –æ–¥–Ω–∞ –∑ —Ç—Ä—å–æ—Ö –Ω–∞–π—Å–∫–ª–∞–¥–Ω—ñ—à–∏—Ö –¥–ª—è –¥—ñ–∞–≥–Ω–æ—Å—Ç–∏–∫–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ–π –±–∞–≥—ñ–≤ (—Ä–∞–∑–æ–º –∑ memory leaks —Ç–∞ deadlocks). –í–æ–Ω–∏ —á–∞—Å—Ç–æ –∑'—è–≤–ª—è—é—Ç—å—Å—è –ª–∏—à–µ –ø—ñ–¥ –≤–∏—Å–æ–∫–∏–º –Ω–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è–º —É production.
::

### –¢–∏–ø–∏ –ü—Ä–æ–±–ª–µ–º –ë–∞–≥–∞—Ç–æ–ø–æ—Ç–æ–∫–æ–≤–æ—Å—Ç—ñ

| –ü—Ä–æ–±–ª–µ–º–∞           | –û–ø–∏—Å                               | –ù–∞—Å–ª—ñ–¥–æ–∫                           |
| :----------------- | :--------------------------------- | :--------------------------------- |
| **Race Condition** | –ö–æ–Ω–∫—É—Ä–µ–Ω—Ü—ñ—è –∑–∞ —Å–ø—ñ–ª—å–Ω–∏–π —Ä–µ—Å—É—Ä—Å     | Data corruption, inconsistency     |
| **Deadlock**       | –í–∑–∞—î–º–Ω–µ –±–ª–æ–∫—É–≤–∞–Ω–Ω—è –ø–æ—Ç–æ–∫—ñ–≤         | Program hang (100% CPU –∞–±–æ freeze) |
| **Livelock**       | –ü–æ—Ç–æ–∫–∏ –∞–∫—Ç–∏–≤–Ω—ñ, –∞–ª–µ –Ω–µ –ø—Ä–æ–≥—Ä–µ—Å—É—é—Ç—å | –ù–µ—Å–∫—ñ–Ω—á–µ–Ω–Ω–∏–π —Ü–∏–∫–ª –±–µ–∑ –∫–æ—Ä–∏—Å—Ç—ñ      |
| **Starvation**     | –ü–æ—Ç—ñ–∫ –Ω–µ –æ—Ç—Ä–∏–º—É—î —Ä–µ—Å—É—Ä—Å            | –ó–∞—Ç—Ä–∏–º–∫–∏, timeout failures         |

::mermaid

```mermaid
graph TD
    subgraph "Race Condition"
        A1[Thread A: Read X] --> A2[Thread B: Read X]
        A2 --> A3[Thread A: Write X+1]
        A3 --> A4[Thread B: Write X+1]
        A4 --> A5[Expected: X+2<br/>Actual: X+1]
    end

    subgraph "Deadlock"
        B1[Thread A: Lock Resource 1] --> B2[Thread B: Lock Resource 2]
        B2 --> B3[Thread A: Wait for Resource 2]
        B3 --> B4[Thread B: Wait for Resource 1]
        B4 --> B5[Both Blocked Forever]
    end

    style A5 fill:#ef4444,stroke:#dc2626,color:#ffffff
    style B5 fill:#ef4444,stroke:#dc2626,color:#ffffff
```

::

---

## Lock Statement: –ù–∞–π–ø—Ä–æ—Å—Ç—ñ—à–∏–π –ó–∞—Ö–∏—Å—Ç

### –ë–∞–∑–æ–≤–∏–π –°–∏–Ω—Ç–∞–∫—Å–∏—Å

–ö–ª—é—á–æ–≤–µ —Å–ª–æ–≤–æ `lock` ‚Äî —Ü–µ –Ω–∞–π–ø–æ—à–∏—Ä–µ–Ω—ñ—à–∏–π —Å–ø–æ—Å—ñ–± –∑–∞—Ö–∏—Å—Ç—É –∫—Ä–∏—Ç–∏—á–Ω–∏—Ö —Å–µ–∫—Ü—ñ–π:

```csharp showLineNumbers
public class ThreadSafeCounter
{
    private int _count = 0;
    private readonly object _lock = new object();  // –û–±'—î–∫—Ç –¥–ª—è –±–ª–æ–∫—É–≤–∞–Ω–Ω—è

    public void Increment()
    {
        lock (_lock)  // [!code highlight]
        {
            // –ö—Ä–∏—Ç–∏—á–Ω–∞ —Å–µ–∫—Ü—ñ—è: —Ç—ñ–ª—å–∫–∏ –æ–¥–∏–Ω –ø–æ—Ç—ñ–∫ –æ–¥–Ω–æ—á–∞—Å–Ω–æ
            _count++;
        }
    }

    public int GetCount()
    {
        lock (_lock)
        {
            return _count;
        }
    }
}
```

**–î–µ–∫–æ–º–ø–æ–∑–∏—Ü—ñ—è:**

-   **–†—è–¥–æ–∫ 3**: `_lock` ‚Äî reference type –æ–±'—î–∫—Ç, —è–∫–∏–π —Å–ª—É–≥—É—î "–∑–∞–º–∫–æ–º"
-   **–†—è–¥–æ–∫ 8**: `lock (_lock)` ‚Äî –ø–æ—Ç—ñ–∫ –Ω–∞–º–∞–≥–∞—î—Ç—å—Å—è "–∑–∞—Ö–æ–ø–∏—Ç–∏" –∑–∞–º–æ–∫
-   –Ø–∫—â–æ –∑–∞–º–æ–∫ –≤—ñ–ª—å–Ω–∏–π ‚Üí –ø–æ—Ç—ñ–∫ –≤—Ö–æ–¥–∏—Ç—å —É –∫—Ä–∏—Ç–∏—á–Ω—É —Å–µ–∫—Ü—ñ—é
-   –Ø–∫—â–æ –∑–∞–º–æ–∫ –∑–∞–π–Ω—è—Ç–∏–π ‚Üí –ø–æ—Ç—ñ–∫ **–±–ª–æ–∫—É—î—Ç—å—Å—è** –¥–æ –∑–≤—ñ–ª—å–Ω–µ–Ω–Ω—è

### –ü—ñ–¥ –ö–∞–ø–æ—Ç–æ–º: Lock —è–∫ Monitor

–ö–æ–º–ø—ñ–ª—è—Ç–æ—Ä –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—î `lock` —É –≤–∏–∫–ª–∏–∫–∏ `Monitor`:

::code-group

```csharp [–û—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–∏–π –ö–æ–¥]
lock (_lock)
{
    _count++;
}
```

```csharp [–ü—ñ—Å–ª—è –ö–æ–º–ø—ñ–ª—è—Ü—ñ—ó]
bool lockTaken = false;
try
{
    Monitor.Enter(_lock, ref lockTaken);
    _count++;
}
finally
{
    if (lockTaken)
    {
        Monitor.Exit(_lock);
    }
}
```

::

::note
**–ß–æ–º—É `try-finally`?** –ì–∞—Ä–∞–Ω—Ç—É—î –∑–≤—ñ–ª—å–Ω–µ–Ω–Ω—è lock –Ω–∞–≤—ñ—Ç—å –ø—Ä–∏ –≤–∏–Ω—è—Ç–∫—É. –ë–µ–∑ —Ü—å–æ–≥–æ –ø–æ—Ç—ñ–∫ –º—ñ–≥ –±–∏ "–∑–∞–±—É—Ç–∏" –∑–≤—ñ–ª—å–Ω–∏—Ç–∏ –∑–∞–º–æ–∫, –∑–∞–±–ª–æ–∫—É–≤–∞–≤—à–∏ —ñ–Ω—à—ñ –ø–æ—Ç–æ–∫–∏ –Ω–∞–∑–∞–≤–∂–¥–∏.
::

### –ü—Ä–∞–≤–∏–ª–∞ –í–∏–±–æ—Ä—É Lock Object

| –ü—Ä–∞–≤–∏–ª–æ              | ‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ                             | ‚ùå –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ                                                         |
| :------------------- | :--------------------------------------- | :--------------------------------------------------------------------- |
| **–ü—Ä–∏–≤–∞—Ç–Ω–∏–π –æ–±'—î–∫—Ç** | `private readonly object _lock = new();` | `lock(this)` ‚Äî –∑–æ–≤–Ω—ñ—à–Ω—ñ–π –∫–æ–¥ –º–æ–∂–µ –∑–∞–±–ª–æ–∫—É–≤–∞—Ç–∏ –≤–∞—à –æ–±'—î–∫—Ç               |
| **Reference type**   | `object`, `class instance`               | `lock(5)` ‚Äî value types –Ω–µ –ø—Ä–∞—Ü—é—é—Ç—å                                    |
| **Readonly**         | `readonly object _lock`                  | –ú–æ–∂–ª–∏–≤–µ –ø–µ—Ä–µ–ø—Ä–∏–∑–Ω–∞—á–µ–Ω–Ω—è                                                |
| **–ù–µ string**        | `object`                                 | `lock("myLock")` ‚Äî string interning –º–æ–∂–µ —Å–ø—Ä–∏—á–∏–Ω–∏—Ç–∏ unexpected sharing |
| **Dedicated object** | –û–∫—Ä–µ–º–∏–π –æ–±'—î–∫—Ç –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ —Ä–µ—Å—É—Ä—Å—É       | –û–¥–∏–Ω lock –¥–ª—è –≤—Å—å–æ–≥–æ –∫–ª–∞—Å—É                                             |

::caution
**–¢–∏–ø–æ–≤–∞ –ü–æ–º–∏–ª–∫–∞: lock(this)**

```csharp
public class BadExample
{
    public void DoWork()
    {
        lock (this)  // ‚ùå –ü–û–ì–ê–ù–û!
        {
            // –ó–æ–≤–Ω—ñ—à–Ω—ñ–π –∫–æ–¥ –º–æ–∂–µ –∑—Ä–æ–±–∏—Ç–∏:
            // lock(badExampleInstance) { ... }
            // —ñ –∑–∞–±–ª–æ–∫—É–≤–∞—Ç–∏ –≤–∞—à –º–µ—Ç–æ–¥!
        }
    }
}
```

::

---

## Monitor Class: –ü–æ–≤–Ω–∏–π –ö–æ–Ω—Ç—Ä–æ–ª—å

`System.Threading.Monitor` –Ω–∞–¥–∞—î –±—ñ–ª—å—à–µ flexibility –Ω—ñ–∂ `lock`:

### Monitor.TryEnter(): Timeout –¥–ª—è Lock

```csharp showLineNumbers
using System;
using System.Threading;

public class ResourceManager
{
    private readonly object _resourceLock = new object();

    public bool TryAccessResource(TimeSpan timeout)
    {
        bool lockTaken = false;

        try
        {
            // –°–ø—Ä–æ–±—É–≤–∞—Ç–∏ –∑–∞—Ö–æ–ø–∏—Ç–∏ lock –∑ timeout
            Monitor.TryEnter(_resourceLock, timeout, ref lockTaken);  // [!code highlight]

            if (lockTaken)
            {
                // –£—Å–ø—ñ—à–Ω–æ –æ—Ç—Ä–∏–º–∞–ª–∏ lock
                ProcessResource();
                return true;
            }
            else
            {
                // Timeout ‚Äî –Ω–µ –≤–¥–∞–ª–æ—Å—å –æ—Ç—Ä–∏–º–∞—Ç–∏ lock
                Console.WriteLine("–ù–µ –≤–¥–∞–ª–æ—Å—å –æ—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø –¥–æ —Ä–µ—Å—É—Ä—Å—É");
                return false;
            }
        }
        finally
        {
            if (lockTaken)
            {
                Monitor.Exit(_resourceLock);
            }
        }
    }

    private void ProcessResource()
    {
        Console.WriteLine("Processing resource...");
        Thread.Sleep(1000);
    }
}
```

::tip
**Use Case –¥–ª—è TryEnter**: –ö–æ–ª–∏ –≤–∏ –Ω–µ —Ö–æ—á–µ—Ç–µ –±–ª–æ–∫—É–≤–∞—Ç–∏ –ø–æ—Ç—ñ–∫ –Ω–∞–∑–∞–≤–∂–¥–∏ ‚Äî –Ω–∞–ø—Ä–∏–∫–ª–∞–¥, —É real-time —Å–∏—Å—Ç–µ–º–∞—Ö –∞–±–æ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ HTTP requests –∑ timeout.
::

### Monitor.Wait() —Ç–∞ Monitor.Pulse(): –°–∏–≥–Ω–∞–ª—ñ–∑–∞—Ü—ñ—è

–¶—ñ –º–µ—Ç–æ–¥–∏ –¥–æ–∑–≤–æ–ª—è—é—Ç—å –ø–æ—Ç–æ–∫–∞–º **–∫–æ–º—É–Ω—ñ–∫—É–≤–∞—Ç–∏** —á–µ—Ä–µ–∑ —Å–ø—ñ–ª—å–Ω–∏–π lock:

```csharp showLineNumbers
using System;
using System.Collections.Generic;
using System.Threading;

public class BlockingQueue<T>
{
    private readonly Queue<T> _queue = new Queue<T>();
    private readonly object _lock = new object();

    public void Enqueue(T item)
    {
        lock (_lock)
        {
            _queue.Enqueue(item);
            Monitor.Pulse(_lock);  // –°–∏–≥–Ω–∞–ª—ñ–∑—É—î–º–æ –æ–¥–Ω–æ–º—É –æ—á—ñ–∫—É—é—á–æ–º—É –ø–æ—Ç–æ–∫—É  // [!code highlight]
        }
    }

    public T Dequeue()
    {
        lock (_lock)
        {
            // –ß–µ–∫–∞—î–º–æ, –ø–æ–∫–∏ —á–µ—Ä–≥–∞ –Ω–µ –±—É–¥–µ –ø–æ—Ä–æ–∂–Ω—å–æ—é
            while (_queue.Count == 0)
            {
                Monitor.Wait(_lock);  // –ó–≤—ñ–ª—å–Ω—è—î–º–æ lock —Ç–∞ –∑–∞—Å–∏–Ω–∞—î–º–æ  // [!code highlight]
                // –ü—Ä–∏ –ø—Ä–æ–±—É–¥–∂–µ–Ω–Ω—ñ –∑–Ω–æ–≤—É –∑–∞—Ö–æ–ø–ª—é—î–º–æ lock
            }

            return _queue.Dequeue();
        }
    }
}

class Program
{
    static BlockingQueue<int> _queue = new BlockingQueue<int>();

    static void Main()
    {
        // Consumer thread
        Thread consumer = new Thread(() =>
        {
            for (int i = 0; i < 5; i++)
            {
                int item = _queue.Dequeue();
                Console.WriteLine($"Consumed: {item}");
            }
        });

        // Producer thread
        Thread producer = new Thread(() =>
        {
            for (int i = 0; i < 5; i++)
            {
                Thread.Sleep(500);
                _queue.Enqueue(i);
                Console.WriteLine($"Produced: {i}");
            }
        });

        consumer.Start();
        producer.Start();

        consumer.Join();
        producer.Join();
    }
}
```

**–Ø–∫ –ø—Ä–∞—Ü—é—î Wait/Pulse:**

::mermaid

```mermaid
sequenceDiagram
    participant Consumer
    participant Lock
    participant WaitQueue as Wait Queue
    participant Producer

    Consumer->>Lock: Enter lock
    Lock-->>Consumer: Lock acquired
    Consumer->>Consumer: Check: queue empty?
    Consumer->>WaitQueue: Monitor.Wait() - release lock & sleep

    Note over Consumer: Sleeping in wait queue

    Producer->>Lock: Enter lock
    Lock-->>Producer: Lock acquired
    Producer->>Producer: Enqueue item
    Producer->>WaitQueue: Monitor.Pulse()
    WaitQueue-->>Consumer: Wake up (ready queue)
    Producer->>Lock: Exit lock

    Consumer->>Lock: Re-acquire lock
    Lock-->>Consumer: Lock acquired
    Consumer->>Consumer: Dequeue item
    Consumer->>Lock: Exit lock
```

::

::warning
**–í–∞–∂–ª–∏–≤–æ**: –ó–∞–≤–∂–¥–∏ –ø–µ—Ä–µ–≤—ñ—Ä—è–π—Ç–µ —É–º–æ–≤—É —É `while`, –∞ –Ω–µ –≤ `if`!

```csharp
// ‚ùå –ü–û–ì–ê–ù–û: spurious wakeup –º–æ–∂–µ –ø–æ—Ä—É—à–∏—Ç–∏ –ª–æ–≥—ñ–∫—É
if (_queue.Count == 0) Monitor.Wait(_lock);

// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û: –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –ø—ñ—Å–ª—è –∫–æ–∂–Ω–æ–≥–æ –ø—Ä–æ–±—É–¥–∂–µ–Ω–Ω—è
while (_queue.Count == 0) Monitor.Wait(_lock);
```

::

---

## System.Threading.Lock (C# 13)

### –ù–æ–≤–∏–π –¢–∏–ø —É .NET 9

C# 13 –≤–≤–æ–¥–∏—Ç—å –Ω–æ–≤–∏–π —Ç–∏–ø `System.Threading.Lock`, –æ–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω–∏–π –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—ó:

```csharp showLineNumbers
using System;
using System.Threading;

public class Account
{
    private readonly Lock _balanceLock = new();  // –ù–æ–≤–∏–π —Ç–∏–ø Lock  // [!code highlight]
    private decimal _balance;

    public Account(decimal initialBalance) => _balance = initialBalance;

    public decimal Debit(decimal amount)
    {
        lock (_balanceLock)  // –ö–æ–º–ø—ñ–ª—è—Ç–æ—Ä —Ä–æ–∑–ø—ñ–∑–Ω–∞—î Lock —Ç–∏–ø  // [!code highlight]
        {
            if (_balance >= amount)
            {
                _balance -= amount;
                return amount;
            }
            return 0;
        }
    }

    public void Credit(decimal amount)
    {
        lock (_balanceLock)
        {
            _balance += amount;
        }
    }
}
```

### Lock.EnterScope(): –Ø–≤–Ω–∏–π API

```csharp showLineNumbers
using System;
using System.Threading;

public class ResourceController
{
    private readonly Lock _lock = new();

    public void Process()
    {
        // EnterScope() –ø–æ–≤–µ—Ä—Ç–∞—î ref struct, —â–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∑–≤—ñ–ª—å–Ω—è—î—Ç—å—Å—è
        using (Lock.Scope scope = _lock.EnterScope())  // [!code highlight]
        {
            // –ö—Ä–∏—Ç–∏—á–Ω–∞ —Å–µ–∫—Ü—ñ—è
            Console.WriteLine("Processing...");
        }
        // scope.Dispose() –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≤–∏–∫–ª–∏–∫–∞—î Exit
    }
}
```

### –ü–µ—Ä–µ–≤–∞–≥–∏ Lock –Ω–∞–¥ object

| –ê—Å–ø–µ–∫—Ç             | `object` lock             | `System.Threading.Lock`        |
| :----------------- | :------------------------ | :----------------------------- |
| **–ü—Ä–æ–¥—É–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å** | Monitor-based (older API) | –û–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω–∏–π –¥–ª—è —Å—É—á–∞—Å–Ω–∏—Ö CPU |
| **–°–µ–º–∞–Ω—Ç–∏–∫–∞**      | –ù–µ—è–≤–Ω–∞ (–±—É–¥—å-—è–∫–∏–π object) | –Ø–≤–Ω–∞ (dedicated type)          |
| **API**            | –ß–µ—Ä–µ–∑ Monitor class       | –í–±—É–¥–æ–≤–∞–Ω—ñ –º–µ—Ç–æ–¥–∏               |
| **Boxing**         | –ù—ñ                        | –ù—ñ (value-like semantics)      |
| **Code clarity**   | –ú–µ–Ω—à –æ—á–µ–≤–∏–¥–Ω–æ             | –°–∞–º–æ–¥–æ–∫—É–º–µ–Ω—Ç–æ–≤–∞–Ω–∏–π –∫–æ–¥         |

::tip
**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—è**: –î–ª—è –Ω–æ–≤–∏—Ö –ø—Ä–æ—î–∫—Ç—ñ–≤ –Ω–∞ .NET 9+ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ `System.Threading.Lock` –∑–∞–º—ñ—Å—Ç—å `object` –¥–ª—è lock objects.
::

---

## Mutex: Cross-Process Synchronization

### –©–æ —Ç–∞–∫–µ Mutex?

**Mutex (Mutual Exclusion)** ‚Äî –ø—Ä–∏–º—ñ—Ç–∏–≤ —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—ó, —â–æ –º–æ–∂–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏—Å—å –º—ñ–∂ **—Ä—ñ–∑–Ω–∏–º–∏ –ø—Ä–æ—Ü–µ—Å–∞–º–∏**:

| –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞     | lock/Monitor       | Mutex                          |
| :----------------- | :----------------- | :----------------------------- |
| **Scope**          | –û–¥–∏–Ω –ø—Ä–æ—Ü–µ—Å        | –°–∏—Å—Ç–µ–º–∞ (kernel-level)         |
| **–ü—Ä–æ–¥—É–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å** | –®–≤–∏–¥—à–µ (user-mode) | –ü–æ–≤—ñ–ª—å–Ω—ñ—à–µ (kernel transition) |
| **Ownership**      | Thread             | Thread (–∞–ª–µ kernel-tracked)    |
| **Named**          | –ù—ñ                 | –¢–∞–∫ (system-wide)              |

### Local Mutex (In-Process)

```csharp showLineNumbers
using System;
using System.Threading;

class Program
{
    private static Mutex _mutex = new Mutex();  // –õ–æ–∫–∞–ª—å–Ω–∏–π mutex

    static void Main()
    {
        Thread t1 = new Thread(AccessResource);
        Thread t2 = new Thread(AccessResource);

        t1.Start("Thread 1");
        t2.Start("Thread 2");

        t1.Join();
        t2.Join();
    }

    static void AccessResource(object? name)
    {
        Console.WriteLine($"{name}: Waiting for mutex...");

        _mutex.WaitOne();  // –ó–∞—Ö–æ–ø–∏—Ç–∏ mutex  // [!code highlight]
        try
        {
            Console.WriteLine($"{name}: Entered critical section");
            Thread.Sleep(2000);
        }
        finally
        {
            _mutex.ReleaseMutex();  // –ó–≤—ñ–ª—å–Ω–∏—Ç–∏ mutex  // [!code highlight]
            Console.WriteLine($"{name}: Released mutex");
        }
    }
}
```

### Named Mutex: Single Instance Application

–ö–ª–∞—Å–∏—á–Ω–∏–π use case ‚Äî –∑–∞–±–µ–∑–ø–µ—á–∏—Ç–∏, —â–æ —Ç—ñ–ª—å–∫–∏ –æ–¥–∏–Ω –µ–∫–∑–µ–º–ø–ª—è—Ä –ø—Ä–æ–≥—Ä–∞–º–∏ –∑–∞–ø—É—â–µ–Ω–∏–π:

```csharp showLineNumbers
using System;
using System.Threading;

class Program
{
    static void Main()
    {
        // –£–Ω—ñ–∫–∞–ª—å–Ω–µ —ñ–º'—è –¥–ª—è mutex (—á–∞—Å—Ç–æ GUID)
        const string mutexName = "Global\\MyApp_SingleInstance_12345";

        // CreatedNew = true, —è–∫—â–æ mutex —Å—Ç–≤–æ—Ä–µ–Ω–æ –≤–ø–µ—Ä—à–µ
        using Mutex mutex = new Mutex(true, mutexName, out bool createdNew);  // [!code highlight]

        if (!createdNew)
        {
            Console.WriteLine("–Ü–Ω—à–∏–π –µ–∫–∑–µ–º–ø–ª—è—Ä –ø—Ä–æ–≥—Ä–∞–º–∏ –≤–∂–µ –∑–∞–ø—É—â–µ–Ω–∏–π!");
            return;
        }

        Console.WriteLine("–ü—Ä–æ–≥—Ä–∞–º–∞ –∑–∞–ø—É—â–µ–Ω–∞. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å Enter –¥–ª—è –≤–∏—Ö–æ–¥—É...");
        Console.ReadLine();
    }
}
```

**–î–µ–∫–æ–º–ø–æ–∑–∏—Ü—ñ—è:**

-   `true` (–ø–µ—Ä—à–∏–π –∞—Ä–≥—É–º–µ–Ω—Ç) ‚Äî —Å–ø—Ä–æ–±—É–≤–∞—Ç–∏ –æ–¥—Ä–∞–∑—É –∑–∞—Ö–æ–ø–∏—Ç–∏ mutex
-   `mutexName` ‚Äî —Å–∏—Å—Ç–µ–º–Ω–µ —ñ–º'—è (Global\\ –¥–ª—è –≤—Å—ñ—Ö —Å–µ—Å—ñ–π, Local\\ –¥–ª—è –ø–æ—Ç–æ—á–Ω–æ—ó)
-   `createdNew` ‚Äî `true` —è–∫—â–æ –º–∏ —Å—Ç–≤–æ—Ä–∏–ª–∏ mutex, `false` —è–∫—â–æ –≤—ñ–Ω –≤–∂–µ —ñ—Å–Ω—É–≤–∞–≤

::warning
**–í–∞–∂–ª–∏–≤–æ**: –ó–∞–≤–∂–¥–∏ –∑–≤—ñ–ª—å–Ω—è–π—Ç–µ mutex! –Ø–∫—â–æ –ø—Ä–æ—Ü–µ—Å –∞–≤–∞—Ä—ñ–π–Ω–æ –∑–∞–≤–µ—Ä—à–∏—Ç—å—Å—è –±–µ–∑ `ReleaseMutex()`, —Å–∏—Å—Ç–µ–º–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –ø–æ–∑–Ω–∞—á–∏—Ç—å mutex —è–∫ **abandoned**, —ñ –Ω–∞—Å—Ç—É–ø–Ω–∏–π `WaitOne()` –∫–∏–Ω–µ `AbandonedMutexException`.
::

---

## Semaphore: –û–±–º–µ–∂–µ–Ω–Ω—è Concurrency

### –ö–æ–Ω—Ü–µ–ø—Ü—ñ—è –°–µ–º–∞—Ñ–æ—Ä–∞

**Semaphore** ‚Äî –¥–æ–∑–≤–æ–ª—è—î –æ–±–º–µ–∂–µ–Ω—É –∫—ñ–ª—å–∫—ñ—Å—Ç—å –ø–æ—Ç–æ–∫—ñ–≤ –æ–¥–Ω–æ—á–∞—Å–Ω–æ:

::mermaid

```mermaid
graph LR
    subgraph "Semaphore(3)"
        A[Slot 1: Thread A]
        B[Slot 2: Thread B]
        C[Slot 3: Thread C]
    end

    D[Thread D: Waiting] --> A
    E[Thread E: Waiting] --> B

    style A fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style B fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style C fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style D fill:#f59e0b,stroke:#b45309,color:#ffffff
    style E fill:#f59e0b,stroke:#b45309,color:#ffffff
```

::

### SemaphoreSlim: Lightweight In-Process

```csharp showLineNumbers
using System;
using System.Threading;
using System.Threading.Tasks;

class ConnectionPool
{
    // –ú–∞–∫—Å–∏–º—É–º 5 –æ–¥–Ω–æ—á–∞—Å–Ω–∏—Ö –ø—ñ–¥–∫–ª—é—á–µ–Ω—å
    private readonly SemaphoreSlim _semaphore = new SemaphoreSlim(5, 5);  // [!code highlight]

    public async Task<string> QueryDatabaseAsync(string query)
    {
        Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] Waiting for connection...");

        await _semaphore.WaitAsync();  // Async wait  // [!code highlight]
        try
        {
            Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] Got connection, executing: {query}");
            await Task.Delay(2000);  // –°–∏–º—É–ª—è—Ü—ñ—è –∑–∞–ø–∏—Ç—É
            return $"Result for: {query}";
        }
        finally
        {
            _semaphore.Release();  // –ó–≤—ñ–ª—å–Ω–∏—Ç–∏ slot  // [!code highlight]
            Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] Released connection");
        }
    }
}

class Program
{
    static async Task Main()
    {
        var pool = new ConnectionPool();

        // –ó–∞–ø—É—Å–∫–∞—î–º–æ 10 –ø–∞—Ä–∞–ª–µ–ª—å–Ω–∏—Ö –∑–∞–ø–∏—Ç—ñ–≤
        var tasks = new Task<string>[10];
        for (int i = 0; i < 10; i++)
        {
            tasks[i] = pool.QueryDatabaseAsync($"SELECT * FROM Table{i}");
        }

        await Task.WhenAll(tasks);
    }
}
```

**–ü–∞—Ä–∞–º–µ—Ç—Ä–∏ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞:**

-   `initialCount` ‚Äî —Å–∫—ñ–ª—å–∫–∏ slots –¥–æ—Å—Ç—É–ø–Ω–æ –Ω–∞ —Å—Ç–∞—Ä—Ç—ñ
-   `maxCount` ‚Äî –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å (Release –Ω–µ –º–æ–∂–µ –ø–µ—Ä–µ–≤–∏—â–∏—Ç–∏)

### –ü–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è Semaphore —Ç–∞ SemaphoreSlim

| –ê—Å–ø–µ–∫—Ç            | Semaphore             | SemaphoreSlim              |
| :---------------- | :-------------------- | :------------------------- |
| **Scope**         | Cross-process (named) | In-process only            |
| **Performance**   | Kernel mode (slower)  | User mode (faster)         |
| **Async support** | –ù—ñ                    | ‚úÖ WaitAsync()             |
| **Cancellation**  | –ù—ñ                    | ‚úÖ CancellationToken       |
| **Use case**      | IPC, system resources | Application-level limiting |

::tip
**Rate Limiting Example:**

```csharp
// –û–±–º–µ–∂–µ–Ω–Ω—è –¥–æ 100 requests/second
private readonly SemaphoreSlim _rateLimiter = new SemaphoreSlim(100, 100);

public async Task HandleRequestAsync()
{
    await _rateLimiter.WaitAsync();
    try
    {
        await ProcessRequestAsync();
    }
    finally
    {
        // –ü–æ–≤–µ—Ä–Ω—É—Ç–∏ slot —á–µ—Ä–µ–∑ 1 —Å–µ–∫—É–Ω–¥—É
        _ = Task.Delay(1000).ContinueWith(_ => _rateLimiter.Release());
    }
}
```

::

---

## AutoResetEvent —Ç–∞ ManualResetEvent

### Signaling Mechanism

Events ‚Äî —Ü–µ –º–µ—Ö–∞–Ω—ñ–∑–º **—Å–∏–≥–Ω–∞–ª—ñ–∑–∞—Ü—ñ—ó** –º—ñ–∂ –ø–æ—Ç–æ–∫–∞–º–∏:

| Event                | –ü–æ–≤–µ–¥—ñ–Ω–∫–∞ –ø—ñ—Å–ª—è Signal   | –ê–Ω–∞–ª–æ–≥—ñ—è                            |
| :------------------- | :----------------------- | :---------------------------------- |
| **AutoResetEvent**   | –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ —Å–∫–∏–¥–∞—î—Ç—å—Å—è   | –¢—É—Ä–Ω—ñ–∫–µ—Ç (–æ–¥–∏–Ω –ø—Ä–æ–π—à–æ–≤ ‚Äî –∑–∞–∫—Ä–∏–≤—Å—è)  |
| **ManualResetEvent** | –ó–∞–ª–∏—à–∞—î—Ç—å—Å—è –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–º | –í–æ—Ä–æ—Ç–∞ (–≤—ñ–¥–∫—Ä–∏–ª–∏—Å—å ‚Äî –≤—Å—ñ –ø—Ä–æ—Ö–æ–¥—è—Ç—å) |

### AutoResetEvent

```csharp showLineNumbers
using System;
using System.Threading;

class Program
{
    // false = –ø–æ—á–∞—Ç–∫–æ–≤–∏–π —Å—Ç–∞–Ω "–∑–∞–∫—Ä–∏—Ç–∏–π"
    static AutoResetEvent _event = new AutoResetEvent(false);  // [!code highlight]

    static void Main()
    {
        Thread waiter = new Thread(() =>
        {
            Console.WriteLine("Waiter: Waiting for signal...");
            _event.WaitOne();  // –ë–ª–æ–∫—É—î—Ç—å—Å—è –¥–æ —Å–∏–≥–Ω–∞–ª—É  // [!code highlight]
            Console.WriteLine("Waiter: Got signal!");

            // AutoReset: event –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ —Å–∫–∏–Ω—É–≤—Å—è
            Console.WriteLine("Waiter: Waiting again...");
            _event.WaitOne();  // –ó–Ω–æ–≤—É –±–ª–æ–∫—É—î—Ç—å—Å—è  // [!code highlight]
            Console.WriteLine("Waiter: Got second signal!");
        });

        waiter.Start();
        Thread.Sleep(1000);

        Console.WriteLine("Main: Sending first signal");
        _event.Set();  // [!code highlight]

        Thread.Sleep(1000);

        Console.WriteLine("Main: Sending second signal");
        _event.Set();

        waiter.Join();
    }
}
```

### ManualResetEvent (—Ç–∞ ManualResetEventSlim)

```csharp showLineNumbers
using System;
using System.Threading;

class Program
{
    static ManualResetEventSlim _gate = new ManualResetEventSlim(false);  // [!code highlight]

    static void Main()
    {
        // –ó–∞–ø—É—Å–∫–∞—î–º–æ 5 –ø–æ—Ç–æ–∫—ñ–≤, —â–æ —á–µ–∫–∞—é—Ç—å –Ω–∞ "–≤–æ—Ä–æ—Ç–∞"
        for (int i = 0; i < 5; i++)
        {
            int id = i;
            new Thread(() =>
            {
                Console.WriteLine($"Thread {id}: Waiting at gate...");
                _gate.Wait();  // –í—Å—ñ –ø–æ—Ç–æ–∫–∏ —á–µ–∫–∞—é—Ç—å  // [!code highlight]
                Console.WriteLine($"Thread {id}: Passed through gate!");
            }).Start();
        }

        Thread.Sleep(2000);
        Console.WriteLine("Main: Opening gate...");
        _gate.Set();  // –í—Å—ñ 5 –ø–æ—Ç–æ–∫—ñ–≤ –ø—Ä–æ—Ö–æ–¥—è—Ç—å –æ–¥–Ω–æ—á–∞—Å–Ω–æ!  // [!code highlight]

        Thread.Sleep(1000);
        Console.WriteLine("Main: Closing gate...");
        _gate.Reset();  // –ó–∞–∫—Ä–∏–≤–∞—î–º–æ –≤–æ—Ä–æ—Ç–∞  // [!code highlight]
    }
}
```

::note
**ManualResetEventSlim** ‚Äî –ª–µ–≥—à–∞ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞ –¥–ª—è in-process –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è. –í–æ–Ω–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î spin-waiting –¥–ª—è –∫–æ—Ä–æ—Ç–∫–∏—Ö –æ—á—ñ–∫—É–≤–∞–Ω—å, —â–æ –µ—Ñ–µ–∫—Ç–∏–≤–Ω—ñ—à–µ –∑–∞ kernel transition.
::

### Use Case: Producer-Consumer –∑ Signaling

```csharp showLineNumbers
using System;
using System.Collections.Concurrent;
using System.Threading;

class ProducerConsumer
{
    private readonly ConcurrentQueue<int> _queue = new();
    private readonly AutoResetEvent _itemAvailable = new(false);
    private volatile bool _running = true;

    public void Producer()
    {
        for (int i = 0; i < 10; i++)
        {
            Thread.Sleep(500);
            _queue.Enqueue(i);
            Console.WriteLine($"Produced: {i}");
            _itemAvailable.Set();  // –°–∏–≥–Ω–∞–ª—ñ–∑—É—î–º–æ consumer
        }
        _running = false;
        _itemAvailable.Set();  // –†–æ–∑–±–ª–æ–∫—É–≤–∞—Ç–∏ consumer –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è
    }

    public void Consumer()
    {
        while (_running || !_queue.IsEmpty)
        {
            _itemAvailable.WaitOne(1000);  // Timeout –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ _running

            while (_queue.TryDequeue(out int item))
            {
                Console.WriteLine($"Consumed: {item}");
            }
        }
    }
}
```

---

## Interlocked Operations: Lock-Free Programming

### –ê—Ç–æ–º–∞—Ä–Ω—ñ –û–ø–µ—Ä–∞—Ü—ñ—ó

`System.Threading.Interlocked` –Ω–∞–¥–∞—î **–∞—Ç–æ–º–∞—Ä–Ω—ñ** –æ–ø–µ—Ä–∞—Ü—ñ—ó, —â–æ –Ω–µ –ø–æ—Ç—Ä–µ–±—É—é—Ç—å lock:

```csharp showLineNumbers
using System;
using System.Threading;

class AtomicCounter
{
    private long _count = 0;

    // ‚ùå –ù–ï –∞—Ç–æ–º–∞—Ä–Ω–æ (read-modify-write)
    public void IncrementWrong()
    {
        _count++;  // –ù–∞—Å–ø—Ä–∞–≤–¥—ñ: temp = _count; temp++; _count = temp;
    }

    // ‚úÖ –ê—Ç–æ–º–∞—Ä–Ω–æ
    public void IncrementRight()
    {
        Interlocked.Increment(ref _count);  // [!code highlight]
    }

    public long Value => Interlocked.Read(ref _count);  // –ê—Ç–æ–º–∞—Ä–Ω–µ —á–∏—Ç–∞–Ω–Ω—è –¥–ª—è long
}
```

### –û—Å–Ω–æ–≤–Ω—ñ –ú–µ—Ç–æ–¥–∏ Interlocked

| –ú–µ—Ç–æ–¥                                  | –û–ø–∏—Å                       | –ü—Ä–∏–∫–ª–∞–¥                                 |
| :------------------------------------- | :------------------------- | :-------------------------------------- |
| `Increment(ref int)`                   | +1, –ø–æ–≤–µ—Ä—Ç–∞—î –Ω–æ–≤–µ –∑–Ω–∞—á–µ–Ω–Ω—è | `Interlocked.Increment(ref x)`          |
| `Decrement(ref int)`                   | -1, –ø–æ–≤–µ—Ä—Ç–∞—î –Ω–æ–≤–µ –∑–Ω–∞—á–µ–Ω–Ω—è | `Interlocked.Decrement(ref x)`          |
| `Add(ref int, int)`                    | –î–æ–¥–∞—î –∑–Ω–∞—á–µ–Ω–Ω—è             | `Interlocked.Add(ref x, 5)`             |
| `Exchange(ref int, int)`               | –ó–∞–º—ñ–Ω–∞, –ø–æ–≤–µ—Ä—Ç–∞—î —Å—Ç–∞—Ä–µ     | `old = Interlocked.Exchange(ref x, 10)` |
| `CompareExchange(ref, new, comparand)` | CAS –æ–ø–µ—Ä–∞—Ü—ñ—è               | –î–∏–≤. –Ω–∏–∂—á–µ                              |
| `Read(ref long)`                       | –ê—Ç–æ–º–∞—Ä–Ω–µ —á–∏—Ç–∞–Ω–Ω—è 64-bit    | `Interlocked.Read(ref x)`               |

### CompareExchange: Compare-And-Swap (CAS)

CAS ‚Äî —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω–∞ –æ–ø–µ—Ä–∞—Ü—ñ—è –¥–ª—è lock-free –∞–ª–≥–æ—Ä–∏—Ç–º—ñ–≤:

```csharp showLineNumbers
using System;
using System.Threading;

class SpinLock  // –°–ø—Ä–æ—â–µ–Ω–∞ —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—è
{
    private int _locked = 0;  // 0 = –≤—ñ–ª—å–Ω–∏–π, 1 = –∑–∞–π–Ω—è—Ç–∏–π

    public void Enter()
    {
        // –°–ø—Ä–æ–±—É–≤–∞—Ç–∏ –∑–∞–º—ñ–Ω–∏—Ç–∏ 0 –Ω–∞ 1
        while (Interlocked.CompareExchange(ref _locked, 1, 0) != 0)  // [!code highlight]
        {
            // –Ø–∫—â–æ –Ω–µ –≤–¥–∞–ª–æ—Å—å ‚Äî —Ö—Ç–æ—Å—å —ñ–Ω—à–∏–π —Ç—Ä–∏–º–∞—î lock
            Thread.SpinWait(10);  // –ö–æ—Ä–æ—Ç–∫–µ –æ—á—ñ–∫—É–≤–∞–Ω–Ω—è
        }
    }

    public void Exit()
    {
        Interlocked.Exchange(ref _locked, 0);
    }
}
```

**–Ø–∫ –ø—Ä–∞—Ü—é—î CompareExchange:**

```
CompareExchange(ref location, newValue, comparand):

1. –ê—Ç–æ–º–∞—Ä–Ω–æ —á–∏—Ç–∞—î location
2. –Ø–∫—â–æ location == comparand:
   - –ó–∞–ø–∏—Å—É—î newValue –≤ location
   - –ü–æ–≤–µ—Ä—Ç–∞—î —Å—Ç–∞—Ä–µ –∑–Ω–∞—á–µ–Ω–Ω—è (comparand)
3. –Ø–∫—â–æ location != comparand:
   - –ù—ñ—á–æ–≥–æ –Ω–µ –∑–º—ñ–Ω—é—î
   - –ü–æ–≤–µ—Ä—Ç–∞—î –ø–æ—Ç–æ—á–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è location
```

### Lock-Free Max Update

```csharp showLineNumbers
using System;
using System.Threading;

class ThreadSafeMax
{
    private int _max = int.MinValue;

    public void UpdateIfGreater(int value)
    {
        int current;
        do
        {
            current = _max;
            if (value <= current)
                return;  // –ù–µ –ø–æ—Ç—Ä—ñ–±–Ω–æ –æ–Ω–æ–≤–ª—é–≤–∞—Ç–∏

        } while (Interlocked.CompareExchange(ref _max, value, current) != current);  // [!code highlight]
        // –Ø–∫—â–æ CAS –Ω–µ –≤–¥–∞–≤—Å—è ‚Äî —Ö—Ç–æ—Å—å –∑–º—ñ–Ω–∏–≤ _max, –ø—Ä–æ–±—É—î–º–æ –∑–Ω–æ–≤—É
    }

    public int Max => _max;
}
```

::tip
**–ö–æ–ª–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ Interlocked:**

-   –ü—Ä–æ—Å—Ç—ñ –ª—ñ—á–∏–ª—å–Ω–∏–∫–∏ —Ç–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
-   Flags —Ç–∞ —Å—Ç–∞–Ω–∏
-   Lock-free —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ –¥–∞–Ω–∏—Ö (advanced)

**–ö–æ–ª–∏ –ù–ï –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏:**

-   –°–∫–ª–∞–¥–Ω—ñ –æ–ø–µ—Ä–∞—Ü—ñ—ó –Ω–∞–¥ –∫—ñ–ª—å–∫–æ–º–∞ –∑–º—ñ–Ω–Ω–∏–º–∏
-   –ö–æ–ª–∏ –ø–æ—Ç—Ä—ñ–±–µ–Ω "all-or-nothing" transaction

::

---

## Volatile Keyword

### Memory Visibility Problem

–°—É—á–∞—Å–Ω—ñ –ø—Ä–æ—Ü–µ—Å–æ—Ä–∏ —Ç–∞ –∫–æ–º–ø—ñ–ª—è—Ç–æ—Ä–∏ –æ–ø—Ç–∏–º—ñ–∑—É—é—Ç—å –∫–æ–¥, —â–æ –º–æ–∂–µ –ø–æ—Ä—É—à–∏—Ç–∏ –≤–∏–¥–∏–º—ñ—Å—Ç—å –∑–º—ñ–Ω –º—ñ–∂ –ø–æ—Ç–æ–∫–∞–º–∏:

```csharp
// ‚ùå –ú–û–ñ–ï –ù–ï –ü–†–ê–¶–Æ–í–ê–¢–ò –±–µ–∑ volatile
class Worker
{
    private bool _shouldStop = false;  // –ù–µ volatile

    public void DoWork()
    {
        while (!_shouldStop)  // –ö–æ–º–ø—ñ–ª—è—Ç–æ—Ä –º–æ–∂–µ –∑–∞–∫–µ—à—É–≤–∞—Ç–∏ _shouldStop!
        {
            // –†–æ–±–æ—Ç–∞...
        }
    }

    public void Stop() => _shouldStop = true;
}
```

**–©–æ –º–æ–∂–µ –ø—ñ—Ç–∏ –Ω–µ —Ç–∞–∫:**

1. JIT –∫–µ—à—É—î `_shouldStop` –≤ —Ä–µ–≥—ñ—Å—Ç—Ä CPU
2. –Ü–Ω—à–∏–π –ø–æ—Ç—ñ–∫ –∑–º—ñ–Ω—é—î `_shouldStop` –≤ –ø–∞–º'—è—Ç—ñ
3. Worker thread –Ω–µ –±–∞—á–∏—Ç—å –∑–º—ñ–Ω–∏ ‚Äî –Ω–µ—Å–∫—ñ–Ω—á–µ–Ω–Ω–∏–π —Ü–∏–∫–ª!

### Volatile: Memory Barrier

```csharp showLineNumbers
class Worker
{
    private volatile bool _shouldStop = false;  // [!code highlight]

    public void DoWork()
    {
        while (!_shouldStop)  // –ó–∞–≤–∂–¥–∏ —á–∏—Ç–∞—î –∑ –ø–∞–º'—è—Ç—ñ
        {
            // –†–æ–±–æ—Ç–∞...
        }
    }

    public void Stop() => _shouldStop = true;  // –ù–µ–≥–∞–π–Ω–æ –≤–∏–¥–∏–º–∞ –¥–ª—è —ñ–Ω—à–∏—Ö –ø–æ—Ç–æ–∫—ñ–≤
}
```

**–©–æ —Ä–æ–±–∏—Ç—å volatile:**

-   **Read**: –í—Å—Ç–∞–≤–ª—è—î **acquire barrier** ‚Äî —á–∏—Ç–∞–Ω–Ω—è –Ω–µ –º–æ–∂–µ –±—É—Ç–∏ –ø–µ—Ä–µ–º—ñ—â–µ–Ω–µ –¥–æ –Ω—å–æ–≥–æ
-   **Write**: –í—Å—Ç–∞–≤–ª—è—î **release barrier** ‚Äî –∑–∞–ø–∏—Å –Ω–µ –º–æ–∂–µ –±—É—Ç–∏ –ø–µ—Ä–µ–º—ñ—â–µ–Ω–∏–π –ø—ñ—Å–ª—è –Ω—å–æ–≥–æ

### Volatile Class (–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞)

```csharp showLineNumbers
using System.Threading;

class Counter
{
    private int _count = 0;

    public void Increment()
    {
        // Volatile.Write –≥–∞—Ä–∞–Ω—Ç—É—î –≤–∏–¥–∏–º—ñ—Å—Ç—å
        Volatile.Write(ref _count, Volatile.Read(ref _count) + 1);
    }

    public int Count => Volatile.Read(ref _count);
}
```

::warning
**–í–∞–∂–ª–∏–≤–æ**: `volatile` –ù–ï —Ä–æ–±–∏—Ç—å –æ–ø–µ—Ä–∞—Ü—ñ—ó –∞—Ç–æ–º–∞—Ä–Ω–∏–º–∏!

```csharp
private volatile int _count = 0;

// ‚ùå –ù–ï –ê–¢–û–ú–ê–†–ù–û –Ω–∞–≤—ñ—Ç—å –∑ volatile!
_count++;  // Read + Increment + Write ‚Äî —Ç—Ä–∏ –æ–ø–µ—Ä–∞—Ü—ñ—ó

// ‚úÖ –î–ª—è –∞—Ç–æ–º–∞—Ä–Ω–æ—Å—Ç—ñ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ Interlocked
Interlocked.Increment(ref _count);
```

::

### –ö–æ–ª–∏ (–ù–µ) –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ Volatile

| –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ `volatile`        | –ù–ï –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ `volatile`   |
| :------------------------------- | :----------------------------- |
| –ü—Ä–æ—Å—Ç—ñ boolean flags –¥–ª—è –∑—É–ø–∏–Ω–∫–∏ | –õ—ñ—á–∏–ª—å–Ω–∏–∫–∏, —â–æ —ñ–Ω–∫—Ä–µ–º–µ–Ω—Ç—É—é—Ç—å—Å—è |
| Status indicators                | –°–∫–ª–∞–¥–Ω—ñ –æ–±'—î–∫—Ç–∏                |
| –û–¥–Ω–æ—Ä–∞–∑–æ–≤—ñ –ø—Ä–∏—Å–≤–æ—î–Ω–Ω—è            | –û–ø–µ—Ä–∞—Ü—ñ—ó –Ω–∞ –∫—ñ–ª—å–∫–æ—Ö –∑–º—ñ–Ω–Ω–∏—Ö    |

::tip
**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—è**: –£ –±—ñ–ª—å—à–æ—Å—Ç—ñ –≤–∏–ø–∞–¥–∫—ñ–≤ –∑–∞–º—ñ—Å—Ç—å `volatile` –∫—Ä–∞—â–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏:

1. `lock` ‚Äî –¥–ª—è –∫–æ–º–ø–ª–µ–∫—Å–Ω–∏—Ö –æ–ø–µ—Ä–∞—Ü—ñ–π
2. `Interlocked` ‚Äî –¥–ª—è –∞—Ç–æ–º–∞—Ä–Ω–∏—Ö –æ–ø–µ—Ä–∞—Ü—ñ–π
3. `Monitor.Wait/Pulse` ‚Äî –¥–ª—è —Å–∏–≥–Ω–∞–ª—ñ–∑–∞—Ü—ñ—ó

::

---

## –ü–æ—Ä—ñ–≤–Ω—è–ª—å–Ω–∞ –¢–∞–±–ª–∏—Ü—è –ü—Ä–∏–º—ñ—Ç–∏–≤—ñ–≤

| –ü—Ä–∏–º—ñ—Ç–∏–≤                | Scope         | Performance      | Async | Use Case                        |
| :---------------------- | :------------ | :--------------- | :---- | :------------------------------ |
| `lock` / `Monitor`      | In-process    | ‚ö°‚ö°‚ö° Fast      | ‚ùå    | –ó–∞–≥–∞–ª—å–Ω–∞ —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—è          |
| `System.Threading.Lock` | In-process    | ‚ö°‚ö°‚ö° Fast      | ‚ùå    | .NET 9+, —è–≤–Ω–∏–π API              |
| `Mutex`                 | Cross-process | ‚ö° Slow          | ‚ùå    | Single instance, IPC            |
| `Semaphore`             | Cross-process | ‚ö° Slow          | ‚ùå    | Resource limiting               |
| `SemaphoreSlim`         | In-process    | ‚ö°‚ö°‚ö° Fast      | ‚úÖ    | Connection pools, rate limiting |
| `AutoResetEvent`        | Cross-process | ‚ö°‚ö° Medium      | ‚ùå    | Point-to-point signaling        |
| `ManualResetEventSlim`  | In-process    | ‚ö°‚ö°‚ö° Fast      | ‚úÖ    | Broadcast signaling             |
| `Interlocked`           | N/A           | ‚ö°‚ö°‚ö°‚ö° Fastest | N/A   | Atomic operations               |
| `volatile`              | N/A           | ‚ö°‚ö°‚ö°‚ö° Fastest | N/A   | Visibility only                 |

### Decision Flowchart

::mermaid

```mermaid
flowchart TD
    A[–ü–æ—Ç—Ä—ñ–±–Ω–∞ —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—è?] -->|–ê—Ç–æ–º–∞—Ä–Ω–∞ –æ–ø–µ—Ä–∞—Ü—ñ—è| B[Interlocked]
    A -->|–ö—Ä–∏—Ç–∏—á–Ω–∞ —Å–µ–∫—Ü—ñ—è| C{Cross-process?}
    C -->|–ù—ñ| D[lock / Monitor]
    C -->|–¢–∞–∫| E[Mutex]

    A -->|–û–±–º–µ–∂–∏—Ç–∏ concurrency| F{Async needed?}
    F -->|–¢–∞–∫| G[SemaphoreSlim]
    F -->|–ù—ñ| H{Cross-process?}
    H -->|–¢–∞–∫| I[Semaphore]
    H -->|–ù—ñ| G

    A -->|Signaling| J{Behavior?}
    J -->|One-at-a-time| K[AutoResetEvent]
    J -->|Broadcast| L[ManualResetEventSlim]

    style B fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style D fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style G fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style L fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
```

::

---

## –ü—Ä–∞–∫—Ç–∏—á–Ω—ñ –ó–∞–≤–¥–∞–Ω–Ω—è

### –†—ñ–≤–µ–Ω—å 1: –ü–æ—á–∞—Ç–∫–æ–≤–∏–π

::collapsible{title="–ó–∞–≤–¥–∞–Ω–Ω—è 1.1: Thread-Safe Counter"}
–†–µ–∞–ª—ñ–∑—É–π—Ç–µ –∫–ª–∞—Å `SafeCounter` –¥–≤–æ–º–∞ —Å–ø–æ—Å–æ–±–∞–º–∏:

1. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—á–∏ `lock`
2. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—á–∏ `Interlocked`

–ü—Ä–æ—Ç–µ—Å—Ç—É–π—Ç–µ –∑ 10 –ø–æ—Ç–æ–∫–∞–º–∏, –∫–æ–∂–µ–Ω –¥–æ–¥–∞—î 1000 –¥–æ –ª—ñ—á–∏–ª—å–Ω–∏–∫–∞. –ü–æ—Ä—ñ–≤–Ω—è–π—Ç–µ –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å –æ–±–æ—Ö –ø—ñ–¥—Ö–æ–¥—ñ–≤.
::

::collapsible{title="–ó–∞–≤–¥–∞–Ω–Ω—è 1.2: Single Instance App"}
–°—Ç–≤–æ—Ä—ñ—Ç—å WPF –∞–±–æ Console –¥–æ–¥–∞—Ç–æ–∫, —â–æ –∑–∞–±–æ—Ä–æ–Ω—è—î –∑–∞–ø—É—Å–∫ –¥—Ä—É–≥–æ–≥–æ –µ–∫–∑–µ–º–ø–ª—è—Ä–∞, –ø–æ–∫–∞–∑—É—é—á–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—É.
::

### –†—ñ–≤–µ–Ω—å 2: –°–µ—Ä–µ–¥–Ω—ñ–π

::collapsible{title="–ó–∞–≤–¥–∞–Ω–Ω—è 2.1: Bounded Buffer"}
–†–µ–∞–ª—ñ–∑—É–π—Ç–µ –∫–ª–∞—Å `BoundedBuffer<T>` –∑ –º–µ—Ç–æ–¥–∞–º–∏:

-   `Put(T item)` ‚Äî –±–ª–æ–∫—É—î—Ç—å—Å—è, —è–∫—â–æ –±—É—Ñ–µ—Ä –ø–æ–≤–Ω–∏–π (–º–∞–∫—Å. 10 –µ–ª–µ–º–µ–Ω—Ç—ñ–≤)
-   `Take()` ‚Äî –±–ª–æ–∫—É—î—Ç—å—Å—è, —è–∫—â–æ –±—É—Ñ–µ—Ä –ø–æ—Ä–æ–∂–Ω—ñ–π

–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ `Monitor.Wait()` / `Monitor.Pulse()`.
::

::collapsible{title="–ó–∞–≤–¥–∞–Ω–Ω—è 2.2: API Rate Limiter"}
–†–µ–∞–ª—ñ–∑—É–π—Ç–µ –∫–ª–∞—Å `RateLimiter` –∑ –º–µ—Ç–æ–¥–æ–º:

-   `async Task<bool> TryAcquireAsync(TimeSpan timeout)`

–û–±–º–µ–∂–µ–Ω–Ω—è: –º–∞–∫—Å–∏–º—É–º 10 –∑–∞–ø–∏—Ç—ñ–≤ –Ω–∞ —Å–µ–∫—É–Ω–¥—É. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ `SemaphoreSlim`.
::

### –†—ñ–≤–µ–Ω—å 3: –ü—Ä–æ—Å—É–Ω—É—Ç–∏–π

::collapsible{title="–ó–∞–≤–¥–∞–Ω–Ω—è 3.1: Lock-Free Stack"}
–†–µ–∞–ª—ñ–∑—É–π—Ç–µ lock-free stack –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—á–∏ —Ç—ñ–ª—å–∫–∏ `Interlocked.CompareExchange`:

-   `Push(T item)`
-   `bool TryPop(out T item)`

–ü—ñ–¥–∫–∞–∑–∫–∞: –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ linked list –¥–µ –≥–æ–ª–æ–≤–∞ –∞—Ç–æ–º–∞—Ä–Ω–æ –æ–Ω–æ–≤–ª—é—î—Ç—å—Å—è —á–µ—Ä–µ–∑ CAS.
::

---

## –ü—ñ–¥—Å—É–º–∫–∏

–£ —Ü—å–æ–º—É —Ä–æ–∑–¥—ñ–ª—ñ –º–∏ —Ä–æ–∑–≥–ª—è–Ω—É–ª–∏ –≤—Å—ñ –æ—Å–Ω–æ–≤–Ω—ñ –ø—Ä–∏–º—ñ—Ç–∏–≤–∏ —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—ó .NET:

-   **lock / Monitor** ‚Äî –±–∞–∑–æ–≤–∞ –≤–∑–∞—î–º–æ–≤–∏–∫–ª—é—á–Ω–∞ —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—è
-   **System.Threading.Lock** ‚Äî –Ω–æ–≤–∏–π –æ–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω–∏–π —Ç–∏–ø —É C# 13
-   **Mutex** ‚Äî cross-process –≤–∑–∞—î–º–æ–≤–∏–∫–ª—é—á–µ–Ω–Ω—è
-   **Semaphore / SemaphoreSlim** ‚Äî –æ–±–º–µ–∂–µ–Ω–Ω—è –∫—ñ–ª—å–∫–æ—Å—Ç—ñ concurrent –¥–æ—Å—Ç—É–ø—ñ–≤
-   **AutoResetEvent / ManualResetEvent** ‚Äî –º–µ—Ö–∞–Ω—ñ–∑–º–∏ —Å–∏–≥–Ω–∞–ª—ñ–∑–∞—Ü—ñ—ó
-   **Interlocked** ‚Äî –∞—Ç–æ–º–∞—Ä–Ω—ñ lock-free –æ–ø–µ—Ä–∞—Ü—ñ—ó
-   **volatile** ‚Äî –∑–∞–±–µ–∑–ø–µ—á–µ–Ω–Ω—è memory visibility

::tip
**–ù–∞—Å—Ç—É–ø–Ω–∏–π –∫—Ä–æ–∫**: –î–ª—è –≤–∏—Å–æ–∫–æ—Ä—ñ–≤–Ω–µ–≤–æ–≥–æ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º—É–≤–∞–Ω–Ω—è –≤–∏–≤—á—ñ—Ç—å [Task Parallel Library (TPL)](./8.task-parallel-library.md) —Ç–∞ async/await pattern.
::

## –ö–æ—Ä–∏—Å–Ω—ñ –ü–æ—Å–∏–ª–∞–Ω–Ω—è

-   [Threading in C# - Joseph Albahari](https://www.albahari.com/threading/)
-   [Synchronization Primitives - Microsoft Docs](https://learn.microsoft.com/en-us/dotnet/standard/threading/overview-of-synchronization-primitives)
-   [Lock Statement - C# Reference](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/lock)
-   [Interlocked Class](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked)
