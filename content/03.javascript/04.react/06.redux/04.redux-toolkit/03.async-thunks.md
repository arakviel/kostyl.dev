# –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ñ—Å—Ç—å –∑ createAsyncThunk

–¢–µ–ø–µ—Ä, –∫–æ–ª–∏ –º–∏ –≤–º—ñ—î–º–æ –ø—Ä–∞—Ü—é–≤–∞—Ç–∏ –∑ —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ—é –ª–æ–≥—ñ–∫–æ—é —á–µ—Ä–µ–∑ `createSlice`, —á–∞—Å –Ω–∞–≤—á–∏—Ç–∏—Å—è –ø—Ä–∞—Ü—é–≤–∞—Ç–∏ –∑ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∏–º–∏ –æ–ø–µ—Ä–∞—Ü—ñ—è–º–∏ ‚Äî API –∑–∞–ø–∏—Ç–∞–º–∏, —Ç–∞–π–º–µ—Ä–∞–º–∏, –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è–º —Ñ–∞–π–ª—ñ–≤. Redux Toolkit –Ω–∞–¥–∞—î `createAsyncThunk` –¥–ª—è —Ü—å–æ–≥–æ.

## –ü—Ä–æ–±–ª–µ–º–∞: –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ñ—Å—Ç—å —É Redux

Reducers –º–∞—é—Ç—å –±—É—Ç–∏ **pure functions** ‚Äî –≤–æ–Ω–∏ –Ω–µ –º–æ–∂—É—Ç—å –º—ñ—Å—Ç–∏—Ç–∏:

- API –∑–∞–ø–∏—Ç–∏ (fetch, axios)
- –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∏–π –∫–æ–¥ (async/await, Promise)
- Side effects (console.log, timers)

```javascript
// ‚ùå –¶–ï –ù–ï –ü–†–ê–¶–Æ–Ñ
reducers: {
  fetchUser: async (state) => {
    const data = await fetch('/api/user'); // async –≤ reducer - –ü–û–ú–ò–õ–ö–ê!
    state.user = data;
  },
}
```

**–†—ñ—à–µ–Ω–Ω—è**: –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—É –ª–æ–≥—É —Ç—Ä–µ–±–∞ –≤–∏–Ω–µ—Å—Ç–∏ **–ó–ê –ú–ï–ñ–Ü** reducers. –£ –∫–ª–∞—Å–∏—á–Ω–æ–º—É Redux —Ü–µ —Ä–æ–±–∏–ª–∏ —á–µ—Ä–µ–∑ thunks –≤—Ä—É—á–Ω—É.

---

## Thunk Pattern: –ö–æ–Ω—Ü–µ–ø—Ü—ñ—è

**Thunk** ‚Äî —Ü–µ —Ñ—É–Ω–∫—Ü—ñ—è, —è–∫–∞ –ø–æ–≤–µ—Ä—Ç–∞—î —ñ–Ω—à—É —Ñ—É–Ω–∫—Ü—ñ—é (—è–∫–∞ –º–∞—î –¥–æ—Å—Ç—É–ø –¥–æ `dispatch` —Ç–∞ `getState`).

```javascript
// –ö–ª–∞—Å–∏—á–Ω–∏–π thunk (–≤—Ä—É—á–Ω—É)
function fetchUser(userId) {
    return async function (dispatch, getState) {
        dispatch({ type: 'users/fetchStart' })
        try {
            const response = await fetch(`/api/users/${userId}`)
            const data = await response.json()
            dispatch({ type: 'users/fetchSuccess', payload: data })
        } catch (error) {
            dispatch({ type: 'users/fetchError', payload: error.message })
        }
    }
}
```

**–ü—Ä–æ–±–ª–µ–º–∞**: –ü–æ—Ç—Ä—ñ–±–Ω–æ –≤—Ä—É—á–Ω—É —Å—Ç–≤–æ—Ä—é–≤–∞—Ç–∏ 3 action types —Ç–∞ —ó—Ö –æ–±—Ä–æ–±–ª—è—Ç–∏.

---

## createAsyncThunk: –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü—ñ—è

`createAsyncThunk` –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≥–µ–Ω–µ—Ä—É—î —Ü—ñ 3 action types:

::mermaid

```mermaid
graph LR
    A[dispatch thunk] --> B[pending action]
    B --> C[–í–∏–∫–ª–∏–∫ async —Ñ—É–Ω–∫—Ü—ñ—ó]
    C --> D{–†–µ–∑—É–ª—å—Ç–∞—Ç?}
    D -->|Success| E[fulfilled action]
    D -->|Error| F[rejected action]

    B --> G[extraReducers: pending]
    E --> H[extraReducers: fulfilled]
    F --> I[extraReducers: rejected]

    style A fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style B fill:#f59e0b,stroke:#b45309,color:#ffffff
    style C fill:#64748b,stroke:#334155,color:#ffffff
    style D fill:#64748b,stroke:#334155,color:#ffffff
    style E fill:#10b981,stroke:#059669,color:#ffffff
    style F fill:#ef4444,stroke:#dc2626,color:#ffffff
```

::

---

## –°—Ç–≤–æ—Ä–µ–Ω–Ω—è Async Thunk

### –ë–∞–∑–æ–≤–∏–π –ø—Ä–∏–∫–ª–∞–¥

```javascript [features/users/userThunks.js]
import { createAsyncThunk } from '@reduxjs/toolkit'

export const fetchUserById = createAsyncThunk(
    'users/fetchById', // Action type prefix
    async (userId) => {
        const response = await fetch(`https://api.example.com/users/${userId}`)
        const data = await response.json()
        return data // –¶–µ —Å—Ç–∞–Ω–µ action.payload —É fulfilled
    },
)
```

### –©–æ –≥–µ–Ω–µ—Ä—É—î—Ç—å—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ?

```javascript
fetchUserById.pending // 'users/fetchById/pending'
fetchUserById.fulfilled // 'users/fetchById/fulfilled'
fetchUserById.rejected // 'users/fetchById/rejected'
```

---

## Lifecycle Actions

::mermaid

```mermaid
stateDiagram-v2
    [*] --> Idle
    Idle --> Pending: dispatch(thunk)
    Pending --> Fulfilled: Success
    Pending --> Rejected: Error
    Fulfilled --> Idle
    Rejected --> Idle

    note right of Pending
        loading = true
        error = null
    end note

    note right of Fulfilled
        loading = false
        data = payload
    end note

    note right of Rejected
        loading = false
        error = message
    end note
```

::

### Action —Å—Ç—Ä—É–∫—Ç—É—Ä–∞

```javascript
// pending
{
  type: 'users/fetchById/pending',
  meta: { arg: 123, requestId: 'xyzabc' }
}

// fulfilled
{
  type: 'users/fetchById/fulfilled',
  payload: { id: 123, name: 'John' },
  meta: { arg: 123, requestId: 'xyzabc' }
}

// rejected
{
  type: 'users/fetchById/rejected',
  error: { message: 'Network error' },
  meta: { arg: 123, requestId: 'xyzabc' }
}
```

---

## ThunkAPI Object

–î—Ä—É–≥–∏–π –ø–∞—Ä–∞–º–µ—Ç—Ä payload creator –æ—Ç—Ä–∏–º—É—î `thunkAPI` –æ–±'—î–∫—Ç:

```javascript
export const fetchUserById = createAsyncThunk('users/fetchById', async (userId, thunkAPI) => {
    // –î–æ—Å—Ç—É–ø –¥–æ:
    thunkAPI.dispatch // –§—É–Ω–∫—Ü—ñ—è dispatch
    thunkAPI.getState() // –ü–æ—Ç–æ—á–Ω–∏–π state
    thunkAPI.extra // –ö–∞—Å—Ç–æ–º–Ω—ñ –¥–∞–Ω—ñ (–Ω–∞–ª–∞—à—Ç–æ–≤—É—î—Ç—å—Å—è –≤ store)
    thunkAPI.requestId // –£–Ω—ñ–∫–∞–ª—å–Ω–∏–π ID –∑–∞–ø–∏—Ç—É
    thunkAPI.signal // AbortSignal –¥–ª—è —Å–∫–∞—Å—É–≤–∞–Ω–Ω—è
    thunkAPI.rejectWithValue // –ö–∞—Å—Ç–æ–º–Ω–∏–π reject payload
    thunkAPI.fulfillWithValue // –ö–∞—Å—Ç–æ–º–Ω–∏–π fulfill payload
})
```

### –ü—Ä–∏–∫–ª–∞–¥ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è

```javascript
export const fetchUserById = createAsyncThunk(
  'users/fetchById',
  async (userId, {get State, rejectWithValue }) => {
    // Conditional fetching
    const state = getState();
    if (state.users.cache[userId]) {
      return state.users.cache[userId]; // –ü–æ–≤–µ—Ä–Ω—É—Ç–∏ –∑ –∫–µ—à—É
    }

    try {
      const response = await fetch(`/api/users/${userId}`);
      if (!response.ok) {
        // –ö–∞—Å—Ç–æ–º–Ω–∞ –ø–æ–º–∏–ª–∫–∞
        return rejectWithValue({ status: response.status, message: 'Not found' });
      }
      return await response.json();
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);
```

---

## –û–±—Ä–æ–±–∫–∞ –≤ Slice

```javascript [features/users/usersSlice.js]
import { createSlice } from '@reduxjs/toolkit'
import { fetchUserById } from './userThunks'

const usersSlice = createSlice({
    name: 'users',
    initialState: {
        entities: {},
        loading: 'idle', // 'idle' | 'pending' | 'succeeded' | 'failed'
        error: null,
    },
    reducers: {},
    extraReducers: (builder) => {
        builder
            .addCase(fetchUserById.pending, (state) => {
                state.loading = 'pending'
                state.error = null
            })
            .addCase(fetchUserById.fulfilled, (state, action) => {
                state.loading = 'succeeded'
                state.entities[action.payload.id] = action.payload
            })
            .addCase(fetchUserById.rejected, (state, action) => {
                state.loading = 'failed'
                state.error = action.payload || action.error.message
            })
    },
})

export default usersSlice.reducer
```

---

## Patterns –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è

### 1. Simple GET request

```javascript
export const fetchPosts = createAsyncThunk('posts/fetch', async () => {
    const response = await fetch('/api/posts')
    return response.json()
})
```

### 2. POST –∑ payload

```javascript
export const createPost = createAsyncThunk('posts/create', async (newPost) => {
    const response = await fetch('/api/posts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newPost),
    })
    return response.json()
})

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
dispatch(createPost({ title: 'Hello', content: 'World' }))
```

### 3. Conditional Fetching (skip if cached)

```javascript
export const fetchPosts = createAsyncThunk(
    'posts/fetch',
    async (_, { getState }) => {
        const state = getState()
        // –ü—Ä–æ–ø—É—Å—Ç–∏—Ç–∏, —è–∫—â–æ –¥–∞–Ω—ñ –≤–∂–µ —î —ñ —Å–≤—ñ–∂—ñ
        if (state.posts.items.length > 0 && state.posts.lastFetch > Date.now() - 60000) {
            return state.posts.items // –ü–æ–≤–µ—Ä–Ω—É—Ç–∏ –∑ –∫–µ—à—É
        }
        const response = await fetch('/api/posts')
        return response.json()
    },
    {
        condition: (_, { getState }) => {
            const state = getState()
            // –ó–∞–±–æ—Ä–æ–Ω–∏—Ç–∏ –≤–∏–∫–ª–∏–∫, —è–∫—â–æ –≤–∂–µ loading
            return state.posts.loading !== 'pending'
        },
    },
)
```

### 4. Sequential Thunks (–æ–¥–∏–Ω –∑–∞ –æ–¥–Ω–∏–º)

```javascript
export const loginAndFetchProfile = createAsyncThunk('auth/loginAndFetch', async (credentials, { dispatch }) => {
    // 1. Login
    const loginResult = await dispatch(login(credentials)).unwrap()

    // 2. Fetch profile (–ø—ñ—Å–ª—è —É—Å–ø—ñ—à–Ω–æ–≥–æ login)
    const profile = await dispatch(fetchUserProfile()).unwrap()

    return { ...loginResult, profile }
})
```

::note
`.unwrap()` –ø–æ–≤–µ—Ä—Ç–∞—î payload –∞–±–æ –∫–∏–¥–∞—î –ø–æ–º–∏–ª–∫—É. –ö–æ—Ä–∏—Å–Ω–æ –¥–ª—è chaining.
::

### 5. Parallel Requests (Promise.all)

```javascript
export const fetchDashboardData = createAsyncThunk('dashboard/fetchAll', async () => {
    const [users, posts, stats] = await Promise.all([
        fetch('/api/users').then((r) => r.json()),
        fetch('/api/posts').then((r) => r.json()),
        fetch('/api/stats').then((r) => r.json()),
    ])

    return { users, posts, stats }
})
```

### 6. Cancellation –∑ AbortController

```javascript
export const fetchPosts = createAsyncThunk('posts/fetch', async (_, { signal }) => {
    const response = await fetch('/api/posts', {
        signal, // –ü–µ—Ä–µ–¥–∞—î–º–æ signal –¥–ª—è —Å–∫–∞—Å—É–≤–∞–Ω–Ω—è
    })
    return response.json()
})

// –°–∫–∞—Å—É–≤–∞–Ω–Ω—è
const promise = dispatch(fetchPosts())
promise.abort() // –°–∫–∞—Å—É–≤–∞—Ç–∏ –∑–∞–ø–∏—Ç
```

### 7. Retry Logic

```javascript
export const fetchWithRetry = createAsyncThunk('data/fetchWithRetry', async (url, { rejectWithValue }) => {
    let attempts = 0
    const maxAttempts = 3

    while (attempts < maxAttempts) {
        try {
            const response = await fetch(url)
            if (response.ok) {
                return await response.json()
            }
            attempts++
            if (attempts < maxAttempts) {
                await new Promise((resolve) => setTimeout(resolve, 1000 * attempts))
            }
        } catch (error) {
            attempts++
        }
    }

    return rejectWithValue('Failed after 3 attempts')
})
```

### 8. Optimistic Updates

```javascript
export const toggleTodo = createAsyncThunk('todos/toggle', async (todoId, { getState, rejectWithValue }) => {
    try {
        const response = await fetch(`/api/todos/${todoId}/toggle`, {
            method: 'PATCH',
        })
        return response.json()
    } catch (error) {
        return rejectWithValue(todoId) // –ü–æ–≤–µ—Ä–Ω—É—Ç–∏ ID –¥–ª—è rollback
    }
})

// –£ slice:
extraReducers: (builder) => {
    builder
        .addCase(toggleTodo.pending, (state, action) => {
            // Optimistic: –æ–Ω–æ–≤–∏—Ç–∏ UI –≤—ñ–¥—Ä–∞–∑—É
            const todo = state.items.find((t) => t.id === action.meta.arg)
            if (todo) {
                todo.completed = !todo.completed
            }
        })
        .addCase(toggleTodo.rejected, (state, action) => {
            // Rollback –ø—Ä–∏ –ø–æ–º–∏–ª—Ü—ñ
            const todo = state.items.find((t) => t.id === action.payload)
            if (todo) {
                todo.completed = !todo.completed // –ü–æ–≤–µ—Ä–Ω—É—Ç–∏ –Ω–∞–∑–∞–¥
            }
        })
}
```

---

## Error Handling

### –ë–∞–∑–æ–≤–∞ –æ–±—Ä–æ–±–∫–∞

```javascript
extraReducers: (builder) => {
    builder.addCase(fetchUser.rejected, (state, action) => {
        state.error = action.error.message // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞ –ø–æ–º–∏–ª–∫–∞
    })
}
```

### Custom Error –∑ rejectWithValue

```javascript
export const fetchUser = createAsyncThunk('users/fetch', async (userId, { rejectWithValue }) => {
    try {
        const response = await fetch(`/api/users/${userId}`)

        if (!response.ok) {
            const error = await response.json()
            return rejectWithValue(error) // –ö–∞—Å—Ç–æ–º–Ω–∏–π payload –ø–æ–º–∏–ª–∫–∏
        }

        return await response.json()
    } catch (error) {
        return rejectWithValue({ message: error.message })
    }
})

// –û–±—Ä–æ–±–∫–∞
extraReducers: (builder) => {
    builder.addCase(fetchUser.rejected, (state, action) => {
        // action.payload === –Ω–∞—à –∫–∞—Å—Ç–æ–º–Ω–∏–π –æ–±'—î–∫—Ç –ø–æ–º–∏–ª–∫–∏
        state.error = action.payload.message
    })
}
```

### Typed Errors (TypeScript)

```typescript
interface ValidationError {
    field: string
    message: string
}

export const submitForm = createAsyncThunk<
    FormData, // Return type
    FormInput, // Arg type
    { rejectValue: ValidationError[] } // Reject type
>('form/submit', async (formData, { rejectWithValue }) => {
    const response = await fetch('/api/form', {
        method: 'POST',
        body: JSON.stringify(formData),
    })

    if (!response.ok) {
        const errors: ValidationError[] = await response.json()
        return rejectWithValue(errors)
    }

    return response.json()
})
```

---

## Loading State Patterns

### 1. Simple Boolean

```javascript
initialState: {
  data: null,
  isLoading: false,
}

extraReducers: (builder) => {
  builder
    .addCase(fetchData.pending, (state) => { state.isLoading = true })
    .addCase(fetchData.fulfilled, (state, action) => {
      state.isLoading = false;
      state.data = action.payload;
    })
    .addCase(fetchData.rejected, (state) => { state.isLoading = false });
}
```

### 2. Enum Status (—Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–æ)

```javascript
initialState: {
  data: null,
  status: 'idle', // 'idle' | 'pending' | 'succeeded' | 'failed'
}

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –≤ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ñ
if (status === 'pending') return <Spinner />;
if (status === 'failed') return <Error />;
if (status === 'succeeded') return <Data />;
```

### 3. Per-item Loading

```javascript
initialState: {
  items: {},
  loadingIds: [], // [1, 5, 7] - IDs —â–æ –∑–∞–≤–∞–Ω—Ç–∞–∂—É—é—Ç—å—Å—è
}

extraReducers: (builder) => {
  builder
    .addCase(fetchItem.pending, (state, action) => {
      state.loadingIds.push(action.meta.arg); // arg = itemId
    })
    .addCase(fetchItem.fulfilled, (state, action) => {
      state.items[action.payload.id] = action.payload;
      state.loadingIds = state.loadingIds.filter(id => id !== action.payload.id);
    });
}
```

---

## Real-World Examples

::accordion

::accordion-item{label="Authentication Flow" icon="i-lucide-lock"}

```javascript
export const login = createAsyncThunk('auth/login', async (credentials, { rejectWithValue }) => {
    try {
        const response = await fetch('/api/auth/login', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(credentials),
        })

        if (!response.ok) {
            const error = await response.json()
            return rejectWithValue(error)
        }

        const data = await response.json()
        localStorage.setItem('token', data.token)
        return data
    } catch (error) {
        return rejectWithValue({ message: 'Network error' })
    }
})

// Slice
const authSlice = createSlice({
    name: 'auth',
    initialState: {
        user: null,
        token: null,
        status: 'idle',
        error: null,
    },
    reducers: {
        logout: (state) => {
            state.user = null
            state.token = null
            localStorage.removeItem('token')
        },
    },
    extraReducers: (builder) => {
        builder
            .addCase(login.pending, (state) => {
                state.status = 'pending'
                state.error = null
            })
            .addCase(login.fulfilled, (state, action) => {
                state.status = 'succeeded'
                state.user = action.payload.user
                state.token = action.payload.token
            })
            .addCase(login.rejected, (state, action) => {
                state.status = 'failed'
                state.error = action.payload.message
            })
    },
})
```

::

::accordion-item{label="Infinite Scroll Pagination" icon="i-lucide-list"}

```javascript
export const fetchPostsPage = createAsyncThunk(
    'posts/fetchPage',
    async (page, { getState }) => {
        const response = await fetch(`/api/posts?page=${page}&limit=20`)
        const data = await response.json()
        return data
    },
    {
        condition: (page, { getState }) => {
            const { posts } = getState()
            // –ù–µ –∑–∞–≤–∞–Ω—Ç–∞–∂—É–≤–∞—Ç–∏, —è–∫—â–æ –≤–∂–µ loading –∞–±–æ –Ω–µ–º–∞—î –±—ñ–ª—å—à–µ —Å—Ç–æ—Ä—ñ–Ω–æ–∫
            return posts.status !== 'pending' && posts.hasMore
        },
    },
)

const postsSlice = createSlice({
    name: 'posts',
    initialState: {
        items: [],
        page: 1,
        hasMore: true,
        status: 'idle',
    },
    reducers: {},
    extraReducers: (builder) => {
        builder
            .addCase(fetchPostsPage.pending, (state) => {
                state.status = 'pending'
            })
            .addCase(fetchPostsPage.fulfilled, (state, action) => {
                state.status = 'succeeded'
                state.items.push(...action.payload.posts)
                state.page += 1
                state.hasMore = action.payload.hasMore
            })
    },
})
```

::

::accordion-item{label="File Upload –∑ Progress" icon="i-lucide-upload"}

```javascript
export const uploadFile = createAsyncThunk('files/upload', async (file, { rejectWithValue, dispatch }) => {
    const formData = new FormData()
    formData.append('file', file)

    try {
        const response = await fetch('/api/upload', {
            method: 'POST',
            body: formData,
        })

        if (!response.ok) {
            return rejectWithValue('Upload failed')
        }

        return response.json()
    } catch (error) {
        return rejectWithValue(error.message)
    }
})

// –ó –ø—Ä–æ–≥—Ä–µ—Å–æ–º (–ø–æ—Ç—Ä–µ–±—É—î axios)
import axios from 'axios'

export const uploadFileWithProgress = createAsyncThunk(
    'files/uploadWithProgress',
    async (file, { rejectWithValue, dispatch }) => {
        const formData = new FormData()
        formData.append('file', file)

        try {
            const response = await axios.post('/api/upload', formData, {
                onUploadProgress: (progressEvent) => {
                    const percent = Math.round((progressEvent.loaded * 100) / progressEvent.total)
                    dispatch(setUploadProgress(percent))
                },
            })

            return response.data
        } catch (error) {
            return rejectWithValue(error.message)
        }
    },
)
```

::

::accordion-item{label="Search –∑ Debouncing" icon="i-lucide-search"}

```javascript
// Debounce helper
function debounce(fn, delay) {
    let timeoutId
    return (...args) => {
        clearTimeout(timeoutId)
        return new Promise((resolve) => {
            timeoutId = setTimeout(() => resolve(fn(...args)), delay)
        })
    }
}

export const searchProducts = createAsyncThunk(
    'products/search',
    async (query, { signal }) => {
        // Debounce –Ω–∞ —Ä—ñ–≤–Ω—ñ thunk
        await new Promise((resolve) => setTimeout(resolve, 300))

        const response = await fetch(`/api/products/search?q=${query}`, { signal })
        return response.json()
    },
    {
        condition: (query, { getState }) => {
            // –ù–µ —à—É–∫–∞—Ç–∏ –ø–æ—Ä–æ–∂–Ω—ñ–π –∑–∞–ø–∏—Ç
            return query.trim().length > 0
        },
    },
)

// –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞: debounce –≤ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ñ
import { useMemo } from 'react'

function SearchComponent() {
    const dispatch = useDispatch()

    const debouncedSearch = useMemo(() => debounce((query) => dispatch(searchProducts(query)), 300), [dispatch])

    return <input onChange={(e) => debouncedSearch(e.target.value)} />
}
```

::

::

---

## Testing Async Thunks

```javascript
import { configureStore } from '@reduxjs/toolkit'
import usersReducer from './usersSlice'
import { fetchUserById } from './userThunks'

test('fetchUserById —É—Å–ø—ñ—à–Ω–∏–π', async () => {
    const store = configureStore({ reducer: { users: usersReducer } })

    // Mock fetch
    global.fetch = jest.fn(() =>
        Promise.resolve({
            ok: true,
            json: () => Promise.resolve({ id: 1, name: 'John' }),
        }),
    )

    await store.dispatch(fetchUserById(1))

    const state = store.getState()
    expect(state.users.loading).toBe('succeeded')
    expect(state.users.entities[1]).toEqual({ id: 1, name: 'John' })
})
```

---

## –ü–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è: createAsyncThunk vs RTK Query

| –ö—Ä–∏—Ç–µ—Ä—ñ–π                 | createAsyncThunk                        | RTK Query                      |
| ------------------------ | --------------------------------------- | ------------------------------ |
| **Use case**             | –°–∫–ª–∞–¥–Ω–∞ async –ª–æ–≥—ñ–∫–∞, –Ω–µ –ø—Ä–æ—Å—Ç–æ CRUD    | CRUD operations, data fetching |
| **Boilerplate**          | –°–µ—Ä–µ–¥–Ω—ñ–π                                | –ú—ñ–Ω—ñ–º–∞–ª—å–Ω–∏–π                    |
| **Caching**              | –†—É—á–Ω–∏–π                                  | –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π                   |
| **Deduplication**        | –†—É—á–Ω–∏–π                                  | –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π                   |
| **Polling**              | –†—É—á–Ω–∏–π                                  | –í–±—É–¥–æ–≤–∞–Ω–∏–π                     |
| **–ö–æ–ª–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏** | Custom workflows, sequential operations | RESTful/GraphQL APIs           |

::tip
**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—è**: –î–ª—è –ø—Ä–æ—Å—Ç–∏—Ö CRUD –æ–ø–µ—Ä–∞—Ü—ñ–π –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ RTK Query. –î–ª—è —Å–∫–ª–∞–¥–Ω–∏—Ö workflows ‚Äî createAsyncThunk.
::

---

## –í–∏—Å–Ω–æ–≤–æ–∫

`createAsyncThunk` –∞–≤—Ç–æ–º–∞—Ç–∏–∑—É—î:

‚úÖ –ì–µ–Ω–µ—Ä–∞—Ü—ñ—é 3 action types (pending/fulfilled/rejected)  
‚úÖ –í—ñ–¥–ø—Ä–∞–≤–∫—É actions —É –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º—É –ø–æ—Ä—è–¥–∫—É  
‚úÖ Error handling  
‚úÖ Cancellation support  
‚úÖ TypeScript –ø—ñ–¥—Ç—Ä–∏–º–∫—É

::warning
**–ü–∞–º'—è—Ç–∞–π—Ç–µ**: Async thunks ‚Äî –¥–ª—è —Å–∫–ª–∞–¥–Ω–æ—ó –ª–æ–≥—ñ–∫–∏. –î–ª—è –ø—Ä–æ—Å—Ç–æ–≥–æ data fetching —Ä–æ–∑–≥–ª—è–Ω—å—Ç–µ RTK Query.
::

---

## –ù–∞—Å—Ç—É–ø–Ω—ñ –∫—Ä–æ–∫–∏

–¢–µ–ø–µ—Ä –º–∏ –≤–º—ñ—î–º–æ –ø—Ä–∞—Ü—é–≤–∞—Ç–∏ –∑ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ñ—Å—Ç—é. –ê–ª–µ —è–∫ –µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ –∑–±–µ—Ä—ñ–≥–∞—Ç–∏ –≤–µ–ª–∏–∫—ñ –Ω–∞–±–æ—Ä–∏ –¥–∞–Ω–∏—Ö?

üëâ [–î–∞–ª—ñ: –ù–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è –¥–∞–Ω–∏—Ö –∑ createEntityAdapter](./04.entity-adapter.md)
