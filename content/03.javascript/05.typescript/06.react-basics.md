# React + TypeScript: Основи типізації компонентів

::lead
Ви вже знаєте React. Тепер ви навчитеся писати React-код, який сам себе документує та ловить помилки на етапі компіляції. Це не просто додавання типів до існуючого коду — це інша філософія розробки.
::

---

## Вступ: Навіщо TypeScript у React?

React з JavaScript чудово працює. Але з ростом команди та кодової бази з'являються проблеми:

- Ви передали `userId` як число, але компонент очікував рядок.
- Ви перейменували пропс `onSubmit` на `handleSubmit`, але забули оновити його у 15 місцях.
- Ви видалили поле з API відповіді, і додаток впав у продакшені.

**TypeScript не робить React швидшим. Він робить вашу команду швидшою.**

::warning
**Не плутайте:**

- **Типізація runtime** (Zod, Yup) — перевіряє дані під час виконання (наприклад, з API).
- **Типізація compile-time** (TypeScript) — перевіряє код під час розробки.  
  Вони доповнюють одне одного!

::

---

## 1. Налаштування Environment

### Створення React + TS проєкту

Найпростіший спосіб:

```bash
# Vite (рекомендовано у 2024+)
npm create vite@latest my-app -- --template react-ts

# Create React App (застарілий, але іноді використовується)
npx create-react-app my-app --template typescript
```

### Ключові файли конфігурації

#### `tsconfig.json`

```json
{
    "compilerOptions": {
        "target": "ES2020",
        "lib": ["ES2020", "DOM", "DOM.Iterable"],
        "jsx": "react-jsx", // Використовує нову JSX трансформацію (React 17+)
        "strict": true, // КРИТИЧНО: вмикає всі строгі перевірки
        "moduleResolution": "bundler",
        "allowImportingTsExtensions": true,
        "resolveJsonModule": true,
        "isolatedModules": true,
        "noEmit": true,

        // Додаткові корисні опції
        "noUnusedLocals": true,
        "noUnusedParameters": true,
        "noFallthroughCasesInSwitch": true
    }
}
```

**Важливо:**

- `"jsx": "react-jsx"` — означає, що вам не потрібно імпортувати `React` у кожному файлі.
- `"strict": true"` — це не опція, а необхідність. Без неї TypeScript майже марний.

---

## 2. Типізація React Компонентів

### 2.1. Function Components: `FC` vs Явна типізація

Існує два основні підходи до типізації функціональних компонентів.

#### Підхід 1: `React.FC<Props>` (заст

арілий, але популярний)

```typescript
import { FC } from 'react';

interface ButtonProps {
  label: string;
  onClick: () => void;
}

const Button: FC<ButtonProps> = ({ label, onClick }) => {
  return <button onClick={onClick}>{label}</button>;
};
```

**Що дає `FC`?**

- Автоматично додає тип `children?: ReactNode`.
- Встановлює тип повернення як `JSX.Element`.

**Проблеми:**

- До React 18, `FC` автоматично додавав `children`, навіть якщо компонент їх не приймав (це було виправлено).
- Неявність: новачки не розуміють, звідки взявся `children`.

#### Підхід 2: Явна типізація (рекомендується)

```typescript
interface ButtonProps {
  label: string;
  onClick: () => void;
}

function Button({ label, onClick }: ButtonProps): JSX.Element {
  return <button onClick={onClick}>{label}</button>;
}
```

**Переваги:**

- Повна прозорість.
- Ви самі контролюєте, чи приймає компонент `children`.

::tip
**Рекомендація 2024+:** Використовуйте явну типізацію. `FC` — це legacy підхід.
::

---

### 2.2. Пропси з `children`

Якщо ваш компонент може приймати вкладені елементи, є три варіанти типізації:

#### Варіант 1: Вручну додати `children`

```typescript
import { ReactNode } from 'react';

interface CardProps {
  title: string;
  children: ReactNode; // Найбільш гнучкий тип
}

function Card({ title, children }: CardProps) {
  return (
    <div>
      <h2>{title}</h2>
      <div>{children}</div>
    </div>
  );
}
```

#### Варіант 2: `PropsWithChildren` (утиліта з React)

```typescript
import { PropsWithChildren } from 'react';

interface CardProps {
  title: string;
}

function Card({ title, children }: PropsWithChildren<CardProps>) {
  return (
    <div>
      <h2>{title}</h2>
      <div>{children}</div>
    </div>
  );
}
```

**Що таке `ReactNode`?**
Це Union тип, який включає все, що можна рендерити у React:

- Рядки, числа
- `JSX.Element`
- `null`, `undefined`, `boolean` (рендеряться як порожні)
- Масиви `ReactNode[]`
- `ReactPortal`

```typescript
type ReactNode = ReactElement | string | number | ReactFragment | ReactPortal | boolean | null | undefined
```

---

### 2.3. Опціональні пропси та значення за замовчуванням

#### Опціональні пропси через `?`

```typescript
interface AvatarProps {
  src: string;
  alt?: string; // Опціональний
  size?: number;
}

function Avatar({ src, alt = 'User avatar', size = 48 }: AvatarProps) {
  return <img src={src} alt={alt} width={size} height={size} />;
}
```

#### Перевірка vs Inference

TypeScript автоматично виведе тип з значень за замовчуванням:

```typescript
// ✅ size має тип number (завдяки = 48)
function Avatar({ src, alt = 'User', size = 48 }: AvatarProps) {}

// ❌ size може бути undefined, якщо не передано
function Avatar({ src, alt, size }: AvatarProps) {
    console.log(size.toFixed(2)) // Error: size може бути undefined
}
```

---

## 3. Типізація Props: Патерни та Best Practices

### 3.1. `interface` vs `type` для пропсів

Обидва працюють, але є нюанси:

```typescript
// ✅ Interface (рекомендується для пропсів)
interface UserCardProps {
    name: string
    email: string
}

// ✅ Type Alias (працює так само)
type UserCardProps = {
    name: string
    email: string
}
```

**Коли використовувати `interface`?**

- Для пропсів, стейту, контекстів.
- Коли потрібна можливість розширення (Declaration Merging).

**Коли використовувати `type`?**

- Для Union типів (`type Status = 'idle' | 'loading'`).
- Для Mapped Types, Utility Types.

::tip
**Стиль кодування:** У React екосистемі традиційно використовують `interface` для об'єктних типів та `type` для примітивів/унійонів.
::

---

### 3.2. Деструктуризація пропсів

TypeScript чудово працює з деструктуризацією:

```typescript
interface ProductProps {
  id: string;
  name: string;
  price: number;
  inStock: boolean;
}

// ✅ Деструктуризація з типом
function Product({ id, name, price, inStock }: ProductProps) {
  return (
    <div data-id={id}>
      <h3>{name}</h3>
      <span>${price.toFixed(2)}</span>
      {!inStock && <p>Out of stock</p>}
    </div>
  );
}
```

#### Nested деструктуризація

```typescript
interface UserProps {
  user: {
    name: string;
    address: {
      city: string;
    };
  };
}

function UserCard({ user: { name, address: { city } } }: UserProps) {
  return <div>{name} from {city}</div>;
}
```

---

### 3.3. Spread Props Pattern

Іноді потрібно передати всі атрибути HTML елементу:

```typescript
import { ComponentProps } from 'react';

type ButtonProps = ComponentProps<'button'> & {
  variant?: 'primary' | 'secondary';
};

function Button({ variant = 'primary', ...props }: ButtonProps) {
  return <button className={`btn-${variant}`} {...props} />;
}

// Використання
<Button onClick={() => {}} disabled aria-label="Close">
  Click me
</Button>
```

**Що таке `ComponentProps<'button'>`?**
Це утиліта, яка витягує всі стандартні HTML атрибути для елемента `<button>`:

- `onClick`, `disabled`, `type`, `aria-*`, тощо.

---

## 4. Типізація `useState`

### 4.1. Автоматичний Inference

У більшості випадків TypeScript сам виведе тип:

```typescript
// ✅ TypeScript знає, що count - це number
const [count, setCount] = useState(0)

// ✅ TypeScript знає, що name - це string
const [name, setName] = useState('')
```

### 4.2. Явна типізація через Generic

Коли потрібно вказати тип вручну:

```typescript
interface User {
    id: string
    name: string
}

// ✅ Явний Generic
const [user, setUser] = useState<User | null>(null)

// Тепер можна безпечно працювати:
if (user) {
    console.log(user.name) // OK
}
```

**Без явного типу:**

```typescript
// ❌ TypeScript не може вивести тип із null
const [user, setUser] = useState(null)
// user має тип null, навіть після setUser({ id: '1', name: 'Alice' })
```

---

### 4.3. Складні стани (Union Types)

Класичний приклад: асинхронне завантаження даних.

#### Поганий спосіб (Boolean прапорці)

```typescript
const [isLoading, setIsLoading] = useState(false)
const [error, setError] = useState<string | null>(null)
const [data, setData] = useState<User[] | null>(null)

// ❌ Можливі невалідні стани:
// isLoading: true, error: "Failed", data: [...]
```

#### Хороший спосіб (Discriminated Union)

```typescript
type DataState =
    | { status: 'idle' }
    | { status: 'loading' }
    | { status: 'success'; data: User[] }
    | { status: 'error'; error: string }

const [state, setState] = useState<DataState>({ status: 'idle' })

// Використання з Type Narrowing
if (state.status === 'success') {
    console.log(state.data) // ✅ TypeScript знає, що data існує
}
```

---

## 5. Типізація `useRef`

`useRef` має два основні сценарії використання, і типізація відрізняється.

### 5.1. Для DOM елементів (read-only)

```typescript
import { useRef } from 'react';

function TextInput() {
  // ✅ HTMLInputElement | null
  const inputRef = useRef<HTMLInputElement>(null);

  const focusInput = () => {
    inputRef.current?.focus(); // Optional chaining, бо може бути null
  };

  return <input ref={inputRef} />;
}
```

**Чому `null`?**
На момент виклику `useRef`, елемент ще не змонтований. Тому початкове значення завжди `null`.

---

### 5.2. Для мутабельних значень

Якщо ви використовуєте `useRef` для зберігання значення (не DOM ref):

```typescript
function Timer() {
  // ✅ Мутабельне число
  const intervalId = useRef<number | null>(null);

  const startTimer = () => {
    intervalId.current = window.setInterval(() => {
      console.log('Tick');
    }, 1000);
  };

  const stopTimer = () => {
    if (intervalId.current) {
      clearInterval(intervalId.current);
    }
  };

  return <button onClick={startTimer}>Start</button>;
}
```

---

### 5.3. Non-null assertion (`!`)

Якщо ви **впевнені**, що ref буде встановлений до моменту першого використання:

```typescript
const inputRef = useRef<HTMLInputElement>(null!)
// ⚠️ Небезпечно: ви гарантуєте, що це ніколи не буде null

inputRef.current.focus() // Немає optional chaining
```

::warning
**Використовуйте `!` обережно!**
Це відключає перевірку на `null`, що може призвести до runtime помилок.
::

---

## 6. Типізація `useEffect` та `useCallback`

### 6.1. `useEffect`

`useEffect` не повертає значення (крім cleanup функції), тому його типізація проста:

```typescript
useEffect(
    () => {
        // ✅ TypeScript перевіряє тіло ефекту
        const subscription = api.subscribe()

        // ✅ Cleanup функція
        return () => {
            subscription.unsubscribe()
        }
    },
    [
        /* dependencies */
    ],
)
```

**Типові помилки:**

```typescript
// ❌ useEffect не може бути async
useEffect(async () => {
    const data = await fetchData()
}, [])

// ✅ Правильний спосіб
useEffect(() => {
    async function loadData() {
        const data = await fetchData()
    }
    loadData()
}, [])
```

---

### 6.2. `useCallback`

TypeScript автоматично виводить типи параметрів та повернення:

```typescript
const handleClick = useCallback((event: React.MouseEvent<HTMLButtonElement>) => {
    console.log(event.currentTarget.value)
}, [])

// TypeScript знає:
// handleClick: (event: React.MouseEvent<HTMLButtonElement>) => void
```

---

## 7. Типізація Events (Події)

Це одна з найчастіших проблем новачків у React + TS.

### 7.1. Основні типи подій

#### `ChangeEvent` (для `<input>`, `<textarea>`, `<select>`)

```typescript
import { ChangeEvent } from 'react';

function NameInput() {
  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    console.log(e.target.value); // string
  };

  return <input onChange={handleChange} />;
}
```

#### `FormEvent` (для `<form>`)

```typescript
import { FormEvent } from 'react';

function LoginForm() {
  const handleSubmit = (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const formData = new FormData(e.currentTarget);
  };

  return <form onSubmit={handleSubmit}>...</form>;
}
```

#### `MouseEvent`

```typescript
import { MouseEvent } from 'react';

function Button() {
  const handleClick = (e: MouseEvent<HTMLButtonElement>) => {
    console.log(e.clientX, e.clientY);
  };

  return <button onClick={handleClick}>Click</button>;
}
```

#### `KeyboardEvent`

```typescript
import { KeyboardEvent } from 'react';

function SearchInput() {
  const handleKeyDown = (e: KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      console.log('Search:', e.currentTarget.value);
    }
  };

  return <input onKeyDown={handleKeyDown} />;
}
```

---

### 7.2. Generic Element Type

Ви можете параметризувати тип івента:

```typescript
function handleChange<T extends HTMLInputElement | HTMLTextAreaElement>(
  e: ChangeEvent<T>
) {
  console.log(e.target.value);
}

// Працює для обох
<input onChange={handleChange} />
<textarea onChange={handleChange} />
```

---

### 7.3. Inline Handlers

TypeScript виводить типи автоматично:

```typescript
<button onClick={(e) => {
  // e має тип MouseEvent<HTMLButtonElement>
  console.log(e.currentTarget.tagName);
}}>
  Click
</button>
```

---

## 8. Типізація Style та ClassName

### 8.1. `className` (string)

```typescript
interface DivProps {
  className?: string;
}

function CustomDiv({ className }: DivProps) {
  return <div className={className} />;
}
```

### 8.2. `style` (CSSProperties)

```typescript
import { CSSProperties } from 'react';

interface BoxProps {
  style?: CSSProperties;
}

function Box({ style }: BoxProps) {
  return <div style={{ padding: '10px', ...style }} />;
}

// Використання
<Box style={{ backgroundColor: 'blue' }} />
```

**Що таке `CSSProperties`?**
Це тип з React, який містить всі валідні CSS властивості як camelCase:

```typescript
const styles: CSSProperties = {
    backgroundColor: 'red',
    marginTop: '20px',
    fontSize: '16px',
}
```

---

## 9. Типізація пропсів для компонентів вищого порядку (HOC)

### 9.1. Base HOC Pattern

```typescript
import { ComponentType } from 'react';

interface WithLoadingProps {
  isLoading: boolean;
}

function withLoading<P extends object>(
  Component: ComponentType<P>
): ComponentType<P & WithLoadingProps> {
  return ({ isLoading, ...props }: P & WithLoadingProps) => {
    if (isLoading) {
      return <div>Loading...</div>;
    }
    return <Component {...(props as P)} />;
  };
}

// Використання
interface UserProps {
  name: string;
}

const User = ({ name }: UserProps) => <div>{name}</div>;
const UserWithLoading = withLoading(User);

<UserWithLoading name="Alice" isLoading={false} />
```

---

## 10. Типізація defaultProps (Legacy)

::warning
**Deprecated у React 18+!**
Замість `defaultProps` використовуйте ES6 default parameters.
::

### Старий спосіб (не рекомендується)

```typescript
interface ButtonProps {
  label: string;
  variant?: 'primary' | 'secondary';
}

function Button({ label, variant }: ButtonProps) {
  return <button className={variant}>{label}</button>;
}

Button.defaultProps = {
  variant: 'primary',
};
```

### Сучасний спосіб (рекомендується)

```typescript
interface ButtonProps {
  label: string;
  variant?: 'primary' | 'secondary';
}

function Button({ label, variant = 'primary' }: ButtonProps) {
  return <button className={variant}>{label}</button>;
}
```

---

## 11. Практичний кейс: Form з валідацією

Давайте створимо компонент форми з типізацією на всіх рівнях.

```typescript
import { FormEvent, ChangeEvent, useState } from 'react';

interface FormData {
  email: string;
  password: string;
}

interface FormErrors {
  email?: string;
  password?: string;
}

function LoginForm() {
  const [formData, setFormData] = useState<FormData>({
    email: '',
    password: '',
  });

  const [errors, setErrors] = useState<FormErrors>({});

  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setFormData((prev) => ({ ...prev, [name]: value }));
  };

  const validate = (): boolean => {
    const newErrors: FormErrors = {};

    if (!formData.email.includes('@')) {
      newErrors.email = 'Invalid email';
    }

    if (formData.password.length < 6) {
      newErrors.password = 'Password must be at least 6 characters';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    if (validate()) {
      console.log('Form data:', formData);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        name="email"
        value={formData.email}
        onChange={handleChange}
      />
      {errors.email && <span>{errors.email}</span>}

      <input
        type="password"
        name="password"
        value={formData.password}
        onChange={handleChange}
      />
      {errors.password && <span>{errors.password}</span>}

      <button type="submit">Login</button>
    </form>
  );
}
```

---

## 12. Type Guards у компонентах

Іноді потрібно перевірити тип пропсу у runtime.

### 12.1. Type Predicate

```typescript
interface Dog {
  type: 'dog';
  bark: () => void;
}

interface Cat {
  type: 'cat';
  meow: () => void;
}

type Pet = Dog | Cat;

function isDog(pet: Pet): pet is Dog {
  return pet.type === 'dog';
}

function PetCard({ pet }: { pet: Pet }) {
  if (isDog(pet)) {
    return <button onClick={pet.bark}>Bark</button>;
  }

  return <button onClick={pet.meow}>Meow</button>;
}
```

---

## 13. Помилки та їх рішення

### Помилка 1: "Type 'string' is not assignable to type 'never'"

```typescript
// ❌ Проблема
const [data, setData] = useState({})
data.name = 'Alice' // Error!

// ✅ Рішення
interface Data {
    name: string
}
const [data, setData] = useState<Data>({ name: '' })
```

### Помилка 2: "Object is possibly 'null'"

```typescript
// ❌ Проблема
const ref = useRef<HTMLDivElement>(null)
ref.current.scrollIntoView() // Error!

// ✅ Рішення 1: Optional chaining
ref.current?.scrollIntoView()

// ✅ Рішення 2: Non-null assertion (якщо впевнені)
ref.current!.scrollIntoView()

// ✅ Рішення 3: Guard clause
if (ref.current) {
    ref.current.scrollIntoView()
}
```

### Помилка 3: "Property 'value' does not exist on type 'EventTarget'"

```typescript
// ❌ Проблема
const handleChange = (e) => {
    console.log(e.target.value) // Error!
}

// ✅ Рішення
const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    console.log(e.target.value) // OK
}
```

---

## 14. Best Practices

::card-group
::card
**1. Використовуйте `strict: true`**  
Це активує всі строгі перевірки TypeScript. Без цього ви втрачаєте 50% переваг TS.
::

::card
**2. Уникайте `any`**  
Кожен `any` — це "дірка" у вашій типовій безпеці. Використовуйте `unknown` як безпечну альтернативу.
::

::card
**3. Не типізуйте очевидне**  
TypeScript чудово виводить типи. Не пишіть `const count: number = 0`, це надлишково.
::

::card
**4. Використовуйте Utility Types**  
`Partial`, `Pick`, `Omit`, `Record` — ваші друзі. Не дублюйте типи вручну.
::

::card
**5. Зберігайте типи поряд із компонентами**  
Не створюйте папку `types/` для всього. Типи — це частина компонента.
::

::card
**6. Discriminated Unions для стану**  
Замість `isLoading + error + data` використовуйте `{ status: 'loading' } | { status: 'error', error } | { status: 'success', data }`.
::
::

---

## 15. Cheat Sheet: Типи React

```typescript
import {
    // Компоненти
    FC,
    ComponentType,
    ComponentProps,

    // Типи пропсів
    PropsWithChildren,
    ReactNode,
    ReactElement,

    // Події
    ChangeEvent,
    FormEvent,
    MouseEvent,
    KeyboardEvent,
    FocusEvent,

    // Хуки
    Dispatch,
    SetStateAction,
    MutableRefObject,
    RefObject,

    // Стилі
    CSSProperties,

    // Інше
    JSX,
} from 'react'
```

---

## 16. Практичне завдання

Створіть компонент `UserList` з наступними вимогами:

1.  **Пропси:**
    - `users: User[]` — масив користувачів.
    - `onUserClick: (userId: string) => void` — callback при кліку.
    - `emptyMessage?: string` — повідомлення, якщо список порожній (за замовчуванням "No users found").
2.  **Тип `User`:**
    ```typescript
    interface User {
        id: string
        name: string
        email: string
        role: 'admin' | 'user' | 'guest'
    }
    ```
3.  **Додаткова логіка:**
    - Якщо `users` порожній, показати `emptyMessage`.
    - Кожен елемент списку має бути кнопкою з `onClick`.
    - Адміністратори мають відмінний стиль (використовуйте `CSSProperties`).

### Рішення (спробуйте спочатку самі!)

```typescript
import { CSSProperties } from 'react';

interface User {
  id: string;
  name: string;
  email: string;
  role: 'admin' | 'user' | 'guest';
}

interface UserListProps {
  users: User[];
  onUserClick: (userId: string) => void;
  emptyMessage?: string;
}

function UserList({
  users,
  onUserClick,
  emptyMessage = 'No users found'
}: UserListProps) {
  if (users.length === 0) {
    return <p>{emptyMessage}</p>;
  }

  const getStyle = (role: User['role']): CSSProperties => {
    if (role === 'admin') {
      return { fontWeight: 'bold', color: 'red' };
    }
    return {};
  };

  return (
    <ul>
      {users.map((user) => (
        <li key={user.id}>
          <button
            onClick={() => onUserClick(user.id)}
            style={getStyle(user.role)}
          >
            {user.name} ({user.email})
          </button>
        </li>
      ))}
    </ul>
  );
}

export default UserList;
```

---

## Підсумок

Ви навчилися:

- ✅ Типізувати функціональні компоненти через явну типізацію (рекомендовано) або `FC`.
- ✅ Працювати з пропсами: опціональні поля, деструктуризація, spread.
- ✅ Типізувати хуки `useState`, `useRef`, `useEffect`.
- ✅ Правильно типізувати React події: `ChangeEvent`, `MouseEvent`, `FormEvent`.
- ✅ Використовувати Utility Types (`ComponentProps`, `PropsWithChildren`, `CSSProperties`).
- ✅ Розуміти різницю між `interface` та `type` для пропсів.
- ✅ Застосовувати Type Guards для умовного рендерингу.

**Наступний крок:** У наступному розділі ми розглянемо Context API, Generic Components та Polymorphic Components — найскладніші та найпотужніші патерни React + TypeScript.
