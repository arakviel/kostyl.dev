---
title: Advanced Types
description: –ì–ª–∏–±–æ–∫–µ –∑–∞–Ω—É—Ä–µ–Ω–Ω—è —É —Ä–æ–∑—à–∏—Ä–µ–Ω—ñ —Ç–∏–ø–∏ –¥–∞–Ω–∏—Ö C# - —Å—Ç—Ä—É–∫—Ç—É—Ä–∏, –ø–µ—Ä–µ—Ä–∞—Ö—É–≤–∞–Ω–Ω—è, –∑–∞–ø–∏—Å–∏, –∫–æ—Ä—Ç–µ–∂—ñ —Ç–∞ nullable —Ç–∏–ø–∏
---

# Advanced Types (–†–æ–∑—à–∏—Ä–µ–Ω—ñ –¢–∏–ø–∏)

## –í—Å—Ç—É–ø

–£—è–≤—ñ—Ç—å, —â–æ –≤–∏ —Ä–æ–∑—Ä–æ–±–ª—è—î—Ç–µ —Å–∏—Å—Ç–µ–º—É –¥–ª—è —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è –≥–µ–æ–º–µ—Ç—Ä–∏—á–Ω–∏–º–∏ —Ñ—ñ–≥—É—Ä–∞–º–∏. –í–∞–º –ø–æ—Ç—Ä—ñ–±–Ω–æ –∑–±–µ—Ä—ñ–≥–∞—Ç–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ —Ç–æ—á–æ–∫, –∫–æ–ª—å–æ—Ä–∏, —Å—Ç–∞–Ω–∏ –æ–±'—î–∫—Ç—ñ–≤ —Ç–∞ –±–∞–≥–∞—Ç–æ —ñ–Ω—à–∏—Ö –¥–∞–Ω–∏—Ö. –Ø–∫–∏–π —Ç–∏–ø –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ –≤–∏–ø–∞–¥–∫—É? –ö–ª–∞—Å? –°—Ç—Ä—É–∫—Ç—É—Ä—É? –ó–∞–ø–∏—Å? –í–∏–±—ñ—Ä –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ —Ç–∏–ø—É –¥–∞–Ω–∏—Ö –≤–ø–ª–∏–≤–∞—î –Ω–µ –ª–∏—à–µ –Ω–∞ —á–∏—Ç–∞–±–µ–ª—å–Ω—ñ—Å—Ç—å –∫–æ–¥—É, –∞–ª–µ –π –Ω–∞ –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å, —Å–ø–æ–∂–∏–≤–∞–Ω–Ω—è –ø–∞–º'—è—Ç—ñ —Ç–∞ –∑–∞–≥–∞–ª—å–Ω—É –∞—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä—É –∑–∞—Å—Ç–æ—Å—É–Ω–∫—É.

C# –ø—Ä–æ–ø–æ–Ω—É—î –±–∞–≥–∞—Ç–∏–π –Ω–∞–±—ñ—Ä —Ä–æ–∑—à–∏—Ä–µ–Ω–∏—Ö —Ç–∏–ø—ñ–≤ –¥–∞–Ω–∏—Ö, –∫–æ–∂–µ–Ω –∑ —è–∫–∏—Ö –æ–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω–∏–π –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏—Ö —Å—Ü–µ–Ω–∞—Ä—ñ—ó–≤ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è. –£ —Ü—å–æ–º—É —Ä–æ–∑–¥—ñ–ª—ñ –º–∏ –¥–µ—Ç–∞–ª—å–Ω–æ —Ä–æ–∑–≥–ª—è–Ω–µ–º–æ **—Å—Ç—Ä—É–∫—Ç—É—Ä–∏ (structs)**, **–ø–µ—Ä–µ—Ä–∞—Ö—É–≤–∞–Ω–Ω—è (enums)**, **–∑–∞–ø–∏—Å–∏ (records)**, **–∫–æ—Ä—Ç–µ–∂—ñ (tuples)**, **–∞–Ω–æ–Ω—ñ–º–Ω—ñ —Ç–∏–ø–∏ (anonymous types)**, **nullable —Ç–∏–ø–∏** —Ç–∞ –∫–æ–Ω—Ü–µ–ø—Ü—ñ—é **discriminated unions**.

::tip
–†–æ–∑—É–º—ñ–Ω–Ω—è –≤—ñ–¥–º—ñ–Ω–Ω–æ—Å—Ç–µ–π –º—ñ–∂ —Ä—ñ–∑–Ω–∏–º–∏ —Ç–∏–ø–∞–º–∏ –¥–∞–Ω–∏—Ö ‚Äî –∫–ª—é—á –¥–æ –Ω–∞–ø–∏—Å–∞–Ω–Ω—è –µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–≥–æ —Ç–∞ –ø—ñ–¥—Ç—Ä–∏–º—É–≤–∞–Ω–æ–≥–æ –∫–æ–¥—É. –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∏–π –≤–∏–±—ñ—Ä —Ç–∏–ø—É –º–æ–∂–µ –ø—Ä–∏–∑–≤–µ—Å—Ç–∏ –¥–æ –ø—Ä–æ–±–ª–µ–º –∑ –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω—ñ—Å—Ç—é –∞–±–æ –∞—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–Ω–∏—Ö –ø–æ–º–∏–ª–æ–∫.
::

## Structs (–°—Ç—Ä—É–∫—Ç—É—Ä–∏)

### –©–æ —Ç–∞–∫–µ Struct?

**Struct (—Å—Ç—Ä—É–∫—Ç—É—Ä–∞)** ‚Äî —Ü–µ value type (—Ç–∏–ø-–∑–Ω–∞—á–µ–Ω–Ω—è), —è–∫–∏–π –∑–±–µ—Ä—ñ–≥–∞—î—Ç—å—Å—è –Ω–∞ —Å—Ç–µ–∫—É (stack) —ñ –ø–µ—Ä–µ–¥–∞—î—Ç—å—Å—è –∑–∞ –∑–Ω–∞—á–µ–Ω–Ω—è–º. –ù–∞ –≤—ñ–¥–º—ñ–Ω—É –≤—ñ–¥ –∫–ª–∞—Å—ñ–≤, —è–∫—ñ —î reference types (—Ç–∏–ø–∞–º–∏-–ø–æ—Å–∏–ª–∞–Ω–Ω—è–º–∏) —ñ –∑–±–µ—Ä—ñ–≥–∞—é—Ç—å—Å—è –≤ –∫—É–ø—ñ (heap), —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ –æ–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω—ñ –¥–ª—è –Ω–µ–≤–µ–ª–∏–∫–∏—Ö, –ª–µ–≥–∫–∏—Ö –æ–±'—î–∫—Ç—ñ–≤.

### Struct vs Class: –ö–ª—é—á–æ–≤—ñ –≤—ñ–¥–º—ñ–Ω–Ω–æ—Å—Ç—ñ

| –ö—Ä–∏—Ç–µ—Ä—ñ–π                       | Struct                                   | Class                      |
| :----------------------------- | :--------------------------------------- | :------------------------- |
| **–¢–∏–ø**                        | Value Type                               | Reference Type             |
| **–†–æ–∑–º—ñ—â–µ–Ω–Ω—è –≤ –ø–∞–º'—è—Ç—ñ**       | Stack (–∑–∞–∑–≤–∏—á–∞–π)                         | Heap                       |
| **–ü–µ—Ä–µ–¥–∞—á–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤**        | –ó–∞ –∑–Ω–∞—á–µ–Ω–Ω—è–º (–∫–æ–ø—ñ—è)                     | –ó–∞ –ø–æ—Å–∏–ª–∞–Ω–Ω—è–º              |
| **–ù–∞—Å–ª—ñ–¥—É–≤–∞–Ω–Ω—è**               | –ù–µ–º–æ–∂–ª–∏–≤–µ                                | –ú–æ–∂–ª–∏–≤–µ                    |
| **`null` –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º**    | –ù–µ –º–æ–∂–µ –±—É—Ç–∏ `null` (–∫—Ä—ñ–º `Nullable<T>`) | –ú–æ–∂–µ –±—É—Ç–∏ `null`           |
| **–ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –±–µ–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤** | –ó–∞–≤–∂–¥–∏ —î (–∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π)                  | –ü–æ—Ç—Ä–µ–±—É—î –æ–≥–æ–ª–æ—à–µ–Ω–Ω—è        |
| **–ü—Ä–æ–¥—É–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å**             | –ö—Ä–∞—â–∞ –¥–ª—è –º–∞–ª–∏—Ö –¥–∞–Ω–∏—Ö                    | –ö—Ä–∞—â–∞ –¥–ª—è –≤–µ–ª–∏–∫–∏—Ö –æ–±'—î–∫—Ç—ñ–≤ |

::note
**Value Type vs Reference Type**: Value types –∑–±–µ—Ä—ñ–≥–∞—é—Ç—å –¥–∞–Ω—ñ –±–µ–∑–ø–æ—Å–µ—Ä–µ–¥–Ω—å–æ, –∞ reference types –∑–±–µ—Ä—ñ–≥–∞—é—Ç—å –∞–¥—Ä–µ—Å—É (–ø–æ—Å–∏–ª–∞–Ω–Ω—è) –Ω–∞ –æ–±'—î–∫—Ç —É –ø–∞–º'—è—Ç—ñ. –¶–µ —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω–∞ —Ä—ñ–∑–Ω–∏—Ü—è, —è–∫–∞ –≤–ø–ª–∏–≤–∞—î –Ω–∞ –ø–æ–≤–µ–¥—ñ–Ω–∫—É –∫–æ–¥—É.
::

### –û–≥–æ–ª–æ—à–µ–Ω–Ω—è Struct

```csharp [Point.cs] showLineNumbers
public struct Point
{
    public double X { get; set; }
    public double Y { get; set; }

    public Point(double x, double y)
    {
        X = x;
        Y = y;
    }

    public double DistanceFromOrigin()
    {
        return Math.Sqrt(X * X + Y * Y);
    }

    public override string ToString()
    {
        return $"({X}, {Y})";
    }
}

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
Point p1 = new Point(3, 4);
Point p2 = p1; // –ö–æ–ø—ñ—è –∑–Ω–∞—á–µ–Ω–Ω—è, –∞ –Ω–µ –ø–æ—Å–∏–ª–∞–Ω–Ω—è!
p2.X = 10;

Console.WriteLine(p1); // (3, 4) - p1 –Ω–µ –∑–º—ñ–Ω–∏–≤—Å—è
Console.WriteLine(p2); // (10, 4)
```

::warning
**–í–∞–∂–ª–∏–≤–æ**: –ü—Ä–∏ –ø—Ä–∏—Å–≤–æ—î–Ω–Ω—ñ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ —ñ–Ω—à—ñ–π –∑–º—ñ–Ω–Ω—ñ–π —Å—Ç–≤–æ—Ä—é—î—Ç—å—Å—è **–ø–æ–≤–Ω–∞ –∫–æ–ø—ñ—è** –¥–∞–Ω–∏—Ö. –¶–µ –≤—ñ–¥—Ä—ñ–∑–Ω—è—î—Ç—å—Å—è –≤—ñ–¥ –∫–ª–∞—Å—ñ–≤, –¥–µ –æ–±–∏–¥–≤—ñ –∑–º—ñ–Ω–Ω—ñ –≤–∫–∞–∑—É–≤–∞–ª–∏ –± –Ω–∞ —Ç–æ–π —Å–∞–º–∏–π –æ–±'—î–∫—Ç —É –ø–∞–º'—è—Ç—ñ.
::

### –ö–æ–ª–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ Struct?

**–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ struct, —è–∫—â–æ:**

-   –û–±'—î–∫—Ç –Ω–µ–≤–µ–ª–∏–∫–∏–π (–∑–∞–∑–≤–∏—á–∞–π ‚â§ 16 –±–∞–π—Ç)
-   –õ–æ–≥—ñ—á–Ω–æ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—î –æ–¥–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è (–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞, –∫–æ–ª—ñ—Ä, —Ä–æ–∑–º—ñ—Ä)
-   –ù–µ –ø–æ—Ç—Ä—ñ–±–Ω–µ –Ω–∞—Å–ª—ñ–¥—É–≤–∞–Ω–Ω—è
-   –û–±'—î–∫—Ç –Ω–µ –∑–º—ñ–Ω—é—î—Ç—å—Å—è –ø—ñ—Å–ª—è —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è (immutable)
-   –ß–∞—Å—Ç–æ –ø–µ—Ä–µ–¥–∞—î—Ç—å—Å—è —è–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä –º–µ—Ç–æ–¥—ñ–≤

**–ü—Ä–∏–∫–ª–∞–¥–∏ –∑ .NET BCL**: `DateTime`, `TimeSpan`, `Guid`, `Int32`, `Double`

```csharp [Examples.cs] showLineNumbers
// –ì–∞—Ä–Ω–∏–π –ø—Ä–∏–∫–ª–∞–¥ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è struct - –Ω–µ–≤–µ–ª–∏–∫–∏–π immutable —Ç–∏–ø
public readonly struct Color
{
    public byte R { get; }
    public byte G { get; }
    public byte B { get; }

    public Color(byte r, byte g, byte b)
    {
        R = r;
        G = g;
        B = b;
    }
}

// –ü–æ–≥–∞–Ω–∏–π –ø—Ä–∏–∫–ª–∞–¥ - –∑–∞–Ω–∞–¥—Ç–æ –≤–µ–ª–∏–∫–∏–π –¥–ª—è struct
public struct HugeData // ‚ùå –ö—Ä–∞—â–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ class
{
    public double[] Data { get; set; } // –ú–∞—Å–∏–≤ –∑ 1000 –µ–ª–µ–º–µ–Ω—Ç—ñ–≤
    public string Description { get; set; }
    // ... –±–∞–≥–∞—Ç–æ –ø–æ–ª—ñ–≤
}
```

### ref struct: –û–±–º–µ–∂–µ–Ω–Ω—è —Å—Ç–µ–∫–æ–º

**ref struct** ‚Äî —Ü–µ —Å–ø–µ—Ü—ñ–∞–ª—å–Ω–∏–π –≤–∏–¥ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏, —è–∫–∏–π **–æ–±–æ–≤'—è–∑–∫–æ–≤–æ** –º–∞—î –∑–±–µ—Ä—ñ–≥–∞—Ç–∏—Å—è –Ω–∞ —Å—Ç–µ–∫—É —ñ –Ω–µ –º–æ–∂–µ –ø–æ—Ç—Ä–∞–ø–∏—Ç–∏ –≤ –∫—É–ø—É. –¶–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –¥–ª—è –≤–∏—Å–æ–∫–æ–ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–∏—Ö —Å—Ü–µ–Ω–∞—Ä—ñ—ó–≤, –Ω–∞–ø—Ä–∏–∫–ª–∞–¥, `Span<T>`.

```csharp [RefStruct.cs] showLineNumbers
public ref struct SpanExample
{
    private Span<int> _numbers;

    public SpanExample(Span<int> numbers)
    {
        _numbers = numbers;
    }

    // ref struct –º–∞—î —Å—É–≤–æ—Ä—ñ –æ–±–º–µ–∂–µ–Ω–Ω—è:
    // ‚ùå –ù–µ –º–æ–∂–µ –±—É—Ç–∏ –ø–æ–ª–µ–º –∫–ª–∞—Å—É
    // ‚ùå –ù–µ –º–æ–∂–µ —Ä–µ–∞–ª—ñ–∑–æ–≤—É–≤–∞—Ç–∏ —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∏
    // ‚ùå –ù–µ –º–æ–∂–µ –±—É—Ç–∏ boxing (–ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è –≤ object)
    // ‚ùå –ù–µ –º–æ–∂–µ –±—É—Ç–∏ —Ç–∏–ø–æ–º –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ async –º–µ—Ç–æ–¥—É
}
```

::tip
**ref struct** –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –ª–∏—à–µ –¥–ª—è –≤–∏—Å–æ–∫–æ–ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–∏—Ö –æ–ø–µ—Ä–∞—Ü—ñ–π –∑ –ø–∞–º'—è—Ç—Ç—é, –∫–æ–ª–∏ –ø–æ—Ç—Ä—ñ–±–µ–Ω –ø–æ–≤–Ω–∏–π –∫–æ–Ω—Ç—Ä–æ–ª—å –Ω–∞–¥ —Ä–æ–∑–º—ñ—â–µ–Ω–Ω—è–º –¥–∞–Ω–∏—Ö –Ω–∞ —Å—Ç–µ–∫—É. –ü—Ä–∏–∫–ª–∞–¥–∏: `Span<T>`, `ReadOnlySpan<T>`, `Utf8JsonReader`.
::

::mermaid

```mermaid
graph LR
    A[Struct Types] --> B[Regular Struct]
    A --> C[ref struct]
    A --> D[readonly struct]

    B --> E[Can be boxed]
    B --> F[Can be in heap as field]

    C --> G[Stack only]
    C --> H[No boxing]
    C --> I[No async methods]

    D --> J[Immutable]
    D --> K[Better performance]

    style A fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style B fill:#64748b,stroke:#334155,color:#ffffff
    style C fill:#f59e0b,stroke:#b45309,color:#ffffff
    style D fill:#64748b,stroke:#334155,color:#ffffff
    style E fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style F fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style G fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style H fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style I fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style J fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style K fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
```

::

![–†–æ–∑–º—ñ—â–µ–Ω–Ω—è struct vs class —É –ø–∞–º'—è—Ç—ñ](/images/csharp/oop/advanced-types/struct-vs-class-memory.png)

<!-- Search Query: C# struct vs class memory layout diagram stack heap visualization -->

---

## Enums (–ü–µ—Ä–µ—Ä–∞—Ö—É–≤–∞–Ω–Ω—è)

### –ë–∞–∑–æ–≤–µ –æ–≥–æ–ª–æ—à–µ–Ω–Ω—è

**Enum (enumeration, –ø–µ—Ä–µ—Ä–∞—Ö—É–≤–∞–Ω–Ω—è)** ‚Äî —Ü–µ value type, —è–∫–∏–π –≤–∏–∑–Ω–∞—á–∞—î –Ω–∞–±—ñ—Ä —ñ–º–µ–Ω–æ–≤–∞–Ω–∏—Ö –∫–æ–Ω—Å—Ç–∞–Ω—Ç. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –¥–ª—è –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—è —Ñ—ñ–∫—Å–æ–≤–∞–Ω–æ–≥–æ –Ω–∞–±–æ—Ä—É –º–æ–∂–ª–∏–≤–∏—Ö –∑–Ω–∞—á–µ–Ω—å.

```csharp [OrderStatus.cs] showLineNumbers
public enum OrderStatus
{
    Pending,      // 0 (–∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º)
    Processing,   // 1
    Shipped,      // 2
    Delivered,    // 3
    Cancelled     // 4
}

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
OrderStatus status = OrderStatus.Pending;

if (status == OrderStatus.Delivered)
{
    Console.WriteLine("–ó–∞–º–æ–≤–ª–µ–Ω–Ω—è –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ!");
}

// –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—è –≤ int
int statusCode = (int)status; // 0

// –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—è –∑ int
OrderStatus newStatus = (OrderStatus)2; // Shipped
```

### Underlying Types (–ë–∞–∑–æ–≤—ñ —Ç–∏–ø–∏)

–ó–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º enum –±–∞–∑—É—î—Ç—å—Å—è –Ω–∞ —Ç–∏–ø—ñ `int`, –∞–ª–µ –º–æ–∂–Ω–∞ –≤–∫–∞–∑–∞—Ç–∏ —ñ–Ω—à–∏–π —Ü—ñ–ª–æ—á–∏—Å–ª–æ–≤–∏–π —Ç–∏–ø (`byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`).

```csharp [ErrorCode.cs] showLineNumbers
// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è ushort –¥–ª—è –µ–∫–æ–Ω–æ–º—ñ—ó –ø–∞–º'—è—Ç—ñ
public enum ErrorCode : ushort
{
    None = 0,
    NotFound = 404,
    Unauthorized = 401,
    InternalServerError = 500
}

// –í–µ–ª–∏–∫—ñ –∑–Ω–∞—á–µ–Ω–Ω—è - –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è long
public enum LargeValues : long
{
    SmallValue = 1,
    HugeValue = 9_223_372_036_854_775_807 // long.MaxValue
}
```

### Flags Attribute: –ë—ñ—Ç–æ–≤—ñ –ø—Ä–∞–ø–æ—Ä—Ü—ñ

**`[Flags]` attribute** –¥–æ–∑–≤–æ–ª—è—î –∫–æ–º–±—ñ–Ω—É–≤–∞—Ç–∏ –∑–Ω–∞—á–µ–Ω–Ω—è enum —á–µ—Ä–µ–∑ –±—ñ—Ç–æ–≤—ñ –æ–ø–µ—Ä–∞—Ü—ñ—ó. –ó–Ω–∞—á–µ–Ω–Ω—è –ø–æ–≤–∏–Ω–Ω—ñ –±—É—Ç–∏ —Å—Ç–µ–ø–µ–Ω—è–º–∏ –¥–≤—ñ–π–∫–∏ (1, 2, 4, 8, 16...).

```csharp [FilePermissions.cs] showLineNumbers {1,4-8}
[Flags]
public enum FilePermissions
{
    None = 0,           // 0000
    Read = 1,           // 0001
    Write = 2,          // 0010
    Execute = 4,        // 0100
    Delete = 8,         // 1000
    ReadWrite = Read | Write,              // 0011 (3)
    FullControl = Read | Write | Execute | Delete  // 1111 (15)
}

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
FilePermissions userPermissions = FilePermissions.Read | FilePermissions.Write;

// –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞—è–≤–Ω–æ—Å—Ç—ñ –ø—Ä–∞–ø–æ—Ä—Ü—è
if (userPermissions.HasFlag(FilePermissions.Read))
{
    Console.WriteLine("–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –º–æ–∂–µ —á–∏—Ç–∞—Ç–∏ —Ñ–∞–π–ª");
}

// –î–æ–¥–∞–≤–∞–Ω–Ω—è –ø—Ä–∞–ø–æ—Ä—Ü—è
userPermissions |= FilePermissions.Execute;

// –í–∏–¥–∞–ª–µ–Ω–Ω—è –ø—Ä–∞–ø–æ—Ä—Ü—è
userPermissions &= ~FilePermissions.Write;

// –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —á–µ—Ä–µ–∑ –±—ñ—Ç–æ–≤—É –æ–ø–µ—Ä–∞—Ü—ñ—é (—à–≤–∏–¥—à–µ)
bool canWrite = (userPermissions & FilePermissions.Write) == FilePermissions.Write;
```

::tip
**Best Practice**: –î–ª—è flags enum –∑–∞–≤–∂–¥–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ `[Flags]` attribute —Ç–∞ —Å—Ç–µ–ø–µ–Ω—ñ –¥–≤—ñ–π–∫–∏. –¶–µ –∑–∞–±–µ–∑–ø–µ—á—É—î –∫–æ—Ä–µ–∫—Ç–Ω—É —Ä–æ–±–æ—Ç—É –º–µ—Ç–æ–¥—É `ToString()` —Ç–∞ —ñ–Ω—à–∏—Ö –æ–ø–µ—Ä–∞—Ü—ñ–π.
::

::mermaid

```mermaid
graph TD
    A[FilePermissions Flags] --> B[None = 0]
    A --> C[Read = 1]
    A --> D[Write = 2]
    A --> E[Execute = 4]
    A --> F[Delete = 8]

    G["Read | Write"] --> H[Result = 3]
    I["Read | Write | Execute"] --> J[Result = 7]

    H -.Binary.-> K[0011]
    J -.Binary.-> L[0111]

    style A fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style B fill:#64748b,stroke:#334155,color:#ffffff
    style C fill:#64748b,stroke:#334155,color:#ffffff
    style D fill:#64748b,stroke:#334155,color:#ffffff
    style E fill:#64748b,stroke:#334155,color:#ffffff
    style F fill:#64748b,stroke:#334155,color:#ffffff
    style G fill:#f59e0b,stroke:#b45309,color:#ffffff
    style H fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style I fill:#f59e0b,stroke:#b45309,color:#ffffff
    style J fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style K fill:#64748b,stroke:#334155,color:#ffffff
    style L fill:#64748b,stroke:#334155,color:#ffffff
```

::

### –û–ø–µ—Ä–∞—Ü—ñ—ó –∑ Enum

::code-group

```csharp [Parsing.cs] showLineNumbers
// Parse –∑ string
OrderStatus status = Enum.Parse<OrderStatus>("Shipped");

// TryParse (–±–µ–∑–ø–µ—á–Ω—ñ—à–∏–π –≤–∞—Ä—ñ–∞–Ω—Ç)
if (Enum.TryParse<OrderStatus>("Pending", out var result))
{
    Console.WriteLine($"Parsed: {result}");
}

// –û—Ç—Ä–∏–º–∞–Ω–Ω—è –≤—Å—ñ—Ö –∑–Ω–∞—á–µ–Ω—å
foreach (OrderStatus s in Enum.GetValues<OrderStatus>())
{
    Console.WriteLine($"{s} = {(int)s}");
}

// –û—Ç—Ä–∏–º–∞–Ω–Ω—è –≤—Å—ñ—Ö —ñ–º–µ–Ω
string[] names = Enum.GetNames<OrderStatus>();
```

```csharp [ToString.cs] showLineNumbers
FilePermissions perms = FilePermissions.Read | FilePermissions.Write;

// –ó [Flags] attribute
Console.WriteLine(perms.ToString());
// Output: "Read, Write"

// –ë–µ–∑ [Flags] attribute
Console.WriteLine(perms.ToString());
// Output: "3" (–ø—Ä–æ—Å—Ç–æ —á–∏—Å–ª–æ)
```

::

![–ë—ñ—Ç–æ–≤—ñ –æ–ø–µ—Ä–∞—Ü—ñ—ó –∑ flags enum](/images/csharp/oop/advanced-types/flags-enum-bitwise.png)

<!-- Search Query: C# flags enum bitwise operations diagram OR Read Write Execute -->

---

## Records (–ó–∞–ø–∏—Å–∏)

### –©–æ —Ç–∞–∫–µ Record?

**Record (–∑–∞–ø–∏—Å)** ‚Äî —Ü–µ reference type (–∞–±–æ value type –¥–ª—è `record struct`), –æ–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω–∏–π –¥–ª—è –Ω–µ–∑–º—ñ–Ω–Ω–∏—Ö (immutable) –¥–∞–Ω–∏—Ö –∑ –≤–±—É–¥–æ–≤–∞–Ω–æ—é **value equality** (—Ä—ñ–≤–Ω—ñ—Å—Ç—é –∑–∞ –∑–Ω–∞—á–µ–Ω–Ω—è–º). Records –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≥–µ–Ω–µ—Ä—É—é—Ç—å –º–µ—Ç–æ–¥–∏ `Equals()`, `GetHashCode()`, —Ç–∞ `ToString()`.

### Positional Records

```csharp [Person.cs] showLineNumbers
// Positional syntax (–∫–æ–º–ø–∞–∫—Ç–Ω–∏–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å)
public record Person(string FirstName, string LastName, int Age);

// –ï–∫–≤—ñ–≤–∞–ª–µ–Ω—Ç–Ω–æ:
public record Person
{
    public string FirstName { get; init; }
    public string LastName { get; init; }
    public int Age { get; init; }

    public Person(string firstName, string lastName, int age)
    {
        FirstName = firstName;
        LastName = lastName;
        Age = age;
    }
}

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
Person person1 = new("John", "Doe", 30);
Person person2 = new("John", "Doe", 30);

Console.WriteLine(person1 == person2); // True - value equality!
```

::note
**Value Equality**: –ù–∞ –≤—ñ–¥–º—ñ–Ω—É –≤—ñ–¥ –∑–≤–∏—á–∞–π–Ω–∏—Ö –∫–ª–∞—Å—ñ–≤, –¥–µ –ø–æ—Ä—ñ–≤–Ω—é—é—Ç—å—Å—è –ø–æ—Å–∏–ª–∞–Ω–Ω—è, records –ø–æ—Ä—ñ–≤–Ω—é—é—Ç—å **–∑–Ω–∞—á–µ–Ω–Ω—è –≤—Å—ñ—Ö –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç–µ–π**. –î–≤–∞ records —Ä—ñ–≤–Ω—ñ, —è–∫—â–æ –≤—Å—ñ —ó—Ö–Ω—ñ –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—ñ –º–∞—é—Ç—å –æ–¥–Ω–∞–∫–æ–≤—ñ –∑–Ω–∞—á–µ–Ω–Ω—è.
::

### with Expressions: Non-destructive Mutation

**`with` expression** –¥–æ–∑–≤–æ–ª—è—î —Å—Ç–≤–æ—Ä–∏—Ç–∏ –∫–æ–ø—ñ—é record –∑ –∑–º—ñ–Ω–µ–Ω–∏–º–∏ –ø–µ–≤–Ω–∏–º–∏ –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—è–º–∏, –Ω–µ –∑–º—ñ–Ω—é—é—á–∏ –æ—Ä–∏–≥—ñ–Ω–∞–ª.

```csharp [WithExpressions.cs] showLineNumbers
public record Person(string FirstName, string LastName, int Age);

Person person = new("John", "Doe", 30);

// –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –∫–æ–ø—ñ—ó –∑—ñ –∑–º—ñ–Ω–µ–Ω–∏–º –≤—ñ–∫–æ–º
Person olderPerson = person with { Age = 31 };

Console.WriteLine(person);       // Person { FirstName = John, LastName = Doe, Age = 30 }
Console.WriteLine(olderPerson);  // Person { FirstName = John, LastName = Doe, Age = 31 }

// person –∑–∞–ª–∏—à–∏–≤—Å—è –Ω–µ–∑–º—ñ–Ω–Ω–∏–º!

// –ú–æ–∂–Ω–∞ –∑–º—ñ–Ω—é–≤–∞—Ç–∏ –∫—ñ–ª—å–∫–∞ –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç–µ–π
Person different = person with
{
    FirstName = "Jane",
    Age = 25
};
```

### Record Struct vs Record Class

::code-group

```csharp [RecordClass.cs] showLineNumbers
// Record class (reference type) - –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º
public record Person(string Name, int Age);

Person p1 = new("Alice", 25);
Person p2 = p1; // –û–±–∏–¥–≤—ñ –∑–º—ñ–Ω–Ω—ñ –≤–∫–∞–∑—É—é—Ç—å –Ω–∞ —Ç–æ–π —Å–∞–º–∏–π –æ–±'—î–∫—Ç

// –ê–ª–µ —á–µ—Ä–µ–∑ immutability —Ü–µ –Ω–µ –ø—Ä–æ–±–ª–µ–º–∞
```

```csharp [RecordStruct.cs] showLineNumbers
// Record struct (value type)
public record struct Point(double X, double Y);

Point p1 = new(3, 4);
Point p2 = p1; // –ö–æ–ø—ñ—è –∑–Ω–∞—á–µ–Ω–Ω—è

p2 = p2 with { X = 10 };

Console.WriteLine(p1); // Point { X = 3, Y = 4 }
Console.WriteLine(p2); // Point { X = 10, Y = 4 }
```

::

### –ü–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è Record, Class, —Ç–∞ Struct

| –ö—Ä–∏—Ç–µ—Ä—ñ–π              | Record Class            | Record Struct           | Class              | Struct            |
| :-------------------- | :---------------------- | :---------------------- | :----------------- | :---------------- |
| **–¢–∏–ø**               | Reference               | Value                   | Reference          | Value             |
| **Equality**          | Value Equality          | Value Equality          | Reference Equality | Value Equality    |
| **Mutability**        | Immutable (recommended) | Immutable (recommended) | Mutable            | Mutable/Immutable |
| **`with` expression** | ‚úÖ                      | ‚úÖ                      | ‚ùå                 | ‚ùå                |
| **Inheritance**       | ‚úÖ                      | ‚ùå                      | ‚úÖ                 | ‚ùå                |
| **Performance**       | Heap allocation         | Stack allocation        | Heap allocation    | Stack allocation  |

::tip
**–ö–æ–ª–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ records:**

-   –î–ª—è DTO (Data Transfer Objects)
-   –î–ª—è immutable –º–æ–¥–µ–ª–µ–π –¥–∞–Ω–∏—Ö
-   –ö–æ–ª–∏ –ø–æ—Ç—Ä—ñ–±–Ω–∞ value equality
-   –î–ª—è –ø—Ä–æ—Å—Ç–∏—Ö –æ–±'—î–∫—Ç—ñ–≤ –±–µ–∑ —Å–∫–ª–∞–¥–Ω–æ—ó –±—ñ–∑–Ω–µ—Å-–ª–æ–≥—ñ–∫–∏

::

::mermaid

```mermaid
graph TD
    A[Records] --> B[record class]
    A --> C[record struct]

    B --> D[Reference Type]
    B --> E[Value Equality]
    B --> F[with Expressions]
    B --> G[Can Inherit]

    C --> H[Value Type]
    C --> I[Value Equality]
    C --> J[with Expressions]
    C --> K[No Inheritance]

    style A fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style B fill:#f59e0b,stroke:#b45309,color:#ffffff
    style C fill:#f59e0b,stroke:#b45309,color:#ffffff
    style D fill:#64748b,stroke:#334155,color:#ffffff
    style E fill:#64748b,stroke:#334155,color:#ffffff
    style F fill:#64748b,stroke:#334155,color:#ffffff
    style G fill:#64748b,stroke:#334155,color:#ffffff
    style H fill:#64748b,stroke:#334155,color:#ffffff
    style I fill:#64748b,stroke:#334155,color:#ffffff
    style J fill:#64748b,stroke:#334155,color:#ffffff
    style K fill:#64748b,stroke:#334155,color:#ffffff
```

::

![Record value equality –ø–æ—Ä—ñ–≤–Ω—è–Ω–æ –∑ class reference equality](/images/csharp/oop/advanced-types/record-equality.png)

<!-- Search Query: C# record value equality vs class reference equality visualization -->

---

## Tuples (–ö–æ—Ä—Ç–µ–∂—ñ)

### ValueTuple: –°—É—á–∞—Å–Ω–∏–π –ø—ñ–¥—Ö—ñ–¥

**Tuple (–∫–æ—Ä—Ç–µ–∂)** –¥–æ–∑–≤–æ–ª—è—î –≥—Ä—É–ø—É–≤–∞—Ç–∏ –∫—ñ–ª—å–∫–∞ –∑–Ω–∞—á–µ–Ω—å –≤ –æ–¥–∏–Ω –æ–±'—î–∫—Ç –±–µ–∑ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –æ–∫—Ä–µ–º–æ–≥–æ —Ç–∏–ø—É. –°—É—á–∞—Å–Ω–∏–π `ValueTuple` (C# 7+) —î value type —ñ –º–∞—î –∑—Ä—É—á–Ω–∏–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å.

```csharp [TupleBasics.cs] showLineNumbers
// –û–≥–æ–ª–æ—à–µ–Ω–Ω—è tuple
(string Name, int Age) person = ("Alice", 25);

// –î–æ—Å—Ç—É–ø –¥–æ –µ–ª–µ–º–µ–Ω—Ç—ñ–≤
Console.WriteLine(person.Name); // Alice
Console.WriteLine(person.Age);  // 25

// –ë–µ–∑ —ñ–º–µ–Ω (–¥–æ—Å—Ç—É–ø —á–µ—Ä–µ–∑ Item1, Item2...)
(string, int) unnamed = ("Bob", 30);
Console.WriteLine(unnamed.Item1); // Bob

// Tuple literal
var point = (X: 3.0, Y: 4.0);
```

### –ü–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è –º–Ω–æ–∂–∏–Ω–Ω–∏—Ö –∑–Ω–∞—á–µ–Ω—å

Tuples —ñ–¥–µ–∞–ª—å–Ω–æ –ø—ñ–¥—Ö–æ–¥—è—Ç—å –¥–ª—è –ø–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è –¥–µ–∫—ñ–ª—å–∫–æ—Ö –∑–Ω–∞—á–µ–Ω—å –∑ –º–µ—Ç–æ–¥—É –±–µ–∑ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è —Å–ø–µ—Ü—ñ–∞–ª—å–Ω–æ–≥–æ –∫–ª–∞—Å—É.

```csharp [ReturningMultipleValues.cs] showLineNumbers
public (int Min, int Max, double Average) AnalyzeNumbers(int[] numbers)
{
    if (numbers.Length == 0)
    {
        return (0, 0, 0);
    }

    int min = numbers.Min();
    int max = numbers.Max();
    double avg = numbers.Average();

    return (min, max, avg);
}

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
int[] data = { 5, 2, 8, 1, 9 };
var result = AnalyzeNumbers(data);

Console.WriteLine($"Min: {result.Min}");         // 1
Console.WriteLine($"Max: {result.Max}");         // 9
Console.WriteLine($"Avg: {result.Average}");     // 5
```

### Deconstruction (–î–µ–∫–æ–Ω—Å—Ç—Ä—É–∫—Ü—ñ—è)

**Deconstruction** –¥–æ–∑–≤–æ–ª—è—î —Ä–æ–∑–ø–∞–∫—É–≤–∞—Ç–∏ tuple –≤ –æ–∫—Ä–µ–º—ñ –∑–º—ñ–Ω–Ω—ñ.

```csharp [Deconstruction.cs] showLineNumbers
// –ü–æ–≤–Ω–∏–π –ø—Ä–∏–∫–ª–∞–¥ deconstructon
(string Name, int Age) GetPerson() => ("Alice", 25);

// Deconstruct –≤ –Ω–æ–≤—ñ –∑–º—ñ–Ω–Ω—ñ
var (name, age) = GetPerson();
Console.WriteLine($"{name} is {age} years old");

// Deconstruct –≤ —ñ—Å–Ω—É—é—á—ñ –∑–º—ñ–Ω–Ω—ñ
string personName;
int personAge;
(personName, personAge) = GetPerson();

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è discard (_) –¥–ª—è —ñ–≥–Ω–æ—Ä—É–≤–∞–Ω–Ω—è –∑–Ω–∞—á–µ–Ω—å
var (_, onlyAge) = GetPerson(); // –Ü–≥–Ω–æ—Ä—É—î–º–æ —ñ–º'—è
Console.WriteLine($"Age: {onlyAge}");

// Deconstruction –≤ foreach
var people = new[]
{
    ("Alice", 25),
    ("Bob", 30)
};

foreach (var (n, a) in people)
{
    Console.WriteLine($"{n}: {a}");
}
```

### ValueTuple vs —Å—Ç–∞—Ä–∏–π Tuple

::code-group

```csharp [ValueTuple(Modern).cs] showLineNumbers
// ‚úÖ ValueTuple (C# 7+) - –†–µ–∫–æ–º–µ–Ω–¥—É—î—Ç—å—Å—è
(int X, int Y) point = (3, 4);
Console.WriteLine(point.X);

// Value type (struct)
// –ó—Ä—É—á–Ω–∏–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å
// Named elements
```

```csharp [Tuple(Legacy).cs] showLineNumbers
// ‚ùå –°—Ç–∞—Ä–∏–π Tuple - –ù–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ!
Tuple<int, int> point = Tuple.Create(3, 4);
Console.WriteLine(point.Item1);

// Reference type (class)
// –ù–µ–∑—Ä—É—á–Ω–∏–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å
// –¢—ñ–ª—å–∫–∏ Item1, Item2...
```

::

::warning
**–í–∞–∂–ª–∏–≤–æ**: ValueTuple —î **mutable** –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º. –Ø–∫—â–æ –ø–æ—Ç—Ä—ñ–±–Ω–∞ immutability, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ records –∞–±–æ readonly fields.
::

---

## Anonymous Types (–ê–Ω–æ–Ω—ñ–º–Ω—ñ —Ç–∏–ø–∏)

### –©–æ —Ç–∞–∫–µ Anonymous Type?

**Anonymous type (–∞–Ω–æ–Ω—ñ–º–Ω–∏–π —Ç–∏–ø)** ‚Äî —Ü–µ reference type –±–µ–∑ —è–≤–Ω–æ–≥–æ –æ–≥–æ–ª–æ—à–µ–Ω–Ω—è –∫–ª–∞—Å—É. –ö–æ–º–ø—ñ–ª—è—Ç–æ—Ä –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≥–µ–Ω–µ—Ä—É—î –∫–ª–∞—Å –∑ read-only –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—è–º–∏.

```csharp [AnonymousBasics.cs] showLineNumbers
// –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –∞–Ω–æ–Ω—ñ–º–Ω–æ–≥–æ —Ç–∏–ø—É
var person = new
{
    Name = "Alice",
    Age = 25,
    City = "Kyiv"
};

Console.WriteLine(person.Name);  // Alice
Console.WriteLine(person.Age);   // 25

// –¢–∏–ø –≤—ñ–¥–æ–º–∏–π —Ç—ñ–ª—å–∫–∏ –∫–æ–º–ø—ñ–ª—è—Ç–æ—Ä—É
// person.Name = "Bob"; // ‚ùå –ü–æ–º–∏–ª–∫–∞ - read-only
```

### –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –≤ LINQ

–ê–Ω–æ–Ω—ñ–º–Ω—ñ —Ç–∏–ø–∏ –Ω–∞–π—á–∞—Å—Ç—ñ—à–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—Ç—å—Å—è –≤ LINQ –∑–∞–ø–∏—Ç–∞—Ö –¥–ª—è –ø—Ä–æ–µ–∫—Ü—ñ—ó (projection) –¥–∞–Ω–∏—Ö.

```csharp [LinqProjection.cs] showLineNumbers
public record Product(string Name, decimal Price, string Category);

List<Product> products = new()
{
    new("Laptop", 1200m, "Electronics"),
    new("Mouse", 25m, "Electronics"),
    new("Desk", 300m, "Furniture")
};

// –ü—Ä–æ–µ–∫—Ü—ñ—è –≤ –∞–Ω–æ–Ω—ñ–º–Ω–∏–π —Ç–∏–ø
var result = products
    .Where(p => p.Category == "Electronics")
    .Select(p => new
    {
        ProductName = p.Name,
        PriceInUah = p.Price * 40, // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—è –≤ –≥—Ä–∏–≤–Ω—ñ
        Discount = p.Price > 1000 ? 10 : 5
    });

foreach (var item in result)
{
    Console.WriteLine($"{item.ProductName}: {item.PriceInUah} UAH (Discount: {item.Discount}%)");
}
```

### with Expressions –∑ Anonymous Types (C# 10+)

```csharp [AnonymousWithExpressions.cs] showLineNumbers
var person = new { Name = "Alice", Age = 25 };

// –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –∫–æ–ø—ñ—ó –∑—ñ –∑–º—ñ–Ω–µ–Ω–æ—é –≤–ª–∞—Å—Ç–∏–≤—ñ—Å—Ç—é
var olderPerson = person with { Age = 26 };

Console.WriteLine(person);       // { Name = Alice, Age = 25 }
Console.WriteLine(olderPerson);  // { Name = Alice, Age = 26 }
```

### –û–±–º–µ–∂–µ–Ω–Ω—è Anonymous Types

::warning
**–û–±–º–µ–∂–µ–Ω–Ω—è:**

-   –ú–æ–∂–Ω–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ —Ç—ñ–ª—å–∫–∏ –≤—Å–µ—Ä–µ–¥–∏–Ω—ñ –º–µ—Ç–æ–¥—É (–Ω–µ –º–æ–∂–Ω–∞ –ø–æ–≤–µ—Ä—Ç–∞—Ç–∏ –∑ –º–µ—Ç–æ–¥—É —è–∫ —Ç–∏–ø)
-   –í—Å—ñ –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—ñ read-only
-   –ù–µ –º–æ–∂–Ω–∞ –¥–æ–¥–∞—Ç–∏ –º–µ—Ç–æ–¥–∏ –∞–±–æ –ø–æ–¥—ñ—ó
-   –°–∫–ª–∞–¥–Ω–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ –≤ —é–Ω—ñ—Ç-—Ç–µ—Å—Ç–∞—Ö

::

::code-group

```csharp [Good.cs] showLineNumbers
// ‚úÖ –ì–∞—Ä–Ω–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è - –ª–æ–∫–∞–ª—å–Ω–æ –≤ –º–µ—Ç–æ–¥—ñ
public void ProcessData()
{
    var temp = new { X = 10, Y = 20 };
    Console.WriteLine(temp.X + temp.Y);
}
```

```csharp [Bad.cs] showLineNumbers
// ‚ùå –ü–æ–≥–∞–Ω–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è - –ø–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è –∑ –º–µ—Ç–æ–¥—É
public object GetData() // –¢–∏–ø object - –≤—Ç—Ä–∞—Ç–∞ type safety!
{
    return new { X = 10, Y = 20 };
}

// –ö—Ä–∞—â–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ record –∞–±–æ tuple
public (int X, int Y) GetData()
{
    return (10, 20);
}
```

::

---

## Nullable Types (Nullable –¢–∏–ø–∏)

### Value Types: Nullable<T> –∞–±–æ T?

**Nullable value types** –¥–æ–∑–≤–æ–ª—è—é—Ç—å value types –ø—Ä–∏–π–º–∞—Ç–∏ –∑–Ω–∞—á–µ–Ω–Ω—è `null`. –¶–µ –∫–æ—Ä–∏—Å–Ω–æ, –∫–æ–ª–∏ –∑–Ω–∞—á–µ–Ω–Ω—è –º–æ–∂–µ –±—É—Ç–∏ –≤—ñ–¥—Å—É—Ç–Ω—ñ–º (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, –¥–∞–Ω—ñ –∑ –±–∞–∑–∏ –¥–∞–Ω–∏—Ö).

```csharp [NullableValueTypes.cs] showLineNumbers
// –î–≤–∞ —Å–ø–æ—Å–æ–±–∏ –æ–≥–æ–ª–æ—à–µ–Ω–Ω—è - –µ–∫–≤—ñ–≤–∞–ª–µ–Ω—Ç–Ω—ñ
Nullable<int> age1 = null;
int? age2 = null; // –°–∫–æ—Ä–æ—á–µ–Ω–∏–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å (—Ä–µ–∫–æ–º–µ–Ω–¥—É—î—Ç—å—Å—è)

// –ü—Ä–∏—Å–≤–æ—î–Ω–Ω—è –∑–Ω–∞—á–µ–Ω–Ω—è
age2 = 25;

// –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞—è–≤–Ω–æ—Å—Ç—ñ –∑–Ω–∞—á–µ–Ω–Ω—è
if (age2.HasValue)
{
    Console.WriteLine($"Age: {age2.Value}");
}

// –ë–µ–∑–ø–µ—á–Ω–∏–π –¥–æ—Å—Ç—É–ø
Console.WriteLine(age2.GetValueOrDefault()); // 25
Console.WriteLine(age2.GetValueOrDefault(18)); // 25 (–∞–±–æ 18, —è–∫—â–æ null)

// Null-coalescing operator
int definiteAge = age2 ?? 18; // –Ø–∫—â–æ age2 == null, —Ç–æ 18
```

### Reference Types: Nullable Reference Types (NRT)

–ü–æ—á–∏–Ω–∞—é—á–∏ –∑ C# 8, reference types –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º **non-nullable** (—è–∫—â–æ –≤–≤—ñ–º–∫–Ω–µ–Ω–æ NRT). –î–ª—è nullable –ø–æ—Ç—Ä—ñ–±–µ–Ω `?`.

```csharp [NullableReferenceTypes.cs] showLineNumbers
// –£–≤—ñ–º–∫–Ω–µ–Ω–Ω—è NRT —É —Ñ–∞–π–ª—ñ
#nullable enable

// Non-nullable reference type
string name = "Alice";
// name = null; // ‚ö†Ô∏è –ü–æ–ø–µ—Ä–µ–¥–∂–µ–Ω–Ω—è –∫–æ–º–ø—ñ–ª—è—Ç–æ—Ä–∞

// Nullable reference type
string? nullableName = null; // OK

// Compiler warning —è–∫—â–æ –Ω–µ –ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –Ω–∞ null
void PrintLength(string? input)
{
    // Console.WriteLine(input.Length); // ‚ö†Ô∏è –ü–æ–ø–µ—Ä–µ–¥–∂–µ–Ω–Ω—è

    // ‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ - –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ null
    if (input != null)
    {
        Console.WriteLine(input.Length);
    }

    // –ê–±–æ –∑ null-conditional operator
    Console.WriteLine(input?.Length);
}
```

### Null-Coalescing Operators

| –û–ø–µ—Ä–∞—Ç–æ—Ä | –ù–∞–∑–≤–∞                      | –û–ø–∏—Å                                                 | –ü—Ä–∏–∫–ª–∞–¥                        |
| :------- | :------------------------- | :--------------------------------------------------- | :----------------------------- |
| `??`     | Null-coalescing            | –ü–æ–≤–µ—Ä—Ç–∞—î –ª—ñ–≤–µ –∑–Ω–∞—á–µ–Ω–Ω—è, —è–∫—â–æ –Ω–µ `null`, —ñ–Ω–∞–∫—à–µ –ø—Ä–∞–≤–µ | `int age = nullableAge ?? 18;` |
| `??=`    | Null-coalescing assignment | –ü—Ä–∏—Å–≤–æ—é—î –ø—Ä–∞–≤–µ –∑–Ω–∞—á–µ–Ω–Ω—è, —è–∫—â–æ –ª—ñ–≤–µ `null`            | `name ??= "Default";`          |
| `?.`     | Null-conditional           | –í–∏–∫–ª–∏–∫–∞—î —á–ª–µ–Ω, —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –æ–±'—î–∫—Ç –Ω–µ `null`          | `int? length = text?.Length;`  |
| `?[]`    | Null-conditional index     | –Ü–Ω–¥–µ–∫—Å—É—î –º–∞—Å–∏–≤, —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –Ω–µ `null`                | `int? first = array?[0];`      |
| `!`      | Null-forgiving             | –ü—ñ–¥–∫–∞–∑—É—î –∫–æ–º–ø—ñ–ª—è—Ç–æ—Ä—É, —â–æ –∑–Ω–∞—á–µ–Ω–Ω—è —Ç–æ—á–Ω–æ –Ω–µ `null`    | `string name = nullableText!;` |

```csharp [NullOperators.cs] showLineNumbers {5,8,12,16,20}
string? name = null;
string? city = "Kyiv";

// ?? - Null-coalescing
string displayName = name ?? "Guest"; // "Guest"

// ??= - Null-coalescing assignment
name ??= "Default"; // name —Ç–µ–ø–µ—Ä "Default"

// ?. - Null-conditional member access
int? nameLength = name?.Length; // 7 (–¥–æ–≤–∂–∏–Ω–∞ "Default")
int? nullLength = ((string?)null)?.Length; // null

// ?[] - Null-conditional indexing
int[] numbers = { 1, 2, 3 };
int? first = numbers?[0]; // 1
int? nullArrayFirst = ((int[]?)null)?[0]; // null

// ! - Null-forgiving operator (–≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –æ–±–µ—Ä–µ–∂–Ω–æ!)
string definitelyNotNull = name!; // –ö–æ–º–ø—ñ–ª—è—Ç–æ—Ä –Ω–µ –ø–æ–ø–µ—Ä–µ–¥–∂–∞—î
string riskyAccess = name!.ToUpper(); // "DEFAULT"
```

::warning
**Null-forgiving operator (`!`)**: –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —Ç—ñ–ª—å–∫–∏ –∫–æ–ª–∏ –≤–∏ **—Ç–æ—á–Ω–æ –≤–ø–µ–≤–Ω–µ–Ω—ñ**, —â–æ –∑–Ω–∞—á–µ–Ω–Ω—è –Ω–µ `null`. –Ø–∫—â–æ –ø–æ–º–∏–ª–∏—Ç–µ—Å—è, –æ—Ç—Ä–∏–º–∞—î—Ç–µ `NullReferenceException` —É runtime.
::

### Best Practices –¥–ª—è —Ä–æ–±–æ—Ç–∏ –∑ Null

::steps

### –£–≤—ñ–º–∫–Ω—ñ—Ç—å Nullable Reference Types

–£ `.csproj` —Ñ–∞–π–ª—ñ:

```xml
<Nullable>enable</Nullable>
```

### –ó–∞–≤–∂–¥–∏ –ø–µ—Ä–µ–≤—ñ—Ä—è–π—Ç–µ nullable –∑–Ω–∞—á–µ–Ω–Ω—è

```csharp
if (nullableValue != null)
{
    // –ë–µ–∑–ø–µ—á–Ω–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
}
```

### –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ null-conditional operators

```csharp
// –ó–∞–º—ñ—Å—Ç—å:
int length = text != null ? text.Length : 0;

// –ö—Ä–∞—â–µ:
int length = text?.Length ?? 0;
```

### –£–Ω–∏–∫–∞–π—Ç–µ null-forgiving –±–µ–∑ –ø—Ä–∏—á–∏–Ω–∏

```csharp
// ‚ùå –ü–æ–≥–∞–Ω–æ
string name = GetName()!;

// ‚úÖ –î–æ–±—Ä–µ
string? name = GetName();
if (name != null)
{
    // –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
}
```

::

::mermaid

```mermaid
graph TD
    A[Nullable Types] --> B[Value Types]
    A --> C[Reference Types]

    B --> D["int? nullable = null"]
    B --> E[HasValue Property]
    B --> F[Value Property]
    B --> G[GetValueOrDefault]

    C --> H["string? nullable = null"]
    C --> I["Nullable Reference Types NRT"]
    C --> J[Compiler Warnings]

    K[Null Operators] --> L["?? Coalescing"]
    K --> M["??= Assignment"]
    K --> N["?. Conditional"]
    K --> O["! Forgiving"]

    style A fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style B fill:#f59e0b,stroke:#b45309,color:#ffffff
    style C fill:#f59e0b,stroke:#b45309,color:#ffffff
    style D fill:#64748b,stroke:#334155,color:#ffffff
    style E fill:#64748b,stroke:#334155,color:#ffffff
    style F fill:#64748b,stroke:#334155,color:#ffffff
    style G fill:#64748b,stroke:#334155,color:#ffffff
    style H fill:#64748b,stroke:#334155,color:#ffffff
    style I fill:#64748b,stroke:#334155,color:#ffffff
    style J fill:#64748b,stroke:#334155,color:#ffffff
    style K fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style L fill:#64748b,stroke:#334155,color:#ffffff
    style M fill:#64748b,stroke:#334155,color:#ffffff
    style N fill:#64748b,stroke:#334155,color:#ffffff
    style O fill:#64748b,stroke:#334155,color:#ffffff
```

::

---

## Discriminated Unions (–ö–æ–Ω—Ü–µ–ø—Ü—ñ—è)

### –©–æ —Ç–∞–∫–µ Discriminated Unions?

**Discriminated Unions (—Ç–∞–∫–æ–∂ tagged unions –∞–±–æ sum types)** ‚Äî —Ü–µ —Ç–∏–ø –¥–∞–Ω–∏—Ö, —è–∫–∏–π –º–æ–∂–µ –±—É—Ç–∏ **–æ–¥–Ω–∏–º –∑ –∫—ñ–ª—å–∫–æ—Ö –º–æ–∂–ª–∏–≤–∏—Ö –≤–∞—Ä—ñ–∞–Ω—Ç—ñ–≤**. –¶–µ –ø–æ—à–∏—Ä–µ–Ω–∞ –∫–æ–Ω—Ü–µ–ø—Ü—ñ—è –≤ —Ñ—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª—å–Ω–æ–º—É –ø—Ä–æ–≥—Ä–∞–º—É–≤–∞–Ω–Ω—ñ (F#, Rust, TypeScript), –∞–ª–µ **–Ω–∞—Ç–∏–≤–Ω–æ –Ω–µ –ø—ñ–¥—Ç—Ä–∏–º—É—î—Ç—å—Å—è –≤ C#** (—Å—Ç–∞–Ω–æ–º –Ω–∞ C# 13).

### –ü—Ä–∏–∫–ª–∞–¥ –∑ F# (–¥–ª—è —Ä–æ–∑—É–º—ñ–Ω–Ω—è –∫–æ–Ω—Ü–µ–ø—Ü—ñ—ó)

```fsharp
type PaymentMethod =
    | Cash of amount: decimal
    | CreditCard of cardNumber: string * cvv: string
    | BankTransfer of accountNumber: string

let processPayment payment =
    match payment with
    | Cash amount -> printfn "Cash payment: %M" amount
    | CreditCard (number, cvv) -> printfn "Card: %s" number
    | BankTransfer account -> printfn "Transfer from: %s" account
```

### –ï–º—É–ª—è—Ü—ñ—è –≤ C# —á–µ—Ä–µ–∑ Pattern Matching

–ù–∞–π–∫—Ä–∞—â–∏–π —Å–ø–æ—Å—ñ–± –µ–º—É–ª—é–≤–∞—Ç–∏ discriminated unions —É C# ‚Äî sealed class hierarchy –∑ pattern matching.

```csharp [DiscriminatedUnionEmulation.cs] showLineNumbers
// –ë–∞–∑–∞ - sealed —â–æ–± –∑–∞–ø–æ–±—ñ–≥—Ç–∏ —Ä–æ–∑—à–∏—Ä–µ–Ω–Ω—é –∑–∑–æ–≤–Ω—ñ
public abstract record PaymentMethod;

// –í–∞—Ä—ñ–∞–Ω—Ç–∏
public record Cash(decimal Amount) : PaymentMethod;
public record CreditCard(string CardNumber, string Cvv) : PaymentMethod;
public record BankTransfer(string AccountNumber) : PaymentMethod;

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –∑ pattern matching
public static string ProcessPayment(PaymentMethod payment)
{
    return payment switch
    {
        Cash { Amount: var amount } =>
            $"Cash payment: {amount:C}",

        CreditCard { CardNumber: var number } =>
            $"Card payment: {number[^4..]} (last 4 digits)",

        BankTransfer { AccountNumber: var account } =>
            $"Bank transfer from: {account}",

        _ => throw new ArgumentException("Unknown payment method")
    };
}

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
PaymentMethod payment1 = new Cash(100m);
PaymentMethod payment2 = new CreditCard("1234-5678-9012-3456", "123");

Console.WriteLine(ProcessPayment(payment1));
// Cash payment: $100.00

Console.WriteLine(ProcessPayment(payment2));
// Card payment: 3456 (last 4 digits)
```

### OneOf Library: –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–µ —Ä—ñ—à–µ–Ω–Ω—è

**OneOf** ‚Äî –ø–æ–ø—É–ª—è—Ä–Ω–∞ –±—ñ–±–ª—ñ–æ—Ç–µ–∫–∞ NuGet, —è–∫–∞ –Ω–∞–¥–∞—î discriminated unions –¥–ª—è C#.

```csharp [OneOfExample.cs] showLineNumbers
using OneOf;

// –í–∏–∑–Ω–∞—á–µ–Ω–Ω—è union type
public class Result : OneOfBase<Success, Error>
{
    public Result(OneOf<Success, Error> input) : base(input) { }
}

public record Success(string Message);
public record Error(string ErrorMessage, int Code);

// –ú–µ—Ç–æ–¥, —â–æ –ø–æ–≤–µ—Ä—Ç–∞—î union
public Result DivideNumbers(int a, int b)
{
    if (b == 0)
    {
        return new Error("Division by zero", 400);
    }

    return new Success($"Result: {a / b}");
}

// Pattern matching –∑ OneOf
Result result = DivideNumbers(10, 2);

string output = result.Match(
    success => $"‚úì {success.Message}",
    error => $"‚úó Error {error.Code}: {error.ErrorMessage}"
);

Console.WriteLine(output); // ‚úì Result: 5
```

::note
**–ú–∞–π–±—É—Ç–Ω—î C#**: –†–æ–∑—Ä–æ–±–Ω–∏–∫–∏ C# —Ä–æ–∑–≥–ª—è–¥–∞—é—Ç—å –¥–æ–¥–∞–≤–∞–Ω–Ω—è –Ω–∞—Ç–∏–≤–Ω–æ—ó –ø—ñ–¥—Ç—Ä–∏–º–∫–∏ discriminated unions —É –º–∞–π–±—É—Ç–Ω—ñ—Ö –≤–µ—Ä—Å—ñ—è—Ö –º–æ–≤–∏. –°–ª—ñ–¥–∫—É–π—Ç–µ –∑–∞ GitHub —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä—ñ—î–º [csharplang proposals](https://github.com/dotnet/csharplang).
::

---

## –ü–æ—Ä—ñ–≤–Ω—è–ª—å–Ω–∞ —Ç–∞–±–ª–∏—Ü—è –≤—Å—ñ—Ö —Ç–∏–ø—ñ–≤

| –¢–∏–ø               | Value/Reference | Mutability  | Equality  | Inheritance | –ö–æ–ª–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏                           |
| :---------------- | :-------------- | :---------- | :-------- | :---------- | :--------------------------------------------- |
| **Struct**        | Value           | Mutable     | Value     | ‚ùå          | –ú–∞–ª—ñ, –ª–æ–≥—ñ—á–Ω–æ –æ–¥–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è, –ø–µ—Ä–µ–¥–∞—î—Ç—å—Å—è —á–∞—Å—Ç–æ |
| **Enum**          | Value           | Immutable   | Value     | ‚ùå          | –§—ñ–∫—Å–æ–≤–∞–Ω–∏–π –Ω–∞–±—ñ—Ä –≤–∞—Ä—ñ–∞–Ω—Ç—ñ–≤                     |
| **Record class**  | Reference       | Immutable\* | Value     | ‚úÖ          | DTO, immutable –¥–∞–Ω—ñ, value equality            |
| **Record struct** | Value           | Immutable\* | Value     | ‚ùå          | –ú–∞–ª—ñ immutable –¥–∞–Ω—ñ –∑ value equality           |
| **Tuple**         | Value           | Mutable     | Value     | ‚ùå          | –ü–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è –∫—ñ–ª—å–∫–æ—Ö –∑–Ω–∞—á–µ–Ω—å, –ª–æ–∫–∞–ª—å–Ω—ñ –≥—Ä—É–ø–∏     |
| **Anonymous**     | Reference       | Immutable   | Value     | ‚ùå          | LINQ –ø—Ä–æ–µ–∫—Ü—ñ—ó, —Ç–∏–º—á–∞—Å–æ–≤—ñ –æ–±'—î–∫—Ç–∏               |
| **Class**         | Reference       | Mutable     | Reference | ‚úÖ          | –°–∫–ª–∞–¥–Ω—ñ –æ–±'—î–∫—Ç–∏, entity, –±–∞–≥–∞—Ç–æ –ª–æ–≥—ñ–∫–∏         |

_\* Recommended immutable, –∞–ª–µ –º–æ–∂–Ω–∞ –∑—Ä–æ–±–∏—Ç–∏ mutable_

::mermaid

```mermaid
graph TD
    A[Advanced Types] --> B[Value Types]
    A --> C[Reference Types]

    B --> D[Struct]
    B --> E[Enum]
    B --> F[Record Struct]
    B --> G[Tuple]

    C --> H[Record Class]
    C --> I[Anonymous Type]
    C --> J[Class]

    K[Choose Based On] --> L[Size]
    K --> M[Mutability]
    K --> N[Equality Semantics]
    K --> O[Inheritance Need]

    style A fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style B fill:#f59e0b,stroke:#b45309,color:#ffffff
    style C fill:#f59e0b,stroke:#b45309,color:#ffffff
    style D fill:#64748b,stroke:#334155,color:#ffffff
    style E fill:#64748b,stroke:#334155,color:#ffffff
    style F fill:#64748b,stroke:#334155,color:#ffffff
    style G fill:#64748b,stroke:#334155,color:#ffffff
    style H fill:#64748b,stroke:#334155,color:#ffffff
    style I fill:#64748b,stroke:#334155,color:#ffffff
    style J fill:#64748b,stroke:#334155,color:#ffffff
    style K fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style L fill:#64748b,stroke:#334155,color:#ffffff
    style M fill:#64748b,stroke:#334155,color:#ffffff
    style N fill:#64748b,stroke:#334155,color:#ffffff
    style O fill:#64748b,stroke:#334155,color:#ffffff
```

::

---

## Troubleshooting (–£—Å—É–Ω–µ–Ω–Ω—è –ø—Ä–æ–±–ª–µ–º)

### Struct: Boxing performance penalty

::warning
**–ü—Ä–æ–±–ª–µ–º–∞**: –ü—Ä–∏ –ø–µ—Ä–µ–¥–∞—á—ñ struct —è–∫ `object` –∞–±–æ —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å –≤—ñ–¥–±—É–≤–∞—î—Ç—å—Å—è **boxing** ‚Äî –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö –Ω–∞ heap.

```csharp
public struct Point
{
    public int X, Y;
}

Point p = new Point { X = 10, Y = 20 };
object obj = p; // ‚ö†Ô∏è Boxing - –∫–æ–ø—ñ—è –Ω–∞ heap
```

**–†—ñ—à–µ–Ω–Ω—è**: –£–Ω–∏–∫–∞–π—Ç–µ boxing, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ generics.
::

### Enum: –ù–µ–≤–∞–ª—ñ–¥–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è

::warning
**–ü—Ä–æ–±–ª–µ–º–∞**: –ú–æ–∂–Ω–∞ cast –Ω–µ–≤–∞–ª—ñ–¥–Ω–µ —á–∏—Å–ª–æ –≤ enum.

```csharp
OrderStatus status = (OrderStatus)999; // –ö–æ–º–ø—ñ–ª—é—î—Ç—å—Å—è!
```

**–†—ñ—à–µ–Ω–Ω—è**: –ü–µ—Ä–µ–≤—ñ—Ä—è–π—Ç–µ —á–µ—Ä–µ–∑ `Enum.IsDefined()`.

```csharp
if (Enum.IsDefined(typeof(OrderStatus), status))
{
    // –í–∞–ª—ñ–¥–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è
}
```

::

### Record: Mutable –≤–∫–ª–∞–¥–µ–Ω—ñ –æ–±'—î–∫—Ç–∏

::warning
**–ü—Ä–æ–±–ª–µ–º–∞**: Records –∑ mutable –≤–∫–ª–∞–¥–µ–Ω–∏–º–∏ –æ–±'—î–∫—Ç–∞–º–∏ –Ω–µ –ø–æ–≤–Ω—ñ—Å—Ç—é immutable.

```csharp
public record Person(string Name, List<string> Hobbies);

var p1 = new Person("Alice", new List<string> { "Reading" });
var p2 = p1 with { };

p2.Hobbies.Add("Coding"); // –ó–º—ñ–Ω—é—î —ñ p1.Hobbies!
```

**–†—ñ—à–µ–Ω–Ω—è**: –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ immutable collections.

```csharp
using System.Collections.Immutable;

public record Person(string Name, ImmutableList<string> Hobbies);
```

::

### Nullable: –ó–∞–±—É–ª–∏ –ø–µ—Ä–µ–≤—ñ—Ä–∫—É –Ω–∞ null

::warning
**–ü—Ä–æ–±–ª–µ–º–∞**: `NullReferenceException` –ø—Ä–∏ –¥–æ—Å—Ç—É–ø—ñ –¥–æ nullable reference.

```csharp
string? name = GetName();
Console.WriteLine(name.Length); // üí• NullReferenceException
```

**–†—ñ—à–µ–Ω–Ω—è**: –ó–∞–≤–∂–¥–∏ –ø–µ—Ä–µ–≤—ñ—Ä—è–π—Ç–µ –∞–±–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ null-conditional.

```csharp
Console.WriteLine(name?.Length ?? 0);
```

::

---

## Practice Tasks (–ü—Ä–∞–∫—Ç–∏—á–Ω—ñ –∑–∞–≤–¥–∞–Ω–Ω—è)

### Beginner: –ë–∞–∑–æ–≤—ñ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ —Ç–∞ –ø–µ—Ä–µ—Ä–∞—Ö—É–≤–∞–Ω–Ω—è

–°—Ç–≤–æ—Ä—ñ—Ç—å –ø—Ä–æ–≥—Ä–∞–º—É –¥–ª—è —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è –≥–µ–æ–º–µ—Ç—Ä–∏—á–Ω–∏–º–∏ —Ñ—ñ–≥—É—Ä–∞–º–∏:

1. –°—Ç–≤–æ—Ä—ñ—Ç—å `struct Point` –∑ –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—è–º–∏ `X` —Ç–∞ `Y` (readonly)
2. –î–æ–¥–∞–π—Ç–µ –º–µ—Ç–æ–¥ `DistanceTo(Point other)` –¥–ª—è –æ–±—á–∏—Å–ª–µ–Ω–Ω—è –≤—ñ–¥—Å—Ç–∞–Ω—ñ
3. –°—Ç–≤–æ—Ä—ñ—Ç—å `enum Shape { Circle, Rectangle, Triangle }`
4. –°—Ç–≤–æ—Ä—ñ—Ç—å `enum Direction { North, South, East, West }` —Ç–∞ –º–µ—Ç–æ–¥ `GetOpposite()` –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –ø—Ä–æ—Ç–∏–ª–µ–∂–Ω–æ–≥–æ –Ω–∞–ø—Ä—è–º–∫—É

::collapsible{title="–†—ñ—à–µ–Ω–Ω—è"}

```csharp [Solution.cs] showLineNumbers
public readonly struct Point
{
    public double X { get; }
    public double Y { get; }

    public Point(double x, double y)
    {
        X = x;
        Y = y;
    }

    public double DistanceTo(Point other)
    {
        double dx = X - other.X;
        double dy = Y - other.Y;
        return Math.Sqrt(dx * dx + dy * dy);
    }
}

public enum Shape
{
    Circle,
    Rectangle,
    Triangle
}

public enum Direction
{
    North,
    South,
    East,
    West
}

public static Direction GetOpposite(this Direction direction)
{
    return direction switch
    {
        Direction.North => Direction.South,
        Direction.South => Direction.North,
        Direction.East => Direction.West,
        Direction.West => Direction.East,
        _ => throw new ArgumentException()
    };
}
```

::

### Intermediate: Records —Ç–∞ Flags

–°—Ç–≤–æ—Ä—ñ—Ç—å —Å–∏—Å—Ç–µ–º—É –¥–ª—è —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞–º–∏ —Ç–∞ –ø—Ä–∞–≤–∞–º–∏ –¥–æ—Å—Ç—É–ø—É:

1. –°—Ç–≤–æ—Ä—ñ—Ç—å `record User(string Name, string Email, DateTime RegisteredAt)`
2. –î–æ–¥–∞–π—Ç–µ –º–µ—Ç–æ–¥ `GetAge()` –¥–æ record —á–µ—Ä–µ–∑ extension
3. –°—Ç–≤–æ—Ä—ñ—Ç—å `[Flags] enum Permissions` –∑ –ø—Ä–∞–≤–∞–º–∏: Read, Write, Execute, Delete
4. –†–µ–∞–ª—ñ–∑—É–π—Ç–µ –º–µ—Ç–æ–¥–∏ `AddPermission`, `RemovePermission`, `HasPermission`
5. –í–∏–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ `with` expression –¥–ª—è —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –∞–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –∑ –∫–æ–ø—ñ—ó –∑–≤–∏—á–∞–π–Ω–æ–≥–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞

::collapsible{title="–†—ñ—à–µ–Ω–Ω—è"}

```csharp [Solution.cs] showLineNumbers
public record User(string Name, string Email, DateTime RegisteredAt, Permissions Permissions);

[Flags]
public enum Permissions
{
    None = 0,
    Read = 1,
    Write = 2,
    Execute = 4,
    Delete = 8,
    Full = Read | Write | Execute | Delete
}

public static class PermissionsExtensions
{
    public static Permissions Add(this Permissions current, Permissions permission)
    {
        return current | permission;
    }

    public static Permissions Remove(this Permissions current, Permissions permission)
    {
        return current & ~permission;
    }

    public static bool Has(this Permissions current, Permissions permission)
    {
        return (current & permission) == permission;
    }
}

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
User user = new("Alice", "alice@example.com", DateTime.Now, Permissions.Read);
User admin = user with
{
    Permissions = Permissions.Full
};

Console.WriteLine(admin.Permissions.Has(Permissions.Write)); // True
```

::

### Advanced: Emulating Discriminated Unions

–°—Ç–≤–æ—Ä—ñ—Ç—å —Å–∏—Å—Ç–µ–º—É –æ–±—Ä–æ–±–∫–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤ –æ–ø–µ—Ä–∞—Ü—ñ–π –±–µ–∑ exceptions:

1. –°—Ç–≤–æ—Ä—ñ—Ç—å discriminated union `Result<T>` –∑ –≤–∞—Ä—ñ–∞–Ω—Ç–∞–º–∏ `Success<T>` —Ç–∞ `Failure`
2. `Success` –º—ñ—Å—Ç–∏—Ç—å –∑–Ω–∞—á–µ–Ω–Ω—è —Ç–∏–ø—É `T`
3. `Failure` –º—ñ—Å—Ç–∏—Ç—å –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—Ä–æ –ø–æ–º–∏–ª–∫—É —Ç–∞ –∫–æ–¥ –ø–æ–º–∏–ª–∫–∏
4. –†–µ–∞–ª—ñ–∑—É–π—Ç–µ –º–µ—Ç–æ–¥–∏ `Match<TOut>`, `Bind<TOut>`, `Map<TOut>` –¥–ª—è —Ñ—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª—å–Ω–æ—ó —Ä–æ–±–æ—Ç–∏
5. –°—Ç–≤–æ—Ä—ñ—Ç—å –ø—Ä–∏–∫–ª–∞–¥ –ª–∞–Ω—Ü—é–∂–∫–∞ –æ–ø–µ—Ä–∞—Ü—ñ–π (parsing ‚Üí validation ‚Üí computation)

::collapsible{title="–†—ñ—à–µ–Ω–Ω—è"}

```csharp [Result.cs] showLineNumbers
public abstract record Result<T>
{
    public abstract TOut Match<TOut>(
        Func<T, TOut> onSuccess,
        Func<string, int, TOut> onFailure);
}

public record Success<T>(T Value) : Result<T>
{
    public override TOut Match<TOut>(
        Func<T, TOut> onSuccess,
        Func<string, int, TOut> onFailure)
    {
        return onSuccess(Value);
    }
}

public record Failure<T>(string Message, int ErrorCode) : Result<T>
{
    public override TOut Match<TOut>(
        Func<T, TOut> onSuccess,
        Func<string, int, TOut> onFailure)
    {
        return onFailure(Message, ErrorCode);
    }
}

// Extension methods –¥–ª—è —Ñ—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª—å–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º—É–≤–∞–Ω–Ω—è
public static class ResultExtensions
{
    public static Result<TOut> Bind<T, TOut>(
        this Result<T> result,
        Func<T, Result<TOut>> func)
    {
        return result.Match(
            onSuccess: func,
            onFailure: (msg, code) => new Failure<TOut>(msg, code)
        );
    }

    public static Result<TOut> Map<T, TOut>(
        this Result<T> result,
        Func<T, TOut> mapper)
    {
        return result.Match(
            onSuccess: value => new Success<TOut>(mapper(value)),
            onFailure: (msg, code) => new Failure<TOut>(msg, code)
        );
    }
}

// –ü—Ä–∏–∫–ª–∞–¥ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
Result<int> ParseNumber(string input)
{
    if (int.TryParse(input, out int value))
    {
        return new Success<int>(value);
    }
    return new Failure<int>("Invalid number format", 400);
}

Result<int> ValidatePositive(int number)
{
    if (number > 0)
    {
        return new Success<int>(number);
    }
    return new Failure<int>("Number must be positive", 400);
}

Result<int> Double(int number)
{
    return new Success<int>(number * 2);
}

// –õ–∞–Ω—Ü—é–∂–æ–∫ –æ–ø–µ—Ä–∞—Ü—ñ–π
var result = ParseNumber("42")
    .Bind(ValidatePositive)
    .Map(Double);

string output = result.Match(
    onSuccess: value => $"Result: {value}",
    onFailure: (msg, code) => $"Error {code}: {msg}"
);

Console.WriteLine(output); // Result: 84
```

::

---

## –†–µ–∑—é–º–µ

–£ —Ü—å–æ–º—É —Ä–æ–∑–¥—ñ–ª—ñ –º–∏ –¥–µ—Ç–∞–ª—å–Ω–æ —Ä–æ–∑–≥–ª—è–Ω—É–ª–∏ —Ä–æ–∑—à–∏—Ä–µ–Ω—ñ —Ç–∏–ø–∏ –¥–∞–Ω–∏—Ö –≤ C#:

-   **Structs** ‚Äî value types –¥–ª—è –º–∞–ª–∏—Ö, —á–∞—Å—Ç–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞–Ω–∏—Ö –æ–±'—î–∫—Ç—ñ–≤. `ref struct` –¥–ª—è high-performance —Å—Ü–µ–Ω–∞—Ä—ñ—ó–≤.
-   **Enums** ‚Äî —ñ–º–µ–Ω–æ–≤–∞–Ω—ñ –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∏ –¥–ª—è —Ñ—ñ–∫—Å–æ–≤–∞–Ω–∏—Ö –Ω–∞–±–æ—Ä—ñ–≤ –∑–Ω–∞—á–µ–Ω—å. `[Flags]` attribute –¥–ª—è –±—ñ—Ç–æ–≤–∏—Ö –æ–ø–µ—Ä–∞—Ü—ñ–π.
-   **Records** ‚Äî reference –∞–±–æ value types –∑ value equality —Ç–∞ `with` expressions –¥–ª—è immutable –¥–∞–Ω–∏—Ö.
-   **Tuples** ‚Äî –ª–µ–≥–∫—ñ –≥—Ä—É–ø–∏ –∑–Ω–∞—á–µ–Ω—å –±–µ–∑ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –æ–∫—Ä–µ–º–∏—Ö —Ç–∏–ø—ñ–≤. –Ü–¥–µ–∞–ª—å–Ω–æ –¥–ª—è –ø–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è multiple values.
-   **Anonymous Types** ‚Äî compiler-generated types –¥–ª—è LINQ –ø—Ä–æ–µ–∫—Ü—ñ–π —Ç–∞ –ª–æ–∫–∞–ª—å–Ω–∏—Ö —Ç–∏–º—á–∞—Å–æ–≤–∏—Ö –æ–±'—î–∫—Ç—ñ–≤.
-   **Nullable Types** ‚Äî –ø—ñ–¥—Ç—Ä–∏–º–∫–∞ `null` –¥–ª—è value (`int?`) —Ç–∞ reference types (`string?`). Null-coalescing operators –¥–ª—è –±–µ–∑–ø–µ—á–Ω–æ—ó —Ä–æ–±–æ—Ç–∏.
-   **Discriminated Unions** ‚Äî –∫–æ–Ω—Ü–µ–ø—Ü—ñ—è –∑ —Ñ—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª—å–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º—É–≤–∞–Ω–Ω—è. –ï–º—É–ª—é—î—Ç—å—Å—è —á–µ—Ä–µ–∑ sealed hierarchies –∞–±–æ OneOf library.

–í–∏–±—ñ—Ä –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ —Ç–∏–ø—É –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ —Ä–æ–∑–º—ñ—Ä—É –¥–∞–Ω–∏—Ö, mutability, equality semantics —Ç–∞ –ø–æ—Ç—Ä–µ–±–∏ –≤ inheritance. –†–æ–∑—É–º—ñ–Ω–Ω—è —Ü–∏—Ö –≤—ñ–¥–º—ñ–Ω–Ω–æ—Å—Ç–µ–π –¥–æ–∑–≤–æ–ª—è—î –ø–∏—Å–∞—Ç–∏ –±—ñ–ª—å—à –µ—Ñ–µ–∫—Ç–∏–≤–Ω–∏–π, —á–∏—Ç–∞–±–µ–ª—å–Ω–∏–π —Ç–∞ –ø—ñ–¥—Ç—Ä–∏–º—É–≤–∞–Ω–∏–π –∫–æ–¥.

::tip
**–ù–∞—Å—Ç—É–ø–Ω—ñ –∫—Ä–æ–∫–∏**: –í–∏–≤—á—ñ—Ç—å —Ä–æ–∑–¥—ñ–ª "Namespaces" –¥–ª—è –æ—Ä–≥–∞–Ω—ñ–∑–∞—Ü—ñ—ó –∫–æ–¥—É —Ç–∞ —Ä–æ–∑–¥—ñ–ª "Generics" –¥–ª—è —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è —É–Ω—ñ–≤–µ—Ä—Å–∞–ª—å–Ω–∏—Ö —Ç–∏–ø—ñ–≤, —è–∫—ñ –ø—Ä–∞—Ü—é—é—Ç—å –∑ –±—É–¥—å-—è–∫–∏–º–∏ –∑ —Ä–æ–∑–≥–ª—è–Ω—É—Ç–∏—Ö —Ç–∏–ø—ñ–≤ –¥–∞–Ω–∏—Ö.
::
