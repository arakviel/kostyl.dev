# [Generics (–£–∑–∞–≥–∞–ª—å–Ω–µ–Ω–Ω—è)](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/generics)

::note
**–ü–µ—Ä–µ–¥—É–º–æ–≤–∏**: –†–µ–∫–æ–º–µ–Ω–¥—É—î—Ç—å—Å—è –æ–∑–Ω–∞–π–æ–º–∏—Ç–∏—Å—å –∑ [–∫–ª–∞—Å–∞–º–∏ —Ç–∞ –æ–±'—î–∫—Ç–∞–º–∏](/csharp/oop/classes-objects), [—ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞–º–∏](/csharp/oop/oop-pillars#abstraction) —Ç–∞ [–¥–µ–ª–µ–≥–∞—Ç–∞–º–∏](/csharp/advanced-core/delegates-events-lambdas) –ø–µ—Ä–µ–¥ –≤–∏–≤—á–µ–Ω–Ω—è–º —Ü—å–æ–≥–æ —Ä–æ–∑–¥—ñ–ª—É.
::

## –ù–∞–≤—ñ—â–æ —Ü–µ –ø–æ—Ç—Ä—ñ–±–Ω–æ?

–£—è–≤—ñ—Ç—å, —â–æ –≤–∞–º –ø–æ—Ç—Ä—ñ–±–Ω–æ —Å—Ç–≤–æ—Ä–∏—Ç–∏ —Å—Ç–µ–∫ (stack) –¥–ª—è –∑–±–µ—Ä—ñ–≥–∞–Ω–Ω—è —Ü—ñ–ª–∏—Ö —á–∏—Å–µ–ª:

```csharp showLineNumbers
public class IntStack
{
    private int[] _items = new int[100];
    private int _count = 0;

    public void Push(int item)
    {
        _items[_count++] = item;
    }

    public int Pop()
    {
        return _items[--_count];
    }
}
```

–ß—É–¥–æ–≤–æ! –ê–ª–µ —â–æ, —è–∫—â–æ –≤–∞–º –ø–æ—Ç—Ä—ñ–±–µ–Ω —Å—Ç–µ–∫ –¥–ª—è —Ä—è–¥–∫—ñ–≤? –î–æ–≤–µ–¥–µ—Ç—å—Å—è —Å—Ç–≤–æ—Ä–∏—Ç–∏ —â–µ –æ–¥–∏–Ω –∫–ª–∞—Å:

```csharp showLineNumbers
public class StringStack
{
    private string[] _items = new string[100];
    private int _count = 0;

    public void Push(string item)
    {
        _items[_count++] = item;
    }

    public string Pop()
    {
        return _items[--_count];
    }
}
```

–ê —è–∫—â–æ –ø–æ—Ç—Ä—ñ–±–µ–Ω —Å—Ç–µ–∫ –¥–ª—è `Customer`, `Order`, `Product`? **–î—É–±–ª—é–≤–∞–Ω–Ω—è –∫–æ–¥—É!**

–î–æ –ø–æ—è–≤–∏ generics —É .NET 2.0, —Ä–æ–∑—Ä–æ–±–Ω–∏–∫–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞–ª–∏ `object`:

```csharp showLineNumbers
public class ObjectStack
{
    private object[] _items = new object[100];
    private int _count = 0;

    public void Push(object item)
    {
        _items[_count++] = item;
    }

    public object Pop()
    {
        return _items[--_count];
    }
}

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
ObjectStack stack = new ObjectStack();
stack.Push(42);
int value = (int)stack.Pop(); // ‚ùå –ù–µ–æ–±—Ö—ñ–¥–Ω–∏–π cast
stack.Push("Hello");
int broken = (int)stack.Pop(); // ‚ùå Runtime –ø–æ–º–∏–ª–∫–∞!
```

**–ü—Ä–æ–±–ª–µ–º–∏ –ø—ñ–¥—Ö–æ–¥—É –∑ `object`:**

-   üö´ **–ù–µ–º–∞—î type safety** ‚Äî –º–æ–∂–Ω–∞ –¥–æ–¥–∞—Ç–∏ –±—É–¥—å-—è–∫–∏–π —Ç–∏–ø
-   üêå **Performance overhead** ‚Äî boxing/unboxing –¥–ª—è value types
-   üí• **Runtime errors** ‚Äî –ø–æ–º–∏–ª–∫–∏ –≤–∏—è–≤–ª—è—é—Ç—å—Å—è –ª–∏—à–µ –ø—ñ–¥ —á–∞—Å –≤–∏–∫–æ–Ω–∞–Ω–Ω—è

**Generics –≤–∏—Ä—ñ—à—É—é—Ç—å —Ü—ñ –ø—Ä–æ–±–ª–µ–º–∏:**

```csharp showLineNumbers
public class Stack<T>
{
    private T[] _items = new T[100];
    private int _count = 0;

    public void Push(T item)
    {
        _items[_count++] = item;
    }

    public T Pop()
    {
        return _items[--_count];
    }
}

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
Stack<int> intStack = new Stack<int>();
intStack.Push(42);
int value = intStack.Pop(); // ‚úÖ –ë–µ–∑ cast

Stack<string> stringStack = new Stack<string>();
stringStack.Push("Hello");
// stringStack.Push(42); // ‚ùå Compile-time –ø–æ–º–∏–ª–∫–∞!
```

**–ü–µ—Ä–µ–≤–∞–≥–∏ Generics:**

-   ‚úÖ **Type Safety** ‚Äî –ø–æ–º–∏–ª–∫–∏ –≤–∏—è–≤–ª—è—é—Ç—å—Å—è –Ω–∞ –µ—Ç–∞–ø—ñ –∫–æ–º–ø—ñ–ª—è—Ü—ñ—ó
-   ‚úÖ **Code Reuse** ‚Äî –æ–¥–∏–Ω –∫–ª–∞—Å –¥–ª—è –≤—Å—ñ—Ö —Ç–∏–ø—ñ–≤
-   ‚úÖ **Performance** ‚Äî –Ω–µ–º–∞—î boxing/unboxing
-   ‚úÖ **IntelliSense** ‚Äî –∫—Ä–∞—â–∏–π –∞–≤—Ç–æ–∫–æ–º–ø–ª—ñ—Ç —É IDE

## –§—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ñ –ö–æ–Ω—Ü–µ–ø—Ü—ñ—ó

### Type Parameters vs Type Arguments

[**Type Parameter** (–ø–∞—Ä–∞–º–µ—Ç—Ä —Ç–∏–ø—É)](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generic-type-parameters) ‚Äî —Ü–µ placeholder —É –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—ñ generic —Ç–∏–ø—É:

```csharp showLineNumbers
public class Box<T>  // T ‚Äî —Ü–µ Type Parameter
{
    public T Value { get; set; }
}
```

**Type Argument** (–∞—Ä–≥—É–º–µ–Ω—Ç —Ç–∏–ø—É) ‚Äî —Ü–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏–π —Ç–∏–ø, —è–∫–∏–º –∑–∞–º—ñ–Ω—é—î—Ç—å—Å—è –ø–∞—Ä–∞–º–µ—Ç—Ä:

```csharp showLineNumbers
Box<int> intBox = new Box<int>();     // int ‚Äî —Ü–µ Type Argument
Box<string> strBox = new Box<string>(); // string ‚Äî —Ü–µ Type Argument
```

### Open vs Closed Constructed Types

::mermaid

```mermaid
graph TD
    A[Generic Type Definition\nList&lt;T&gt;] -->|Type Argument: int| B[Closed Constructed Type\nList&lt;int&gt;]
    A -->|Type Argument: string| C[Closed Constructed Type\nList&lt;string&gt;]
    A -->|No Type Argument| D[Open Constructed Type\nList&lt;T&gt;]

    style A fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style B fill:#64748b,stroke:#334155,color:#ffffff
    style C fill:#64748b,stroke:#334155,color:#ffffff
    style D fill:#f59e0b,stroke:#b45309,color:#ffffff
```

::

-   **Open Constructed Type**: Generic —Ç–∏–ø –±–µ–∑ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏—Ö type arguments (`List<T>`)
-   **Closed Constructed Type**: Generic —Ç–∏–ø –∑ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏–º–∏ type arguments (`List<int>`)

### Naming Conventions

::tip
**Best Practice**: –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —Ü—ñ conventions –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤ —Ç–∏–ø—ñ–≤:

-   **Single parameter**: `T` (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, `List<T>`, `Queue<T>`)
-   **Multiple parameters**: –û–ø–∏—Å–æ–≤—ñ —ñ–º–µ–Ω–∞ –∑ –ø—Ä–µ—Ñ—ñ–∫—Å–æ–º `T`
    -   `TKey`, `TValue` (Dictionary<TKey, TValue>)
    -   `TInput`, `TOutput` (Converter<TInput, TOutput>)
    -   `TResult` (Func<T, TResult>)

–¶–µ —Ä–æ–±–∏—Ç—å –∫–æ–¥ —Å–∞–º–æ–¥–æ–∫—É–º–µ–Ω—Ç–æ–≤–∞–Ω–∏–º!
::

## Generic Classes

### –û—Å–Ω–æ–≤–Ω–∏–π –°–∏–Ω—Ç–∞–∫—Å–∏—Å

```csharp [Repository.cs] showLineNumbers
public class Repository<T>
{
    private readonly List<T> _items = new List<T>();

    public void Add(T item)
    {
        _items.Add(item);
    }

    public T GetById(int id)
    {
        return _items[id];
    }

    public IEnumerable<T> GetAll()
    {
        return _items;
    }

    public void Remove(T item)
    {
        _items.Remove(item);
    }
}
```

**–í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è:**

```csharp showLineNumbers
// Repository –¥–ª—è —Ä—ñ–∑–Ω–∏—Ö —Ç–∏–ø—ñ–≤
Repository<Customer> customers = new Repository<Customer>();
customers.Add(new Customer { Id = 1, Name = "Alice" });

Repository<Product> products = new Repository<Product>();
products.Add(new Product { Id = 1, Name = "Laptop" });
```

### Multiple Type Parameters

```csharp [KeyValueStore.cs] showLineNumbers
public class KeyValueStore<TKey, TValue>
{
    private readonly Dictionary<TKey, TValue> _storage = new();

    public void Set(TKey key, TValue value)
    {
        _storage[key] = value;
    }

    public TValue Get(TKey key)
    {
        return _storage[key];
    }

    public bool TryGet(TKey key, out TValue value)
    {
        return _storage.TryGetValue(key, out value);
    }
}
```

**–í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è:**

```csharp showLineNumbers
var cache = new KeyValueStore<string, Customer>();
cache.Set("customer_1", new Customer { Name = "Bob" });

Customer customer = cache.Get("customer_1");
```

### Generic Properties —Ç–∞ Fields

```csharp showLineNumbers
public class Result<T>
{
    // Generic property
    public T Data { get; set; }

    public bool IsSuccess { get; set; }
    public string ErrorMessage { get; set; }

    // Generic field
    private T _cachedValue;

    public T GetOrCache()
    {
        if (_cachedValue == null)
        {
            _cachedValue = Data;
        }
        return _cachedValue;
    }
}
```

### Static Members —É Generic Classes

::warning
**–í–∞–∂–ª–∏–≤–æ**: –ö–æ–∂–µ–Ω **closed constructed type** –º–∞—î —Å–≤–æ—ó –≤–ª–∞—Å–Ω—ñ —Å—Ç–∞—Ç–∏—á–Ω—ñ —á–ª–µ–Ω–∏!
::

```csharp showLineNumbers
public class Counter<T>
{
    private static int _count = 0;

    public static void Increment()
    {
        _count++;
    }

    public static int GetCount()
    {
        return _count;
    }
}

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
Counter<int>.Increment();
Counter<int>.Increment();
Console.WriteLine(Counter<int>.GetCount());    // 2

Counter<string>.Increment();
Console.WriteLine(Counter<string>.GetCount()); // 1 (–æ–∫—Ä–µ–º–∏–π –ª—ñ—á–∏–ª—å–Ω–∏–∫!)
```

## Generic Methods

### –°–∏–Ω—Ç–∞–∫—Å–∏—Å Generic Methods

Generic –º–µ—Ç–æ–¥–∏ –º–æ–∂—É—Ç—å –±—É—Ç–∏ —É **–±—É–¥—å-—è–∫–æ–º—É** –∫–ª–∞—Å—ñ (generic –∞–±–æ non-generic):

```csharp showLineNumbers
public class Utility
{
    // Generic –º–µ—Ç–æ–¥ —É non-generic –∫–ª–∞—Å—ñ
    public static void Swap<T>(ref T a, ref T b)
    {
        T temp = a;
        a = b;
        b = temp;
    }

    public static T[] CreateArray<T>(int size, T defaultValue)
    {
        T[] array = new T[size];
        for (int i = 0; i < size; i++)
        {
            array[i] = defaultValue;
        }
        return array;
    }
}
```

**–í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è:**

```csharp showLineNumbers
int x = 5, y = 10;
Utility.Swap<int>(ref x, ref y); // –Ø–≤–Ω–µ –≤–∫–∞–∑–∞–Ω–Ω—è —Ç–∏–ø—É
Console.WriteLine($"x={x}, y={y}"); // x=10, y=5

string a = "Hello", b = "World";
Utility.Swap(ref a, ref b); // ‚úÖ Type inference!
Console.WriteLine($"a={a}, b={b}"); // a=World, b=Hello
```

### Type Inference

–ö–æ–º–ø—ñ–ª—è—Ç–æ—Ä C# —á–∞—Å—Ç–æ –º–æ–∂–µ **–∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≤–∏–∑–Ω–∞—á–∏—Ç–∏** type arguments:

```csharp showLineNumbers
public static T Max<T>(T a, T b) where T : IComparable<T>
{
    return a.CompareTo(b) > 0 ? a : b;
}

// –Ø–≤–Ω–µ –≤–∫–∞–∑–∞–Ω–Ω—è —Ç–∏–ø—É
int result1 = Max<int>(5, 10);

// Type inference ‚Äî –∫–æ–º–ø—ñ–ª—è—Ç–æ—Ä –≤–∏–∑–Ω–∞—á–∞—î —Ç–∏–ø –∑ –∞—Ä–≥—É–º–µ–Ω—Ç—ñ–≤
int result2 = Max(5, 10);           // ‚úÖ T –≤–∏–≤–æ–¥–∏—Ç—å—Å—è —è–∫ int
string result3 = Max("abc", "xyz"); // ‚úÖ T –≤–∏–≤–æ–¥–∏—Ç—å—Å—è —è–∫ string
```

### Extension Methods –∑ Generics

```csharp showLineNumbers
public static class EnumerableExtensions
{
    public static IEnumerable<T> WhereNot<T>(
        this IEnumerable<T> source,
        Func<T, bool> predicate)
    {
        return source.Where(x => !predicate(x));
    }

    public static T Second<T>(this IEnumerable<T> source)
    {
        return source.Skip(1).First();
    }
}

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
var numbers = new[] { 1, 2, 3, 4, 5 };
var evenNumbers = numbers.WhereNot(n => n % 2 != 0); // –ù–µ–ø–∞—Ä–Ω—ñ –≤–∏–∫–ª—é—á–µ–Ω—ñ
int secondNumber = numbers.Second(); // 2
```

## Constraints (–û–±–º–µ–∂–µ–Ω–Ω—è)

[**Constraints**](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters) –¥–æ–∑–≤–æ–ª—è—é—Ç—å –æ–±–º–µ–∂–∏—Ç–∏ —Ç–∏–ø–∏, —è–∫—ñ –º–æ–∂–Ω–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ —è–∫ type arguments.

### Primary Constraints

#### `where T : class` ‚Äî Reference Type

```csharp showLineNumbers
public class ReferenceRepository<T> where T : class
{
    private T _cachedItem;

    public void Cache(T item)
    {
        _cachedItem = item; // ‚úÖ –ú–æ–∂–Ω–∞ –∑–±–µ—Ä—ñ–≥–∞—Ç–∏ null
    }

    public bool IsCached()
    {
        return _cachedItem != null; // ‚úÖ –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ null
    }
}

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
var repo = new ReferenceRepository<string>();  // ‚úÖ OK
var repo2 = new ReferenceRepository<Customer>(); // ‚úÖ OK
// var repo3 = new ReferenceRepository<int>(); // ‚ùå int ‚Äî value type
```

#### `where T : class?` ‚Äî Nullable Reference Type

```csharp showLineNumbers
public class NullableRepository<T> where T : class?
{
    public T? FindOrDefault(int id)
    {
        // –ú–æ–∂–µ –ø–æ–≤–µ—Ä–Ω—É—Ç–∏ null
        return default(T);
    }
}
```

#### `where T : struct` ‚Äî Value Type

```csharp showLineNumbers
public struct Point<T> where T : struct
{
    public T X { get; set; }
    public T Y { get; set; }

    public Point(T x, T y)
    {
        X = x;
        Y = y;
    }
}

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
var intPoint = new Point<int>(10, 20);       // ‚úÖ OK
var doublePoint = new Point<double>(1.5, 2.5); // ‚úÖ OK
// var stringPoint = new Point<string>("", ""); // ‚ùå string ‚Äî reference type
```

#### `where T : notnull` ‚Äî Non-Nullable Type

–ó–∞–±–æ—Ä–æ–Ω –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è nullable types:

```csharp showLineNumbers
public class NonNullProcessor<T> where T : notnull
{
    public void Process(T item)
    {
        // item –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–æ –Ω–µ null
        Console.WriteLine(item.ToString());
    }
}

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
var processor1 = new NonNullProcessor<int>();    // ‚úÖ OK
var processor2 = new NonNullProcessor<string>(); // ‚úÖ OK (—è–∫—â–æ NRT enabled)
// var processor3 = new NonNullProcessor<string?>(); // ‚ùå nullable
```

#### `where T : unmanaged` ‚Äî Unmanaged Type

–¢–∏–ø, —è–∫–∏–π –Ω–µ –º—ñ—Å—Ç–∏—Ç—å reference types (primitives, structs –±–µ–∑ reference fields):

```csharp showLineNumbers
public unsafe class UnsafeBuffer<T> where T : unmanaged
{
    private T* _buffer;
    private int _size;

    public UnsafeBuffer(int size)
    {
        _size = size;
        _buffer = (T*)Marshal.AllocHGlobal(size * sizeof(T));
    }

    public T this[int index]
    {
        get => _buffer[index];
        set => _buffer[index] = value;
    }
}

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
var buffer1 = new UnsafeBuffer<int>(10);    // ‚úÖ OK
var buffer2 = new UnsafeBuffer<double>(10); // ‚úÖ OK
// var buffer3 = new UnsafeBuffer<string>(10); // ‚ùå string –Ω–µ unmanaged
```

#### `where T : new()` ‚Äî Parameterless Constructor

```csharp showLineNumbers
public class Factory<T> where T : new()
{
    public T Create()
    {
        return new T(); // ‚úÖ –ú–æ–∂–µ–º–æ —Å—Ç–≤–æ—Ä—é–≤–∞—Ç–∏ –µ–∫–∑–µ–º–ø–ª—è—Ä–∏
    }

    public List<T> CreateMany(int count)
    {
        var list = new List<T>();
        for (int i = 0; i < count; i++)
        {
            list.Add(new T());
        }
        return list;
    }
}

public class Customer
{
    public Customer() { } // ‚úÖ Parameterless constructor
}

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
var factory = new Factory<Customer>();
Customer customer = factory.Create(); // ‚úÖ OK
```

### Secondary Constraints

#### Base Class Constraint

```csharp showLineNumbers
public abstract class Entity
{
    public int Id { get; set; }
    public DateTime CreatedAt { get; set; }
}

public class EntityRepository<T> where T : Entity
{
    public void Save(T entity)
    {
        entity.CreatedAt = DateTime.Now; // ‚úÖ –î–æ—Å—Ç—É–ø –¥–æ –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç–µ–π Entity
        // –õ–æ–≥—ñ–∫–∞ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è
    }

    public T GetById(int id)
    {
        // –õ–æ–≥—ñ–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è
        return default(T);
    }
}

public class Customer : Entity
{
    public string Name { get; set; }
}

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
var repo = new EntityRepository<Customer>(); // ‚úÖ Customer : Entity
```

#### Interface Constraint

```csharp showLineNumbers
public class Sorter<T> where T : IComparable<T>
{
    public void BubbleSort(List<T> items)
    {
        for (int i = 0; i < items.Count - 1; i++)
        {
            for (int j = 0; j < items.Count - i - 1; j++)
            {
                if (items[j].CompareTo(items[j + 1]) > 0) // ‚úÖ CompareTo –¥–æ—Å—Ç—É–ø–Ω–∏–π
                {
                    T temp = items[j];
                    items[j] = items[j + 1];
                    items[j + 1] = temp;
                }
            }
        }
    }
}
```

**Multiple Interface Constraints:**

```csharp showLineNumbers
public class AdvancedProcessor<T>
    where T : IComparable<T>, IEquatable<T>, IDisposable
{
    public void Process(T item)
    {
        // –î–æ—Å—Ç—É–ø–Ω—ñ –º–µ—Ç–æ–¥–∏ –∑ —É—Å—ñ—Ö —Ç—Ä—å–æ—Ö —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ñ–≤
        item.CompareTo(default(T));
        item.Equals(default(T));
        item.Dispose();
    }
}
```

#### Type Parameter Constraint

–û–¥–∏–Ω type parameter –º–æ–∂–µ –±—É—Ç–∏ constraint –¥–ª—è —ñ–Ω—à–æ–≥–æ:

```csharp showLineNumbers
public class Mapper<TSource, TDestination>
    where TDestination : TSource
{
    public TDestination Convert(TSource source)
    {
        // TDestination –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–æ —É—Å–ø–∞–¥–∫–æ–≤—É—î—Ç—å—Å—è –≤—ñ–¥ TSource
        return (TDestination)source;
    }
}

public class Animal { }
public class Dog : Animal { }

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
var mapper = new Mapper<Animal, Dog>();
Dog dog = mapper.Convert(new Dog()); // ‚úÖ OK
```

### Anti-Constraints (C# 13)

#### `where T : allows ref struct`

–ù–æ–≤–∞ –º–æ–∂–ª–∏–≤—ñ—Å—Ç—å C# 13 ‚Äî –¥–æ–∑–≤–æ–ª—è—î –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ [`ref struct`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/where-generic-type-constraint#allows-ref-struct) —Ç–∏–ø–∏ —è–∫ generic arguments:

```csharp showLineNumbers
public class DataProcessor<T> where T : allows ref struct
{
    public void Process(scoped T data)
    {
        // T –º–æ–∂–µ –±—É—Ç–∏ ref struct (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, Span<T>)
        // –ü–∞—Ä–∞–º–µ—Ç—Ä scoped –≥–∞—Ä–∞–Ω—Ç—É—î ref safety
    }
}

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –∑ ref struct
public ref struct MyRefType
{
    public int Value;
}

var processor = new DataProcessor<MyRefType>();
var data = new MyRefType { Value = 42 };
processor.Process(data); // ‚úÖ OK –∑ C# 13
```

::tip
**C# 13 Feature**: –î–æ C# 13 –Ω–µ–º–æ–∂–ª–∏–≤–æ –±—É–ª–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ `ref struct` —Ç–∏–ø–∏ (—è–∫ `Span<T>`, `ReadOnlySpan<T>`) —è–∫ generic type arguments. –¢–µ–ø–µ—Ä –∑ `allows ref struct` —Ü–µ –º–æ–∂–ª–∏–≤–æ!
::

### Multiple Constraints

```csharp showLineNumbers
public class AdvancedRepository<T>
    where T : Entity,        // Base class
              IValidatable,  // Interface 1
              INotifyPropertyChanged, // Interface 2
              new()         // Constructor (–∑–∞–≤–∂–¥–∏ –æ—Å—Ç–∞–Ω–Ω—ñ–π!)
{
    public void Add(T item)
    {
        // –î–æ—Å—Ç—É–ø –¥–æ –≤—Å—ñ—Ö –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç–µ–π —Ç–∞ –º–µ—Ç–æ–¥—ñ–≤
        item.Id = GenerateId();
        if (!item.Validate())
        {
            throw new InvalidOperationException("Invalid entity");
        }
        // –ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è...
    }
}
```

::warning
**–ü–æ—Ä—è–¥–æ–∫ Constraints**:

1. Primary constraint (`class`, `struct`, base class)
2. Interface constraints
3. `new()` –∑–∞–≤–∂–¥–∏ –æ—Å—Ç–∞–Ω–Ω—ñ–π!
   ::

### –ü–æ—Ä—ñ–≤–Ω—è–ª—å–Ω–∞ –¢–∞–±–ª–∏—Ü—è Constraints

| Constraint          | –û–ø–∏—Å                        | –ü—Ä–∏–∫–ª–∞–¥                       |
| :------------------ | :-------------------------- | :---------------------------- |
| `class`             | Reference type              | `where T : class`             |
| `class?`            | Nullable reference type     | `where T : class?`            |
| `struct`            | Value type                  | `where T : struct`            |
| `notnull`           | Non-nullable type           | `where T : notnull`           |
| `unmanaged`         | Unmanaged type              | `where T : unmanaged`         |
| `new()`             | Parameterless constructor   | `where T : new()`             |
| Base class          | –£—Å–ø–∞–¥–∫–æ–≤—É—î—Ç—å—Å—è –≤—ñ–¥ –∫–ª–∞—Å—É    | `where T : Entity`            |
| Interface           | –†–µ–∞–ª—ñ–∑—É—î —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å          | `where T : IComparable<T>`    |
| Type parameter      | Type constraint             | `where TDest : TSource`       |
| `allows ref struct` | –î–æ–∑–≤–æ–ª—è—î ref struct (C# 13) | `where T : allows ref struct` |

## Covariance —Ç–∞ Contravariance

[**Variance** (–≤–∞—Ä—ñ–∞–Ω—Ç–Ω—ñ—Å—Ç—å)](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/covariance-contravariance/) –æ–ø–∏—Å—É—î, —è–∫ –º–æ–∂–Ω–∞ –∑–∞–º—ñ–Ω—é–≤–∞—Ç–∏ generic —Ç–∏–ø–∏ –≤ hierarchy —É—Å–ø–∞–¥–∫—É–≤–∞–Ω–Ω—è.

### –û—Å–Ω–æ–≤–Ω—ñ –ö–æ–Ω—Ü–µ–ø—Ü—ñ—ó

–ü—Ä–∏–ø—É—Å—Ç–∏–º–æ, —É –Ω–∞—Å —î —Ç–∞–∫–∞ hierarchy:

```csharp showLineNumbers
public class Animal
{
    public string Name { get; set; }
}

public class Dog : Animal
{
    public void Bark() => Console.WriteLine("Woof!");
}

public class Cat : Animal
{
    public void Meow() => Console.WriteLine("Meow!");
}
```

::mermaid

```mermaid
graph TD
    A[Animal] --> B[Dog]
    A --> C[Cat]

    style A fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style B fill:#64748b,stroke:#334155,color:#ffffff
    style C fill:#64748b,stroke:#334155,color:#ffffff
```

::

### Covariance (`out` keyword)

[**Covariance**](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/covariance-contravariance/covariance-and-contravariance-in-generics) –¥–æ–∑–≤–æ–ª—è—î –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ **–±—ñ–ª—å—à –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏–π** (derived) —Ç–∏–ø –∑–∞–º—ñ—Å—Ç—å **–∑–∞–≥–∞–ª—å–Ω–æ–≥–æ** (base).

```csharp showLineNumbers
// IEnumerable<T> —î covariant (–º–∞—î out modifier)
IEnumerable<Dog> dogs = new List<Dog>
{
    new Dog { Name = "Rex" },
    new Dog { Name = "Buddy" }
};

// ‚úÖ Covariance: Dog ‚Üí Animal
IEnumerable<Animal> animals = dogs; // –ü—Ä–∞—Ü—é—î!

foreach (Animal animal in animals)
{
    Console.WriteLine(animal.Name); // Rex, Buddy
}
```

**–ß–æ–º—É —Ü–µ –ø—Ä–∞—Ü—é—î?**

-   `Dog` —î `Animal`
-   –ú–∏ **—Ç—ñ–ª—å–∫–∏ —á–∏—Ç–∞—î–º–æ** –∑ `IEnumerable<T>` (get, iterate)
-   –ë–µ–∑–ø–µ—á–Ω–æ –ø–æ–≤–µ—Ä—Ç–∞—Ç–∏ `Dog` –∫–æ–ª–∏ –æ—á—ñ–∫—É—î—Ç—å—Å—è `Animal`

**–í–∏–∑–Ω–∞—á–µ–Ω–Ω—è Covariant Interface:**

```csharp showLineNumbers
public interface IReadOnlyRepository<out T>
{
    T GetById(int id);              // ‚úÖ T —É return position
    IEnumerable<T> GetAll();        // ‚úÖ T —É return position
    // void Add(T item);            // ‚ùå T —É input position ‚Äî –Ω–µ –º–æ–∂–Ω–∞!
}

public class DogRepository : IReadOnlyRepository<Dog>
{
    public Dog GetById(int id) => new Dog { Name = "Rex" };
    public IEnumerable<Dog> GetAll() => new List<Dog>();
}

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è covariance
IReadOnlyRepository<Dog> dogRepo = new DogRepository();
IReadOnlyRepository<Animal> animalRepo = dogRepo; // ‚úÖ Covariance

Animal animal = animalRepo.GetById(1); // –ü–æ–≤–µ—Ä—Ç–∞—î Dog
```

### Contravariance (`in` keyword)

[**Contravariance**](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/covariance-contravariance/covariance-and-contravariance-in-generics) –¥–æ–∑–≤–æ–ª—è—î –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ **–±—ñ–ª—å—à –∑–∞–≥–∞–ª—å–Ω–∏–π** (base) —Ç–∏–ø –∑–∞–º—ñ—Å—Ç—å **–∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ** (derived).

```csharp showLineNumbers
// IComparer<T> —î contravariant (–º–∞—î in modifier)
public class AnimalComparer : IComparer<Animal>
{
    public int Compare(Animal x, Animal y)
    {
        return string.Compare(x.Name, y.Name);
    }
}

var animalComparer = new AnimalComparer();

// ‚úÖ Contravariance: Animal ‚Üí Dog
IComparer<Dog> dogComparer = animalComparer; // –ü—Ä–∞—Ü—é—î!

var dogs = new List<Dog>
{
    new Dog { Name = "Buddy" },
    new Dog { Name = "Rex" }
};

dogs.Sort(dogComparer); // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î AnimalComparer –¥–ª—è Dog
```

**–ß–æ–º—É —Ü–µ –ø—Ä–∞—Ü—é—î?**

-   –ú–µ—Ç–æ–¥ –ø—Ä–∏–π–º–∞—î `Animal`, —Ç–æ–º—É –º–æ–∂–µ –ø—Ä–∞—Ü—é–≤–∞—Ç–∏ –∑ `Dog`
-   –ú–∏ **—Ç—ñ–ª—å–∫–∏ –ø–∏—à–µ–º–æ** –≤ `IComparer<T>` (input parameters)
-   –ë–µ–∑–ø–µ—á–Ω–æ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç–∏ `Dog` –∫–æ–ª–∏ –æ—á—ñ–∫—É—î—Ç—å—Å—è `Animal`

**–í–∏–∑–Ω–∞—á–µ–Ω–Ω—è Contravariant Interface:**

```csharp showLineNumbers
public interface IProcessor<in T>
{
    void Process(T item);           // ‚úÖ T —É input position
    void ProcessMany(IEnumerable<T> items); // ‚úÖ T —É input position
    // T Get();                     // ‚ùå T —É return position ‚Äî –Ω–µ –º–æ–∂–Ω–∞!
}

public class AnimalProcessor : IProcessor<Animal>
{
    public void Process(Animal animal)
    {
        Console.WriteLine($"Processing: {animal.Name}");
    }

    public void ProcessMany(IEnumerable<Animal> items)
    {
        foreach (var animal in items)
        {
            Process(animal);
        }
    }
}

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è contravariance
IProcessor<Animal> animalProcessor = new AnimalProcessor();
IProcessor<Dog> dogProcessor = animalProcessor; // ‚úÖ Contravariance

dogProcessor.Process(new Dog { Name = "Rex" });
```

### Invariance (–ó–∞ –ó–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º)

–Ø–∫—â–æ –Ω–µ–º–∞—î `in` –∞–±–æ `out`, generic —Ç–∏–ø —î **invariant** ‚Äî –Ω–µ –º–æ–∂–Ω–∞ –∑–∞–º—ñ–Ω—é–≤–∞—Ç–∏ —Ç–∏–ø–∏:

```csharp showLineNumbers
public interface IRepository<T> // Invariant (–Ω–µ–º–∞—î in/out)
{
    void Add(T item);      // Input
    T GetById(int id);     // Output
}

IRepository<Dog> dogRepo = new DogRepository();
// IRepository<Animal> animalRepo = dogRepo; // ‚ùå –ù–µ –ø—Ä–∞—Ü—é—î ‚Äî invariant
```

### Variance —É Delegates

#### Func<T, TResult> ‚Äî Covariant —É TResult

```csharp showLineNumbers
Func<Dog> getDog = () => new Dog { Name = "Rex" };

// ‚úÖ Covariance: Dog ‚Üí Animal —É return type
Func<Animal> getAnimal = getDog;

Animal animal = getAnimal(); // –ü–æ–≤–µ—Ä—Ç–∞—î Dog
```

#### Action<T> ‚Äî Contravariant —É T

```csharp showLineNumbers
Action<Animal> processAnimal = (animal) =>
{
    Console.WriteLine($"Processing: {animal.Name}");
};

// ‚úÖ Contravariance: Animal ‚Üí Dog —É parameter
Action<Dog> processDog = processAnimal;

processDog(new Dog { Name = "Buddy" });
```

#### Func<T, TResult> ‚Äî Contravariant —É T, Covariant —É TResult

```csharp showLineNumbers
Func<Animal, Dog> converter = (animal) => new Dog { Name = animal.Name };

// ‚úÖ Contravariance —É input (Animal ‚Üí Dog)
// ‚úÖ Covariance —É output (Dog ‚Üí Animal)
Func<Dog, Animal> varianceConverter = converter;

Animal result = varianceConverter(new Dog { Name = "Rex" });
```

### –ü–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è Variance

| Variance           | Keyword | –î–æ–∑–≤–æ–ª—è—î          | –ü–æ–∑–∏—Ü—ñ—è        | –ü—Ä–∏–∫–ª–∞–¥              |
| :----------------- | :------ | :---------------- | :------------- | :------------------- |
| **Covariance**     | `out`   | Derived ‚Üí Base    | Return types   | `IEnumerable<out T>` |
| **Contravariance** | `in`    | Base ‚Üí Derived    | Parameters     | `IComparer<in T>`    |
| **Invariance**     | ‚Äî       | –¢—ñ–ª—å–∫–∏ —Ç–æ—á–Ω–∏–π —Ç–∏–ø | Input + Output | `IList<T>`           |

::tip
**–ü—Ä–∞–≤–∏–ª–æ –ø–∞–º'—è—Ç—ñ**:

-   **out** = **out**put positions ‚Üí **co**variant ‚Üí more derived **out**
-   **in** = **in**put positions ‚Üí **contra**variant ‚Üí more general **in**
    ::

## [Generic Interfaces](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generic-interfaces)

### Implementing Generic Interfaces

```csharp showLineNumbers
public interface IRepository<T>
{
    void Add(T item);
    T GetById(int id);
    IEnumerable<T> GetAll();
    void Remove(T item);
}

public class CustomerRepository : IRepository<Customer>
{
    private readonly List<Customer> _customers = new();

    public void Add(Customer item)
    {
        _customers.Add(item);
    }

    public Customer GetById(int id)
    {
        return _customers.FirstOrDefault(c => c.Id == id);
    }

    public IEnumerable<Customer> GetAll()
    {
        return _customers;
    }

    public void Remove(Customer item)
    {
        _customers.Remove(item);
    }
}
```

### Standard Generic Interfaces

#### IEnumerable<T> —Ç–∞ ICollection<T>

```csharp showLineNumbers
public class CustomCollection<T> : IEnumerable<T>
{
    private readonly List<T> _items = new();

    public void Add(T item) => _items.Add(item);

    public IEnumerator<T> GetEnumerator()
    {
        return _items.GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
var collection = new CustomCollection<int>();
collection.Add(1);
collection.Add(2);
collection.Add(3);

foreach (int item in collection) // ‚úÖ –ü—Ä–∞—Ü—é—î —á–µ—Ä–µ–∑ IEnumerable<T>
{
    Console.WriteLine(item);
}
```

#### IComparable<T> —Ç–∞ IComparer<T>

```csharp showLineNumbers
public class Product : IComparable<Product>
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }

    public int CompareTo(Product other)
    {
        if (other == null) return 1;
        return Price.CompareTo(other.Price); // –°–æ—Ä—Ç—É–≤–∞–Ω–Ω—è –∑–∞ —Ü—ñ–Ω–æ—é
    }
}

// Custom comparer
public class ProductNameComparer : IComparer<Product>
{
    public int Compare(Product x, Product y)
    {
        if (x == null && y == null) return 0;
        if (x == null) return -1;
        if (y == null) return 1;
        return string.Compare(x.Name, y.Name);
    }
}

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
var products = new List<Product>
{
    new Product { Name = "Laptop", Price = 1000 },
    new Product { Name = "Mouse", Price = 25 },
    new Product { Name = "Keyboard", Price = 75 }
};

products.Sort(); // –°–æ—Ä—Ç—É–≤–∞–Ω–Ω—è –∑–∞ Price (IComparable)
products.Sort(new ProductNameComparer()); // –°–æ—Ä—Ç—É–≤–∞–Ω–Ω—è –∑–∞ Name
```

#### IEquatable<T>

```csharp showLineNumbers
public class Customer : IEquatable<Customer>
{
    public int Id { get; set; }
    public string Email { get; set; }

    public bool Equals(Customer other)
    {
        if (other == null) return false;
        return Id == other.Id && Email == other.Email;
    }

    public override bool Equals(object obj)
    {
        return Equals(obj as Customer);
    }

    public override int GetHashCode()
    {
        return HashCode.Combine(Id, Email);
    }
}

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
var customer1 = new Customer { Id = 1, Email = "test@example.com" };
var customer2 = new Customer { Id = 1, Email = "test@example.com" };

bool areEqual = customer1.Equals(customer2); // true
```

### Multiple Interface Implementations

```csharp showLineNumbers
public class SmartCollection<T> :
    IEnumerable<T>,
    ICollection<T>,
    IList<T>
{
    private readonly List<T> _items = new();

    // IEnumerable<T>
    public IEnumerator<T> GetEnumerator() => _items.GetEnumerator();
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    // ICollection<T>
    public int Count => _items.Count;
    public bool IsReadOnly => false;
    public void Add(T item) => _items.Add(item);
    public void Clear() => _items.Clear();
    public bool Contains(T item) => _items.Contains(item);
    public void CopyTo(T[] array, int arrayIndex) => _items.CopyTo(array, arrayIndex);
    public bool Remove(T item) => _items.Remove(item);

    // IList<T>
    public T this[int index]
    {
        get => _items[index];
        set => _items[index] = value;
    }

    public int IndexOf(T item) => _items.IndexOf(item);
    public void Insert(int index, T item) => _items.Insert(index, item);
    public void RemoveAt(int index) => _items.RemoveAt(index);
}
```

## [Generic Delegates](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generic-delegates)

### Built-in Generic Delegates

#### Func<T, TResult>

–ü—Ä–µ–¥—Å—Ç–∞–≤–ª—è—î –º–µ—Ç–æ–¥, —è–∫–∏–π –ø—Ä–∏–π–º–∞—î –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ —Ç–∞ –ø–æ–≤–µ—Ä—Ç–∞—î –∑–Ω–∞—á–µ–Ω–Ω—è:

```csharp showLineNumbers
// Func<TResult> ‚Äî –±–µ–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤
Func<int> getNumber = () => 42;
int number = getNumber(); // 42

// Func<T, TResult> ‚Äî 1 –ø–∞—Ä–∞–º–µ—Ç—Ä
Func<int, int> square = x => x * x;
int result = square(5); // 25

// Func<T1, T2, TResult> ‚Äî 2 –ø–∞—Ä–∞–º–µ—Ç—Ä–∏
Func<int, int, int> add = (x, y) => x + y;
int sum = add(3, 4); // 7

// Func –ø—ñ–¥—Ç—Ä–∏–º—É—î –¥–æ 16 –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤!
Func<int, int, int, int, int> addFour = (a, b, c, d) => a + b + c + d;
```

**–ü—Ä–∞–∫—Ç–∏—á–Ω–∏–π –ø—Ä–∏–∫–ª–∞–¥:**

```csharp showLineNumbers
public class Calculator
{
    public int Calculate(int a, int b, Func<int, int, int> operation)
    {
        return operation(a, b);
    }
}

var calc = new Calculator();
int sum = calc.Calculate(10, 5, (x, y) => x + y);     // 15
int product = calc.Calculate(10, 5, (x, y) => x * y); // 50
int diff = calc.Calculate(10, 5, (x, y) => x - y);    // 5
```

#### Action<T>

–ü—Ä–µ–¥—Å—Ç–∞–≤–ª—è—î –º–µ—Ç–æ–¥, —è–∫–∏–π –ø—Ä–∏–π–º–∞—î –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –∞–ª–µ **–Ω–µ –ø–æ–≤–µ—Ä—Ç–∞—î** –∑–Ω–∞—á–µ–Ω–Ω—è:

```csharp showLineNumbers
// Action ‚Äî –±–µ–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤
Action sayHello = () => Console.WriteLine("Hello!");
sayHello();

// Action<T> ‚Äî 1 –ø–∞—Ä–∞–º–µ—Ç—Ä
Action<string> greet = name => Console.WriteLine($"Hello, {name}!");
greet("Alice");

// Action<T1, T2> ‚Äî 2 –ø–∞—Ä–∞–º–µ—Ç—Ä–∏
Action<string, int> printInfo = (name, age) =>
{
    Console.WriteLine($"{name} is {age} years old");
};
printInfo("Bob", 30);
```

**–ü—Ä–∞–∫—Ç–∏—á–Ω–∏–π –ø—Ä–∏–∫–ª–∞–¥:**

```csharp showLineNumbers
public class Logger
{
    public void LogAll(IEnumerable<string> messages, Action<string> logAction)
    {
        foreach (var message in messages)
        {
            logAction(message);
        }
    }
}

var logger = new Logger();
var messages = new[] { "Error 1", "Error 2", "Error 3" };

logger.LogAll(messages, msg => Console.WriteLine(msg));
logger.LogAll(messages, msg => File.AppendAllText("log.txt", msg + "\n"));
```

#### Predicate<T>

–ü—Ä–µ–¥—Å—Ç–∞–≤–ª—è—î –º–µ—Ç–æ–¥, —è–∫–∏–π –ø—Ä–∏–π–º–∞—î 1 –ø–∞—Ä–∞–º–µ—Ç—Ä —Ç–∞ –ø–æ–≤–µ—Ä—Ç–∞—î `bool`:

```csharp showLineNumbers
// Predicate<T> –µ–∫–≤—ñ–≤–∞–ª–µ–Ω—Ç–Ω–∏–π Func<T, bool>
Predicate<int> isEven = x => x % 2 == 0;
bool result1 = isEven(4);  // true
bool result2 = isEven(5);  // false

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –∑ List<T>.FindAll
var numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
List<int> evenNumbers = numbers.FindAll(isEven); // [2, 4, 6, 8, 10]
```

### Custom Generic Delegates

```csharp showLineNumbers
// Custom delegate –∑ –¥–≤–æ–º–∞ type parameters
public delegate TResult Converter<TInput, TResult>(TInput input);

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
Converter<string, int> stringToInt = s => int.Parse(s);
int number = stringToInt("42"); // 42

Converter<int, string> intToString = i => i.ToString();
string text = intToString(100); // "100"

// –ó LINQ
var strings = new[] { "1", "2", "3", "4", "5" };
var integers = strings.Select(s => stringToInt(s)).ToList();
```

### Variance —É Generic Delegates

```csharp showLineNumbers
public class Animal
{
    public string Name { get; set; }
}

public class Dog : Animal
{
    public void Bark() => Console.WriteLine("Woof!");
}

// Covariance —É Func<TResult>
Func<Dog> getDog = () => new Dog { Name = "Rex" };
Func<Animal> getAnimal = getDog; // ‚úÖ Covariance

// Contravariance —É Action<T>
Action<Animal> processAnimal = a => Console.WriteLine(a.Name);
Action<Dog> processDog = processAnimal; // ‚úÖ Contravariance

// –ö–æ–º–±—ñ–Ω–∞—Ü—ñ—è —É Func<T, TResult>
Func<Animal, Dog> convertAnimalToDog = a => new Dog { Name = a.Name };
Func<Dog, Animal> convertDogToAnimal = convertAnimalToDog; // ‚úÖ –û–±–∏–¥–≤–∞!
```

## Best Practices

### 1. –ö–æ–ª–∏ –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ Generics

::tip
**–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ Generics –∫–æ–ª–∏:**

-   ‚úÖ –ü–æ—Ç—Ä—ñ–±–Ω–∞ type safety –ø—Ä–∏ —Ä–æ–±–æ—Ç—ñ –∑ —Ä—ñ–∑–Ω–∏–º–∏ —Ç–∏–ø–∞–º–∏
-   ‚úÖ –õ–æ–≥—ñ–∫–∞ –æ–¥–Ω–∞–∫–æ–≤–∞ –¥–ª—è —Ä—ñ–∑–Ω–∏—Ö —Ç–∏–ø—ñ–≤
-   ‚úÖ –•–æ—á–µ—Ç–µ —É–Ω–∏–∫–Ω—É—Ç–∏ boxing/unboxing
-   ‚úÖ –°—Ç–≤–æ—Ä—é—î—Ç–µ –∫–æ–ª–µ–∫—Ü—ñ—ó, –∞–ª–≥–æ—Ä–∏—Ç–º–∏, —É—Ç–∏–ª—ñ—Ç–∏

**–ù–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ Generics –∫–æ–ª–∏:**

-   ‚ùå –õ–æ–≥—ñ–∫–∞ —Å–ø–µ—Ü–∏—Ñ—ñ—á–Ω–∞ –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ —Ç–∏–ø—É
-   ‚ùå –ü–æ—Ç—Ä—ñ–±–Ω–∞ reflection –¥–ª—è —Ä–æ–±–æ—Ç–∏ –∑ —Ç–∏–ø–∞–º–∏
-   ‚ùå –ü—Ä–∞—Ü—é—î—Ç–µ –∑ legacy –∫–æ–¥–æ–º, —è–∫–∏–π –æ—á—ñ–∫—É—î `object`
    ::

### 2. Naming Conventions

```csharp showLineNumbers
// ‚úÖ –î–û–ë–†–ï: –û–ø–∏—Å–æ–≤—ñ —ñ–º–µ–Ω–∞
public class Dictionary<TKey, TValue> { }
public interface IConverter<TInput, TOutput> { }
public delegate TResult Func<T, TResult>(T arg);

// ‚úÖ –î–û–ë–†–ï: Single parameter ‚Äî –ø—Ä–æ—Å—Ç–æ T
public class List<T> { }
public interface IComparable<T> { }

// ‚ùå –ü–û–ì–ê–ù–û: –ù–µ–∑—Ä–æ–∑—É–º—ñ–ª—ñ —ñ–º–µ–Ω–∞
public class MyClass<A, B, C> { }
public interface IConverter<X, Y> { }
```

### 3. Constraints Minimalism

```csharp showLineNumbers
// ‚ùå –ü–û–ì–ê–ù–û: –ù–∞–¥–º—ñ—Ä–Ω—ñ constraints
public class Processor<T>
    where T : class, IDisposable, IComparable<T>, IEquatable<T>, new()
{
    // –ó–∞–Ω–∞–¥—Ç–æ –±–∞–≥–∞—Ç–æ –≤–∏–º–æ–≥!
}

// ‚úÖ –ö–†–ê–©–ï: –¢—ñ–ª—å–∫–∏ –Ω–µ–æ–±—Ö—ñ–¥–Ω—ñ constraints
public class Processor<T>
    where T : IDisposable
{
    // –¢—ñ–ª—å–∫–∏ —Ç–µ, —â–æ —Ä–µ–∞–ª—å–Ω–æ –ø–æ—Ç—Ä—ñ–±–Ω–æ
}
```

### 4. Generic vs Object

```csharp showLineNumbers
// ‚ùå –°–¢–ê–†–ò–ô –ü–Ü–î–•–Ü–î: Object
public class OldStack
{
    private object[] items;
    public void Push(object item) { }
    public object Pop() { return items[0]; } // –ü–æ—Ç—Ä—ñ–±–µ–Ω cast
}

// ‚úÖ –°–£–ß–ê–°–ù–ò–ô: Generics
public class Stack<T>
{
    private T[] items;
    public void Push(T item) { }
    public T Pop() { return items[0]; } // –ë–µ–∑ cast!
}
```

### 5. Performance Considerations

::tip
**Performance Benefits:**

-   **No Boxing/Unboxing**: Value types –Ω–µ —É–ø–∞–∫–æ–≤—É—é—Ç—å—Å—è –≤ object
-   **Type Safety at Compile Time**: –ú–µ–Ω—à–µ runtime –ø–µ—Ä–µ–≤—ñ—Ä–æ–∫
-   **JIT Optimization**: –î–ª—è value types JIT —Å—Ç–≤–æ—Ä—é—î —Å–ø–µ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–∏–π –∫–æ–¥

```csharp showLineNumbers
// Boxing –∑ object ‚Äî –ø–æ–≤—ñ–ª—å–Ω–æ
ArrayList list = new ArrayList();
list.Add(42);           // Boxing: int ‚Üí object
int value = (int)list[0]; // Unboxing: object ‚Üí int

// Generics ‚Äî —à–≤–∏–¥–∫–æ
List<int> genericList = new List<int>();
genericList.Add(42);    // –ë–µ–∑ boxing
int value2 = genericList[0]; // –ë–µ–∑ unboxing
```

::

### 6. Covariance/Contravariance Best Practices

```csharp showLineNumbers
// ‚úÖ –î–û–ë–†–ï: out –¥–ª—è read-only operations
public interface IReadOnlyRepository<out T>
{
    T GetById(int id);
    IEnumerable<T> GetAll();
}

// ‚úÖ –î–û–ë–†–ï: in –¥–ª—è write-only operations
public interface IWriter<in T>
{
    void Write(T item);
}

// ‚úÖ –î–û–ë–†–ï: Invariant –¥–ª—è read-write
public interface IRepository<T>
{
    void Add(T item);
    T GetById(int id);
}
```

## Troubleshooting

### –ü—Ä–æ–±–ª–µ–º–∞ 1: CS0693 ‚Äî Type Parameter Same Name

**–ü–æ–º–∏–ª–∫–∞:**

```csharp
// CS0693: Type parameter has the same name as the type parameter from outer type
public class Outer<T>
{
    public void Method<T>() // ‚ùå T –ø—Ä–∏—Ö–æ–≤—É—î T –∑ –∫–ª–∞—Å—É
    {
        // ...
    }
}
```

**–†—ñ—à–µ–Ω–Ω—è:**

```csharp showLineNumbers
// ‚úÖ –í–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ —Ä—ñ–∑–Ω—ñ —ñ–º–µ–Ω–∞
public class Outer<T>
{
    public void Method<U>() // ‚úÖ U –Ω–µ –∫–æ–Ω—Ñ–ª—ñ–∫—Ç—É—î –∑ T
    {
        // ...
    }
}
```

### –ü—Ä–æ–±–ª–µ–º–∞ 2: CS0311 ‚Äî Invalid Type Argument

**–ü–æ–º–∏–ª–∫–∞:**

```csharp
public class Repository<T> where T : IEntity
{
}

public class Customer { } // –ù–µ —Ä–µ–∞–ª—ñ–∑—É—î IEntity

var repo = new Repository<Customer>(); // ‚ùå CS0311
```

**–†—ñ—à–µ–Ω–Ω—è:**

```csharp showLineNumbers
// ‚úÖ Customer –º–∞—î —Ä–µ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ IEntity
public class Customer : IEntity
{
    public int Id { get; set; }
}

var repo = new Repository<Customer>(); // ‚úÖ OK
```

### –ü—Ä–æ–±–ª–µ–º–∞ 3: CS0452 ‚Äî Must Be Reference Type

**–ü–æ–º–∏–ª–∫–∞:**

```csharp
public class Handler<T> where T : class
{
}

var handler = new Handler<int>(); // ‚ùå CS0452: int ‚Äî value type
```

**–†—ñ—à–µ–Ω–Ω—è:**

```csharp showLineNumbers
// –í–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ reference type
var handler1 = new Handler<string>(); // ‚úÖ OK

// –ê–±–æ –≤–∏–¥–∞–ª–∏—Ç–∏ constraint
public class Handler<T> // –ë–µ–∑ constraint
{
}
var handler2 = new Handler<int>(); // ‚úÖ OK
```

### –ü—Ä–æ–±–ª–µ–º–∞ 4: CS0695 ‚Äî Cannot Implement Both Interfaces

**–ü–æ–º–∏–ª–∫–∞:**

```csharp
public interface IProcessor<T> { }

// CS0695: Cannot implement both...
public class MyClass<T1, T2> : IProcessor<T1>, IProcessor<T2>
{
    // –Ø–∫—â–æ T1 == T2, –∫–æ–Ω—Ñ–ª—ñ–∫—Ç!
}
```

**–†—ñ—à–µ–Ω–Ω—è:**

```csharp showLineNumbers
// ‚úÖ –û–∫—Ä–µ–º—ñ —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∏ –¥–ª—è —Ä—ñ–∑–Ω–∏—Ö —Ç–∏–ø—ñ–≤
public interface IProcessor1<T> { }
public interface IProcessor2<T> { }

public class MyClass<T1, T2> : IProcessor1<T1>, IProcessor2<T2>
{
    // ‚úÖ –ù–µ–º–∞—î –∫–æ–Ω—Ñ–ª—ñ–∫—Ç—É
}
```

### –ü—Ä–æ–±–ª–µ–º–∞ 5: Variance Compilation Errors

**–ü–æ–º–∏–ª–∫–∞:**

```csharp
public interface IBad<out T>
{
    void Process(T item); // ‚ùå T —É input position –∑ 'out'
}
```

**–†—ñ—à–µ–Ω–Ω—è:**

```csharp showLineNumbers
// ‚úÖ –í–∏–¥–∞–ª–∏—Ç–∏ 'out' –¥–ª—è invariant
public interface IProcessor<T>
{
    void Process(T item);
}

// ‚úÖ –ê–±–æ –∑—Ä–æ–±–∏—Ç–∏ —Ç—ñ–ª—å–∫–∏ output operations
public interface IReadOnly<out T>
{
    T Get();
    IEnumerable<T> GetAll();
}
```

## –ü—Ä–∞–∫—Ç–∏—á–Ω—ñ –ó–∞–≤–¥–∞–Ω–Ω—è

### –ó–∞–≤–¥–∞–Ω–Ω—è 1: Generic Repository (–õ–µ–≥–∫–∏–π)

**–ú–µ—Ç–∞**: –°—Ç–≤–æ—Ä–∏—Ç–∏ generic repository –∑ CRUD –æ–ø–µ—Ä–∞—Ü—ñ—è–º–∏.

**–û–ø–∏—Å**: –†–µ–∞–ª—ñ–∑—É–π—Ç–µ `Repository<T>` –∫–ª–∞—Å –∑ –±–∞–∑–æ–≤–∏–º–∏ –æ–ø–µ—Ä–∞—Ü—ñ—è–º–∏ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è, —á–∏—Ç–∞–Ω–Ω—è, –æ–Ω–æ–≤–ª–µ–Ω–Ω—è —Ç–∞ –≤–∏–¥–∞–ª–µ–Ω–Ω—è.

**–í–∏–º–æ–≥–∏**:

1. –ö–ª–∞—Å –º–∞—î constraint `where T : IEntity` (–¥–µ `IEntity` –º–∞—î –≤–ª–∞—Å—Ç–∏–≤—ñ—Å—Ç—å `Id`)
2. –ú–µ—Ç–æ–¥–∏: `Add`, `GetById`, `GetAll`, `Update`, `Delete`
3. –í–Ω—É—Ç—Ä—ñ—à–Ω—î –∑–±–µ—Ä—ñ–≥–∞–Ω–Ω—è —á–µ—Ä–µ–∑ `List<T>`

**–ü–æ—á–∞—Ç–∫–æ–≤–∏–π –ö–æ–¥:**

```csharp showLineNumbers
public interface IEntity
{
    int Id { get; set; }
}

// TODO: –†–µ–∞–ª—ñ–∑—É–π—Ç–µ Repository<T>
```

::collapsible{title="–†—ñ—à–µ–Ω–Ω—è –ó–∞–≤–¥–∞–Ω–Ω—è 1"}

```csharp showLineNumbers
public interface IEntity
{
    int Id { get; set; }
}

public class Repository<T> where T : IEntity
{
    private readonly List<T> _items = new List<T>();
    private int _nextId = 1;

    public void Add(T item)
    {
        item.Id = _nextId++;
        _items.Add(item);
    }

    public T GetById(int id)
    {
        return _items.FirstOrDefault(x => x.Id == id);
    }

    public IEnumerable<T> GetAll()
    {
        return _items.ToList();
    }

    public void Update(T item)
    {
        var existing = GetById(item.Id);
        if (existing != null)
        {
            int index = _items.IndexOf(existing);
            _items[index] = item;
        }
    }

    public void Delete(int id)
    {
        var item = GetById(id);
        if (item != null)
        {
            _items.Remove(item);
        }
    }
}

// –ü—Ä–∏–∫–ª–∞–¥ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
public class Customer : IEntity
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Email { get; set; }
}

var repo = new Repository<Customer>();

repo.Add(new Customer { Name = "Alice", Email = "alice@example.com" });
repo.Add(new Customer { Name = "Bob", Email = "bob@example.com" });

var customers = repo.GetAll();
foreach (var customer in customers)
{
    Console.WriteLine($"{customer.Id}: {customer.Name}");
}
```

**–ü–æ—è—Å–Ω–µ–Ω–Ω—è:**

-   –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–æ constraint `where T : IEntity` –¥–ª—è –¥–æ—Å—Ç—É–ø—É –¥–æ `Id`
-   Auto-increment –¥–ª—è `Id` –ø—Ä–∏ –¥–æ–¥–∞–≤–∞–Ω–Ω—ñ
-   CRUD –æ–ø–µ—Ä–∞—Ü—ñ—ó —Ä–µ–∞–ª—ñ–∑–æ–≤–∞–Ω—ñ —á–µ—Ä–µ–∑ `List<T>`

::

### –ó–∞–≤–¥–∞–Ω–Ω—è 2: Generic Factory (–°–µ—Ä–µ–¥–Ω—ñ–π)

**–ú–µ—Ç–∞**: –°—Ç–≤–æ—Ä–∏—Ç–∏ generic factory pattern –∑ constraints —Ç–∞ dependency injection.

**–û–ø–∏—Å**: –†–µ–∞–ª—ñ–∑—É–π—Ç–µ `Factory<T>` —è–∫–∏–π –º–æ–∂–µ —Å—Ç–≤–æ—Ä—é–≤–∞—Ç–∏ –µ–∫–∑–µ–º–ø–ª—è—Ä–∏ —Ä—ñ–∑–Ω–∏—Ö —Ç–∏–ø—ñ–≤ –∑ –º–æ–∂–ª–∏–≤—ñ—Å—Ç—é —ñ–Ω'—î–∫—Ü—ñ—ó –∑–∞–ª–µ–∂–Ω–æ—Å—Ç–µ–π.

**–í–∏–º–æ–≥–∏**:

1. –ü—ñ–¥—Ç—Ä–∏–º–∫–∞ –¥–≤–æ—Ö —Ä–µ–∂–∏–º—ñ–≤: –∑ parameterless constructor —Ç–∞ –∑ dependency injection
2. –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è constraints –¥–ª—è –∑–∞–±–µ–∑–ø–µ—á–µ–Ω–Ω—è –º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –æ–±'—î–∫—Ç—ñ–≤
3. –ö–µ—à—É–≤–∞–Ω–Ω—è —Å—Ç–≤–æ—Ä–µ–Ω–∏—Ö –µ–∫–∑–µ–º–ø–ª—è—Ä—ñ–≤ (singleton —Ä–µ–∂–∏–º)

::collapsible{title="–†—ñ—à–µ–Ω–Ω—è –ó–∞–≤–¥–∞–Ω–Ω—è 2"}

```csharp showLineNumbers
public class Factory<T> where T : new()
{
    private T _cachedInstance;
    private bool _isSingleton;

    public Factory(bool singleton = false)
    {
        _isSingleton = singleton;
    }

    public T Create()
    {
        if (_isSingleton)
        {
            if (_cachedInstance == null)
            {
                _cachedInstance = new T();
            }
            return _cachedInstance;
        }

        return new T();
    }
}

// Factory –∑ dependency injection
public class FactoryWithDI<T>
{
    private readonly Func<T> _creator;
    private T _cachedInstance;
    private bool _isSingleton;

    public FactoryWithDI(Func<T> creator, bool singleton = false)
    {
        _creator = creator;
        _isSingleton = singleton;
    }

    public T Create()
    {
        if (_isSingleton)
        {
            if (_cachedInstance == null)
            {
                _cachedInstance = _creator();
            }
            return _cachedInstance;
        }

        return _creator();
    }
}

// –ü—Ä–∏–∫–ª–∞–¥–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è

// 1. Simple factory –∑ parameterless constructor
public class Logger
{
    public Logger() { }
    public void Log(string message) => Console.WriteLine(message);
}

var loggerFactory = new Factory<Logger>(singleton: true);
var logger1 = loggerFactory.Create();
var logger2 = loggerFactory.Create();
Console.WriteLine(ReferenceEquals(logger1, logger2)); // true

// 2. Factory –∑ DI
public class DatabaseConnection
{
    private readonly string _connectionString;

    public DatabaseConnection(string connectionString)
    {
        _connectionString = connectionString;
    }
}

var dbFactory = new FactoryWithDI<DatabaseConnection>(
    () => new DatabaseConnection("Server=localhost;Database=MyDb"),
    singleton: true
);

var db1 = dbFactory.Create();
var db2 = dbFactory.Create();
Console.WriteLine(ReferenceEquals(db1, db2)); // true
```

**–ü–æ—è—Å–Ω–µ–Ω–Ω—è:**

-   `Factory<T>` –≤–∏–º–∞–≥–∞—î `new()` constraint
-   `FactoryWithDI<T>` –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î `Func<T>` –¥–ª—è –≥–Ω—É—á–∫–æ—Å—Ç—ñ
-   Singleton —Ä–µ–∂–∏–º –∫–µ—à—É—î —î–¥–∏–Ω–∏–π –µ–∫–∑–µ–º–ø–ª—è—Ä

::

### –ó–∞–≤–¥–∞–Ω–Ω—è 3: Variance-Aware Collection Wrapper (–°–∫–ª–∞–¥–Ω–∏–π)

**–ú–µ—Ç–∞**: –°—Ç–≤–æ—Ä–∏—Ç–∏ generic collection wrapper –∑ –ø—ñ–¥—Ç—Ä–∏–º–∫–æ—é covariance —Ç–∞ contravariance –æ–ø–µ—Ä–∞—Ü—ñ–π.

**–û–ø–∏—Å**: –†–µ–∞–ª—ñ–∑—É–π—Ç–µ wrapper –Ω–∞–¥ –∫–æ–ª–µ–∫—Ü—ñ—î—é, —è–∫–∏–π –¥–µ–º–æ–Ω—Å—Ç—Ä—É—î –ø—Ä–∞–∫—Ç–∏—á–Ω–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è variance.

**–í–∏–º–æ–≥–∏**:

1. Covariant interface –¥–ª—è read-only –æ–ø–µ—Ä–∞—Ü—ñ–π
2. Contravariant interface –¥–ª—è write-only –æ–ø–µ—Ä–∞—Ü—ñ–π
3. Invariant implementation –¥–ª—è –ø–æ–≤–Ω–æ–≥–æ —Ñ—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª—É
4. –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü—ñ—è type hierarchy –∑ Animal/Dog/Cat

::collapsible{title="–†—ñ—à–µ–Ω–Ω—è –ó–∞–≤–¥–∞–Ω–Ω—è 3"}

```csharp showLineNumbers
// Hierarchy
public class Animal
{
    public string Name { get; set; }
    public virtual void MakeSound() => Console.WriteLine("Some sound");
}

public class Dog : Animal
{
    public override void MakeSound() => Console.WriteLine("Woof!");
}

public class Cat : Animal
{
    public override void MakeSound() => Console.WriteLine("Meow!");
}

// Covariant interface ‚Äî —Ç—ñ–ª—å–∫–∏ —á–∏—Ç–∞–Ω–Ω—è
public interface IReadOnlyAnimalCollection<out T> where T : Animal
{
    T Get(int index);
    IEnumerable<T> GetAll();
    int Count { get; }
}

// Contravariant interface ‚Äî —Ç—ñ–ª—å–∫–∏ –∑–∞–ø–∏—Å
public interface IWriteOnlyAnimalCollection<in T> where T : Animal
{
    void Add(T animal);
    void AddRange(IEnumerable<T> animals);
}

// Invariant implementation ‚Äî –ø–æ–≤–Ω–∏–π —Ñ—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª
public class AnimalCollection<T> :
    IReadOnlyAnimalCollection<T>,
    IWriteOnlyAnimalCollection<T>
    where T : Animal
{
    private readonly List<T> _animals = new List<T>();

    // Read operations (covariant)
    public T Get(int index) => _animals[index];
    public IEnumerable<T> GetAll() => _animals.ToList();
    public int Count => _animals.Count;

    // Write operations (contravariant)
    public void Add(T animal) => _animals.Add(animal);
    public void AddRange(IEnumerable<T> animals) => _animals.AddRange(animals);

    // Additional operations
    public void Remove(T animal) => _animals.Remove(animal);
    public void Clear() => _animals.Clear();
}

// –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü—ñ—è –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
class Program
{
    static void Main()
    {
        // –°—Ç–≤–æ—Ä—é—î–º–æ –∫–æ–ª–µ–∫—Ü—ñ—é —Å–æ–±–∞–∫
        var dogCollection = new AnimalCollection<Dog>();
        dogCollection.Add(new Dog { Name = "Rex" });
        dogCollection.Add(new Dog { Name = "Buddy" });

        // ‚úÖ Covariance: Dog ‚Üí Animal –¥–ª—è read-only
        IReadOnlyAnimalCollection<Animal> readOnlyAnimals = dogCollection;

        Console.WriteLine($"Total animals: {readOnlyAnimals.Count}");
        foreach (Animal animal in readOnlyAnimals.GetAll())
        {
            Console.Write($"{animal.Name}: ");
            animal.MakeSound();
        }

        // ‚úÖ Contravariance: Animal ‚Üí Dog –¥–ª—è write-only
        IWriteOnlyAnimalCollection<Animal> writeOnlyAnimals =
            new AnimalCollection<Animal>();

        IWriteOnlyAnimalCollection<Dog> writeOnlyDogs = writeOnlyAnimals;
        writeOnlyDogs.Add(new Dog { Name = "Max" });

        // –ü—Ä–∞–∫—Ç–∏—á–Ω–∏–π –ø—Ä–∏–∫–ª–∞–¥: –º–µ—Ç–æ–¥, —è–∫–∏–π –ø—Ä–∏–π–º–∞—î read-only animal collection
        PrintAllAnimals(dogCollection); // ‚úÖ –ü—Ä–∞—Ü—é—î —á–µ—Ä–µ–∑ covariance

        // –ü—Ä–∞–∫—Ç–∏—á–Ω–∏–π –ø—Ä–∏–∫–ª–∞–¥: –º–µ—Ç–æ–¥, —è–∫–∏–π –ø—Ä–∏–π–º–∞—î write-only dog collection
        var animalWriter = new AnimalCollection<Animal>();
        AddDogs(animalWriter); // ‚úÖ –ü—Ä–∞—Ü—é—î —á–µ—Ä–µ–∑ contravariance
    }

    // –ú–µ—Ç–æ–¥ –ø—Ä–∏–π–º–∞—î read-only –∫–æ–ª–µ–∫—Ü—ñ—é —Ç–≤–∞—Ä–∏–Ω
    static void PrintAllAnimals(IReadOnlyAnimalCollection<Animal> animals)
    {
        Console.WriteLine("\n=== All Animals ===");
        foreach (var animal in animals.GetAll())
        {
            Console.WriteLine($"- {animal.Name}");
        }
    }

    // –ú–µ—Ç–æ–¥, —è–∫–∏–π –¥–æ–¥–∞—î —Å–æ–±–∞–∫ —É write-only –∫–æ–ª–µ–∫—Ü—ñ—é
    static void AddDogs(IWriteOnlyAnimalCollection<Dog> collection)
    {
        collection.Add(new Dog { Name = "Charlie" });
        collection.Add(new Dog { Name = "Luna" });
    }
}
```

**–ü–æ—è—Å–Ω–µ–Ω–Ω—è:**

**Covariance (`out T`):**

-   `IReadOnlyAnimalCollection<Dog>` –º–æ–∂–µ –±—É—Ç–∏ –ø—Ä–∏—Å–≤–æ—î–Ω–∞ `IReadOnlyAnimalCollection<Animal>`
-   –ë–µ–∑–ø–µ—á–Ω–æ, –±–æ –º–∏ —Ç—ñ–ª—å–∫–∏ **—á–∏—Ç–∞—î–º–æ** (–ø–æ–≤–µ—Ä—Ç–∞—î–º–æ Dog —è–∫ Animal)

**Contravariance (`in T`):**

-   `IWriteOnlyAnimalCollection<Animal>` –º–æ–∂–µ –±—É—Ç–∏ –ø—Ä–∏—Å–≤–æ—î–Ω–∞ `IWriteOnlyAnimalCollection<Dog>`
-   –ë–µ–∑–ø–µ—á–Ω–æ, –±–æ –º–∏ —Ç—ñ–ª—å–∫–∏ **–ø–∏—à–µ–º–æ** (–ø–µ—Ä–µ–¥–∞—î–º–æ Dog —É –º–µ—Ç–æ–¥, —â–æ –ø—Ä–∏–π–º–∞—î Animal)

**–ü—Ä–∞–∫—Ç–∏—á–Ω–µ –ó–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è:**

-   Read-only —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–æ–∑–≤–æ–ª—è—î –ø–µ—Ä–µ–¥–∞–≤–∞—Ç–∏ –±—ñ–ª—å—à –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ñ –∫–æ–ª–µ–∫—Ü—ñ—ó —É –º–µ—Ç–æ–¥–∏, —â–æ –æ—á—ñ–∫—É—é—Ç—å –∑–∞–≥–∞–ª—å–Ω—ñ—à—ñ —Ç–∏–ø–∏
-   Write-only —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–æ–∑–≤–æ–ª—è—î –ø–µ—Ä–µ–¥–∞–≤–∞—Ç–∏ –±—ñ–ª—å—à –∑–∞–≥–∞–ª—å–Ω—ñ –∫–æ–ª–µ–∫—Ü—ñ—ó —É –º–µ—Ç–æ–¥–∏, —â–æ –ø—Ä–∞—Ü—é—é—Ç—å –∑ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏–º–∏ —Ç–∏–ø–∞–º–∏

::

## –†–µ–∑—é–º–µ

**Generics** ‚Äî —Ü–µ –ø–æ—Ç—É–∂–Ω–∏–π –º–µ—Ö–∞–Ω—ñ–∑–º C#, —è–∫–∏–π –¥–æ–∑–≤–æ–ª—è—î –ø–∏—Å–∞—Ç–∏ type-safe —Ç–∞ –µ—Ñ–µ–∫—Ç–∏–≤–Ω–∏–π –∫–æ–¥:

-   üéØ **Type Safety**: –ü–æ–º–∏–ª–∫–∏ –≤–∏—è–≤–ª—è—é—Ç—å—Å—è –Ω–∞ –µ—Ç–∞–ø—ñ –∫–æ–º–ø—ñ–ª—è—Ü—ñ—ó
-   ‚ôªÔ∏è **Code Reuse**: –û–¥–∏–Ω –∫–ª–∞—Å/–º–µ—Ç–æ–¥ –¥–ª—è –±–∞–≥–∞—Ç—å–æ—Ö —Ç–∏–ø—ñ–≤
-   ‚ö° **Performance**: –ë–µ–∑ boxing/unboxing –¥–ª—è value types
-   üìö **Standard Library**: `List<T>`, `Dictionary<K,V>`, LINQ –±–∞–∑—É—é—Ç—å—Å—è –Ω–∞ generics

**–ö–ª—é—á–æ–≤—ñ –ö–æ–Ω—Ü–µ–ø—Ü—ñ—ó:**

1. **Generic Classes & Methods** ‚Äî –ø–∞—Ä–∞–º–µ—Ç—Ä–∏–∑–æ–≤–∞–Ω—ñ —Ç–∏–ø–∏ —Ç–∞ –º–µ—Ç–æ–¥–∏
2. **Constraints** ‚Äî –æ–±–º–µ–∂–µ–Ω–Ω—è –Ω–∞ type parameters (`class`, `struct`, `new()`, `where T : Base`)
3. **C# 13 Feature** ‚Äî `allows ref struct` –¥–ª—è –ø—ñ–¥—Ç—Ä–∏–º–∫–∏ ref struct —Ç–∏–ø—ñ–≤
4. **Covariance (`out`)** ‚Äî –≤–∏–≤–µ–¥–µ–Ω–Ω—è –±—ñ–ª—å—à –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏—Ö —Ç–∏–ø—ñ–≤
5. **Contravariance (`in`)** ‚Äî –≤–≤–µ–¥–µ–Ω–Ω—è –±—ñ–ª—å—à –∑–∞–≥–∞–ª—å–Ω–∏—Ö —Ç–∏–ø—ñ–≤
6. **Generic Interfaces** ‚Äî `IEnumerable<T>`, `IComparable<T>`, `IEquatable<T>`
7. **Generic Delegates** ‚Äî `Func<T>`, `Action<T>`, `Predicate<T>`

**Best Practices:**

-   –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –æ–ø–∏—Å–æ–≤—ñ —ñ–º–µ–Ω–∞ –¥–ª—è type parameters
-   –î–æ–¥–∞–≤–∞–π—Ç–µ constraints —Ç—ñ–ª—å–∫–∏ –∫–æ–ª–∏ –Ω–µ–æ–±—Ö—ñ–¥–Ω–æ
-   –í—Ä–∞—Ö–æ–≤—É–π—Ç–µ variance –ø—Ä–∏ –¥–∏–∑–∞–π–Ω—ñ —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ñ–≤
-   –ù–∞–¥–∞–≤–∞–π—Ç–µ –ø–µ—Ä–µ–≤–∞–≥—É generics –Ω–∞–¥ `object` –¥–ª—è type safety
-   –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ built-in generic delegates –∑–∞–º—ñ—Å—Ç—å custom
