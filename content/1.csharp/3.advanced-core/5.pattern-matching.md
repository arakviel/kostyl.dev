---
title: Pattern Matching
description: –í–∏–≤—á—ñ—Ç—å Pattern Matching —É C# - –ø–æ—Ç—É–∂–Ω–∏–π –º–µ—Ö–∞–Ω—ñ–∑–º –¥–ª—è –≤–∏—Ä–∞–∑–Ω–æ—ó —Ç–∞ –±–µ–∑–ø–µ—á–Ω–æ—ó —Ä–æ–±–æ—Ç–∏ –∑ –¥–∞–Ω–∏–º–∏ —á–µ—Ä–µ–∑ –ø–µ—Ä–µ–≤—ñ—Ä–∫—É —Å—Ç—Ä—É–∫—Ç—É—Ä —Ç–∞ –≤–∏–ª—É—á–µ–Ω–Ω—è –∑–Ω–∞—á–µ–Ω—å.
---

# Pattern Matching

## –í—Å—Ç—É–ø —Ç–∞ –ö–æ–Ω—Ç–µ–∫—Å—Ç

–£—è–≤—ñ—Ç—å, —â–æ –≤–∏ –±—É–¥—É—î—Ç–µ —Å–∏—Å—Ç–µ–º—É –æ–±—Ä–æ–±–∫–∏ –ø–ª–∞—Ç–µ–∂—ñ–≤. –ö–æ–∂–µ–Ω –ø–ª–∞—Ç—ñ–∂ –º–æ–∂–µ –±—É—Ç–∏ —Ä—ñ–∑–Ω–æ–≥–æ —Ç–∏–ø—É: –∫—Ä–µ–¥–∏—Ç–Ω–∞ –∫–∞—Ä—Ç–∫–∞, PayPal, –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–∞. –ö–æ–∂–µ–Ω —Ç–∏–ø –º–∞—î —Ä—ñ–∑–Ω—ñ –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—ñ, —ñ –≤–∞–º –ø–æ—Ç—Ä—ñ–±–Ω–æ –ø—Ä–∏–π–º–∞—Ç–∏ —Ä—ñ—à–µ–Ω–Ω—è –Ω–∞ –æ—Å–Ω–æ–≤—ñ —Ü–∏—Ö –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç–µ–π.

**–ö–ª–∞—Å–∏—á–Ω–∏–π –ø—ñ–¥—Ö—ñ–¥** –ø—Ä–∏–∑–≤–æ–¥–∏—Ç—å –¥–æ "—Å–ø–∞–≥–µ—Ç—Ç—ñ-–∫–æ–¥—É":

```csharp [PaymentProcessor.cs] {1,3,7,11} showLineNumbers
if (payment is CreditCardPayment)
{
    var ccPayment = (CreditCardPayment)payment;
    if (ccPayment.Amount > 1000 && ccPayment.Country == "UA")
    {
        // –°–ø–µ—Ü—ñ–∞–ª—å–Ω–∞ –ª–æ–≥—ñ–∫–∞ –¥–ª—è –≤–µ–ª–∏–∫–∏—Ö –ø–ª–∞—Ç–µ–∂—ñ–≤ –≤ –£–∫—Ä–∞—ó–Ω—ñ
        ApplyFraudCheck(ccPayment);
    }
}
else if (payment is PayPalPayment)
{
    var ppPayment = (PayPalPayment)payment;
    if (ppPayment.IsVerified && ppPayment.Amount < 5000)
    {
        // –Ü–Ω—à–∞ –ª–æ–≥—ñ–∫–∞
        ProcessQuickly(ppPayment);
    }
}
// ... —â–µ 10 —Ç–∏–ø—ñ–≤ –ø–ª–∞—Ç–µ–∂—ñ–≤
```

**Pattern Matching** –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—î —Ü–µ–π –∫–æ–¥ –Ω–∞ –≤–∏—Ä–∞–∑–Ω—É, —Ç–∏–ø–æ–±–µ–∑–ø–µ—á–Ω—É –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü—ñ—é:

```csharp [PaymentProcessor.cs] {1-2,4} showLineNumbers
var action = payment switch
{
    CreditCardPayment { Amount: > 1000, Country: "UA" } => ApplyFraudCheck,
    PayPalPayment { IsVerified: true, Amount: < 5000 } => ProcessQuickly,
    CryptoPayment { Currency: "BTC", Amount: > 0.1m } => ProcessWithDelay,
    _ => ProcessStandard
};
action(payment);
```

::tip
**Filosof –§–ü (–§—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª—å–Ω–µ –ü—Ä–æ–≥—Ä–∞–º—É–≤–∞–Ω–Ω—è)**: Pattern Matching ‚Äî —Ü–µ –æ–¥–Ω–∞ –∑ –Ω–∞–π–ø–æ—Ç—É–∂–Ω—ñ—à–∏—Ö —Ñ—ñ—á, –∑–∞–ø–æ–∑–∏—á–µ–Ω–∏—Ö –∑ —Ñ—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª—å–Ω–∏—Ö –º–æ–≤ (F#, Haskell). –í–æ–Ω–∞ —Ä–æ–±–∏—Ç—å –∫–æ–¥ **–¥–µ–∫–ª–∞—Ä–∞—Ç–∏–≤–Ω–∏–º** –∑–∞–º—ñ—Å—Ç—å —ñ–º–ø–µ—Ä–∞—Ç–∏–≤–Ω–æ–≥–æ: –≤–∏ –æ–ø–∏—Å—É—î—Ç–µ "—â–æ" —à—É–∫–∞—î—Ç–µ, –∞ –Ω–µ "—è–∫" —Ü–µ –∑–Ω–∞–π—Ç–∏.
::

### –Ü—Å—Ç–æ—Ä–∏—á–Ω–∞ –ï–≤–æ–ª—é—Ü—ñ—è

Pattern Matching —É C# –µ–≤–æ–ª—é—Ü—ñ–æ–Ω—É–≤–∞–≤ –ø–æ—Å—Ç—É–ø–æ–≤–æ:

| –í–µ—Ä—Å—ñ—è C#  | –ù–æ–≤–æ–≤–≤–µ–¥–µ–Ω–Ω—è                                                          | –ü—Ä–∏–∫–ª–∞–¥                                |
| :--------- | :-------------------------------------------------------------------- | :------------------------------------- |
| **C# 7.0** | Type patterns, `is` expression –∑ –∑–º—ñ–Ω–Ω–æ—é                              | `if (obj is string s)`                 |
| **C# 8.0** | Switch expressions, property patterns, positional patterns            | `x switch { Point(0, 0) => "Origin" }` |
| **C# 9.0** | Relational patterns (`>`, `<`), logical patterns (`and`, `or`, `not`) | `x is >= 0 and < 100`                  |
| **C# 10**  | Extended property patterns                                            | `obj is { Prop.SubProp: value }`       |
| **C# 11**  | **List patterns** üî•                                                  | `array is [1, 2, ..]`                  |

::note
–£ —Ü—å–æ–º—É —Ä–æ–∑–¥—ñ–ª—ñ –º–∏ —Ä–æ–∑–≥–ª—è–Ω–µ–º–æ –≤—Å—ñ —Å—É—á–∞—Å–Ω—ñ –º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ Pattern Matching –¥–æ C# 11 –≤–∫–ª—é—á–Ω–æ. –ü–µ—Ä–µ–∫–æ–Ω–∞–π—Ç–µ—Å—è, —â–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç–µ .NET 7+ –¥–ª—è –ø—ñ–¥—Ç—Ä–∏–º–∫–∏ –≤—Å—ñ—Ö features.
::

### Prerequisites

–ü–µ—Ä–µ–¥ –≤–∏–≤—á–µ–Ω–Ω—è–º Pattern Matching –≤–∞–º –ø–æ—Ç—Ä—ñ–±–Ω–æ –∑–Ω–∞—Ç–∏:

-   **–¢–∏–ø–∏ –¥–∞–Ω–∏—Ö**: Reference types, Value types, Records ([–†–æ–∑–¥—ñ–ª 2.5](/csharp/oop/advanced-types))
-   **–Ü–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∏**: –ë–∞–∑–æ–≤–µ —Ä–æ–∑—É–º—ñ–Ω–Ω—è ([–†–æ–∑–¥—ñ–ª 2.4](/csharp/oop/oop-pillars))
-   **Tuples**: –ö–æ—Ä—Ç–µ–∂—ñ —Ç–∞ deconstruction ([–†–æ–∑–¥—ñ–ª 2.5](/csharp/oop/advanced-types))
-   **Switch statement**: –ö–ª–∞—Å–∏—á–Ω–∏–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å ([–†–æ–∑–¥—ñ–ª 1.6](/csharp/fundamentals/control-flow))

---

## –§—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ñ –ö–æ–Ω—Ü–µ–ø—Ü—ñ—ó

### –©–æ —Ç–∞–∫–µ Pattern?

**Pattern (–ü–∞—Ç–µ—Ä–Ω)** ‚Äî —Ü–µ _—à–∞–±–ª–æ–Ω_, —è–∫–∏–π –æ–ø–∏—Å—É—î —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–∞–Ω–∏—Ö. –ö–æ–º–ø—ñ–ª—è—Ç–æ—Ä –ø–µ—Ä–µ–≤—ñ—Ä—è—î, —á–∏ **–≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î** (matches) –≤–∏—Ä–∞–∑ —Ü—å–æ–º—É —à–∞–±–ª–æ–Ω—É, —ñ —è–∫—â–æ —Ç–∞–∫ ‚Äî –º–æ–∂–µ **–≤–∏–ª—É—á–∏—Ç–∏** (extract) –∑–Ω–∞—á–µ–Ω–Ω—è –∑ –≤–∏—Ä–∞–∑—É.

> **–ê–Ω–∞–ª–æ–≥—ñ—è –∑ —Ä–µ–∞–ª—å–Ω–æ–≥–æ —Å–≤—ñ—Ç—É**: –£—è–≤—ñ—Ç—å, —â–æ –≤–∏ —Å–æ—Ä—Ç—É—î—Ç–µ –ª–∏—Å—Ç–∏ –Ω–∞ –ø–æ—à—Ç—ñ. –í–∏ –º–∞—î—Ç–µ –Ω–∞–±—ñ—Ä "—à–∞–±–ª–æ–Ω—ñ–≤":
>
> -   "–Ø–∫—â–æ –∫–æ–Ω–≤–µ—Ä—Ç –≤–µ–ª–∏–∫–∏–π —ñ –º–∞—î —á–µ—Ä–≤–æ–Ω—É –º–∞—Ä–∫—É ‚Üí –≤—ñ–¥–ø—Ä–∞–≤–∏—Ç–∏ —É –≤—ñ–¥–¥—ñ–ª–µ–Ω–Ω—è A"
> -   "–Ø–∫—â–æ –∫–æ–Ω–≤–µ—Ä—Ç –º–∞–ª–µ–Ω—å–∫–∏–π —ñ –∞–¥—Ä–µ—Å–∞ –ø–æ—á–∏–Ω–∞—î—Ç—å—Å—è –∑ '–ö–∏—ó–≤' ‚Üí –≤—ñ–¥–¥—ñ–ª–µ–Ω–Ω—è B"
>
> Pattern Matching –ø—Ä–∞—Ü—é—î —Ç–∞–∫ —Å–∞–º–æ: –≤–∏ –æ–ø–∏—Å—É—î—Ç–µ "—à–∞–±–ª–æ–Ω–∏" –¥–∞–Ω–∏—Ö, —ñ –∫–æ–º–ø—ñ–ª—è—Ç–æ—Ä –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≤–∏–∑–Ω–∞—á–∞—î, —è–∫–∏–π —à–∞–±–ª–æ–Ω –ø—ñ–¥—Ö–æ–¥–∏—Ç—å.

### –î–µ –º–æ–∂–Ω–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ Patterns?

Pattern Matching –º–æ–∂–Ω–∞ –∑–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ —É:

1. **`is` expression** ‚Äî –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∑ –º–æ–∂–ª–∏–≤—ñ—Å—Ç—é –≤–∏–ª—É—á–µ–Ω–Ω—è –∑–º—ñ–Ω–Ω–æ—ó
2. **`switch` expression** ‚Äî –≤–∏–±—ñ—Ä –∑–Ω–∞—á–µ–Ω–Ω—è –Ω–∞ –æ—Å–Ω–æ–≤—ñ patterns (C# 8+)
3. **`switch` statement** ‚Äî –∫–ª–∞—Å–∏—á–Ω–∏–π switch –∑ patterns —É `case`

::code-group

```csharp [is Expression] showLineNumbers
if (obj is string { Length: > 0 } s)
{
    Console.WriteLine($"–ù–µ–ø–æ—Ä–æ–∂–Ω—ñ–π —Ä—è–¥–æ–∫: {s}");
}
```

```csharp [switch Expression] showLineNumbers
var result = obj switch
{
    string { Length: > 0 } s => $"–†—è–¥–æ–∫: {s}",
    int i when i > 0 => $"–ü–æ–∑–∏—Ç–∏–≤–Ω–µ —á–∏—Å–ª–æ: {i}",
    _ => "–©–æ—Å—å —ñ–Ω—à–µ"
};
```

```csharp [switch Statement] showLineNumbers
switch (obj)
{
    case string { Length: > 0 } s:
        Console.WriteLine($"–†—è–¥–æ–∫: {s}");
        break;
    case int i when i > 0:
        Console.WriteLine($"–ß–∏—Å–ª–æ: {i}");
        break;
    default:
        Console.WriteLine("–Ü–Ω—à–µ");
        break;
}
```

::

::warning
**Switch Expression vs Switch Statement**: Switch expression ‚Äî —Ü–µ **–≤–∏—Ä–∞–∑**, –≤—ñ–Ω –ø–æ–≤–µ—Ä—Ç–∞—î –∑–Ω–∞—á–µ–Ω–Ω—è. Switch statement ‚Äî —Ü–µ **—ñ–Ω—Å—Ç—Ä—É–∫—Ü—ñ—è**, –≤–∏–∫–æ–Ω—É—î –¥—ñ—ó. –£ 99% –≤–∏–ø–∞–¥–∫—ñ–≤ switch expression —î –∫—Ä–∞—â–∏–º –≤–∏–±–æ—Ä–æ–º –¥–ª—è pattern matching –∑–∞–≤–¥—è–∫–∏ —Å—Ç–∏—Å–ª–æ—Å—Ç—ñ —Ç–∞ —Ç–∏–ø–æ–±–µ–∑–ø–µ—Ü—ñ.
::

### Exhaustiveness Checking

–û–¥–Ω–∞ –∑ –Ω–∞–π–ø–æ—Ç—É–∂–Ω—ñ—à–∏—Ö —Ñ—ñ—á ‚Äî **–ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –≤–∏—á–µ—Ä–ø–Ω–æ—Å—Ç—ñ** (exhaustiveness checking). –ö–æ–º–ø—ñ–ª—è—Ç–æ—Ä **–ø–æ–ø–µ—Ä–µ–¥–∂–∞—î**, —è–∫—â–æ –≤–∏ –Ω–µ –ø–æ–∫—Ä–∏–ª–∏ –≤—Å—ñ –º–æ–∂–ª–∏–≤—ñ –≤–∞—Ä—ñ–∞–Ω—Ç–∏:

```csharp [Warning.cs] showLineNumbers
enum Status { Pending, Approved, Rejected }

string GetMessage(Status status) => status switch
{
    Status.Pending => "–û—á—ñ–∫—É—î",
    Status.Approved => "–ó–∞—Ç–≤–µ—Ä–¥–∂–µ–Ω–æ"
    // ‚ö†Ô∏è warning CS8509: The switch expression does not handle all possible values
    // (it is not exhaustive). For example, the pattern 'Status.Rejected' is not covered.
};
```

**–í–∏–ø—Ä–∞–≤–ª–µ–Ω–Ω—è** ‚Äî –¥–æ–¥–∞—Ç–∏ discard pattern `_`:

```csharp [Fixed.cs] {5} showLineNumbers
string GetMessage(Status status) => status switch
{
    Status.Pending => "–û—á—ñ–∫—É—î",
    Status.Approved => "–ó–∞—Ç–≤–µ—Ä–¥–∂–µ–Ω–æ",
    _ => "–ù–µ–≤—ñ–¥–æ–º–∏–π —Å—Ç–∞—Ç—É—Å"
};
```

::mermaid

```mermaid
graph TD
    A[Expression] --> B{Pattern Match?}
    B -- Yes --> C[Extract Values]
    B -- No --> D[Next Pattern]
    D --> E{More Patterns?}
    E -- Yes --> B
    E -- No --> F[Default/_]
    C --> G[Execute Arm]
    F --> G

    style A fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style B fill:#f59e0b,stroke:#b45309,color:#ffffff
    style C fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style D fill:#64748b,stroke:#334155,color:#ffffff
    style E fill:#f59e0b,stroke:#b45309,color:#ffffff
    style F fill:#64748b,stroke:#334155,color:#ffffff
    style G fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
```

::

---

## Type Pattern (–ü–∞—Ç–µ—Ä–Ω –¢–∏–ø—É)

**Type Pattern** –ø–µ—Ä–µ–≤—ñ—Ä—è—î, —á–∏ —î –≤–∏—Ä–∞–∑ –ø–µ–≤–Ω–æ–≥–æ —Ç–∏–ø—É, —ñ **–≤–∏–ª—É—á–∞—î** –π–æ–≥–æ —É —Ç–∏–ø–æ–±–µ–∑–ø–µ—á–Ω—É –∑–º—ñ–Ω–Ω—É.

### –°–∏–Ω—Ç–∞–∫—Å–∏—Å

```csharp
// is expression
if (obj is TypeName variable)
{
    // –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ variable
}

// switch expression
var result = obj switch
{
    TypeName variable => /* –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ variable */,
    _ => /* default */
};
```

### –ë–∞–∑–æ–≤–µ –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –∑ `is`

```csharp [TypePattern.cs] showLineNumbers
object data = "Hello, Pattern Matching!";

if (data is string text)
{
    Console.WriteLine($"–¶–µ —Ä—è–¥–æ–∫ –¥–æ–≤–∂–∏–Ω–æ—é {text.Length}");
    // ‚úÖ –∑–º—ñ–Ω–Ω–∞ 'text' –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç—É—Ç
}
// ‚ùå –∑–º—ñ–Ω–Ω–∞ 'text' –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ —Ç—É—Ç
```

**–©–æ –≤—ñ–¥–±—É–≤–∞—î—Ç—å—Å—è –ø—ñ–¥ –∫–∞–ø–æ—Ç–æ–º?**  
–ö–æ–º–ø—ñ–ª—è—Ç–æ—Ä –≥–µ–Ω–µ—Ä—É—î:

1. –ü–µ—Ä–µ–≤—ñ—Ä–∫—É —Ç–∏–ø—É –∑ `is` operator
2. Safe cast –¥–æ `string`
3. –ü—Ä–∏—Å–≤–æ—î–Ω–Ω—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É –∑–º—ñ–Ω–Ω—ñ–π `text`

–¶–µ **–∑–∞–º—ñ–Ω—é—î** —Å—Ç–∞—Ä–∏–π –ø—ñ–¥—Ö—ñ–¥:

```csharp [OldWay.cs] showLineNumbers
if (data is string)
{
    string text = (string)data; // unsafe cast
    Console.WriteLine($"–î–æ–≤–∂–∏–Ω–∞: {text.Length}");
}
```

### Type Patterns —É Switch Expression

```csharp [ShapeCalculator.cs] showLineNumbers
public abstract record Shape;
public record Circle(double Radius) : Shape;
public record Rectangle(double Width, double Height) : Shape;
public record Triangle(double Base, double Height) : Shape;

public static double CalculateArea(Shape shape) => shape switch
{
    Circle c => Math.PI * c.Radius * c.Radius,
    Rectangle r => r.Width * r.Height,
    Triangle t => 0.5 * t.Base * t.Height,
    _ => throw new ArgumentException("–ù–µ–≤—ñ–¥–æ–º–∞ —Ñ—ñ–≥—É—Ä–∞")
};

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
var circle = new Circle(5);
Console.WriteLine($"–ü–ª–æ—â–∞ –∫–æ–ª–∞: {CalculateArea(circle):F2}");
// –í–∏–≤–µ–¥–µ: –ü–ª–æ—â–∞ –∫–æ–ª–∞: 78.54
```

::tip
**Best Practice**: Type patterns —á—É–¥–æ–≤–æ –ø–æ—î–¥–Ω—É—é—Ç—å—Å—è –∑ **record types**, –æ—Å–∫—ñ–ª—å–∫–∏ records –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≥–µ–Ω–µ—Ä—É—é—Ç—å deconstruction, —è–∫–∏–π –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è —É Positional Patterns (div. –¥–∞–ª—ñ).
::

### –í—ñ–¥–º—ñ–Ω–Ω—ñ—Å—Ç—å –≤—ñ–¥ `as` Casting

::code-group

```csharp [Type Pattern ‚úÖ] showLineNumbers
if (obj is string s)
    Console.WriteLine(s.Length);
else
    Console.WriteLine("–ù–µ —Ä—è–¥–æ–∫");
```

```csharp [as Casting ‚ùå] showLineNumbers
var s = obj as string;
if (s != null)
    Console.WriteLine(s.Length);
else
    Console.WriteLine("–ù–µ —Ä—è–¥–æ–∫");
```

::

**–ß–æ–º—É Type Pattern –∫—Ä–∞—â–∏–π?**

-   ‚úÖ –ö–æ—Ä–æ—Ç—à–∏–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å
-   ‚úÖ –ó–º—ñ–Ω–Ω–∞ `s` –¥–æ—Å—Ç—É–ø–Ω–∞ –ª–∏—à–µ —É `if` –±–ª–æ—Ü—ñ (scope safety)
-   ‚úÖ –ü—Ä–∞—Ü—é—î –∑ value types (`obj is int i`)
-   ‚úÖ –ú–æ–∂–Ω–∞ –∫–æ–º–±—ñ–Ω—É–≤–∞—Ç–∏ –∑ —ñ–Ω—à–∏–º–∏ patterns

---

## Property Pattern (–ü–∞—Ç–µ—Ä–Ω –í–ª–∞—Å—Ç–∏–≤–æ—Å—Ç–µ–π)

**Property Pattern** –¥–æ–∑–≤–æ–ª—è—î –ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ **–≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—ñ** –æ–±'—î–∫—Ç–∞ –±–µ–∑ —è–≤–Ω–æ–≥–æ –ø—Ä–∏–≤–µ–¥–µ–Ω–Ω—è —Ç–∏–ø—É.

### –°–∏–Ω—Ç–∞–∫—Å–∏—Å

```csharp
expression is Type { Property1: pattern1, Property2: pattern2 } variable
```

### –ë–∞–∑–æ–≤–∏–π –ü—Ä–∏–∫–ª–∞–¥

```csharp [User.cs] showLineNumbers
public record User(string Name, int Age, string Country);

User user = new("–û–ª–µ–∫—Å–∞–Ω–¥—Ä", 25, "–£–∫—Ä–∞—ó–Ω–∞");

if (user is { Age: >= 18, Country: "–£–∫—Ä–∞—ó–Ω–∞" })
{
    Console.WriteLine("–ü–æ–≤–Ω–æ–ª—ñ—Ç–Ω—ñ–π –≥—Ä–æ–º–∞–¥—è–Ω–∏–Ω –£–∫—Ä–∞—ó–Ω–∏");
}
```

### Nested Property Patterns

–ú–æ–∂–Ω–∞ –ø–µ—Ä–µ–≤—ñ—Ä—è—Ç–∏ **–≤–∫–ª–∞–¥–µ–Ω—ñ –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—ñ**:

```csharp [Order.cs] showLineNumbers
public record Address(string City, string Country);
public record Customer(string Name, Address Address);
public record Order(Customer Customer, decimal Total);

Order order = new(
    new Customer("–ú–∞—Ä—ñ—è", new Address("–ö–∏—ó–≤", "–£–∫—Ä–∞—ó–Ω–∞")),
    1500m
);

var message = order switch
{
    { Customer.Address.Country: "–£–∫—Ä–∞—ó–Ω–∞", Total: > 1000 }
        => "–ë–µ–∑–∫–æ—à—Ç–æ–≤–Ω–∞ –¥–æ—Å—Ç–∞–≤–∫–∞ –ø–æ –£–∫—Ä–∞—ó–Ω—ñ!",
    { Customer.Address.Country: "–£–∫—Ä–∞—ó–Ω–∞" }
        => "–î–æ—Å—Ç–∞–≤–∫–∞: 50 –≥—Ä–Ω",
    _ => "–ú—ñ–∂–Ω–∞—Ä–æ–¥–Ω–∞ –¥–æ—Å—Ç–∞–≤–∫–∞: 200 –≥—Ä–Ω"
};

Console.WriteLine(message);
// –í–∏–≤–µ–¥–µ: –ë–µ–∑–∫–æ—à—Ç–æ–≤–Ω–∞ –¥–æ—Å—Ç–∞–≤–∫–∞ –ø–æ –£–∫—Ä–∞—ó–Ω—ñ!
```

::note
**C# 10+**: –†–æ–∑—à–∏—Ä–µ–Ω–∏–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –¥–æ–∑–≤–æ–ª—è—î –ø–∏—Å–∞—Ç–∏ `Customer.Address.Country` –∑–∞–º—ñ—Å—Ç—å `Customer: { Address: { Country: ... } }`. –¶–µ –∑–Ω–∞—á–Ω–æ –ø–æ–∫—Ä–∞—â—É—î —á–∏—Ç–∞–±–µ–ª—å–Ω—ñ—Å—Ç—å!
::

### –ö–æ–º–±—ñ–Ω—É–≤–∞–Ω–Ω—è Type + Property Patterns

```csharp [Payment.cs] showLineNumbers
public abstract record Payment(decimal Amount);
public record CardPayment(decimal Amount, string CardNumber) : Payment(Amount);
public record CashPayment(decimal Amount, string Currency) : Payment(Amount);

public static string ProcessPayment(Payment payment) => payment switch
{
    CardPayment { Amount: > 1000, CardNumber: var card }
        => $"–ö–∞—Ä—Ç–∫–∞ {card}: –ø–æ—Ç—Ä—ñ–±–Ω–∞ –¥–æ–¥–∞—Ç–∫–æ–≤–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞",

    CardPayment { Amount: <= 1000 }
        => "–û–±—Ä–æ–±–ª–µ–Ω–æ –∫–∞—Ä—Ç–∫–æ—é",

    CashPayment { Currency: "UAH", Amount: < 10000 }
        => "–ì–æ—Ç—ñ–≤–∫–∞ –ø—Ä–∏–π–Ω—è—Ç–∞",

    CashPayment { Currency: not "UAH" }
        => "–í–∞–ª—é—Ç—É –ø–æ—Ç—Ä—ñ–±–Ω–æ –æ–±–º—ñ–Ω—è—Ç–∏",

    _ => "–ù–µ–≤—ñ–¥–æ–º–∏–π —Ç–∏–ø –ø–ª–∞—Ç–µ–∂—É"
};
```

### Real-World –ü—Ä–∏–∫–ª–∞–¥: –í–∞–ª—ñ–¥–∞—Ü—ñ—è

```csharp [Validator.cs] showLineNumbers
public record Product(string Name, decimal Price, int Stock);

public static string ValidateProduct(Product product) => product switch
{
    { Name.Length: 0 }
        => "–ù–∞–∑–≤–∞ –Ω–µ –º–æ–∂–µ –±—É—Ç–∏ –ø–æ—Ä–æ–∂–Ω—å–æ—é",

    { Price: <= 0 }
        => "–¶—ñ–Ω–∞ –º–∞—î –±—É—Ç–∏ –±—ñ–ª—å—à–µ 0",

    { Stock: < 0 }
        => "–ö—ñ–ª—å–∫—ñ—Å—Ç—å –Ω–µ –º–æ–∂–µ –±—É—Ç–∏ –≤—ñ–¥'—î–º–Ω–æ—é",

    { Name.Length: > 100 }
        => "–ù–∞–∑–≤–∞ –∑–∞–Ω–∞–¥—Ç–æ –¥–æ–≤–≥–∞ (–º–∞–∫—Å. 100 —Å–∏–º–≤–æ–ª—ñ–≤)",

    _ => "OK"
};

var product = new Product("", 100m, 10);
Console.WriteLine(ValidateProduct(product));
// –í–∏–≤–µ–¥–µ: –ù–∞–∑–≤–∞ –Ω–µ –º–æ–∂–µ –±—É—Ç–∏ –ø–æ—Ä–æ–∂–Ω—å–æ—é
```

---

## Tuple Pattern (–ö–æ—Ä—Ç–µ–∂–Ω–∏–π –ü–∞—Ç–µ—Ä–Ω)

**Tuple Pattern** –¥–æ–∑–≤–æ–ª—è—î –ø–µ—Ä–µ–≤—ñ—Ä—è—Ç–∏ **–∫–æ—Ä—Ç–µ–∂—ñ** (tuples) —ñ –ø—Ä–∏–π–º–∞—Ç–∏ —Ä—ñ—à–µ–Ω–Ω—è –Ω–∞ –æ—Å–Ω–æ–≤—ñ –º–Ω–æ–∂–∏–Ω–∏ –∑–Ω–∞—á–µ–Ω—å –æ–¥–Ω–æ—á–∞—Å–Ω–æ.

### –ë–∞–∑–æ–≤–∏–π –°–∏–Ω—Ç–∞–∫—Å–∏—Å

```csharp [RockPaperScissors.cs] showLineNumbers
public enum Choice { Rock, Paper, Scissors }

public static string DetermineWinner(Choice player1, Choice player2)
    => (player1, player2) switch
{
    (Choice.Rock, Choice.Scissors) => "–ì—Ä–∞–≤–µ—Ü—å 1 –≤–∏–≥—Ä–∞–≤!",
    (Choice.Scissors, Choice.Paper) => "–ì—Ä–∞–≤–µ—Ü—å 1 –≤–∏–≥—Ä–∞–≤!",
    (Choice.Paper, Choice.Rock) => "–ì—Ä–∞–≤–µ—Ü—å 1 –≤–∏–≥—Ä–∞–≤!",

    (Choice.Scissors, Choice.Rock) => "–ì—Ä–∞–≤–µ—Ü—å 2 –≤–∏–≥—Ä–∞–≤!",
    (Choice.Paper, Choice.Scissors) => "–ì—Ä–∞–≤–µ—Ü—å 2 –≤–∏–≥—Ä–∞–≤!",
    (Choice.Rock, Choice.Paper) => "–ì—Ä–∞–≤–µ—Ü—å 2 –≤–∏–≥—Ä–∞–≤!",

    _ => "–ù—ñ—á–∏—è!"
};

Console.WriteLine(DetermineWinner(Choice.Rock, Choice.Scissors));
// –í–∏–≤–µ–¥–µ: –ì—Ä–∞–≤–µ—Ü—å 1 –≤–∏–≥—Ä–∞–≤!
```

### Combining with Property Patterns

```csharp [DiscountCalculator.cs] showLineNumbers
public record Customer(string Name, bool IsPremium);
public record Product(decimal Price, string Category);

public static decimal CalculateDiscount(Customer customer, Product product)
    => (customer, product) switch
{
    ({ IsPremium: true }, { Category: "Electronics", Price: > 1000 })
        => product.Price * 0.20m, // 20% –¥–ª—è –ø—Ä–µ–º—ñ—É–º –Ω–∞ –¥–æ—Ä–æ–≥—É –µ–ª–µ–∫—Ç—Ä–æ–Ω—ñ–∫—É

    ({ IsPremium: true }, _)
        => product.Price * 0.10m, // 10% –¥–ª—è –ø—Ä–µ–º—ñ—É–º –Ω–∞ –≤—Å–µ —ñ–Ω—à–µ

    (_, { Category: "Books" })
        => product.Price * 0.05m, // 5% –Ω–∞ –∫–Ω–∏–≥–∏ –¥–ª—è –≤—Å—ñ—Ö

    _ => 0m // –±–µ–∑ –∑–Ω–∏–∂–∫–∏
};

var customer = new Customer("–Ü–≤–∞–Ω", true);
var product = new Product(1500m, "Electronics");
var discount = CalculateDiscount(customer, product);

Console.WriteLine($"–ó–Ω–∏–∂–∫–∞: {discount:C}");
// –í–∏–≤–µ–¥–µ: –ó–Ω–∏–∂–∫–∞: 300,00 ‚Ç¥
```

### Practical Example: State Machine

```csharp [DoorStateMachine.cs] showLineNumbers
public enum DoorState { Closed, Open, Locked }
public enum Action { Push, Pull, Lock, Unlock }

public static DoorState TransitionState(DoorState current, Action action, bool hasKey)
    => (current, action, hasKey) switch
{
    (DoorState.Closed, Action.Push, _) => DoorState.Open,
    (DoorState.Open, Action.Pull, _) => DoorState.Closed,
    (DoorState.Closed, Action.Lock, true) => DoorState.Locked,
    (DoorState.Locked, Action.Unlock, true) => DoorState.Closed,

    // –ù–µ–¥–æ–∑–≤–æ–ª–µ–Ω—ñ –ø–µ—Ä–µ—Ö–æ–¥–∏
    (DoorState.Locked, _, false) => throw new InvalidOperationException("–ü–æ—Ç—Ä—ñ–±–µ–Ω –∫–ª—é—á!"),
    (var state, _, _) => state // –∑–∞–ª–∏—à–∞—î–º–æ—Å—å —É –ø–æ—Ç–æ—á–Ω–æ–º—É —Å—Ç–∞–Ω—ñ
};

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
var state = DoorState.Closed;
state = TransitionState(state, Action.Lock, true);
Console.WriteLine(state); // –í–∏–≤–µ–¥–µ: Locked
```

::tip
**Use Case**: Tuple patterns —ñ–¥–µ–∞–ª—å–Ω–æ –ø—ñ–¥—Ö–æ–¥—è—Ç—å –¥–ª—è **state machines**, **game logic**, —Ç–∞ –±—É–¥—å-—è–∫–∏—Ö —Å—Ü–µ–Ω–∞—Ä—ñ—ó–≤, –¥–µ —Ä—ñ—à–µ–Ω–Ω—è –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ –∫–æ–º–±—ñ–Ω–∞—Ü—ñ—ó –º–Ω–æ–∂–∏–Ω–∏ —É–º–æ–≤.
::

---

## Positional Pattern (–ü–æ–∑–∏—Ü—ñ–π–Ω–∏–π –ü–∞—Ç–µ—Ä–Ω)

**Positional Pattern** –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î **deconstruction** –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ –∑–Ω–∞—á–µ–Ω—å —É –ø–µ–≤–Ω–æ–º—É –ø–æ—Ä—è–¥–∫—É.

### –í–∏–º–æ–≥–∏

–¢–∏–ø –ø–æ–≤–∏–Ω–µ–Ω –º–∞—Ç–∏ –º–µ—Ç–æ–¥ `Deconstruct` –∞–±–æ –±—É—Ç–∏ `record` (records –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≥–µ–Ω–µ—Ä—É—é—Ç—å deconstruction).

### –ó Records

```csharp [Point.cs] showLineNumbers
public record Point(int X, int Y);

public static string ClassifyPoint(Point point) => point switch
{
    (0, 0) => "–ü–æ—á–∞—Ç–æ–∫ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç",
    (0, _) => "–ù–∞ –æ—Å—ñ Y",
    (_, 0) => "–ù–∞ –æ—Å—ñ X",
    (var x, var y) when x == y => "–ù–∞ –¥—ñ–∞–≥–æ–Ω–∞–ª—ñ (y = x)",
    (var x, var y) when x == -y => "–ù–∞ –¥—ñ–∞–≥–æ–Ω–∞–ª—ñ (y = -x)",
    (> 0, > 0) => "–ü–µ—Ä—à–∏–π –∫–≤–∞–¥—Ä–∞–Ω—Ç",
    (< 0, > 0) => "–î—Ä—É–≥–∏–π –∫–≤–∞–¥—Ä–∞–Ω—Ç",
    (< 0, < 0) => "–¢—Ä–µ—Ç—ñ–π –∫–≤–∞–¥—Ä–∞–Ω—Ç",
    _ => "–ß–µ—Ç–≤–µ—Ä—Ç–∏–π –∫–≤–∞–¥—Ä–∞–Ω—Ç"
};

var point = new Point(5, 5);
Console.WriteLine(ClassifyPoint(point));
// –í–∏–≤–µ–¥–µ: –ù–∞ –¥—ñ–∞–≥–æ–Ω–∞–ª—ñ (y = x)
```

::note
**–ó–≤–µ—Ä–Ω—ñ—Ç—å —É–≤–∞–≥—É**: `(0, _)` –æ–∑–Ω–∞—á–∞—î "X –¥–æ—Ä—ñ–≤–Ω—é—î 0, Y ‚Äî –±—É–¥—å-—è–∫–µ –∑–Ω–∞—á–µ–Ω–Ω—è". –°–∏–º–≤–æ–ª `_` ‚Äî —Ü–µ **discard pattern**, —è–∫–∏–π —ñ–≥–Ω–æ—Ä—É—î –∑–Ω–∞—á–µ–Ω–Ω—è.
::

### Custom Deconstruct –¥–ª—è Classes

```csharp [Person.cs] showLineNumbers
public class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public int Age { get; set; }

    // –ú–µ—Ç–æ–¥ Deconstruct –¥–æ–∑–≤–æ–ª—è—î –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ positional patterns
    public void Deconstruct(out string firstName, out string lastName, out int age)
    {
        firstName = FirstName;
        lastName = LastName;
        age = Age;
    }
}

public static string GreetPerson(Person person) => person switch
{
    ("–¢–∞—Ä–∞—Å", "–®–µ–≤—á–µ–Ω–∫–æ", _) => "–í–µ–ª–∏–∫–∏–π –ö–æ–±–∑–∞—Ä!",
    (var first, var last, >= 18) => $"–í—ñ—Ç–∞—î–º–æ, {first} {last}!",
    (var first, _, < 18) => $"–ü—Ä–∏–≤—ñ—Ç, {first}!",
    _ => "–ü—Ä–∏–≤—ñ—Ç!"
};

var person = new Person { FirstName = "–û–ª–µ–Ω–∞", LastName = "–ö–æ–≤–∞–ª–µ–Ω–∫–æ", Age = 25 };
Console.WriteLine(GreetPerson(person));
// –í–∏–≤–µ–¥–µ: –í—ñ—Ç–∞—î–º–æ, –û–ª–µ–Ω–∞ –ö–æ–≤–∞–ª–µ–Ω–∫–æ!
```

### Nested Positional Patterns

```csharp [Geometry.cs] showLineNumbers
public record Point(int X, int Y);
public record Line(Point Start, Point End);

public static string AnalyzeLine(Line line) => line switch
{
    ((0, 0), (0, 0)) => "–¶–µ —Ç–æ—á–∫–∞, –∞ –Ω–µ –ª—ñ–Ω—ñ—è",
    ((var x1, var y1), (var x2, var y2)) when x1 == x2 => "–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞ –ª—ñ–Ω—ñ—è",
    ((var x1, var y1), (var x2, var y2)) when y1 == y2 => "–ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞ –ª—ñ–Ω—ñ—è",
    ((0, 0), _) => "–õ—ñ–Ω—ñ—è –ø–æ—á–∏–Ω–∞—î—Ç—å—Å—è –∑ –ø–æ—á–∞—Ç–∫—É –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç",
    (_, (0, 0)) => "–õ—ñ–Ω—ñ—è –∑–∞–∫—ñ–Ω—á—É—î—Ç—å—Å—è —É –ø–æ—á–∞—Ç–∫—É –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç",
    _ => "–ó–≤–∏—á–∞–π–Ω–∞ –ª—ñ–Ω—ñ—è"
};

var line = new Line(new Point(0, 0), new Point(5, 0));
Console.WriteLine(AnalyzeLine(line));
// –í–∏–≤–µ–¥–µ: –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞ –ª—ñ–Ω—ñ—è
```

---

## Relational & Logical Patterns

**Relational Patterns** (C# 9+) –¥–æ–∑–≤–æ–ª—è—é—Ç—å –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ **–æ–ø–µ—Ä–∞—Ç–æ—Ä–∏ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è**: `<`, `>`, `<=`, `>=`.  
**Logical Patterns** –∫–æ–º–±—ñ–Ω—É—é—Ç—å patterns –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é `and`, `or`, `not`.

### Relational Patterns

```csharp [GradeSystem.cs] showLineNumbers
public static string GetGrade(int score) => score switch
{
    >= 90 => "–í—ñ–¥–º—ñ–Ω–Ω–æ",
    >= 75 and < 90 => "–î–æ–±—Ä–µ",
    >= 60 and < 75 => "–ó–∞–¥–æ–≤—ñ–ª—å–Ω–æ",
    >= 0 and < 60 => "–ù–µ–∑–∞–¥–æ–≤—ñ–ª—å–Ω–æ",
    _ => "–ù–µ–≤–∞–ª—ñ–¥–Ω–∏–π –±–∞–ª"
};

Console.WriteLine(GetGrade(85));
// –í–∏–≤–µ–¥–µ: –î–æ–±—Ä–µ
```

### Logical Patterns: `and`, `or`, `not`

```csharp [Validation.cs] showLineNumbers
public static bool IsValidPassword(string password) => password switch
{
    null or { Length: < 8 } => false,
    { Length: >= 8 and <= 20 } => true,
    _ => false
};

// –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∏–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –∑ `is`
public static bool IsWorkingHour(int hour)
    => hour is >= 9 and < 18;

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è `not`
public static bool IsWeekend(DayOfWeek day)
    => day is DayOfWeek.Saturday or DayOfWeek.Sunday;

public static bool IsWorkday(DayOfWeek day)
    => day is not (DayOfWeek.Saturday or DayOfWeek.Sunday);
```

### Parenthesized Patterns

–î–ª—è —Å–∫–ª–∞–¥–Ω–æ—ó –ª–æ–≥—ñ–∫–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ **–¥—É–∂–∫–∏**:

```csharp [ComplexLogic.cs] showLineNumbers
public record Employee(string Name, int Age, string Department, decimal Salary);

public static bool IsEligibleForBonus(Employee emp) => emp switch
{
    { Age: >= 30, Department: "IT" or "Sales", Salary: < 50000 } => true,
    { Department: "Management", Salary: >= 50000 and < 100000 } => true,
    _ => false
};

// –ó –¥—É–∂–∫–∞–º–∏ –¥–ª—è —è—Å–Ω–æ—Å—Ç—ñ
public static string ClassifyEmployee(Employee emp) => emp switch
{
    { Age: < 25 } and { Salary: < 30000 }
        => "Junior",

    ({ Age: >= 25 and < 40 } and { Salary: >= 30000 and < 60000 })
        or { Department: "IT", Age: < 30 }
        => "Middle",

    { Age: >= 40 } or { Salary: >= 60000 }
        => "Senior",

    _ => "Uncategorized"
};
```

### Real Example: Range Validation

```csharp [TemperatureMonitor.cs] showLineNumbers
public enum AlertLevel { Normal, Warning, Critical }

public static AlertLevel CheckTemperature(double celsius) => celsius switch
{
    < -40 or > 60 => AlertLevel.Critical,
    >= -40 and < 0 => AlertLevel.Warning,
    >= 0 and <= 35 => AlertLevel.Normal,
    > 35 and <= 60 => AlertLevel.Warning,
    _ => throw new ArgumentOutOfRangeException(nameof(celsius))
};

Console.WriteLine(CheckTemperature(38));
// –í–∏–≤–µ–¥–µ: Warning
```

::mermaid

```mermaid
graph TD
    A[Input Value] --> B{< -40 or > 60?}
    B -- Yes --> C[Critical]
    B -- No --> D{>= -40 and < 0?}
    D -- Yes --> E[Warning]
    D -- No --> F{>= 0 and <= 35?}
    F -- Yes --> G[Normal]
    F -- No --> H{> 35 and <= 60?}
    H -- Yes --> E
    H -- No --> I[Exception]

    style A fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style B fill:#f59e0b,stroke:#b45309,color:#ffffff
    style C fill:#ef4444,stroke:#b91c1c,color:#ffffff
    style D fill:#f59e0b,stroke:#b45309,color:#ffffff
    style E fill:#f59e0b,stroke:#b45309,color:#ffffff
    style F fill:#f59e0b,stroke:#b45309,color:#ffffff
    style G fill:#10b981,stroke:#047857,color:#ffffff
    style H fill:#f59e0b,stroke:#b45309,color:#ffffff
    style I fill:#64748b,stroke:#334155,color:#ffffff
```

::

---

## List Patterns (C# 11+)

**List Patterns** –¥–æ–∑–≤–æ–ª—è—é—Ç—å –ø–µ—Ä–µ–≤—ñ—Ä—è—Ç–∏ **–ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç—ñ** (arrays, lists, spans) —Ç–∞ —ó—Ö –µ–ª–µ–º–µ–Ω—Ç–∏.

::warning
**–í–∏–º–æ–≥–∞**: List Patterns –¥–æ—Å—Ç—É–ø–Ω—ñ –∑ **C# 11** (.NET 7+). –ü–µ—Ä–µ–∫–æ–Ω–∞–π—Ç–µ—Å—è, —â–æ –≤–∞—à –ø—Ä–æ—î–∫—Ç –Ω–∞–ª–∞—à—Ç–æ–≤–∞–Ω–∏–π –Ω–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω—É –≤–µ—Ä—Å—ñ—é:

```xml
<LangVersion>11</LangVersion>
```

::

### –ë–∞–∑–æ–≤–∏–π –°–∏–Ω—Ç–∞–∫—Å–∏—Å

```csharp [ListPatterns.cs] showLineNumbers
int[] numbers = { 1, 2, 3 };

// –¢–æ—á–Ω–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω—ñ—Å—Ç—å
Console.WriteLine(numbers is [1, 2, 3]); // True
Console.WriteLine(numbers is [1, 2, 4]); // False

// –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –¥–æ–≤–∂–∏–Ω–∏
Console.WriteLine(numbers is [_, _, _]); // True (3 –µ–ª–µ–º–µ–Ω—Ç–∏)
Console.WriteLine(numbers is [_, _]); // False (–Ω–µ 2 –µ–ª–µ–º–µ–Ω—Ç–∏)
```

### Slice Pattern (`..`)

**Slice pattern** (`..`) –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î "–±—É–¥—å-—è–∫—ñ–π –∫—ñ–ª—å–∫–æ—Å—Ç—ñ –µ–ª–µ–º–µ–Ω—Ç—ñ–≤":

```csharp [Slice.cs] showLineNumbers
int[] array = { 1, 2, 3, 4, 5 };

// –ü–µ—Ä—à–∏–π –µ–ª–µ–º–µ–Ω—Ç ‚Äî 1, —Ä–µ—à—Ç–∞ ‚Äî –±—É–¥—å-—â–æ
Console.WriteLine(array is [1, ..]); // True

// –û—Å—Ç–∞–Ω–Ω—ñ–π –µ–ª–µ–º–µ–Ω—Ç ‚Äî 5
Console.WriteLine(array is [.., 5]); // True

// –ü–µ—Ä—à–∏–π ‚Äî 1, –æ—Å—Ç–∞–Ω–Ω—ñ–π ‚Äî 5, —Å–µ—Ä–µ–¥–∏–Ω–∞ ‚Äî –±—É–¥—å-—â–æ
Console.WriteLine(array is [1, .., 5]); // True

// –•–æ—á–∞ –± 3 –µ–ª–µ–º–µ–Ω—Ç–∏
Console.WriteLine(array is [_, _, _, ..]); // True
```

### Capturing with `var`

```csharp [Capture.cs] showLineNumbers
string[] words = { "Hello", "Pattern", "Matching" };

if (words is [var first, .., var last])
{
    Console.WriteLine($"–ü–µ—Ä—à–µ —Å–ª–æ–≤–æ: {first}, –û—Å—Ç–∞–Ω–Ω—î: {last}");
    // –í–∏–≤–µ–¥–µ: –ü–µ—Ä—à–µ —Å–ª–æ–≤–æ: Hello, –û—Å—Ç–∞–Ω–Ω—î: Matching
}

// –ó–∞—Ö–æ–ø–ª–µ–Ω–Ω—è —Å–µ—Ä–µ–¥–∏–Ω–∏
if (words is [_, .. var middle, _])
{
    Console.WriteLine($"–°–µ—Ä–µ–¥–∏–Ω–∞: {string.Join(", ", middle)}");
    // –í–∏–≤–µ–¥–µ: –°–µ—Ä–µ–¥–∏–Ω–∞: Pattern
}
```

### Combining with Other Patterns

```csharp [Advanced.cs] showLineNumbers
int[] data = { 1, 5, 10, 15, 20 };

// –ü–µ—Ä—à–∏–π –µ–ª–µ–º–µ–Ω—Ç 0 –∞–±–æ 1, –¥—Ä—É–≥–∏–π > 0, —Ä–µ—à—Ç–∞ –±—É–¥—å-—â–æ
Console.WriteLine(data is [0 or 1, > 0, ..]); // True

// –î–æ–≤–∂–∏–Ω–∞ 2 –∞–±–æ 4, –ø–µ—Ä—à–∏–π < 0, –æ—Å—Ç–∞–Ω–Ω—ñ–π <= 0
int[] test1 = { -1, 0 };
int[] test2 = { -1, 0, 0, 1 };

static string Validate(int[] arr) => arr is [< 0, .. { Length: 2 or 4 }, > 0]
    ? "valid"
    : "not valid";

Console.WriteLine(Validate(test1)); // not valid
Console.WriteLine(Validate(test2)); // not valid
```

### Real Example: Command Parser

```csharp [CommandParser.cs] showLineNumbers
public record Command(string Action, string[] Args);

public static string ParseCommand(string[] input) => input switch
{
    [] => "–ü–æ—Ä–æ–∂–Ω—è –∫–æ–º–∞–Ω–¥–∞",

    ["help"] => "–î–æ–≤—ñ–¥–∫–∞: –¥–æ—Å—Ç—É–ø–Ω—ñ –∫–æ–º–∞–Ω–¥–∏...",

    ["create", var name] => $"–°—Ç–≤–æ—Ä–µ–Ω–Ω—è: {name}",

    ["delete", var name, "force"] => $"–í–∏–¥–∞–ª–µ–Ω–Ω—è {name} –∑ –ø—Ä–∏–º—É—Å–æ–≤–∏–º —Ä–µ–∂–∏–º–æ–º",
    ["delete", var name] => $"–í–∏–¥–∞–ª–µ–Ω–Ω—è: {name}",

    ["list", .. var options] => $"–°–ø–∏—Å–æ–∫ –∑ –æ–ø—Ü—ñ—è–º–∏: {string.Join(", ", options)}",

    ["config", "set", var key, var value] => $"–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è {key} = {value}",

    [var cmd, ..] => $"–ù–µ–≤—ñ–¥–æ–º–∞ –∫–æ–º–∞–Ω–¥–∞: {cmd}",

    _ => "–ù–µ–≤–∞–ª—ñ–¥–Ω–∏–π –≤–≤—ñ–¥"
};

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
string[] cmd1 = { "create", "project.txt" };
Console.WriteLine(ParseCommand(cmd1));
// –í–∏–≤–µ–¥–µ: –°—Ç–≤–æ—Ä–µ–Ω–Ω—è: project.txt

string[] cmd2 = { "delete", "old.txt", "force" };
Console.WriteLine(ParseCommand(cmd2));
// –í–∏–≤–µ–¥–µ: –í–∏–¥–∞–ª–µ–Ω–Ω—è old.txt –∑ –ø—Ä–∏–º—É—Å–æ–≤–∏–º —Ä–µ–∂–∏–º–æ–º

string[] cmd3 = { "list", "--verbose", "--sort=name" };
Console.WriteLine(ParseCommand(cmd3));
// –í–∏–≤–µ–¥–µ: –°–ø–∏—Å–æ–∫ –∑ –æ–ø—Ü—ñ—è–º–∏: --verbose, --sort=name
```

::tip
**Performance**: List patterns –æ—Å–æ–±–ª–∏–≤–æ –µ—Ñ–µ–∫—Ç–∏–≤–Ω—ñ –∑ `Span<T>` —Ç–∞ `ReadOnlySpan<T>`, –æ—Å–∫—ñ–ª—å–∫–∏ –Ω–µ —Å—Ç–≤–æ—Ä—é—é—Ç—å –Ω–æ–≤–∏—Ö –º–∞—Å–∏–≤—ñ–≤ –¥–ª—è slice operations.
::

---

## Best Practices —Ç–∞ Anti-patterns

### ‚úÖ Best Practices

#### 1. Exhaustive Matching

**–ó–∞–≤–∂–¥–∏ –æ–±—Ä–æ–±–ª—è–π—Ç–µ –≤—Å—ñ –≤–∏–ø–∞–¥–∫–∏** –∞–±–æ –¥–æ–¥–∞–π—Ç–µ `_`:

```csharp [Good.cs] showLineNumbers
string GetStatus(int code) => code switch
{
    200 => "OK",
    404 => "Not Found",
    500 => "Server Error",
    _ => "Unknown" // ‚úÖ –æ–±—Ä–æ–±–ª—è—î–º–æ –≤—Å—ñ —ñ–Ω—à—ñ
};
```

#### 2. Order Patterns from Specific to General

```csharp [Good.cs] showLineNumbers
string Classify(object obj) => obj switch
{
    string { Length: > 100 } => "–î–æ–≤–≥–∏–π —Ä—è–¥–æ–∫", // ‚úÖ —Å–ø–µ—Ü–∏—Ñ—ñ—á–Ω–∏–π
    string => "–†—è–¥–æ–∫",                          // ‚úÖ –∑–∞–≥–∞–ª—å–Ω–∏–π
    int => "–ß–∏—Å–ª–æ",
    _ => "–©–æ—Å—å —ñ–Ω—à–µ"
};
```

```csharp [Bad.cs] showLineNumbers
string Classify(object obj) => obj switch
{
    string => "–†—è–¥–æ–∫",                          // ‚ùå –∑–∞–≥–∞–ª—å–Ω–∏–π —Å–ø–æ—á–∞—Ç–∫—É
    string { Length: > 100 } => "–î–æ–≤–≥–∏–π —Ä—è–¥–æ–∫", // ‚ö†Ô∏è unreachable!
    _ => "–©–æ—Å—å —ñ–Ω—à–µ"
};
```

#### 3. Use Property Patterns –∑–∞–º—ñ—Å—Ç—å Guards (–∫–æ–ª–∏ –º–æ–∂–ª–∏–≤–æ)

```csharp [Good.cs] showLineNumbers
var result = user switch
{
    { Age: >= 18, Country: "UA" } => "OK", // ‚úÖ —á–∏—Ç–∞–±–µ–ª—å–Ω–æ
    _ => "NO"
};
```

```csharp [Less Good.cs] showLineNumbers
var result = user switch
{
    var u when u.Age >= 18 && u.Country == "UA" => "OK", // ‚ùå –º–µ–Ω—à —á–∏—Ç–∞–±–µ–ª—å–Ω–æ
    _ => "NO"
};
```

### ‚ùå Anti-patterns

#### 1. –ù–∞–¥–º—ñ—Ä–Ω–æ –°–∫–ª–∞–¥–Ω—ñ Nested Patterns

```csharp [Bad.cs] showLineNumbers
// ‚ùå –ó–∞–Ω–∞–¥—Ç–æ —Å–∫–ª–∞–¥–Ω–æ –¥–ª—è —á–∏—Ç–∞–Ω–Ω—è
var result = data switch
{
    {
        User: {
            Profile: {
                Settings: {
                    Theme: "Dark",
                    Language: "UK" or "EN"
                }
            },
            Age: >= 18 and < 65
        },
        IsActive: true
    } => "Process",
    _ => "Skip"
};
```

**–ö—Ä–∞—â–µ** ‚Äî —Ä–æ–∑–±–∏—Ç–∏ –Ω–∞ helper methods:

```csharp [Good.cs] showLineNumbers
bool IsValidUser(Data data) => data.User is
    { Age: >= 18 and < 65, Profile.Settings: { Theme: "Dark", Language: "UK" or "EN" } };

var result = data switch
{
    { IsActive: true } when IsValidUser(data) => "Process", // ‚úÖ —á–∏—Ç–∞–±–µ–ª—å–Ω–æ
    _ => "Skip"
};
```

#### 2. Duplicate Logic

```csharp [Bad.cs] showLineNumbers
// ‚ùå –î—É–±–ª—é–≤–∞–Ω–Ω—è –ª–æ–≥—ñ–∫–∏
var result = value switch
{
    > 0 and < 10 => "Small",
    >= 10 and < 100 => "Medium",
    >= 100 => "Large",
    < 0 => "Negative",
    _ => "Zero"
};
```

```csharp [Good.cs] showLineNumbers
// ‚úÖ –õ–æ–≥—ñ—á–Ω–∞ –ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å
var result = value switch
{
    < 0 => "Negative",
    0 => "Zero",
    < 10 => "Small",
    < 100 => "Medium",
    _ => "Large"
};
```

---

## Troubleshooting

### –ü–æ–º–∏–ª–∫–∞ CS8509: Non-Exhaustive Switch

**–ü—Ä–æ–±–ª–µ–º–∞**: Switch expression –Ω–µ –ø–æ–∫—Ä–∏–≤–∞—î –≤—Å—ñ –º–æ–∂–ª–∏–≤—ñ –∑–Ω–∞—á–µ–Ω–Ω—è.

```csharp
enum Color { Red, Green, Blue }

string GetName(Color c) => c switch
{
    Color.Red => "–ß–µ—Ä–≤–æ–Ω–∏–π",
    Color.Green => "–ó–µ–ª–µ–Ω–∏–π"
    // ‚ö†Ô∏è CS8509: The switch expression does not handle all possible values
};
```

**–†—ñ—à–µ–Ω–Ω—è**: –î–æ–¥–∞—Ç–∏ –≤—ñ–¥—Å—É—Ç–Ω—ñ–π –≤–∏–ø–∞–¥–æ–∫ –∞–±–æ `_`:

```csharp
string GetName(Color c) => c switch
{
    Color.Red => "–ß–µ—Ä–≤–æ–Ω–∏–π",
    Color.Green => "–ó–µ–ª–µ–Ω–∏–π",
    Color.Blue => "–°–∏–Ω—ñ–π",
    _ => throw new ArgumentOutOfRangeException(nameof(c))
};
```

::collapsible{title="–ß–æ–º—É –≤–∞—Ä—Ç–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ throw –∑–∞–º—ñ—Å—Ç—å default –∑–Ω–∞—á–µ–Ω–Ω—è?"}

–í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è `throw` —É `_` branch –¥–ª—è enum'—ñ–≤ ‚Äî **best practice**, –æ—Å–∫—ñ–ª—å–∫–∏:

1. **Fail Fast**: –Ø–∫—â–æ –∑'—è–≤–∏—Ç—å—Å—è –Ω–æ–≤–∏–π enum value, –∫–æ–¥ –Ω–µ–≥–∞–π–Ω–æ –≤–ø–∞–¥–µ –∑ –≤–∏—Ä–∞–∑–Ω–æ—é –ø–æ–º–∏–ª–∫–æ—é
2. **–¢–∏–ø–æ–±–µ–∑–ø–µ–∫–∞**: –ö–æ–º–ø—ñ–ª—è—Ç–æ—Ä –ø–æ–ø–µ—Ä–µ–¥–∏—Ç—å, —è–∫—â–æ –≤–∏ –Ω–µ –æ–±—Ä–æ–±–∏–ª–∏ —è–∫–∏–π—Å—å case
3. **Explicit Intent**: –ß—ñ—Ç–∫–æ –ø–æ–∫–∞–∑—É—î, —â–æ —ñ–Ω—à—ñ –∑–Ω–∞—á–µ–Ω–Ω—è –Ω–µ–ø—Ä–∏–ø—É—Å—Ç–∏–º—ñ

```csharp
// ‚úÖ Good
_ => throw new ArgumentOutOfRangeException(nameof(c), "Unexpected color")

// ‚ùå Bad (–ø—Ä–∏—Ö–æ–≤—É—î –ø—Ä–æ–±–ª–µ–º—É)
_ => "Unknown"
```

::

### Unreachable Pattern Warning

**–ü—Ä–æ–±–ª–µ–º–∞**: Pattern –Ω—ñ–∫–æ–ª–∏ –Ω–µ –±—É–¥–µ –¥–æ—Å—è–≥–Ω—É—Ç–∏–π —á–µ—Ä–µ–∑ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ patterns.

```csharp
var result = obj switch
{
    string => "String",
    string { Length: > 10 } => "Long string", // ‚ö†Ô∏è unreachable
    _ => "Other"
};
```

**–†—ñ—à–µ–Ω–Ω—è**: –†–æ–∑—Ç–∞—à—É–π—Ç–µ patterns –≤—ñ–¥ –±—ñ–ª—å—à —Å–ø–µ—Ü–∏—Ñ—ñ—á–Ω–∏—Ö –¥–æ –∑–∞–≥–∞–ª—å–Ω–∏—Ö:

```csharp
var result = obj switch
{
    string { Length: > 10 } => "Long string", // ‚úÖ —Å–ø–µ—Ü–∏—Ñ—ñ—á–Ω–∏–π
    string => "String",                        // ‚úÖ –∑–∞–≥–∞–ª—å–Ω–∏–π
    _ => "Other"
};
```

### Pattern Subsumption

**–ü—Ä–æ–±–ª–µ–º–∞**: –û–¥–∏–Ω pattern "–ø–æ–≥–ª–∏–Ω–∞—î" —ñ–Ω—à–∏–π.

```csharp
var result = number switch
{
    > 0 => "Positive",
    > 10 => "Greater than 10", // ‚ö†Ô∏è unreachable (> 10 –≤–∂–µ –ø–æ–∫—Ä–∏—Ç–æ > 0)
    _ => "Not positive"
};
```

**–†—ñ—à–µ–Ω–Ω—è**:

```csharp
var result = number switch
{
    > 10 => "Greater than 10",  // ‚úÖ —Å–ø–æ—á–∞—Ç–∫—É –±—ñ–ª—å—à —Å–ø–µ—Ü–∏—Ñ—ñ—á–Ω–∏–π
    > 0 => "Positive",
    _ => "Not positive"
};
```

---

## –ü—Ä–∞–∫—Ç–∏–∫–∞

### –†—ñ–≤–µ–Ω—å 1: Beginner

**–ó–∞–≤–¥–∞–Ω–Ω—è**: –°—Ç–≤–æ—Ä–∏—Ç–∏ —Ñ—É–Ω–∫—Ü—ñ—é –∫–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—ó —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç—É –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é Type —Ç–∞ Property patterns.

```csharp [Task.cs] showLineNumbers
public abstract record Vehicle(string Brand);
public record Car(string Brand, int Doors) : Vehicle(Brand);
public record Motorcycle(string Brand, int EngineCC) : Vehicle(Brand);
public record Bicycle(string Brand, bool IsElectric) : Vehicle(Brand);

// TODO: –†–µ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ —Ñ—É–Ω–∫—Ü—ñ—é ClassifyVehicle
// –ü–æ–≤–µ—Ä—Ç–∞—î:
// - "–õ–µ–≥–∫–æ–≤–∏–π –∞–≤—Ç–æ–º–æ–±—ñ–ª—å" –¥–ª—è Car
// - "–ü–æ—Ç—É–∂–Ω–∏–π –º–æ—Ç–æ—Ü–∏–∫–ª" –¥–ª—è Motorcycle –∑ EngineCC > 600
// - "–ó–≤–∏—á–∞–π–Ω–∏–π –º–æ—Ç–æ—Ü–∏–∫–ª" –¥–ª—è —ñ–Ω—à–∏—Ö Motorcycle
// - "–ï–ª–µ–∫—Ç—Ä–æ–≤–µ–ª–æ—Å–∏–ø–µ–¥" –¥–ª—è Bicycle { IsElectric: true }
// - "–í–µ–ª–æ—Å–∏–ø–µ–¥" –¥–ª—è —ñ–Ω—à–∏—Ö Bicycle
// - "–ù–µ–≤—ñ–¥–æ–º–∏–π —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç" –¥–ª—è —ñ–Ω—à–∏—Ö

public static string ClassifyVehicle(Vehicle vehicle)
{
    // –í–∞—à –∫–æ–¥ —Ç—É—Ç
    throw new NotImplementedException();
}
```

::collapsible{title="–†–æ–∑–≤'—è–∑–æ–∫"}

```csharp [Solution.cs] showLineNumbers
public static string ClassifyVehicle(Vehicle vehicle) => vehicle switch
{
    Car => "–õ–µ–≥–∫–æ–≤–∏–π –∞–≤—Ç–æ–º–æ–±—ñ–ª—å",
    Motorcycle { EngineCC: > 600 } => "–ü–æ—Ç—É–∂–Ω–∏–π –º–æ—Ç–æ—Ü–∏–∫–ª",
    Motorcycle => "–ó–≤–∏—á–∞–π–Ω–∏–π –º–æ—Ç–æ—Ü–∏–∫–ª",
    Bicycle { IsElectric: true } => "–ï–ª–µ–∫—Ç—Ä–æ–≤–µ–ª–æ—Å–∏–ø–µ–¥",
    Bicycle => "–í–µ–ª–æ—Å–∏–ø–µ–¥",
    _ => "–ù–µ–≤—ñ–¥–æ–º–∏–π —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç"
};

// –¢–µ—Å—Ç–∏
var car = new Car("Toyota", 4);
var bike = new Motorcycle("Harley", 750);
var ebike = new Bicycle("Trek", true);

Console.WriteLine(ClassifyVehicle(car));   // –õ–µ–≥–∫–æ–≤–∏–π –∞–≤—Ç–æ–º–æ–±—ñ–ª—å
Console.WriteLine(ClassifyVehicle(bike));  // –ü–æ—Ç—É–∂–Ω–∏–π –º–æ—Ç–æ—Ü–∏–∫–ª
Console.WriteLine(ClassifyVehicle(ebike)); // –ï–ª–µ–∫—Ç—Ä–æ–≤–µ–ª–æ—Å–∏–ø–µ–¥
```

::

---

### –†—ñ–≤–µ–Ω—å 2: Intermediate

**–ó–∞–≤–¥–∞–Ω–Ω—è**: –†–µ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä –∑–Ω–∏–∂–æ–∫ –∑ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è–º Tuple —Ç–∞ Relational patterns.

```csharp [Task.cs] showLineNumbers
public record Customer(string Name, int LoyaltyYears, decimal TotalSpent);
public record Purchase(decimal Amount, string Category);

// TODO: –†–µ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ CalculateDiscount
// –ü—Ä–∞–≤–∏–ª–∞ –∑–Ω–∏–∂–æ–∫:
// 1. LoyaltyYears >= 5 AND TotalSpent > 10000 AND Amount > 500: 25%
// 2. LoyaltyYears >= 3 AND Category == "Electronics": 15%
// 3. Amount >= 1000: 10%
// 4. Category == "Books": 5%
// 5. –Ü–Ω–∞–∫—à–µ: 0%

public static decimal CalculateDiscount(Customer customer, Purchase purchase)
{
    // –í–∞—à –∫–æ–¥ —Ç—É—Ç
    throw new NotImplementedException();
}
```

::collapsible{title="–†–æ–∑–≤'—è–∑–æ–∫"}

```csharp [Solution.cs] showLineNumbers
public static decimal CalculateDiscount(Customer customer, Purchase purchase)
    => (customer, purchase) switch
{
    ({ LoyaltyYears: >= 5, TotalSpent: > 10000 }, { Amount: > 500 })
        => purchase.Amount * 0.25m,

    ({ LoyaltyYears: >= 3 }, { Category: "Electronics" })
        => purchase.Amount * 0.15m,

    (_, { Amount: >= 1000 })
        => purchase.Amount * 0.10m,

    (_, { Category: "Books" })
        => purchase.Amount * 0.05m,

    _ => 0m
};

// –¢–µ—Å—Ç–∏
var loyalCustomer = new Customer("–ú–∞—Ä—ñ—è", 6, 15000);
var newCustomer = new Customer("–Ü–≤–∞–Ω", 1, 500);

var expensivePurchase = new Purchase(600, "Electronics");
var bookPurchase = new Purchase(200, "Books");

Console.WriteLine(CalculateDiscount(loyalCustomer, expensivePurchase));
// –í–∏–≤–µ–¥–µ: 150 (25%)

Console.WriteLine(CalculateDiscount(newCustomer, bookPurchase));
// –í–∏–≤–µ–¥–µ: 10 (5%)
```

::

---

### –†—ñ–≤–µ–Ω—å 3: Advanced

**–ó–∞–≤–¥–∞–Ω–Ω—è**: –†–µ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ –ø–∞—Ä—Å–µ—Ä SQL-–ø–æ–¥—ñ–±–Ω–∏—Ö –∫–æ–º–∞–Ω–¥ –∑ List Patterns.

```csharp [Task.cs] showLineNumbers
public abstract record SqlCommand;
public record SelectCommand(string Table, string[] Columns, string? Where) : SqlCommand;
public record InsertCommand(string Table, Dictionary<string, string> Values) : SqlCommand;
public record UpdateCommand(string Table, Dictionary<string, string> Values, string Where) : SqlCommand;
public record DeleteCommand(string Table, string Where) : SqlCommand;

// TODO: –†–µ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ ParseSqlCommand
// –ü—Ä–∏–∫–ª–∞–¥–∏:
// ["SELECT", "*", "FROM", "users"] => SelectCommand("users", ["*"], null)
// ["SELECT", "name", "age", "FROM", "users", "WHERE", "id=1"]
//     => SelectCommand("users", ["name", "age"], "id=1")
// ["INSERT", "INTO", "users", "name=John", "age=30"]
//     => InsertCommand("users", {"name": "John", "age": "30"})
// ["DELETE", "FROM", "users", "WHERE", "id=1"]
//     => DeleteCommand("users", "id=1")

public static SqlCommand ParseSqlCommand(string[] tokens)
{
    // –í–∞—à –∫–æ–¥ —Ç—É—Ç
    throw new NotImplementedException();
}
```

::collapsible{title="–†–æ–∑–≤'—è–∑–æ–∫"}

```csharp [Solution.cs] showLineNumbers
public static SqlCommand ParseSqlCommand(string[] tokens) => tokens switch
{
    // SELECT * FROM table
    ["SELECT", "*", "FROM", var table]
        => new SelectCommand(table, ["*"], null),

    // SELECT col1 col2 FROM table WHERE condition
    ["SELECT", .. var cols, "FROM", var table, "WHERE", var where]
        => new SelectCommand(table, cols.ToArray(), where),

    // SELECT col1 col2 FROM table
    ["SELECT", .. var cols, "FROM", var table]
        => new SelectCommand(table, cols.ToArray(), null),

    // INSERT INTO table col1=val1 col2=val2 ...
    ["INSERT", "INTO", var table, .. var pairs]
        => new InsertCommand(table, ParsePairs(pairs)),

    // UPDATE table col1=val1 WHERE condition
    ["UPDATE", var table, .. var pairsAndWhere] when pairsAndWhere.Contains("WHERE")
        => ParseUpdate(table, pairsAndWhere),

    // DELETE FROM table WHERE condition
    ["DELETE", "FROM", var table, "WHERE", var where]
        => new DeleteCommand(table, where),

    _ => throw new ArgumentException("–ù–µ–≤–∞–ª—ñ–¥–Ω–∞ SQL –∫–æ–º–∞–Ω–¥–∞")
};

static Dictionary<string, string> ParsePairs(string[] pairs)
    => pairs.Select(p => p.Split('='))
            .ToDictionary(parts => parts[0], parts => parts[1]);

static UpdateCommand ParseUpdate(string table, string[] tokens)
{
    var whereIndex = Array.IndexOf(tokens, "WHERE");
    var pairs = tokens[..whereIndex];
    var where = tokens[whereIndex + 1];
    return new UpdateCommand(table, ParsePairs(pairs), where);
}

// –¢–µ—Å—Ç–∏
var cmd1 = ParseSqlCommand(["SELECT", "*", "FROM", "users"]);
Console.WriteLine(cmd1);
// SelectCommand { Table = users, Columns = [*], Where =  }

var cmd2 = ParseSqlCommand(["SELECT", "name", "age", "FROM", "users", "WHERE", "id>10"]);
Console.WriteLine(cmd2);
// SelectCommand { Table = users, Columns = [name, age], Where = id>10 }

var cmd3 = ParseSqlCommand(["INSERT", "INTO", "products", "name=Phone", "price=500"]);
Console.WriteLine(cmd3);
// InsertCommand { Table = products, Values = {name: Phone, price: 500} }
```

::

---

## –†–µ–∑—é–º–µ

### –ö–ª—é—á–æ–≤—ñ –ö–æ–Ω—Ü–µ–ø—Ü—ñ—ó

-   **Pattern Matching** –¥–æ–∑–≤–æ–ª—è—î –ø–µ—Ä–µ–≤—ñ—Ä—è—Ç–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–∞–Ω–∏—Ö —Ç–∞ –≤–∏–ª—É—á–∞—Ç–∏ –∑–Ω–∞—á–µ–Ω–Ω—è —É —Ç–∏–ø–æ–±–µ–∑–ø–µ—á–Ω–∏–π —Å–ø–æ—Å—ñ–±
-   **Type Pattern**: –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Ç–∏–ø—É –∑ –≤–∏–ª—É—á–µ–Ω–Ω—è–º –∑–º—ñ–Ω–Ω–æ—ó (`obj is string s`)
-   **Property Pattern**: –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç–µ–π –±–µ–∑ casting (`{ Age: >= 18 }`)
-   **Tuple Pattern**: —Ä–æ–±–æ—Ç–∞ –∑ –∫–æ—Ä—Ç–µ–∂–∞–º–∏ (`(x, y) switch { ... }`)
-   **Positional Pattern**: –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è deconstruction (`(0, 0) => "Origin"`)
-   **Relational/Logical Patterns**: –æ–ø–µ—Ä–∞—Ç–æ—Ä–∏ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è —Ç–∞ –ª–æ–≥—ñ–∫–∞ (`>= 0 and < 100`, `not null`)
-   **List Patterns** (C# 11+): –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç–µ–π (`[1, .., 5]`)
-   **Switch Expression** ‚Äî –≤–∏—Ä–∞–∑–Ω–∏–π —Ç–∞ —Å—Ç–∏—Å–ª–∏–π —Å–ø–æ—Å—ñ–± pattern matching –∑ exhaustiveness checking

### –ö–æ–ª–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ –∫–æ–∂–µ–Ω Pattern

| Pattern Type   | Use Case                       | –ü—Ä–∏–∫–ª–∞–¥                    |
| :------------- | :----------------------------- | :------------------------- |
| **Type**       | –†–æ–±–æ—Ç–∞ –∑ –ø–æ–ª—ñ–º–æ—Ä—Ñ–Ω–∏–º–∏ —Ç–∏–ø–∞–º–∏   | –û–±—Ä–æ–±–∫–∞ —Ä—ñ–∑–Ω–∏—Ö —Ç–∏–ø—ñ–≤ Shape |
| **Property**   | –í–∞–ª—ñ–¥–∞—Ü—ñ—è –æ–±'—î–∫—Ç—ñ–≤, —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ñ—è | –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ User.Age >= 18   |
| **Tuple**      | State machines, –º–Ω–æ–∂–∏–Ω–Ω—ñ —É–º–æ–≤–∏ | –ì—Ä–∞ "–ö–∞–º—ñ–Ω—å-–Ω–æ–∂–∏—Ü—ñ-–ø–∞–ø—ñ—Ä"  |
| **Positional** | Ge–æ–º–µ—Ç—Ä—ñ—è, —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–≤–∞–Ω—ñ –¥–∞–Ω—ñ  | –ö–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—è Point(x, y)   |
| **Relational** | –î—ñ–∞–ø–∞–∑–æ–Ω–∏, —Ä–µ–π—Ç–∏–Ω–≥–∏            | –°–∏—Å—Ç–µ–º–∞ –æ—Ü—ñ–Ω—é–≤–∞–Ω–Ω—è         |
| **List**       | –ü–∞—Ä—Å–∏–Ω–≥ –∫–æ–º–∞–Ω–¥, –∞–ª–≥–æ—Ä–∏—Ç–º–∏      | Command-line parser        |

### –î–æ–¥–∞—Ç–∫–æ–≤—ñ –†–µ—Å—É—Ä—Å–∏

-   [–û—Ñ—ñ—Ü—ñ–π–Ω–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—è Microsoft Learn: Patterns](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/patterns)
-   [Pattern Matching Tutorial](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/pattern-matching)
-   [C# Language Proposals: Pattern Matching](https://github.com/dotnet/csharplang/tree/main/proposals)

### –ù–∞–≤—ñ–≥–∞—Ü—ñ—è

-   ‚Üê –ü–æ–ø–µ—Ä–µ–¥–Ω—ñ–π —Ä–æ–∑–¥—ñ–ª: [Exception Handling](/csharp/advanced-core/exception-handling)
-   ‚Üí –ù–∞—Å—Ç—É–ø–Ω–∏–π —Ä–æ–∑–¥—ñ–ª: [Additional Features](/csharp/advanced-core/additional-features)

::tip
**–ü—Ä–∞–∫—Ç–∏–∫–∞**: –°–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ–ø–∏—Å–∞—Ç–∏ –≤–∞—à—ñ —ñ—Å–Ω—É—é—á—ñ `if-else` chains –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é pattern matching. –í–∏ –ø–æ–±–∞—á–∏—Ç–µ, –Ω–∞—Å–∫—ñ–ª—å–∫–∏ –≤–∏—Ä–∞–∑–Ω—ñ—à–∏–º —Ç–∞ –±–µ–∑–ø–µ—á–Ω—ñ—à–∏–º —Å—Ç–∞–Ω–µ –∫–æ–¥!
::
