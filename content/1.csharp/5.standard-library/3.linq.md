---
title: LINQ (Language Integrated Query)
description: Повний гід по LINQ в C# — від синтаксису запитів до продуктивних операторів фільтрації, проекції, групування та агрегації даних.
---

# LINQ (Language Integrated Query)

## Вступ та Контекст

Уявіть, що ви аналізуєте дані продажів інтернет-магазину. Потрібно знайти всі замовлення за останній місяць, згрупувати їх за категоріями, відсортувати за сумою та порахувати середній чек. У традиційному підході це вимагає купи циклів,умов, тимчасових змінних і ручного керування станом:

```csharp
// Старий підхід - імператив

ний код
List<Order> lastMonthOrders = new();
foreach (var order in allOrders)
{
    if (order.Date >= DateTime.Now.AddMonths(-1))
    {
        lastMonthOrders.Add(order);
    }
}

Dictionary<string, List<Order>> grouped = new();
foreach (var order in lastMonthOrders)
{
    if (!grouped.ContainsKey(order.Category))
    {
        grouped[order.Category] = new List<Order>();
    }
    grouped[order.Category].Add(order);
}

// ... ще 20 рядків коду для сортування та підрахунку ...
```

**LINQ (Language Integrated Query)** революціонізує цей підхід, дозволяючи писати **декларативні запити** прямо в C#:

```csharp
// Новий підхід - декларативний LINQ
var result = allOrders
    .Where(o => o.Date >= DateTime.Now.AddMonths(-1))
    .GroupBy(o => o.Category)
    .Select(g => new {
        Category = g.Key,
        TotalAmount = g.Sum(o => o.Amount),
        AverageCheck = g.Average(o => o.Amount),
        Count = g.Count()
    })
    .OrderByDescending(x => x.TotalAmount);
```

**3 рядки замість 30!** Код стає читабельним, підтримуваним і виражає **що** ми хочемо, а не **як** це зробити.

### Що таке LINQ?

LINQ — це набір технологій, що надає **уніфікований синтаксис запитів** для роботи з різними джерелами даних:

-   **LINQ to Objects**: запити до колекцій у пам'яті (`List<T>`, масиви, `IEnumerable<T>`)
-   **LINQ to SQL / Entity Framework**: запити до баз даних (перетворюються на SQL)
-   **LINQ to XML**: запити до XML документів
-   **LINQ to JSON** (через бібліотеки типу Newtonsoft.JSON)

У цьому матеріалі фокус на **LINQ to Objects** — найпоширенішому сценарії.

---

## Query Syntax vs Method Syntax

LINQ надає **два способи** написання запитів: query syntax (SQL-подібний) та method syntax (fluent API).

### Query Syntax

Нагадує SQL, використовує ключові слова `from`, `where`, `select`:

```csharp [QuerySyntax.cs] showLineNumbers
List<int> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Query syntax
var evenNumbers = from num in numbers
                  where num % 2 == 0
                  select num;

foreach (int n in evenNumbers)
{
    Console.Write($"{n} "); // 2 4 6 8 10
}
```

### Method Syntax

Використовує extension methods на `IEnumerable<T>`:

```csharp [MethodSyntax.cs] showLineNumbers
List<int> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Method syntax
var evenNumbers = numbers.Where(num => num % 2 == 0);

foreach (int n in evenNumbers)
{
    Console.Write($"{n} "); // 2 4 6 8 10
}
```

### Що компілюється в що?

**Query syntax** — це syntactic sugar. Компілятор **перетворює** його на method syntax:

```csharp
// Ви пишете (query syntax):
var query = from n in numbers
            where n > 5
            select n * 2;

// Компілятор генерує (method syntax):
var query = numbers
    .Where(n => n > 5)
    .Select(n => n * 2);
```

### Порівняння

::code-group

```csharp [Query Syntax] showLineNumbers
List<Student> students = GetStudents();

var topStudents = from s in students
                  where s.Grade >= 90
                  orderby s.Name
                  select new {
                      s.Name,
                      s.Grade
                  };
```

```csharp [Method Syntax] showLineNumbers
List<Student> students = GetStudents();

var topStudents = students
    .Where(s => s.Grade >= 90)
    .OrderBy(s => s.Name)
    .Select(s => new {
        s.Name,
        s.Grade
    });
```

::

### Коли використовувати що?

| Query Syntax                                    | Method Syntax                    |
| :---------------------------------------------- | :------------------------------- |
| ✅ Простіші joins                               | ✅ Всі operators доступні        |
| ✅ SQL-знайомий                                 | ✅ Легше chain-ити               |
| ✅ GroupBy читабельніший                        | ✅ Підтримка custom extensions   |
| ❌ Не всі operators (наприклад, `Take`, `Skip`) | ❌ Складні joins менш читабельні |

::tip[Рекомендація]
**Для більшості випадків**: використовуйте **method syntax** — він універсальніший і є стандартом у сучасному C# коді. **Query syntax** зручний для складних joins та group by.
::

---

## Deferred Execution (Відкладене Виконання)

Це **найважливіша концепція** LINQ, яку потрібно розуміти.

### Lazy Evaluation

Коли ви пишете LINQ query, **воно НЕ виконується негайно**. Натомість створюється **query definition** (опис запиту), який виконається, коли ви почнете **ітерувати** результати.

```csharp [DeferredExecution.cs] showLineNumbers
List<int> numbers = [1, 2, 3, 4, 5];

Console.WriteLine("До створення query");

// Запит створено, але НЕ виконано!
var query = numbers.Where(n => {
    Console.WriteLine($"Перевіряємо {n}");
    return n % 2 == 0;
});

Console.WriteLine("Після створення query, до ітерації");

// ТІЛЬКИ ТЕПЕР виконується!
foreach (int n in query)
{
    Console.WriteLine($"Результат: {n}");
}

// Вивід:
// До створення query
// Після створення query, до ітерації
// Перевіряємо 1
// Перевіряємо 2
// Результат: 2
// Перевіряємо 3
// Перевіряємо 4
// Результат: 4
// Перевіряємо 5
```

### Multiple Enumeration Problem

Кожна ітерація **повторно виконує** запит:

```csharp [MultipleEnumeration.cs] showLineNumbers
var query = numbers.Where(n => {
    Console.WriteLine($"Filtering {n}");
    return n > 3;
});

// Перша ітерація
Console.WriteLine("=== First ===");
foreach (var n in query) Console.Write($"{n} ");

// Друга ітерація - QUERY ВИКОНУЄТЬСЯ ЗНОВУ!
Console.WriteLine("\n=== Second ===");
foreach (var n in query) Console.Write($"{n} ");

// Вивід:
// === First ===
// Filtering 1
// Filtering 2
// Filtering 3
// Filtering 4
// 4 Filtering 5
// 5
// === Second ===
// Filtering 1  ← Знову!
// Filtering 2
// ...
```

::warning[Performance Trap]
Якщо query **дорогий** (наприклад, читає файли, робить HTTP запити), повторна енумерація може бути **катастрофічною** для продуктивності!
::

### Immediate Execution

Щоб **виконати запит одразу** і закешувати результат, використовуйте:

-   **`ToList()`** — створює `List<T>`
-   **`ToArray()`** — створює масив
-   **`Count()`**, **`Sum()`**, **`Max()`**, **`Min()`** — повертають одне значення

```csharp [ImmediateExecution.cs] showLineNumbers
List<int> numbers = [1, 2, 3, 4, 5];

// Deferred - query definition
IEnumerable<int> deferredQuery = numbers.Where(n => n > 2);

// Immediate - виконано ОДРАЗУ, результат у List
List<int> immediateQuery = numbers.Where(n => n > 2).ToList();

// Додали елемент
numbers.Add(6);

// defer

ed побачить 6!
Console.WriteLine(string.Join(", ", deferredQuery)); // 3, 4, 5, 6

// immediate НЕ побачить 6 (було виконано раніше)
Console.WriteLine(string.Join(", ", immediateQuery)); // 3, 4, 5
```

::tip[Best Practice]
Використовуйте **`ToList()`** коли:

-   Потрібно **кілька разів** ітерувати результати
-   Query **дорогий** (database, I/O)
-   Хочете **зафіксувати** результат у певний момент часу
    ::

---

## Filtering (Фільтрація)

### Where

Найпопулярніший оператор. Фільтрує елементи за умовою:

```csharp [WhereBasic.cs] showLineNumbers
List<Product> products = GetProducts();

// Продукти дорожчі за $100
var expensive = products.Where(p => p.Price > 100);

// Множинні умови
var specificProducts = products.Where(p =>
    p.Price > 50 &&
    p.Price < 200 &&
    p.Category == "Electronics" &&
    p.InStock
);

// З індексом (index overload)
var evenIndexProducts = products.Where((p, index) => index % 2 == 0);
```

### OfType

Фільтрує за типом (корисно для mixed collections):

```csharp [OfType.cs] showLineNumbers
object[] mixed = [1, "text", 3.14, "hello", 42, null];

// Тільки числа
var numbers = mixed.OfType<int>();
Console.WriteLine(string.Join(", ", numbers)); // 1, 42

// Тільки рядки
var strings = mixed.OfType<string>();
Console.WriteLine(string.Join(", ", strings)); // text, hello

// З inheritance
List<Animal> animals = [new Dog(), new Cat(), new Dog()];
var dogs = animals.OfType<Dog>(); // Тільки Dog екземпляри
```

---

## Projection (Проекція)

### Select

Трансформує кожен елемент:

```csharp [Select.cs] showLineNumbers
List<Product> products = GetProducts();

// Простa трансформація
var names = products.Select(p => p.Name);

// Anonymous type
var summary = products.Select(p => new {
    p.Name,
    p.Price,
    TaxIncluded = p.Price * 1.2
});

// З індексом
var indexedNames = products.Select((p, i) => $"{i + 1}. {p.Name}");

foreach (var item in indexedNames)
{
    Console.WriteLine(item);
// 1. Laptop
// 2. Mouse
// 3. Keyboard
}
```

### SelectMany

**Flattening** — перетворює колекцію колекцій у плоску колекцію:

```csharp [SelectMany.cs] showLineNumbers
List<Department> departments = [
    new("IT", [new("Alice"), new("Bob")]),
    new("HR", [new("Charlie")]),
    new("Sales", [new("Dave"), new("Eve")])
];

// Без SelectMany (отримаємо IEnumerable<IEnumerable<Employee>>)
var nested = departments.Select(d => d.Employees);

// З SelectMany (отримаємо IEnumerable<Employee>)
var allEmployees = departments.SelectMany(d => d.Employees);

foreach (var emp in allEmployees)
{
    Console.WriteLine(emp.Name);
}
// Alice
// Bob
// Charlie
// Dave
// Eve

// Query syntax еквівалент (множинні from)
var allEmployeesQuery = from dept in departments
                        from emp in dept.Employees
                        select emp;
```

**Combinations** з SelectMany:

```csharp [SelectManyCombinations.cs] showLineNumbers
int[] numbers = [1, 2, 3];
char[] letters = ['a', 'b'];

// Всі комбінації
var combinations = numbers.SelectMany(
    num => letters,
    (num, letter) => $"{num}{letter}"
);

Console.WriteLine(string.Join(", ", combinations));
// 1a, 1b, 2a, 2b, 3a, 3b
```

---

## Sorting (Сортування)

### OrderBy / OrderByDescending

```csharp [Sorting.cs] showLineNumbers
List<Product> products = GetProducts();

// Ascending (за зростанням)
var byPrice = products.OrderBy(p => p.Price);

// Descending (за спаданням)
var byPriceDesc = products.OrderByDescending(p => p.Price);

// Query syntax
var queryOrdered = from p in products
                   orderby p.Price descending
                   select p;
```

### ThenBy / ThenByDescending

Вторинне сортування (коли первинні ключі однакові):

```csharp [ThenBy.cs] showLineNumbers
List<Student> students = GetStudents();

// Сортування: спочатку за Grade, потім за Name
var sorted = students
    .OrderByDescending(s => s.Grade)  // Primary
    .ThenBy(s => s.Name);              // Secondary

// Query syntax
var querySorted = from s in students
                  orderby s.Grade descending, s.Name
                  select s;

// Множинні рівні
var complex = students
    .OrderBy(s => s.Department)
    .ThenByDescending(s => s.Grade)
    .ThenBy(s => s.Age)
    .ThenBy(s => s.Name);
```

---

## Grouping (Групування)

### GroupBy

Групує елементи за ключем, повертає `IGrouping<TKey, TElement>`:

```csharp [GroupBy.cs] showLineNumbers
List<Product> products = GetProducts();

// Групування за категорією
var byCategory = products.GroupBy(p => p.Category);

foreach (var group in byCategory)
{
    Console.WriteLine($"Category: {group.Key}");
    foreach (var product in group)
    {
        Console.WriteLine($"  - {product.Name}: ${product.Price}");
    }
}

// З проекцією результату
var categoryStats = products
    .GroupBy(p => p.Category)
    .Select(g => new {
        Category = g.Key,
        Count = g.Count(),
        TotalValue = g.Sum(p => p.Price),
        AvgPrice = g.Average(p => p.Price),
        MostExpensive = g.Max(p => p.Price)
    });

// Query syntax
var queryGrouped = from p in products
                   group p by p.Category into g
                   select new {
                       Category = g.Key,
                       Products = g.ToList()
                   };
```

**Nested queries** на групах:

```csharp [GroupByNested.cs] showLineNumbers
var topProductsPerCategory = products
    .GroupBy(p => p.Category)
    .Select(g => new {
        Category = g.Key,
        TopProducts = g.OrderByDescending(p => p.Price)
                       .Take(3)
                       .ToList()
    });
```

---

## Joins (З'єднання)

### Inner Join

Поєднує два sequence за ключем:

::code-group

```csharp [Method Syntax] showLineNumbers
List<Customer> customers = GetCustomers();
List<Order> orders = GetOrders();

var customerOrders = customers.Join(
    orders,                     // Друга колекція
    c => c.Id,                  // Ключ з першої
    o => o.CustomerId,          // Ключ з другої
    (c, o) => new {             // Результат
        CustomerName = c.Name,
        OrderDate = o.Date,
        Amount = o.TotalAmount
    }
);
```

```csharp [Query Syntax] showLineNumbers
List<Customer> customers = GetCustomers();
List<Order> orders = GetOrders();

var customerOrders = from c in customers
                     join o in orders
                     on c.Id equals o.CustomerId
                     select new {
                         CustomerName = c.Name,
                         OrderDate = o.Date,
                         Amount = o.TotalAmount
                     };
```

::

### Group Join

Зв'язує кожен елемент першої колекції з **групою** відповідних елементів другої:

```csharp [GroupJoin.cs] showLineNumbers
var customersWithOrders = customers.GroupJoin(
    orders,
    c => c.Id,
    o => o.CustomerId,
    (customer, customerOrders) => new {
        Customer = customer.Name,
        Orders = customerOrders.ToList()
    }
);

foreach (var item in customersWithOrders)
{
    Console.WriteLine($"{item.Customer}: {item.Orders.Count} orders");
}

// Query syntax
var queryGroupJoin = from c in customers
                     join o in orders
                     on c.Id equals o.CustomerId into customerOrders
                     select new {
                         Customer = c.Name,
                         Orders = customerOrders.ToList()
                     };
```

### Left Join Pattern

LINQ не має вбудованого left join, але його можна емулювати через **`DefaultIfEmpty()`**:

```csharp [LeftJoin.cs] showLineNumbers
// Left join: всі customers, навіть без orders
var leftJoin = from c in customers
               join o in orders
               on c.Id equals o.CustomerId into customerOrders
               from order in customerOrders.DefaultIfEmpty()
               select new {
                   CustomerName = c.Name,
                   OrderDate = order?.Date,  // Може бути null!
                   Amount = order?.TotalAmount ?? 0
               };
```

---

## Aggregation (Агрегація)

### Standard Aggregates

```csharp [Aggregates.cs] showLineNumbers
List<int> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

int sum = numbers.Sum();           // 55
int count = numbers.Count();       // 10
int max = numbers.Max();           // 10
int min = numbers.Min();           // 1
double avg = numbers.Average();    // 5.5

// З умовою
int evenCount = numbers.Count(n => n % 2 == 0);  // 5
int evenSum = numbers.Where(n => n % 2 == 0).Sum(); // 30

// LongCount для великих колекцій
long bigCount = hugeCollection.LongCount();
```

### MaxBy / MinBy (.NET 6+)

Знаходить **елемент** з максимальним/мінімальним значенням властивості:

```csharp [MaxByMinBy.cs] showLineNumbers
List<Product> products = GetProducts();

// Старий спосіб (неефективно - два проходи)
var mostExpensiveOld = products
    .Where(p => p.Price == products.Max(x => x.Price))
    .First();

// Новий спосіб (.NET 6+, один прохід)
Product? mostExpensive = products.MaxBy(p => p.Price);
Product? cheapest = products.MinBy(p => p.Price);

// З null handling
Product? mostExpensiveElectronics = products
    .Where(p => p.Category == "Electronics")
    .MaxBy(p => p.Price);
```

### Aggregate

Універсальний оператор для custom aggregation:

```csharp [Aggregate.cs] showLineNumbers
List<int> numbers = [1, 2, 3, 4, 5];

// Добуток всіх чисел
int product = numbers.Aggregate((acc, n) => acc * n);
// 1 * 2 * 3 * 4 * 5 = 120

// З seed (початковим значенням)
int productWithSeed = numbers.Aggregate(1, (acc, n) => acc * n);

// З result selector
string concatenated = numbers.Aggregate(
    "",                            // Seed
    (acc, n) => acc + n.ToString(), // Accumulator
    result => $"Result: {result}"  // Result selector
);
// "Result: 12345"

// Практичний приклад: побудова строки
List<string> words = ["Hello", "World", "From", "LINQ"];
string sentence = words.Aggregate((acc, word) => $"{acc} {word}");
// "Hello World From LINQ"
```

---

## Set Operations (Множинні Операції)

### Distinct

Видаляє дублікати:

```csharp [Distinct.cs] showLineNumbers
int[] numbers = [1, 2, 2, 3, 3, 3, 4, 5, 5];

var unique = numbers.Distinct();
Console.WriteLine(string.Join(", ", unique)); // 1, 2, 3, 4, 5

// З custom comparer
List<Product> products = GetProducts();
var uniqueCategories = products
    .Select(p => p.Category)
    .Distinct();

// Distinct на об'єктах (потребує override Equals/GetHashCode)
var uniqueProducts = products.Distinct(); // За reference за замовчуванням
```

### Union, Intersect, Except

```csharp [SetOperations.cs] showLineNumbers
int[] setA = [1, 2, 3, 4, 5];
int[] setB = [4, 5, 6, 7, 8];

// Union - об'єднання (без дублікатів)
var union = setA.Union(setB);
// 1, 2, 3, 4, 5, 6, 7, 8

// Intersect - перетин (спільні елементи)
var intersect = setA.Intersect(setB);
// 4, 5

// Except - різниця (A \ B)
var except = setA.Except(setB);
// 1, 2, 3
```

---

## Element Operations

### First / FirstOrDefault

```csharp [First.cs] showLineNumbers
List<int> numbers = [1, 2, 3, 4, 5];
List<int> empty = [];

// First - викидає exception якщо порожньо
int first = numbers.First();  // 1
// int bad = empty.First();   // InvalidOperationException!

// FirstOrDefault - повертає default якщо порожньо
int firstOrDefault = empty.FirstOrDefault();  // 0 (default для int)

// З predicate
int firstEven = numbers.First(n => n % 2 == 0);  // 2
int firstBigOrDefault = numbers.FirstOrDefault(n => n > 100); // 0
```

### Single / SingleOrDefault

Гарантує, що є **рівно один** елемент:

```csharp [Single.cs] showLineNumbers
List<int> oneElement = [42];
List<int> multiple = [1, 2, 3];
List<int> empty = [];

// Single - exception якщо 0 або >1
int single = oneElement.Single();  // 42
// int bad1 = multiple.Single();   // InvalidOperationException: More than one
// int bad2 = empty.Single();      // InvalidOperationException: No elements

// SingleOrDefault
int singleOrDefault = empty.SingleOrDefault();  // 0

// Use case: пошук за unique key
User? admin = users.SingleOrDefault(u => u.Role == "Admin");
```

### ElementAt / ElementAtOrDefault

Доступ за індексом (працює з `IEnumerable`, не тільки `IList`):

```csharp [ElementAt.cs] showLineNumbers
IEnumerable<int> numbers = GetNumbers(); // Не обов'язково IList!

int third = numbers.ElementAt(2);  // Третій елемент
// int bad = numbers.ElementAt(100); // ArgumentOutOfRangeException

int safe = numbers.ElementAtOrDefault(100); // 0
```

---

## Other Useful Operators

### Any / All

```csharp [AnyAll.cs] showLineNumbers
List<int> numbers = [1, 3, 5, 7, 9];

// Any - чи є хоч один елемент
bool hasElements = numbers.Any();  // true
bool hasEven = numbers.Any(n => n % 2 == 0);  // false

// All - чи всі елементи задовольняють умову
bool allOdd = numbers.All(n => n % 2 != 0);  // true
bool allPositive = numbers.All(n => n > 0);  // true
```

### Take / Skip (Pagination)

```csharp [Pagination.cs] showLineNumbers
List<int> numbers = Enumerable.Range(1, 100).ToList();

// Перші 10
var first10 = numbers.Take(10);

// Пропустити перші 20, взяти наступні 10
var page3 = numbers.Skip(20).Take(10);

// TakeLast / SkipLast (.NET Core 2.0+)
var last5 = numbers.TakeLast(5);

// TakeWhile / SkipWhile
var takeWhileLessThan50 = numbers.TakeWhile(n => n < 50); // 1..49
var skipWhileLessThan50 = numbers.SkipWhile(n => n < 50); // 50..100
```

### Chunk (.NET 6+)

Розбиває колекцію на batches:

```csharp [Chunk.cs] showLineNumbers
int[] numbers = Enumerable.Range(1, 10).ToArray();

// Розбити по 3
var chunks = numbers.Chunk(3);

foreach (var chunk in chunks)
{
    Console.WriteLine(string.Join(", ", chunk));
}
// 1, 2, 3
// 4, 5, 6
// 7, 8, 9
// 10
```

---

## Performance Considerations

### IEnumerable vs IQueryable

-   **`IEnumerable<T>`**: LINQ to Objects, виконується **у пам'яті**
-   **`IQueryable<T>`**: LINQ to SQL/EF, перетворюється на **SQL query**

```csharp
// IEnumerable - ВСІ дані завантажуються, фільтр у C#
IEnumerable<Product> products = dbContext.Products.AsEnumerable();
var expensive = products.Where(p => p.Price > 100); // Фільтр у RAM!

// IQueryable - фільтр перетворюється на SQL
IQueryable<Product> products = dbContext.Products;
var expensive = products.Where(p => p.Price > 100); // SQL: WHERE Price > 100
```

### Multiple Enumeration

```csharp
var query = bigList.Where(expensiveOperation);

// ❌ Погано - виконується двічі
int count = query.Count();
var first10 = query.Take(10).ToList();

// ✅ Добре - закешувати
var materialized = query.ToList();
int count = materialized.Count;
var first10 = materialized.Take(10).ToList();
```

### LINQ vs Loops

LINQ має **невеликий overhead** (delegates, iterators). Для критичних сценаріїв `for` loop швидший:

**Benchmark** (1M елементів):

-   `for` loop: ~2ms
-   LINQ `Where().Select()`: ~15ms
-   **Trade-off**: LINQ читабельніший, maintainable

::tip
Використовуйте LINQ для **business logic**. Для **hot paths** (inner loops, real-time processing) розгляньте `for`/`foreach`.
::

---

## Best Practices

::tip[Рекомендації]

**1. ToList() для caching**

```csharp
// Query виконається тільки раз
var products = expensiveQuery.ToList();
ProcessProducts(products);
DisplayProducts(products);
```

**2. Method syntax для складних queries**

```csharp
// Читабельніше за query syntax
var result = products
    .Where(p => p.InStock)
    .GroupBy(p => p.Category)
    .SelectMany(g => g.OrderByDescending(p => p.Price).Take(3));
```

**3. FirstOrDefault замість First для безпеки**

```csharp
// Безпечно
var user = users.FirstOrDefault(u => u.Id == id);
if (user != null) { ... }

// Ризиковано
var user = users.First(u => u.Id == id); // Може викинути exception
```

**4. Any() замість Count() для існування**

```csharp
// ✅ Ефективно (зупиняється після першого)
if (products.Any(p => p.Price > 1000)) { ... }

// ❌ Неефективно (рахує всі)
if (products.Count(p => p.Price > 1000) > 0) { ... }
```

**5. Не модифікуйте колекцію під час LINQ**

```csharp
// ❌ Погано
foreach (var item in list.Where(x => x.IsOld))
{
    list.Remove(item); // InvalidOperationException!
}

// ✅ Добре
var toRemove = list.Where(x => x.IsOld).ToList();
foreach (var item in toRemove)
{
    list.Remove(item);
}
```

::

---

## Troubleshooting

### InvalidOperationException: Sequence contains no elements

```csharp
// ❌ Проблема
var first = emptyList.First(); // Exception!

// ✅ Рішення
var first = emptyList.FirstOrDefault();
if (first != null) { ... }
```

### InvalidOperationException: Sequence contains more than one element

```csharp
// ❌ Проблема
var user = users.Single(u => u.Role == "Admin"); // Якщо >1 admin

// ✅ Рішення
var user = users.FirstOrDefault(u => u.Role == "Admin");
```

### NullReferenceException в projection

```csharp
// ❌ Проблема
var names = users.Select(u => u.Address.City); // Address може бути null!

// ✅ Рішення
var names = users.Select(u => u.Address?.City ?? "Unknown");
```

---

## Practice Tasks

### Junior: Top 5 Products

Знайдіть топ-5 найдорожчих продуктів категорії "Electronics", відсортованих за ціною.

```csharp
List<Product> products = GetProducts();

var top5 = // Your code here

foreach (var p in top5)
{
    Console.WriteLine($"{p.Name}: ${p.Price}");
}
```

### Middle: Custom Pagination Helper

Створіть extension method `Paginate<T>()`:

```csharp
public static class LinqExtensions
{
    public static IEnumerable<T> Paginate<T>(
        this IEnumerable<T> source,
        int pageNumber,
        int pageSize)
    {
        // Your code here
    }
}

// Usage:
var page2 = products.Paginate(pageNumber: 2, pageSize: 10);
```

### Senior: Custom LINQ Operator - DistinctBy

Реалізуйте `DistinctBy<T, TKey>()` (є в .NET 6, але реалізуйте самостійно):

```csharp
public static IEnumerable<T> DistinctBy<T, TKey>(
    this IEnumerable<T> source,
    Func<T, TKey> keySelector)
{
    // Your code using yield return
}

// Usage:
var uniqueByCategory = products.DistinctBy(p => p.Category);
```

---

## Резюме

::note
**Ключові висновки:**

-   **LINQ** — декларативний підхід до роботи з даними
-   **Deferred execution** — query виконується при ітерації, не при створенні
-   **Method syntax** — універсальніший, query syntax — для складних joins
-   **ToList()** для caching результатів та уникнення multiple enumeration
-   **Performance**: невеликий overhead, але читабельність/maintainability варті того
-   **Operators**: Where, Select, SelectMany, GroupBy, Join, Sum, Max, First...
    ::

**Наступна тема**: [System Internals & Concurrency](../../6.system-internals-concurrency/1.memory-management.md)
