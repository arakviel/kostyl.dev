---
title: Memory Management
description: –ì–ª–∏–±–æ–∫–∏–π —Ä–æ–∑–±—ñ—Ä —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è –ø–∞–º'—è—Ç—Ç—é –≤ .NET - Garbage Collection, IDisposable, Finalizers, WeakReference —Ç–∞ Memory Layout
---

# Memory Management (–£–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è –ü–∞–º'—è—Ç—Ç—é)

## –í—Å—Ç—É–ø —Ç–∞ –ö–æ–Ω—Ç–µ–∫—Å—Ç

### –ü—Ä–æ–±–ª–µ–º–∞: –ß–æ–º—É –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–µ —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è –ø–∞–º'—è—Ç—Ç—é?

–£—è–≤—ñ—Ç—å, —â–æ –≤–∏ –ø–∏—à–µ—Ç–µ –ø—Ä–æ–≥—Ä–∞–º—É –Ω–∞ C –∞–±–æ C++. –í–∏ –≤–∏–¥—ñ–ª—è—î—Ç–µ –ø–∞–º'—è—Ç—å –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é `malloc()` –∞–±–æ `new`, –ø—Ä–∞—Ü—é—î—Ç–µ –∑ –Ω–µ—é, –∞ –ø–æ—Ç—ñ–º... –∑–∞–±—É–≤–∞—î—Ç–µ —ó—ó –∑–≤—ñ–ª—å–Ω–∏—Ç–∏. –†–µ–∑—É–ª—å—Ç–∞—Ç? **Memory leak (–≤–∏—Ç—ñ–∫ –ø–∞–º'—è—Ç—ñ)**. –í–∞—à–∞ –ø—Ä–æ–≥—Ä–∞–º–∞ –ø–æ—Å—Ç—É–ø–æ–≤–æ —Å–ø–æ–∂–∏–≤–∞—î –≤—Å–µ –±—ñ–ª—å—à–µ –ø–∞–º'—è—Ç—ñ, –ø–æ–∫–∏ –æ–ø–µ—Ä–∞—Ü—ñ–π–Ω–∞ —Å–∏—Å—Ç–µ–º–∞ –Ω–µ –≤–∏—Ä—ñ—à–∏—Ç—å –ø—Ä–∏–ø–∏–Ω–∏—Ç–∏ —Ü–µ–π —Ö–∞–æ—Å.

–ó —ñ–Ω—à–æ–≥–æ –±–æ–∫—É, —è–∫—â–æ –≤–∏ –∑–≤—ñ–ª—å–Ω–∏—Ç–µ –ø–∞–º'—è—Ç—å –Ω–∞–¥—Ç–æ —Ä–∞–Ω–æ –∞–±–æ –¥–≤—ñ—á—ñ, –≤–∏ –æ—Ç—Ä–∏–º–∞—î—Ç–µ **dangling pointer (–≤–∏—Å—è—á–∏–π –≤–∫–∞–∑—ñ–≤–Ω–∏–∫)** —Ç–∞ **undefined behavior** - –≤–∞—à–∞ –ø—Ä–æ–≥—Ä–∞–º–∞ –º–æ–∂–µ –≤–ø–∞—Å—Ç–∏ –≤ –±—É–¥—å-—è–∫–∏–π –º–æ–º–µ–Ω—Ç, —á–∞—Å—Ç–æ —É –Ω–∞–π–Ω–µ—Å–ø–æ–¥—ñ–≤–∞–Ω—ñ—à–∏–π.

```cpp
// C++ - —Ä—É—á–Ω–µ —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è –ø–∞–º'—è—Ç—Ç—é
int* CreateArray() {
    int* arr = new int[1000];
    // ... —Ä–æ–±–æ—Ç–∞ –∑ –º–∞—Å–∏–≤–æ–º ...
    delete[] arr;  // –ü–æ—Ç—Ä—ñ–±–Ω–æ –ø–∞–º'—è—Ç–∞—Ç–∏ –∑–≤—ñ–ª—å–Ω–∏—Ç–∏!
    return arr;    // ‚ùå –ü–û–ú–ò–õ–ö–ê: –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ dangling pointer
}

void ProcessData() {
    int* data = new int[500];
    // ... —Å–∫–ª–∞–¥–Ω–∞ –ª–æ–≥—ñ–∫–∞ ...
    if (error) {
        return;  // ‚ùå Memory leak - –∑–∞–±—É–ª–∏ delete[]
    }
    delete[] data;
}
```

::warning
**–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–º–∏–ª–æ–∫**: –ó–∞ –¥–æ—Å–ª—ñ–¥–∂–µ–Ω–Ω—è–º–∏ Microsoft, –±–ª–∏–∑—å–∫–æ 70% –≤—Ä–∞–∑–ª–∏–≤–æ—Å—Ç–µ–π –±–µ–∑–ø–µ–∫–∏ –≤ –ø—Ä–æ–≥—Ä–∞–º–Ω–æ–º—É –∑–∞–±–µ–∑–ø–µ—á–µ–Ω–Ω—ñ –ø–æ–≤'—è–∑–∞–Ω—ñ –∑ –ø–æ–º–∏–ª–∫–∞–º–∏ —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è –ø–∞–º'—è—Ç—Ç—é (use-after-free, buffer overflows, memory corruption).
::

### –ï–≤–æ–ª—é—Ü—ñ—è: –í—ñ–¥ Manual –¥–æ Automatic

**1990-—Ç—ñ —Ä–æ–∫–∏**: –ú–æ–≤–∏ –ø—Ä–æ–≥—Ä–∞–º—É–≤–∞–Ω–Ω—è –≤–∏–º–∞–≥–∞–ª–∏ —Ä—É—á–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è –ø–∞–º'—è—Ç—Ç—é. –†–æ–∑—Ä–æ–±–Ω–∏–∫–∏ –≤–∏—Ç—Ä–∞—á–∞–ª–∏ –∑–Ω–∞—á–Ω—É —á–∞—Å—Ç–∏–Ω—É —á–∞—Å—É –Ω–∞ –≤—ñ–¥–ª–∞–≥–æ–¥–∂–µ–Ω–Ω—è memory leaks —Ç–∞ crashes.

**1995 —Ä—ñ–∫ - Java**: –ü—Ä–µ–¥—Å—Ç–∞–≤–∏–ª–∞ Garbage Collection —è–∫ —Å—Ç–∞–Ω–¥–∞—Ä—Ç –¥–ª—è enterprise-–¥–æ–¥–∞—Ç–∫—ñ–≤. –ü—Ä–æ–¥—É–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å —Ä–æ–∑—Ä–æ–±–∫–∏ –∑—Ä–æ—Å–ª–∞, –∞–ª–µ –∑'—è–≤–∏–≤—Å—è overhead –Ω–∞ runtime.

**2002 —Ä—ñ–∫ - .NET Framework 1.0**: Microsoft —ñ–Ω—Ç–µ–≥—Ä—É–≤–∞–ª–∞ –ø–æ–∫–æ–ª—ñ–Ω–Ω—è GC (Generational Garbage Collector) –∑ –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è–º–∏ –¥–ª—è —Ä—ñ–∑–Ω–∏—Ö —Å—Ü–µ–Ω–∞—Ä—ñ—ó–≤.

**2010+ —Ä–æ–∫–∏**: Continuous improvements - Server GC, Background GC, LOH compaction, —ñ –∑ .NET 5+ –Ω–∞–≤—ñ—Ç—å Pinned Object Heap (POH).

::tip
**–§—ñ–ª–æ—Å–æ—Ñ—ñ—è .NET**: "–ë–µ–∑–ø–µ–∫–∞ —Ç–∞ –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å —Ä–∞–∑–æ–º". –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–µ —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è –ø–∞–º'—è—Ç—Ç—é –∑–∞–±–µ–∑–ø–µ—á—É—î memory safety –±–µ–∑ –∫—Ä–∏—Ç–∏—á–Ω–æ—ó –≤—Ç—Ä–∞—Ç–∏ —à–≤–∏–¥–∫–æ—Å—Ç—ñ –∑–∞–≤–¥—è–∫–∏ —Ä–æ–∑—É–º–Ω–∏–º –∞–ª–≥–æ—Ä–∏—Ç–º–∞–º —Ç–∞ –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è–º JIT.
::

### –©–æ –≤–∏ –¥—ñ–∑–Ω–∞—î—Ç–µ—Å—å

–ü—ñ—Å–ª—è —Ü—å–æ–≥–æ —Ä–æ–∑–¥—ñ–ª—É –≤–∏ –∑–º–æ–∂–µ—Ç–µ:

-   üß† **–†–æ–∑—É–º—ñ—Ç–∏ –∞—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä—É**: –Ø–∫ CLR –æ—Ä–≥–∞–Ω—ñ–∑–æ–≤—É—î managed heap, —â–æ —Ç–∞–∫–µ –ø–æ–∫–æ–ª—ñ–Ω–Ω—è, —á–æ–º—É —ñ—Å–Ω—É—î LOH/SOH/POH
-   üîç **–ê–Ω–∞–ª—ñ–∑—É–≤–∞—Ç–∏ "–ø—ñ–¥ –∫–∞–ø–æ—Ç–æ–º"**: –Ø–∫ –ø—Ä–∞—Ü—é—î marking-sweeping-compaction, —â–æ –≤—ñ–¥–±—É–≤–∞—î—Ç—å—Å—è –ø—ñ–¥ —á–∞—Å GC
-   üõ°Ô∏è **–£–ø—Ä–∞–≤–ª—è—Ç–∏ –Ω–µker–æ–≤–∞–Ω–∏–º–∏ —Ä–µ—Å—É—Ä—Å–∞–º–∏**: –ü—Ä–∞–≤–∏–ª—å–Ω–æ —Ä–µ–∞–ª—ñ–∑–æ–≤—É–≤–∞—Ç–∏ `IDisposable`, —Ä–æ–∑—É–º—ñ—Ç–∏ —Ä—ñ–∑–Ω–∏—Ü—é –º—ñ–∂ Dispose —Ç–∞ Finalizer
-   ‚ö° **–û–ø—Ç–∏–º—ñ–∑—É–≤–∞—Ç–∏ –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å**: –ó–Ω–∞—Ç–∏, –∫–æ–ª–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ `WeakReference`, —è–∫ —É–Ω–∏–∫–∞—Ç–∏ LOH —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞—Ü—ñ—ó, —è–∫ –Ω–∞–ª–∞—à—Ç—É–≤–∞—Ç–∏ GC mode
-   üî¨ **–†–æ–∑–±–∏—Ä–∞—Ç–∏—Å—å —É memory layout**: –†–æ–∑—É–º—ñ—Ç–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—É –æ–±'—î–∫—Ç—ñ–≤ —É –ø–∞–º'—è—Ç—ñ, padding, alignment, overhead

### Prerequisites (–ü–µ—Ä–µ–¥—É–º–æ–≤–∏)

–ü–µ—Ä–µ–¥ –≤–∏–≤—á–µ–Ω–Ω—è–º —Ü—ñ—î—ó —Ç–µ–º–∏ –ø–µ—Ä–µ–∫–æ–Ω–∞–π—Ç–µ—Å—å, —â–æ –≤–∏ —Ä–æ–∑—É–º—ñ—î—Ç–µ:

-   ‚úÖ [Value Types vs Reference Types](/csharp/fundamentals/variables-data-types#value-reference-types)
-   ‚úÖ [Stack vs Heap](/csharp/fundamentals/variables-data-types#memory-allocation)
-   ‚úÖ [Classes and Objects](/csharp/oop/classes-objects)
-   ‚úÖ –ë–∞–∑–æ–≤—ñ –∫–æ–Ω—Ü–µ–ø—Ü—ñ—ó –û–û–ü (–Ω–∞—Å–ª—ñ–¥—É–≤–∞–Ω–Ω—è, —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∏)

---

## –§—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ñ –ö–æ–Ω—Ü–µ–ø—Ü—ñ—ó

### Managed Heap (–ö–µ—Ä–æ–≤–∞–Ω–∞ –ö—É–ø–∞)

–ö–æ–ª–∏ –≤–∞—à .NET –¥–æ–¥–∞—Ç–æ–∫ —Å—Ç–∞—Ä—Ç—É—î, CLR (Common Language Runtime) —Ä–µ–∑–µ—Ä–≤—É—î –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω—É –æ–±–ª–∞—Å—Ç—å –≤—ñ—Ä—Ç—É–∞–ª—å–Ω–æ—ó –ø–∞–º'—è—Ç—ñ, —è–∫–∞ –Ω–∞–∑–∏–≤–∞—î—Ç—å—Å—è **managed heap**. –¶–µ –Ω–µ —Ñ—ñ–∑–∏—á–Ω–∞ –ø–∞–º'—è—Ç—å, –∞ –≤—ñ—Ä—Ç—É–∞–ª—å–Ω–∏–π –∞–¥—Ä–µ—Å–Ω–∏–π –ø—Ä–æ—Å—Ç—ñ—Ä, —è–∫–∏–π –æ–ø–µ—Ä–∞—Ü—ñ–π–Ω–∞ —Å–∏—Å—Ç–µ–º–∞ –≤–∏–¥—ñ–ª—è—î –ø—Ä–æ—Ü–µ—Å—É.

::mermaid

```mermaid
graph LR
    A[Process Start] --> B[CLR Initialize]
    B --> C[Reserve Virtual Memory]
    C --> D[Managed Heap Created]
    D --> E[Allocation Pointer at Base]

    style A fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style D fill:#f59e0b,stroke:#b45309,color:#ffffff
    style E fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
```

::

#### –Ø–∫ –ø—Ä–∞—Ü—é—î –∞–ª–æ–∫–∞—Ü—ñ—è

Managed heap –ø—ñ–¥—Ç—Ä–∏–º—É—î **allocation pointer** (–≤–∫–∞–∑—ñ–≤–Ω–∏–∫ –Ω–∞ –Ω–∞—Å—Ç—É–ø–Ω—É –≤—ñ–ª—å–Ω—É –ø–æ–∑–∏—Ü—ñ—é). –ö–æ–ª–∏ –≤–∏ —Å—Ç–≤–æ—Ä—é—î—Ç–µ –Ω–æ–≤–∏–π –æ–±'—î–∫—Ç:

```csharp
var person = new Person("John", 30);
```

CLR –≤–∏–∫–æ–Ω—É—î –Ω–∞—Å—Ç—É–ø–Ω—ñ –∫—Ä–æ–∫–∏:

::steps

### –ö—Ä–æ–∫ 1: –û–±—á–∏—Å–ª–µ–Ω–Ω—è —Ä–æ–∑–º—ñ—Ä—É

–í–∏–∑–Ω–∞—á–∞—î—Ç—å—Å—è —Å–∫—ñ–ª—å–∫–∏ –±–∞–π—Ç—ñ–≤ –ø–æ—Ç—Ä—ñ–±–Ω–æ –¥–ª—è –æ–±'—î–∫—Ç–∞:

-   Object header (8-16 –±–∞–π—Ç –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ –ø–ª–∞—Ç—Ñ–æ—Ä–º–∏)
-   Method table pointer (4-8 –±–∞–π—Ç)
-   –†–æ–∑–º—ñ—Ä –≤—Å—ñ—Ö –ø–æ–ª—ñ–≤ –µ–∫–∑–µ–º–ø–ª—è—Ä–∞
-   Padding –¥–ª—è alignment

### –ö—Ä–æ–∫ 2: –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ –ø—Ä–æ—Å—Ç–æ—Ä—É

CLR –ø–µ—Ä–µ–≤—ñ—Ä—è—î, —á–∏ —î –¥–æ—Å—Ç–∞—Ç–Ω—å–æ –º—ñ—Å—Ü—è –≤—ñ–¥ –ø–æ—Ç–æ—á–Ω–æ–≥–æ allocation pointer –¥–æ –∫—ñ–Ω—Ü—è Gen0.

### –ö—Ä–æ–∫ 3: –†–æ–∑–º—ñ—â–µ–Ω–Ω—è –æ–±'—î–∫—Ç–∞

–Ø–∫—â–æ –º—ñ—Å—Ü–µ —î:

-   –û–±'—î–∫—Ç –∫–æ–ø—ñ—é—î—Ç—å—Å—è –∑–∞ –∞–¥—Ä–µ—Å–æ—é allocation pointer
-   Allocation pointer –∑–º—ñ—â—É—î—Ç—å—Å—è –Ω–∞ —Ä–æ–∑–º—ñ—Ä –æ–±'—î–∫—Ç–∞
-   –ü–æ–≤–µ—Ä—Ç–∞—î—Ç—å—Å—è —Ä–µ—Ñ–µ—Ä–µ–Ω—Å –Ω–∞ –Ω–æ–≤–∏–π –æ–±'—î–∫—Ç

### –ö—Ä–æ–∫ 4: –¢—Ä–∏–≥–µ—Ä GC (—è–∫—â–æ –ø–æ—Ç—Ä—ñ–±–Ω–æ)

–Ø–∫—â–æ –º—ñ—Å—Ü—è –Ω–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ, —Å–ø—Ä–∞—Ü—å–æ–≤—É—î Garbage Collection –¥–ª—è –∑–≤—ñ–ª—å–Ω–µ–Ω–Ω—è –ø–∞–º'—è—Ç—ñ.
::

```csharp
// –ü—Å–µ–≤–¥–æ–∫–æ–¥ —Ä–æ–±–æ—Ç–∏ CLR –ø—Ä–∏ –∞–ª–æ–∫–∞—Ü—ñ—ó
object AllocateObject(Type type)
{
    int size = CalculateSize(type);  // –†–æ–∑–º—ñ—Ä –∑ header + fields + padding

    if (allocationPointer + size > gen0End)
    {
        // –ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –º—ñ—Å—Ü—è - –∑–∞–ø—É—Å–∫–∞—î–º–æ GC
        GC.Collect(0);  // –ó–±–∏—Ä–∞—î–º–æ Gen0

        if (allocationPointer + size > gen0End)
        {
            // –í—Å–µ —â–µ –Ω–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ - —Ä–æ–∑—à–∏—Ä—é—î–º–æ heap
            ExpandHeap();
        }
    }

    // –†–æ–∑–º—ñ—â—É—î–º–æ –æ–±'—î–∫—Ç
    void* address = allocationPointer;
    InitializeObject(address, type);
    allocationPointer += size;

    return (object)address;
}
```

::note
**–®–≤–∏–¥–∫—ñ—Å—Ç—å –∞–ª–æ–∫–∞—Ü—ñ—ó**: –£ managed heap –∞–ª–æ–∫–∞—Ü—ñ—è –æ–±'—î–∫—Ç–∞ - —Ü–µ –ø—Ä–æ—Å—Ç–æ –¥–æ–¥–∞–≤–∞–Ω–Ω—è –∑–Ω–∞—á–µ–Ω–Ω—è –¥–æ –≤–∫–∞–∑—ñ–≤–Ω–∏–∫–∞, —â–æ –º–∞–π–∂–µ —Ç–∞–∫ —Å–∞–º–æ —à–≤–∏–¥–∫–æ, —è–∫ –∞–ª–æ–∫–∞—Ü—ñ—è –Ω–∞ —Å—Ç–µ–∫—É! –¶–µ –∫–æ–Ω—Ç—Ä–∞—Å—Ç—É—î –∑ `malloc()` —É C, —è–∫–∏–π –ø–æ–≤–∏–Ω–µ–Ω —à—É–∫–∞—Ç–∏ –≤—ñ–ª—å–Ω–∏–π –±–ª–æ–∫ —É —Å–∫–ª–∞–¥–Ω–∏—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä–∞—Ö –¥–∞–Ω–∏—Ö.
::

### Stack vs Heap: –î–µ—Ç–∞–ª—å–Ω–µ –ü–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è

| –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞        | Stack (–°—Ç–µ–∫)                                    | Heap (–ö—É–ø–∞)                                            |
| :-------------------- | :---------------------------------------------- | :----------------------------------------------------- |
| **–©–æ –∑–±–µ—Ä—ñ–≥–∞—î—Ç—å—Å—è**   | Value types, –ª–æ–∫–∞–ª—å–Ω—ñ –∑–º—ñ–Ω–Ω—ñ, –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –º–µ—Ç–æ–¥—ñ–≤ | Reference types (–æ–±'—î–∫—Ç–∏ –∫–ª–∞—Å—ñ–≤, –º–∞—Å–∏–≤–∏, strings)      |
| **–†–æ–∑–º—ñ—Ä**            | –û–±–º–µ–∂–µ–Ω–∏–π (1-4 MB –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º)             | –û–±–º–µ–∂–µ–Ω–∏–π —Ç—ñ–ª—å–∫–∏ –¥–æ—Å—Ç—É–ø–Ω–æ—é RAM —Ç–∞ –≤—ñ—Ä—Ç—É–∞–ª—å–Ω–æ—é –ø–∞–º'—è—Ç—Ç—é |
| **–®–≤–∏–¥–∫—ñ—Å—Ç—å –¥–æ—Å—Ç—É–ø—É** | –î—É–∂–µ —à–≤–∏–¥–∫–æ (CPU cache-friendly)                | –ü–æ–≤—ñ–ª—å–Ω—ñ—à–µ (–ø–æ—Ç—Ä—ñ–±–Ω–∞ —ñ–Ω–¥–∏—Ä–µ–∫—Ü—ñ—è —á–µ—Ä–µ–∑ —Ä–µ—Ñ–µ—Ä–µ–Ω—Å)        |
| **–ß–∞—Å –∂–∏—Ç—Ç—è**         | –î–æ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –º–µ—Ç–æ–¥—É (scope-based)              | –î–æ –∑–±–æ—Ä—É GC (–Ω–µ–¥–æ—Å—è–∂–Ω—ñ –æ–±'—î–∫—Ç–∏)                        |
| **–ê–ª–æ–∫–∞—Ü—ñ—è**          | –ü–µ—Ä–µ–º—ñ—â–µ–Ω–Ω—è stack pointer                       | –ü–µ—Ä–µ–º—ñ—â–µ–Ω–Ω—è allocation pointer + –º–æ–∂–ª–∏–≤–∏–π GC           |
| **–î–µ–∞–ª–æ–∫–∞—Ü—ñ—è**        | –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –ø—Ä–∏ –≤–∏—Ö–æ–¥—ñ –∑ scope                  | –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ GC (–Ω–µ–¥–µ—Ç–µ—Ä–º—ñ–Ω–æ–≤–∞–Ω–æ)                       |
| **–§—Ä–∞–≥–º–µ–Ω—Ç–∞—Ü—ñ—è**      | –ù–µ–º–æ–∂–ª–∏–≤–∞ (LIFO —Å—Ç—Ä—É–∫—Ç—É—Ä–∞)                      | –ú–æ–∂–ª–∏–≤–∞ (—Ä–æ–∑–≤'—è–∑—É—î—Ç—å—Å—è compaction)                     |
| **Thread safety**     | –ö–æ–∂–µ–Ω thread –º–∞—î —Å–≤—ñ–π stack                     | Shared –º—ñ–∂ threads (–ø–æ—Ç—Ä—ñ–±–Ω–∞ —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—è)            |

```csharp {1,4,9,12} showLineNumbers
void StackVsHeapDemo()
{
    // Stack: value type
    int x = 42;  // 4 –±–∞–π—Ç–∏ –Ω–∞ —Å—Ç–µ–∫—É

    // Stack: struct (—è–∫—â–æ –Ω–µ boxed)
    Point p = new Point(10, 20);  // 8 –±–∞–π—Ç –Ω–∞ —Å—Ç–µ–∫—É

    // Heap: reference type
    Person person = new Person();  // –†–µ—Ñ–µ—Ä–µ–Ω—Å (4/8 –±–∞–π—Ç) –Ω–∞ —Å—Ç–µ–∫—É
                                    // –û–±'—î–∫—Ç –Ω–∞ heap

    // Heap: boxing
    object boxedX = x;  // –°—Ç–≤–æ—Ä—é—î –æ–±'—î–∫—Ç –Ω–∞ heap –∑ –∑–Ω–∞—á–µ–Ω–Ω—è–º 42

} // <-- –ü—Ä–∏ –≤–∏—Ö–æ–¥—ñ: stack –æ—á–∏—â—É—î—Ç—å—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ
  //     Heap –æ–±'—î–∫—Ç–∏ —Å—Ç–∞—é—Ç—å eligible for GC
```

::mermaid

```mermaid
graph TD
    subgraph Stack
        A[Method Frame] --> B[int x = 42]
        A --> C[Point p struct]
        A --> D[Person person reference]
    end

    subgraph Heap
        E[Person Object]
        F[Boxed int Object]
    end

    D -->|points to| E

    style A fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style E fill:#f59e0b,stroke:#b45309,color:#ffffff
    style F fill:#f59e0b,stroke:#b45309,color:#ffffff
```

::

### Value Types vs Reference Types —É –ö–æ–Ω—Ç–µ–∫—Å—Ç—ñ –ü–∞–º'—è—Ç—ñ

#### Value Types (–¢–∏–ø–∏ –ó–Ω–∞—á–µ–Ω—å)

–ó–±–µ—Ä—ñ–≥–∞—é—Ç—å—Å—è **inline** - –±–µ–∑–ø–æ—Å–µ—Ä–µ–¥–Ω—å–æ —Ç–∞–º, –¥–µ –æ–≥–æ–ª–æ—à–µ–Ω—ñ:

```csharp
struct Point
{
    public int X;  // 4 –±–∞–π—Ç–∏
    public int Y;  // 4 –±–∞–π—Ç–∏
    // –ó–∞–≥–∞–ª–æ–º: 8 –±–∞–π—Ç
}

class Container
{
    public int id;        // 4 –±–∞–π—Ç–∏ inline –≤ –æ–±'—î–∫—Ç—ñ
    public Point point;   // 8 –±–∞–π—Ç inline –≤ –æ–±'—î–∫—Ç—ñ
    // –ó–∞–≥–∞–ª–æ–º –≤ –æ–±'—î–∫—Ç—ñ: Object Header + MethodTable + 4 + 8 = ~28-40 –±–∞–π—Ç
}

void Method()
{
    Point p;  // 8 –±–∞–π—Ç –Ω–∞ —Å—Ç–µ–∫—É
    Container c = new Container();  // –†–µ—Ñ–µ—Ä–µ–Ω—Å –Ω–∞ —Å—Ç–µ–∫—É, –æ–±'—î–∫—Ç –Ω–∞ heap
}
```

#### Reference Types (–¢–∏–ø–∏ –ü–æ—Å–∏–ª–∞–Ω—å)

–ó–±–µ—Ä—ñ–≥–∞—é—Ç—å—Å—è —Ç—ñ–ª—å–∫–∏ –Ω–∞ heap. –ó–º—ñ–Ω–Ω–∞ –º—ñ—Å—Ç–∏—Ç—å **—Ä–µ—Ñ–µ—Ä–µ–Ω—Å** (–∞–¥—Ä–µ—Å—É):

```csharp
class Person
{
    public string Name;  // –†–µ—Ñ–µ—Ä–µ–Ω—Å –Ω–∞ string (—è–∫–∏–π —Ç–µ–∂ –Ω–∞ heap)
    public int Age;      // 4 –±–∞–π—Ç–∏ inline
}

Person p1 = new Person();  // Heap: Person –æ–±'—î–∫—Ç
Person p2 = p1;            // Stack: –æ–±–∏–¥–≤—ñ –∑–º—ñ–Ω–Ω—ñ –≤–∫–∞–∑—É—é—Ç—å –Ω–∞ –û–î–ò–ù –æ–±'—î–∫—Ç

p2.Age = 30;
Console.WriteLine(p1.Age);  // 30 - –∑–º—ñ–Ω–∏–ª–∏ —á–µ—Ä–µ–∑ p2, –∞–ª–µ p1 –±–∞—á–∏—Ç—å –∑–º—ñ–Ω–∏!
```

::warning
**–¢–∏–ø–æ–≤–∞ –ø–æ–º–∏–ª–∫–∞**: –ü—Ä–æ–≥—Ä–∞–º—ñ—Å—Ç–∏, —è–∫—ñ –ø—Ä–∏–π—à–ª–∏ –∑ C/C++, —á–∞—Å—Ç–æ –ø–ª—É—Ç–∞—é—Ç—å —Ä–µ—Ñ–µ—Ä–µ–Ω—Å–∏ –≤ C# –∑ –≤–∫–∞–∑—ñ–≤–Ω–∏–∫–∞–º–∏. –†–µ—Ñ–µ—Ä–µ–Ω—Å–∏ –≤ C# –±–µ–∑–ø–µ—á–Ω—ñ—à—ñ - –≤–∏ –Ω–µ –º–æ–∂–µ—Ç–µ –≤–∏–∫–æ–Ω—É–≤–∞—Ç–∏ pointer arithmetic, —ñ –≤–æ–Ω–∏ –∑–∞–≤–∂–¥–∏ –≤–∫–∞–∑—É—é—Ç—å –Ω–∞ –≤–∞–ª—ñ–¥–Ω–∏–π –æ–±'—î–∫—Ç –∞–±–æ `null`.
::

### Boxing —Ç–∞ Unboxing: –í–ø–ª–∏–≤ –Ω–∞ GC

**Boxing** - —Ü–µ –ø—Ä–æ—Ü–µ—Å –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è value type —É reference type (–∞–ª–æ–∫–∞—Ü—ñ—è –Ω–∞ heap).

```csharp
int value = 42;           // Stack: 4 –±–∞–π—Ç–∏
object boxed = value;     // Heap: —Å—Ç–≤–æ—Ä—é—î—Ç—å—Å—è –æ–±'—î–∫—Ç Int32 –∑ value 42
                          // Stack: —Ä–µ—Ñ–µ—Ä–µ–Ω—Å –Ω–∞ —Ü–µ–π –æ–±'—î–∫—Ç

// Unboxing - –∑–≤–æ—Ä–æ—Ç–Ω—ñ–π –ø—Ä–æ—Ü–µ—Å
int unboxed = (int)boxed; // –ö–æ–ø—ñ—é–≤–∞–Ω–Ω—è –∑–Ω–∞—á–µ–Ω–Ω—è –∑ heap –Ω–∞ stack
```

::mermaid

```mermaid
sequenceDiagram
    participant Stack
    participant Heap as Managed Heap
    participant GC as Garbage Collector

    Note over Stack: int value = 42
    Stack->>Stack: Allocate 4 bytes

    Note over Stack,Heap: object boxed = value
    Stack->>Heap: Request boxing
    Heap->>Heap: Allocate Int32 object
    Heap->>Heap: Copy value 42
    Heap-->>Stack: Return reference

    Note over GC: Boxed object —Ç–µ–ø–µ—Ä –ø—ñ–¥ —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è–º GC

    Note over Stack: int unboxed = (int)boxed
    Stack->>Heap: Read value from boxed object
    Heap-->>Stack: Copy value 42

    Note over GC: –Ø–∫—â–æ –Ω–µ–º–∞—î —ñ–Ω—à–∏—Ö refs –¥–æ boxed<br/>–æ–±'—î–∫—Ç eligible for collection

    style Stack fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style Heap fill:#f59e0b,stroke:#b45309,color:#ffffff
    style GC fill:#64748b,stroke:#334155,color:#ffffff
```

::

**Performance implications**:

```csharp
// ‚ùå –ü–æ–≥–∞–Ω–æ: Boxing —É —Ü–∏–∫–ª—ñ
List<object> items = new List<object>();
for (int i = 0; i < 10000; i++)
{
    items.Add(i);  // 10000 boxing –æ–ø–µ—Ä–∞—Ü—ñ–π = 10000 heap –∞–ª–æ–∫–∞—Ü—ñ–π!
}

// ‚úÖ –î–æ–±—Ä–µ: –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è generic –∫–æ–ª–µ–∫—Ü—ñ—ó
List<int> items = new List<int>();
for (int i = 0; i < 10000; i++)
{
    items.Add(i);  // –ë–µ–∑ boxing, –∑–±–µ—Ä—ñ–≥–∞—î—Ç—å—Å—è inline
}
```

::tip
**–ö–æ–ª–∏ –≤—ñ–¥–±—É–≤–∞—î—Ç—å—Å—è boxing:**

-   –ü—Ä–∏—Å–≤–æ—î–Ω–Ω—è value type –¥–æ `object` –∞–±–æ `interface`
-   –í–∏–∫–ª–∏–∫ `ToString()`, `GetHashCode()`, `Equals()` –Ω–∞ value type
-   –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è value type —É non-generic –∫–æ–ª–µ–∫—Ü—ñ—è—Ö (`ArrayList`, `Hashtable`)
-   LINQ –∑–∞–ø–∏—Ç–∏ –Ω–∞–¥ collections value types (—è–∫—â–æ –Ω–µ –æ–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω—ñ)
    ::

---

## Garbage Collection: –°–µ—Ä—Ü–µ –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ–≥–æ –£–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è

### –©–æ —Ç–∞–∫–µ Garbage Collector?

**Garbage Collector (GC)** - —Ü–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç CLR, —è–∫–∏–π –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∫–µ—Ä—É—î –ø–∞–º'—è—Ç—Ç—é —É managed heap. –ô–æ–≥–æ –æ—Å–Ω–æ–≤–Ω—ñ –∑–∞–≤–¥–∞–Ω–Ω—è:

1. **–í–∏–∑–Ω–∞—á–∏—Ç–∏ –Ω–µ–¥–æ—Å—è–∂–Ω—ñ –æ–±'—î–∫—Ç–∏** (garbage)
2. **–ó–≤—ñ–ª—å–Ω–∏—Ç–∏ –ø–∞–º'—è—Ç—å**, —è–∫—É –≤–æ–Ω–∏ –∑–∞–π–º–∞—é—Ç—å
3. **–ö–æ–º–ø–∞–∫—Ç—É–≤–∞—Ç–∏ heap** –¥–ª—è –µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–≥–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –ø–∞–º'—è—Ç—ñ

::note
**–¢–µ—Ä–º—ñ–Ω–æ–ª–æ–≥—ñ—è**: –û–±'—î–∫—Ç –≤–≤–∞–∂–∞—î—Ç—å—Å—è "garbage" (—Å–º—ñ—Ç—Ç—è–º), —è–∫—â–æ –¥–æ –Ω—å–æ–≥–æ –Ω–µ–º–∞—î –∂–æ–¥–Ω–∏—Ö "–∂–∏–≤–∏—Ö" –ø–æ—Å–∏–ª–∞–Ω—å –≤—ñ–¥ roots (–ª–æ–∫–∞–ª—å–Ω—ñ –∑–º—ñ–Ω–Ω—ñ, —Å—Ç–∞—Ç–∏—á–Ω—ñ –ø–æ–ª—è, CPU registers, finalization queue).
::

### –§–∞–∑–∏ Garbage Collection

GC –ø—Ä–∞—Ü—é—î —É —Ç—Ä–∏ –æ—Å–Ω–æ–≤–Ω—ñ —Ñ–∞–∑–∏:

::mermaid

```mermaid
graph TD
    A[GC Triggered] --> B[Phase 1: Marking]
    B --> C[Phase 2: Compacting]
    C --> D[Phase 3: Updating References]
    D --> E[GC Complete]

    B1[Identify Roots] --> B2[Walk Object Graph]
    B2 --> B3[Mark Reachable Objects]

    C1[Determine Live Objects] --> C2[Move to Beginning of Heap]
    C2 --> C3[Free Space at End]

    D1[Update All References] --> D2[Point to New Addresses]

    B --> B1
    B1 --> B2
    B2 --> B3

    C --> C1
    C1 --> C2
    C2 --> C3

    D --> D1
    D1 --> D2

    style A fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style B fill:#f59e0b,stroke:#b45309,color:#ffffff
    style C fill:#f59e0b,stroke:#b45309,color:#ffffff
    style D fill:#f59e0b,stroke:#b45309,color:#ffffff
    style E fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
```

::

#### Phase 1: Marking (–ú–∞—Ä–∫—É–≤–∞–Ω–Ω—è)

GC –ø—Ä–æ—Ö–æ–¥–∏—Ç—å –≥—Ä–∞—Ñ –æ–±'—î–∫—Ç—ñ–≤, –ø–æ—á–∏–Ω–∞—é—á–∏ –∑ **roots** —Ç–∞ –ø–æ–∑–Ω–∞—á–∞—î –≤—Å—ñ –¥–æ—Å—è–∂–Ω—ñ –æ–±'—î–∫—Ç–∏:

```csharp
class Node
{
    public Node Next;
    public string Data;
}

void Example()
{
    Node head = new Node { Data = "A" };  // Root
    head.Next = new Node { Data = "B" };
    head.Next.Next = new Node { Data = "C" };
    Node orphan = new Node { Data = "X" };  // –ù–µ–¥–æ—Å—è–∂–Ω–∏–π –ø—ñ—Å–ª—è –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ —Ä—è–¥–∫–∞
    orphan = null;

    // GC marking:
    // 1. –ó–Ω–∞–π—Ç–∏ roots: head (–ª–æ–∫–∞–ª—å–Ω–∞ –∑–º—ñ–Ω–Ω–∞)
    // 2. –ú–∞—Ä–∫—É–≤–∞—Ç–∏ Node "A" —è–∫ reachable
    // 3. –°–ª—ñ–¥—É–≤–∞—Ç–∏ –∑–∞ Next, –º–∞—Ä–∫—É–≤–∞—Ç–∏ "B"
    // 4. –°–ª—ñ–¥—É–≤–∞—Ç–∏ –∑–∞ Next, –º–∞—Ä–∫—É–≤–∞—Ç–∏ "C"
    // 5. Node "X" –Ω–µ –º–∞—Ä–∫–æ–≤–∞–Ω–∏–π -> garbage
}
```

**Roots –≤–∫–ª—é—á–∞—é—Ç—å:**

-   –õ–æ–∫–∞–ª—å–Ω—ñ –∑–º—ñ–Ω–Ω—ñ —É –∞–∫—Ç–∏–≤–Ω–∏—Ö –º–µ—Ç–æ–¥–∞—Ö (–Ω–∞ stack)
-   –°—Ç–∞—Ç–∏—á–Ω—ñ –ø–æ–ª—è
-   CPU registers
-   GC handles
-   Finalization queue

#### Phase 2: Compacting (–ö–æ–º–ø–∞–∫—Ç—É–≤–∞–Ω–Ω—è)

–ü—ñ—Å–ª—è marking GC **–ø–µ—Ä–µ–º—ñ—â—É—î** –≤—Å—ñ –∂–∏–≤—ñ –æ–±'—î–∫—Ç–∏ –¥–æ –ø–æ—á–∞—Ç–∫—É heap, —É—Å—É–≤–∞—é—á–∏ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞—Ü—ñ—é:

```
Before Compaction:
[Obj A][    ][Obj B][        ][Obj C][    ]
 ^live  ^dead ^live   ^dead   ^live  ^dead

After Compaction:
[Obj A][Obj B][Obj C][                    ]
                      ^ Free space for new objects
```

::warning
**Performance Impact**: Compaction –≤–∏–º–∞–≥–∞—î –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è –æ–±'—î–∫—Ç—ñ–≤ —É –ø–∞–º'—è—Ç—ñ —Ç–∞ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –≤—Å—ñ—Ö –ø–æ—Å–∏–ª–∞–Ω—å. –¶–µ –º–æ–∂–µ –±—É—Ç–∏ expensive –æ–ø–µ—Ä–∞—Ü—ñ—è –¥–ª—è –≤–µ–ª–∏–∫–∏—Ö heaps, —Ç–æ–º—É GC –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î –ø–æ–∫–æ–ª—ñ–Ω–Ω—è –¥–ª—è –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—ó.
::

#### Phase 3: Updating References (–û–Ω–æ–≤–ª–µ–Ω–Ω—è –ü–æ—Å–∏–ª–∞–Ω—å)

–ü—ñ—Å–ª—è –ø–µ—Ä–µ–º—ñ—â–µ–Ω–Ω—è –æ–±'—î–∫—Ç—ñ–≤ GC –æ–Ω–æ–≤–ª—é—î –≤—Å—ñ –ø–æ—Å–∏–ª–∞–Ω–Ω—è –Ω–∞ –Ω–æ–≤—ñ –∞–¥—Ä–µ—Å–∏:

```csharp
// –î–æ compaction
Node n1 = /* 0x1000 */;
Node n2 = /* 0x2000 */;
n1.Next = n2;  // Next –≤–∫–∞–∑—É—î –Ω–∞ 0x2000

// –ü—ñ—Å–ª—è compaction
// n2 –ø–µ—Ä–µ–º—ñ—â–µ–Ω–∏–π –Ω–∞ 0x1100
// GC –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –æ–Ω–æ–≤–ª—é—î:
n1.Next = /* —Ç–µ–ø–µ—Ä 0x1100 */;
```

### –ü–æ–∫–æ–ª—ñ–Ω–Ω—è (Generations): –û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è —á–µ—Ä–µ–∑ –°–ø–æ—Å—Ç–µ—Ä–µ–∂–µ–Ω–Ω—è

#### Generational Hypothesis (–ì—ñ–ø–æ—Ç–µ–∑–∞ –ü–æ–∫–æ–ª—ñ–Ω—å)

.NET GC –±–∞–∑—É—î—Ç—å—Å—è –Ω–∞ –µ–º–ø—ñ—Ä–∏—á–Ω–æ–º—É —Å–ø–æ—Å—Ç–µ—Ä–µ–∂–µ–Ω–Ω—ñ:

> **–ë—ñ–ª—å—à—ñ—Å—Ç—å –æ–±'—î–∫—Ç—ñ–≤ –∂–∏–≤—É—Ç—å –¥—É–∂–µ –∫–æ—Ä–æ—Ç–∫–æ, –∞ —Ç—ñ —â–æ –≤–∏–∂–∏–≤–∞—é—Ç—å - –∂–∏–≤—É—Ç—å –¥–æ–≤–≥–æ.**

–¶–µ –æ–∑–Ω–∞—á–∞—î:

-   üÜï –ù–µ—â–æ–¥–∞–≤–Ω–æ —Å—Ç–≤–æ—Ä–µ–Ω—ñ –æ–±'—î–∫—Ç–∏ —à–≤–∏–¥—à–µ –∑–∞ –≤—Å–µ —Å—Ç–∞–Ω—É—Ç—å garbage
-   ‚è≥ –û–±'—î–∫—Ç–∏, —è–∫—ñ –ø–µ—Ä–µ–∂–∏–ª–∏ –¥–µ–∫—ñ–ª—å–∫–∞ GC —Ü–∏–∫–ª—ñ–≤, –π–º–æ–≤—ñ—Ä–Ω–æ –±—É–¥—É—Ç—å –∂–∏—Ç–∏ –¥–æ–≤–≥–æ

–ù–∞ –æ—Å–Ω–æ–≤—ñ —Ü—å–æ–≥–æ —Å–ø–æ—Å—Ç–µ—Ä–µ–∂–µ–Ω–Ω—è .NET –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î **—Ç—Ä–∏ –ø–æ–∫–æ–ª—ñ–Ω–Ω—è**:

| –ü–æ–∫–æ–ª—ñ–Ω–Ω—è | –ü—Ä–∏–∑–Ω–∞—á–µ–Ω–Ω—è           | –¢–∏–ø–æ–≤—ñ –û–±'—î–∫—Ç–∏                                  | –ß–∞—Å—Ç–æ—Ç–∞ –ó–±–æ—Ä—É  |
| :-------- | :-------------------- | :---------------------------------------------- | :------------- |
| **Gen0**  | –ú–æ–ª–æ–¥—ñ –æ–±'—î–∫—Ç–∏        | –¢–∏–º—á–∞—Å–æ–≤—ñ –∑–º—ñ–Ω–Ω—ñ, –±—É—Ñ–µ—Ä–∏, –∫–æ—Ä–æ—Ç–∫–æ–∂–∏–≤—É—á—ñ –æ–±'—î–∫—Ç–∏ | –î—É–∂–µ —á–∞—Å—Ç–æ     |
| **Gen1**  | –ë—É—Ñ–µ—Ä –º—ñ–∂ Gen0 —ñ Gen2 | –û–±'—î–∫—Ç–∏ —Å–µ—Ä–µ–¥–Ω—å–æ—ó —Ç—Ä–∏–≤–∞–ª–æ—Å—Ç—ñ –∂–∏—Ç—Ç—è              | –†—ñ–¥—à–µ –Ω—ñ–∂ Gen0 |
| **Gen2**  | –°—Ç–∞—Ä—ñ –æ–±'—î–∫—Ç–∏         | –°—Ç–∞—Ç–∏—á–Ω—ñ –¥–∞–Ω—ñ, –¥–æ–≤–≥–æ–∂–∏–≤—É—á—ñ –æ–±'—î–∫—Ç–∏, –∫–µ—à—ñ        | –†—ñ–¥–∫–æ          |

::mermaid

```mermaid
graph TD
    A[New Object Allocated] --> B[Placed in Gen0]
    B --> C{Gen0 GC Survives?}
    C -->|Yes| D[Promoted to Gen1]
    C -->|No| Z[Collected]

    D --> E{Gen1 GC Survives?}
    E -->|Yes| F[Promoted to Gen2]
    E -->|No| Z

    F --> G{Gen2 GC Survives?}
    G -->|Yes| F
    G -->|No| Z

    style A fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style B fill:#f59e0b,stroke:#b45309,color:#ffffff
    style D fill:#f59e0b,stroke:#b45309,color:#ffffff
    style F fill:#f59e0b,stroke:#b45309,color:#ffffff
    style Z fill:#64748b,stroke:#334155,color:#ffffff
```

::

#### Generation 0 (Gen0): –Ø—Å–ª–∞ –¥–ª—è –û–±'—î–∫—Ç—ñ–≤

**–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:**

-   üìè **–†–æ–∑–º—ñ—Ä**: –ó–∞–∑–≤–∏—á–∞–π 256 KB - 4 MB (–∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ –ø–ª–∞—Ç—Ñ–æ—Ä–º–∏ —Ç–∞ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω—å)
-   ‚ö° **–®–≤–∏–¥–∫—ñ—Å—Ç—å**: –ù–∞–π—à–≤–∏–¥—à–∏–π –∑–±—ñ—Ä (–º—ñ–ª—ñ—Å–µ–∫—É–Ω–¥–∏)
-   üìä **–ß–∞—Å—Ç–æ—Ç–∞**: –ù–∞–π—á–∞—Å—Ç—ñ—à–µ (–º–æ–∂–µ –±—É—Ç–∏ –¥–µ—Å—è—Ç–∫–∏ —Ä–∞–∑—ñ–≤ –Ω–∞ —Å–µ–∫—É–Ω–¥—É —É high-load –¥–æ–¥–∞—Ç–∫–∞—Ö)

```csharp
void Gen0Example()
{
    for (int i = 0; i < 1000; i++)
    {
        // –ö–æ–∂–Ω–∞ —ñ—Ç–µ—Ä–∞—Ü—ñ—è —Å—Ç–≤–æ—Ä—é—î –æ–±'—î–∫—Ç–∏ —É Gen0
        var temp = new StringBuilder();
        temp.Append("Temporary data ");
        temp.Append(i);
        string result = temp.ToString();

        // temp —Ç–∞ –ø—Ä–æ–º—ñ–∂–Ω—ñ string –æ–±'—î–∫—Ç–∏ —Å—Ç–∞—é—Ç—å garbage
        // –ø—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è —ñ—Ç–µ—Ä–∞—Ü—ñ—ó
    }
    // –ü—ñ–¥ —á–∞—Å —Ü–∏–∫–ª—É –º–æ–∂–µ —Å—Ç–∞—Ç–∏—Å—è –¥–µ–∫—ñ–ª—å–∫–∞ Gen0 collections
}
```

**–ö–æ–ª–∏ —Å–ø—Ä–∞—Ü—å–æ–≤—É—î Gen0 GC:**

1. Gen0 budget –≤–∏—á–µ—Ä–ø–∞–Ω–æ (–¥–æ—Å—è–≥–Ω—É—Ç–æ –ª—ñ–º—ñ—Ç —Ä–æ–∑–º—ñ—Ä—É)
2. –Ø–≤–Ω–∏–π –≤–∏–∫–ª–∏–∫ `GC.Collect(0)`
3. –°–∏—Å—Ç–µ–º—ñ –±—Ä–∞–∫—É—î –ø–∞–º'—è—Ç—ñ (low memory notification)

::code-group

```csharp [Demo: Gen0 Pressure]
class Gen0PressureDemo
{
    static void Main()
    {
        // –í—ñ–¥—Å–ª—ñ–¥–∫–æ–≤—É—î–º–æ GC –ø–æ–¥—ñ—ó
        int gen0Before = GC.CollectionCount(0);

        // –°—Ç–≤–æ—Ä—é—î–º–æ –±–∞–≥–∞—Ç–æ –∫–æ—Ä–æ—Ç–∫–æ–∂–∏–≤—É—á–∏—Ö –æ–±'—î–∫—Ç—ñ–≤
        for (int i = 0; i < 100_000; i++)
        {
            var obj = new byte[1024];  // 1 KB –æ–±'—î–∫—Ç
            // obj —Å—Ç–∞—î garbage –æ–¥—Ä–∞–∑—É –ø—ñ—Å–ª—è —ñ—Ç–µ—Ä–∞—Ü—ñ—ó
        }

        int gen0After = GC.CollectionCount(0);

        Console.WriteLine($"Gen0 collections: {gen0After - gen0Before}");
        // –í–∏–≤—ñ–¥: Gen0 collections: 25 (–ø—Ä–∏–±–ª–∏–∑–Ω–æ, –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ heap size)
    }
}
```

```csharp [Check Generation]
class CheckGeneration
{
    static void Main()
    {
        var obj = new object();

        // –©–æ–π–Ω–æ —Å—Ç–≤–æ—Ä–µ–Ω–∏–π - –≤ Gen0
        Console.WriteLine($"Generation: {GC.GetGeneration(obj)}");  // 0

        // –í–∏–∫–ª–∏–∫–∞—î–º–æ GC - –æ–±'—î–∫—Ç –≤–∏–∂–∏–≤–∞—î
        GC.Collect();
        Console.WriteLine($"Generation: {GC.GetGeneration(obj)}");  // 1

        // –©–µ —Ä–∞–∑ - –ø—Ä–æ–º–æ—Ü—ñ—è –¥–æ Gen2
        GC.Collect();
        Console.WriteLine($"Generation: {GC.GetGeneration(obj)}");  // 2

        // –î–∞–ª—ñ –æ–±'—î–∫—Ç –∑–∞–ª–∏—à–∞—î—Ç—å—Å—è –≤ Gen2
        GC.Collect();
        Console.WriteLine($"Generation: {GC.GetGeneration(obj)}");  // 2
    }
}
```

::

#### Generation 1 (Gen1): –ü—Ä–æ–º—ñ–∂–Ω–∞ –ó–æ–Ω–∞

**–ü—Ä–∏–∑–Ω–∞—á–µ–Ω–Ω—è**: Gen1 –¥—ñ—î —è–∫ **–±—É—Ñ–µ—Ä** –º—ñ–∂ —á–∞—Å—Ç–æ –∑—ñ–±—Ä–∞–Ω–∏–º Gen0 —Ç–∞ —Ä—ñ–¥–∫–æ –∑—ñ–±—Ä–∞–Ω–∏–º Gen2.

**–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:**

-   üìè **–†–æ–∑–º—ñ—Ä**: –ë—ñ–ª—å—à–∏–π –Ω—ñ–∂ Gen0, –∞–ª–µ –º–µ–Ω—à–∏–π –Ω—ñ–∂ Gen2 (–∑–∞–∑–≤–∏—á–∞–π –∫—ñ–ª—å–∫–∞ MB)
-   ‚ö° **–®–≤–∏–¥–∫—ñ—Å—Ç—å**: –®–≤–∏–¥—à–µ –Ω—ñ–∂ Gen2, –ø–æ–≤—ñ–ª—å–Ω—ñ—à–µ –Ω—ñ–∂ Gen0
-   üìä **–ß–∞—Å—Ç–æ—Ç–∞**: –°–µ—Ä–µ–¥–Ω—è - –∑–±–∏—Ä–∞—î—Ç—å—Å—è –∫–æ–ª–∏ Gen0 –∑–±—ñ—Ä –Ω–µ –∑–≤—ñ–ª—å–Ω–∏–≤ –¥–æ—Å—Ç–∞—Ç–Ω—å–æ –ø–∞–º'—è—Ç—ñ

```csharp
class Gen1Scenario
{
    private List<string> _cache = new List<string>();

    void ProcessRequests()
    {
        for (int i = 0; i < 100; i++)
        {
            string data = FetchData(i);  // Gen0

            // –î–µ—è–∫—ñ –¥–∞–Ω—ñ –∫–µ—à—É—é—Ç—å—Å—è - –≤–∏–∂–∏–≤—É—Ç—å Gen0 GC
            if (i % 10 == 0)
            {
                _cache.Add(data);  // –ü–µ—Ä–µ–º—ñ—Å—Ç–∏—Ç—å—Å—è –¥–æ Gen1, –ø–æ—Ç—ñ–º Gen2
            }

            ProcessData(data);  // –ë—ñ–ª—å—à—ñ—Å—Ç—å data —Å—Ç–∞–Ω–µ garbage –≤ Gen0
        }
    }
}
```

**–ö–æ–ª–∏ —Å–ø—Ä–∞—Ü—å–æ–≤—É—î Gen1 GC:**

-   –ö–æ–ª–∏ Gen0 GC –Ω–µ –∑–≤—ñ–ª—å–Ω–∏–ª–æ –¥–æ—Å—Ç–∞—Ç–Ω—å–æ –ø–∞–º'—è—Ç—ñ
-   –í–∏–∫–ª–∏–∫ `GC.Collect(1)` - –∑–±–µ—Ä–µ Gen0 —Ç–∞ Gen1
-   Gen1 budget –≤–∏—á–µ—Ä–ø–∞–Ω–æ

::note
**–û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è**: GC —Ä—ñ–¥—à–µ –∑–±–∏—Ä–∞—î Gen1, —Ç–æ–º—É —â–æ:

1. –ë—ñ–ª—å—à—ñ—Å—Ç—å garbage –≤–∂–µ –∑—ñ–±—Ä–∞–Ω–æ –≤ Gen0
2. –û–±'—î–∫—Ç–∏ –≤ Gen1 –º–∞—é—Ç—å –≤–∏—â—É –π–º–æ–≤—ñ—Ä–Ω—ñ—Å—Ç—å –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
3. –í–∞—Ä—Ç—ñ—Å—Ç—å –∑–±–æ—Ä—É Gen1 –≤–∏—â–∞ —á–µ—Ä–µ–∑ –±—ñ–ª—å—à–∏–π —Ä–æ–∑–º—ñ—Ä
   ::

#### Generation 2 (Gen2): –î–æ–≤–≥–æ–∂–∏—Ç–µ–ª—ñ

**–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:**

-   üìè **–†–æ–∑–º—ñ—Ä**: –ú–æ–∂–µ –±—É—Ç–∏ –≥—ñ–≥–∞–±–∞–π—Ç–∏
-   ‚ö° **–®–≤–∏–¥–∫—ñ—Å—Ç—å**: –ù–∞–π–ø–æ–≤—ñ–ª—å–Ω—ñ—à–∏–π –∑–±—ñ—Ä (–º–æ–∂–µ –±—É—Ç–∏ –¥–µ—Å—è—Ç–∫–∏-—Å–æ—Ç–Ω—ñ –º—ñ–ª—ñ—Å–µ–∫—É–Ω–¥)
-   üìä **–ß–∞—Å—Ç–æ—Ç–∞**: –†—ñ–¥–∫–æ - —Ç—ñ–ª—å–∫–∏ –ø—Ä–∏ –¥–µ—Ñ—ñ—Ü–∏—Ç—ñ –ø–∞–º'—è—Ç—ñ

**–¢–∏–ø–æ–≤—ñ –æ–±'—î–∫—Ç–∏ –≤ Gen2:**

-   –°—Ç–∞—Ç–∏—á–Ω—ñ –∫–æ–ª–µ–∫—Ü—ñ—ó —Ç–∞ –∫–µ—à—ñ
-   Singleton instances
-   –ì–ª–æ–±–∞–ª—å–Ω—ñ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è
-   –î–æ–≤–≥–æ–∂–∏–≤—É—á—ñ —Å–µ—Ä–≤—ñ—Å–∏

```csharp
// –°—Ç–∞—Ç–∏—á–Ω–∏–π –∫–µ—à - —à–≤–∏–¥–∫–æ –ø–æ—Ç—Ä–∞–ø–∏—Ç—å —É Gen2
public static class ApplicationCache
{
    // –¶—ñ –æ–±'—î–∫—Ç–∏ –±—É–¥—É—Ç—å –∂–∏—Ç–∏ –≤–µ—Å—å —á–∞—Å —Ä–æ–±–æ—Ç–∏ –¥–æ–¥–∞—Ç–∫—É
    private static Dictionary<string, UserProfile> _userCache
        = new Dictionary<string, UserProfile>();

    private static ConnectionPool _connections = new ConnectionPool();

    // Gen2 –æ–±'—î–∫—Ç–∏!
}

// Singleton - —Ç–∞–∫–æ–∂ Gen2
public class ConfigurationManager
{
    private static readonly Lazy<ConfigurationManager> _instance =
        new Lazy<ConfigurationManager>(() => new ConfigurationManager());

    public static ConfigurationManager Instance => _instance.Value;  // Gen2
}
```

**Full GC (Gen2 Collection):**

–ö–æ–ª–∏ CLR –∑–±–∏—Ä–∞—î Gen2, –≤—ñ–¥–±—É–≤–∞—î—Ç—å—Å—è **Full GC** - –∑–±—ñ—Ä –≤—Å—ñ—Ö –ø–æ–∫–æ–ª—ñ–Ω—å (Gen0, Gen1, Gen2):

```csharp
void FullGCDemo()
{
    Console.WriteLine("Before GC:");
    Console.WriteLine($"Gen0: {GC.CollectionCount(0)}");
    Console.WriteLine($"Gen1: {GC.CollectionCount(1)}");
    Console.WriteLine($"Gen2: {GC.CollectionCount(2)}");

    // Full GC - –∑–±–µ—Ä–µ –≤—Å—ñ –ø–æ–∫–æ–ª—ñ–Ω–Ω—è
    GC.Collect(2, GCCollectionMode.Forced, blocking: true, compacting: true);

    Console.WriteLine("\nAfter Full GC:");
    Console.WriteLine($"Gen0: {GC.CollectionCount(0)}");  // +1
    Console.WriteLine($"Gen1: {GC.CollectionCount(1)}");  // +1
    Console.WriteLine($"Gen2: {GC.CollectionCount(2)}");  // +1
}
```

::warning
**Performance Warning**: Full GC - —Ü–µ –¥–æ—Ä–æ–≥–∞ –æ–ø–µ—Ä–∞—Ü—ñ—è! –í—ñ–Ω:

-   –ó—É–ø–∏–Ω—è—î –≤—Å—ñ application threads (Stop-The-World pause)
-   –°–∫–∞–Ω—É—î –≤–µ—Å—å managed heap
-   –ú–æ–∂–µ –∫–æ–º–ø–∞–∫—Ç—É–≤–∞—Ç–∏ –≤–µ–ª–∏–∫—ñ –æ–±'—î–º–∏ –ø–∞–º'—è—Ç—ñ
-   –ú–æ–∂–µ —Ç—Ä–∏–≤–∞—Ç–∏ 100ms+ –¥–ª—è –≤–µ–ª–∏–∫–∏—Ö heaps (4+ GB)

–£–Ω–∏–∫–∞–π—Ç–µ —á–∞—Å—Ç–∏—Ö Full GC! –ú–æ–Ω—ñ—Ç–æ—Ä—å—Ç–µ —á–µ—Ä–µ–∑ Performance Counters –∞–±–æ `GC.CollectionCount(2)`.
::

#### Promotion (–ü—Ä–æ—Å—É–≤–∞–Ω–Ω—è –º—ñ–∂ –ü–æ–∫–æ–ª—ñ–Ω–Ω—è–º–∏)

–û–±'—î–∫—Ç–∏ **–Ω–µ –ø–µ—Ä–µ–º—ñ—â—É—é—Ç—å—Å—è** –º—ñ–∂ –ø–æ–∫–æ–ª—ñ–Ω–Ω—è–º–∏ —Ñ—ñ–∑–∏—á–Ω–æ –ø—Ä–∏ –∫–æ–∂–Ω–æ–º—É GC. –ù–∞—Ç–æ–º—ñ—Å—Ç—å GC –≤—ñ–¥—Å–ª—ñ–¥–∫–æ–≤—É—î boundaries (–º–µ–∂—ñ) –º—ñ–∂ –ø–æ–∫–æ–ª—ñ–Ω–Ω—è–º–∏:

::mermaid

```mermaid
graph LR
    subgraph "Managed Heap Layout"
        A[Gen2 Objects]
        B[Gen1 Objects]
        C[Gen0 Objects]
        D[Free Space]
    end

    A --> B
    B --> C
    C --> D

    style A fill:#64748b,stroke:#334155,color:#ffffff
    style B fill:#f59e0b,stroke:#b45309,color:#ffffff
    style C fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style D fill:#e5e7eb,stroke:#9ca3af,color:#000000
```

::

**–ú–µ—Ö–∞–Ω—ñ–∑–º promotion:**

```
Initial State:
[Gen2][Gen1][Gen0: Obj A | Obj B | Obj C][Free]
              ^live   ^dead  ^live

After Gen0 GC:
[Gen2][Gen1: Obj A | Obj C][Gen0][Free]
     Gen1 boundary moved ‚Üë

After Another Gen0+Gen1 GC (Obj A —Ç–∞ C survive):
[Gen2: Obj A | Obj C][Gen1][Gen0][Free]
     Gen2 boundary moved ‚Üë
```

**–í–∞–∂–ª–∏–≤–æ:** Promotion –Ω–µ –≤–∏–º–∞–≥–∞—î –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è - –ø—Ä–æ—Å—Ç–æ –æ–Ω–æ–≤–ª—é—é—Ç—å—Å—è generation boundaries. –¶–µ —Ä–æ–±–∏—Ç—å –ø—Ä–æ—Ü–µ—Å –¥—É–∂–µ –µ—Ñ–µ–∫—Ç–∏–≤–Ω–∏–º.

::tip
**–ü—Ä–æ—Ñ—ñ–ª—é–≤–∞–Ω–Ω—è**: –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ dotMemory, PerfView –∞–±–æ Visual Studio Profiler –¥–ª—è –∞–Ω–∞–ª—ñ–∑—É, —è–∫—ñ –æ–±'—î–∫—Ç–∏ –¥–æ—Å—è–≥–∞—é—Ç—å Gen2. –Ø–∫—â–æ –±–∞–≥–∞—Ç–æ –∫–æ—Ä–æ—Ç–∫–æ–∂–∏–≤—É—á–∏—Ö –æ–±'—î–∫—Ç—ñ–≤ –ø–æ—Ç—Ä–∞–ø–ª—è—é—Ç—å —É Gen2, —Ü–µ –º–æ–∂–µ –≤–∫–∞–∑—É–≤–∞—Ç–∏ –Ω–∞ –ø—Ä–æ–±–ª–µ–º—É (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, —Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Å–∏–ª–∞–Ω—å –Ω–∞ —Ç–∏–º—á–∞—Å–æ–≤—ñ –æ–±'—î–∫—Ç–∏).
::

---

### Large Object Heap (LOH) vs Small Object Heap (SOH)

#### –ß–æ–º—É LOH –Ü—Å–Ω—É—î?

–ö–æ–º–ø–∞–∫—Ç—É–≤–∞–Ω–Ω—è –≤–µ–ª–∏–∫–∏—Ö –æ–±'—î–∫—Ç—ñ–≤ (>85,000 –±–∞–π—Ç) **–¥–æ—Ä–æ–≥–µ** –∑ —Ç–æ—á–∫–∏ –∑–æ—Ä—É CPU:

-   –ö–æ–ø—ñ—é–≤–∞–Ω–Ω—è –º–µ–≥–∞–±–∞–π—Ç—ñ–≤ –¥–∞–Ω–∏—Ö
-   –û–Ω–æ–≤–ª–µ–Ω–Ω—è –≤—Å—ñ—Ö –ø–æ—Å–∏–ª–∞–Ω—å

–¢–æ–º—É .NET —Ä–æ–∑–¥—ñ–ª—è—î heap –Ω–∞ –¥–≤—ñ —á–∞—Å—Ç–∏–Ω–∏:

| –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞      | SOH (Small Object Heap)         | LOH (Large Object Heap)                 |
| :------------------ | :------------------------------ | :-------------------------------------- |
| **–†–æ–∑–º—ñ—Ä –æ–±'—î–∫—Ç—ñ–≤** | < 85,000 –±–∞–π—Ç                   | ‚â• 85,000 –±–∞–π—Ç                           |
| **–ö–æ–º–ø–∞–∫—Ç—É–≤–∞–Ω–Ω—è**   | –ó–∞–≤–∂–¥–∏ (–∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º)       | –ù—ñ–∫–æ–ª–∏ (–∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º –¥–æ .NET 4.5.1) |
| **–ü–æ–∫–æ–ª—ñ–Ω–Ω—è**       | Gen0, Gen1, Gen2                | –¢—ñ–ª—å–∫–∏ Gen2                             |
| **–ê–ª–æ–∫–∞—Ü—ñ—è**        | Sequential (–ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ)         | Free list (–ø–æ—à—É–∫ –≤—ñ–ª—å–Ω–æ–≥–æ –±–ª–æ–∫—É)        |
| **–§—Ä–∞–≥–º–µ–Ω—Ç–∞—Ü—ñ—è**    | –ú—ñ–Ω—ñ–º–∞–ª—å–Ω–∞ (–∑–∞–≤–¥—è–∫–∏ compaction) | –ú–æ–∂–ª–∏–≤–∞ (–±–µ–∑ compaction)                |

#### –ü–æ—Ä—ñ–≥ 85,000 –ë–∞–π—Ç

```csharp
// SOH - –º–∞–ª–∏–π –æ–±'—î–∫—Ç
byte[] small = new byte[84_999];  // –†–æ–∑—Ç–∞—à—É—î—Ç—å—Å—è –≤ SOH
Console.WriteLine(GC.GetGeneration(small));  // 0 (Gen0)

// LOH - –≤–µ–ª–∏–∫–∏–π –æ–±'—î–∫—Ç
byte[] large = new byte[85_000];  // –†–æ–∑—Ç–∞—à—É—î—Ç—å—Å—è –≤ LOH
Console.WriteLine(GC.GetGeneration(large));  // 2 (LOH –∑–∞–≤–∂–¥–∏ Gen2)
```

::note
**–ß–æ–º—É —Å–∞–º–µ 85,000?** –¶–µ –µ–º–ø—ñ—Ä–∏—á–Ω–æ –≤–∏–∑–Ω–∞—á–µ–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è Microsoft. –ö–æ–º–ø–∞–∫—Ç—É–≤–∞–Ω–Ω—è –æ–±'—î–∫—Ç—ñ–≤ –±—ñ–ª—å—à–µ —Ü—å–æ–≥–æ —Ä–æ–∑–º—ñ—Ä—É —Å—Ç–∞—î –Ω–µ–µ—Ñ–µ–∫—Ç–∏–≤–Ω–∏–º —á–µ—Ä–µ–∑ –≤–∏—Ç—Ä–∞—Ç–∏ –Ω–∞ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è –ø–∞–º'—è—Ç—ñ. –ß–∏—Å–ª–æ 85,000 = 85 KB –ø—Ä–∏–±–ª–∏–∑–Ω–æ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î —Ä–æ–∑–º—ñ—Ä—É, –¥–µ overhead –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è –ø–µ—Ä–µ–≤–∏—â—É—î –≤–∏–≥–æ–¥—É –≤—ñ–¥ —É–Ω–∏–∫–Ω–µ–Ω–Ω—è —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞—Ü—ñ—ó.
::

#### –ü—Ä–æ–±–ª–µ–º–∞: –§—Ä–∞–≥–º–µ–Ω—Ç–∞—Ü—ñ—è LOH

LOH –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î **free list allocation** - –ø–æ—à—É–∫ –≤—ñ–ª—å–Ω–æ–≥–æ –±–ª–æ–∫—É –¥–æ—Å—Ç–∞—Ç–Ω—å–æ–≥–æ —Ä–æ–∑–º—ñ—Ä—É:

```
LOH Before Allocation:
[Large Obj A: 100KB][Free: 50KB][Obj B: 200KB][Free: 150KB][Obj C: 80KB]

Allocate 120KB object:
Need 120KB, but largest free block is 150KB
[Obj A][Free][Obj B][New Obj: 120KB][Free: 30KB][Obj C]

–ü—Ä–æ–±–ª–µ–º–∞: free block 50KB –º–æ–∂–µ –Ω—ñ–∫–æ–ª–∏ –Ω–µ –±—É—Ç–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–∏–π,
—è–∫—â–æ –≤—Å—ñ –Ω–æ–≤—ñ –æ–±'—î–∫—Ç–∏ >50KB
```

**–ù–∞—Å–ª—ñ–¥–∫–∏ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞—Ü—ñ—ó:**

-   –ù–µ–µ—Ñ–µ–∫—Ç–∏–≤–Ω–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –ø–∞–º'—è—Ç—ñ
-   `OutOfMemoryException` –Ω–∞–≤—ñ—Ç—å –ø—Ä–∏ –¥–æ—Å—Ç–∞—Ç–Ω—ñ–π –∑–∞–≥–∞–ª—å–Ω—ñ–π –≤—ñ–ª—å–Ω—ñ–π –ø–∞–º'—è—Ç—ñ
-   –ü–æ–≥—ñ—Ä—à–µ–Ω–Ω—è performance —á–µ—Ä–µ–∑ –ø–æ—à—É–∫ –≤—ñ–ª—å–Ω–∏—Ö –±–ª–æ–∫—ñ–≤

::code-group

```csharp [LOH Fragmentation Demo]
class LOHFragmentationDemo
{
    static void Main()
    {
        List<byte[]> allocated = new List<byte[]>();

        // –ê–ª–æ–∫—É—î–º–æ –±–∞–≥–∞—Ç–æ –≤–µ–ª–∏–∫–∏—Ö –æ–±'—î–∫—Ç—ñ–≤
        for (int i = 0; i < 100; i++)
        {
            allocated.Add(new byte[100_000]);  // 100 KB
        }

        // –ó–≤—ñ–ª—å–Ω—è—î–º–æ –∫–æ–∂–µ–Ω –¥—Ä—É–≥–∏–π
        for (int i = 0; i < allocated.Count; i += 2)
        {
            allocated[i] = null;
        }

        // –¢–µ–ø–µ—Ä LOH —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤–∞–Ω–∏–π:
        // [Obj][Free 100KB][Obj][Free 100KB][Obj]...

        GC.Collect(2, GCCollectionMode.Forced);

        // –°–ø—Ä–æ–±—É—î–º–æ –∞–ª–æ–∫—É–≤–∞—Ç–∏ –æ–±'—î–∫—Ç –±—ñ–ª—å—à–µ –Ω—ñ–∂ 100KB
        try
        {
            var huge = new byte[150_000];  // –ú–æ–∂–µ –∑–∞–π–Ω—è—Ç–∏ —á–∞—Å —á–µ—Ä–µ–∑ –ø–æ—à—É–∫
        }
        catch (OutOfMemoryException)
        {
            Console.WriteLine("LOH fragmented - cannot allocate!");
        }
    }
}
```

```csharp [Enable LOH Compaction]
class LOHCompactionDemo
{
    static void Main()
    {
        // –ó–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º LOH –Ω–µ –∫–æ–º–ø–∞–∫—Ç—É—î—Ç—å—Å—è
        Console.WriteLine($"LOH Compaction: {GCSettings.LargeObjectHeapCompactionMode}");
        // Default

        // –£–≤—ñ–º–∫–Ω—É—Ç–∏ –∫–æ–º–ø–∞–∫—Ç—É–≤–∞–Ω–Ω—è –¥–ª—è –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ GC
        GCSettings.LargeObjectHeapCompactionMode =
            GCLargeObjectHeapCompactionMode.CompactOnce;

        // –í–∏–∫–æ–Ω–∞—Ç–∏ Full GC –∑ –∫–æ–º–ø–∞–∫—Ç—É–≤–∞–Ω–Ω—è–º LOH
        GC.Collect(2, GCCollectionMode.Forced, blocking: true, compacting: true);

        // –ü—ñ—Å–ª—è —Ü—å–æ–≥–æ —Ä–µ–∂–∏–º –ø–æ–≤–µ—Ä—Ç–∞—î—Ç—å—Å—è –¥–æ Default
        Console.WriteLine($"After GC: {GCSettings.LargeObjectHeapCompactionMode}");
        // Default
    }
}
```

::

::warning
**–ö–æ–ª–∏ –ù–ï –∫–æ–º–ø–∞–∫—Ç—É–≤–∞—Ç–∏ LOH:**

-   –Ø–∫—â–æ —î pinned –æ–±'—î–∫—Ç–∏ –≤ LOH (–∫–æ–º–ø–∞–∫—Ç—É–≤–∞–Ω–Ω—è –Ω–µ–º–æ–∂–ª–∏–≤–µ)
-   –£ real-time –¥–æ–¥–∞—Ç–∫–∞—Ö, –¥–µ –ø–∞—É–∑–∏ GC –∫—Ä–∏—Ç–∏—á–Ω—ñ
-   –Ø–∫—â–æ LOH —Ä—ñ–¥–∫–æ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—É—î—Ç—å—Å—è (–ø—Ä–æ–∞–Ω–∞–ª—ñ–∑—É–π—Ç–µ metrics)

**–ö–æ–ª–∏ –∫–æ–º–ø–∞–∫—Ç—É–≤–∞—Ç–∏:**

-   –ü—ñ—Å–ª—è –º–∞—Å–æ–≤–æ–≥–æ –∑–≤—ñ–ª—å–Ω–µ–Ω–Ω—è –≤–µ–ª–∏–∫–∏—Ö –æ–±'—î–∫—Ç—ñ–≤
-   –ü—Ä–∏ –≤–∏—è–≤–ª–µ–Ω–Ω—ñ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞—Ü—ñ—ó (OutOfMemoryException –ø—Ä–∏ –¥–æ—Å—Ç–∞—Ç–Ω—ñ–π –ø–∞–º'—è—Ç—ñ)
-   –£ batch processes —á–∏ –ø—ñ–¥ —á–∞—Å maintenance windows
    ::

#### Pinned Object Heap (POH) - .NET 5+

–ó **.NET 5** –¥–æ–¥–∞–Ω–æ –Ω–æ–≤–µ –ø–æ–∫–æ–ª—ñ–Ω–Ω—è - **Pinned Object Heap**:

**–ü—Ä–∏–∑–Ω–∞—á–µ–Ω–Ω—è:** –ó–±–µ—Ä—ñ–≥–∞–Ω–Ω—è pinned –æ–±'—î–∫—Ç—ñ–≤ –æ–∫—Ä–µ–º–æ –≤—ñ–¥ SOH/LOH –¥–ª—è —É–Ω–∏–∫–Ω–µ–Ω–Ω—è —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞—Ü—ñ—ó.

**–©–æ —Ç–∞–∫–µ Pinned Objects?**

```csharp
unsafe void PinningExample()
{
    byte[] buffer = new byte[1000];

    // Pinning - —Ñ—ñ–∫—Å—É—î–º–æ –æ–±'—î–∫—Ç —É –ø–∞–º'—è—Ç—ñ (–Ω–µ –º–æ–∂–µ –±—É—Ç–∏ –ø–µ—Ä–µ–º—ñ—â–µ–Ω–∏–π GC)
    fixed (byte* ptr = buffer)
    {
        // –í–∏–∫–ª–∏–∫–∞—î–º–æ native —Ñ—É–Ω–∫—Ü—ñ—é, —è–∫–∞ –æ—á—ñ–∫—É—î –≤–∫–∞–∑—ñ–≤–Ω–∏–∫
        NativeApi.ProcessData(ptr, buffer.Length);

        // –ü—ñ–¥ —á–∞—Å —Ü—å–æ–≥–æ buffer –ù–ï –ú–û–ñ–ï –±—É—Ç–∏ –ø–µ—Ä–µ–º—ñ—â–µ–Ω–∏–π compaction!
    }
    // –ü—ñ—Å–ª—è –≤–∏—Ö–æ–¥—É –∑ fixed, –æ–±'—î–∫—Ç unpinned
}

// –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞: GCHandle
void PinWithGCHandle()
{
    byte[] buffer = new byte[1000];

    GCHandle handle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
    try
    {
        IntPtr ptr = handle.AddrOfPinnedObject();
        NativeApi.ProcessData(ptr, buffer.Length);
    }
    finally
    {
        handle.Free();  // Unpinning
    }
}
```

**–ü—Ä–æ–±–ª–µ–º–∞ –∑ pinned –æ–±'—î–∫—Ç–∞–º–∏ –≤ SOH:**

```
Heap –ø–µ—Ä–µ–¥ GC compaction:
[Obj A][Pinned B][Obj C][Free]

Compaction –Ω–µ–º–æ–∂–ª–∏–≤–∏–π –¥–ª—è B, —Ç–æ–º—É:
[Obj A][Pinned B][  ][Obj C][Free]
              ‚Üë gap - —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞—Ü—ñ—è!
```

**POH –≤–∏—Ä—ñ—à–µ–Ω–Ω—è:**

```
SOH:  [Obj A][Obj C][Free]  ‚Üê –ú–æ–∂–µ –±—É—Ç–∏ –∫–æ–º–ø–∞–∫—Ç–æ–≤–∞–Ω–∏–π
POH:  [Pinned B][Pinned D]  ‚Üê –û–∫—Ä–µ–º–∏–π heap –¥–ª—è pinned –æ–±'—î–∫—Ç—ñ–≤
```

::tip
**Best Practice**: –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ `GC.AllocateArray<T>` –¥–ª—è —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è pinned –º–∞—Å–∏–≤—ñ–≤ –Ω–∞–ø—Ä—è–º—É –≤ POH:

```csharp
// .NET 5+
byte[] pinnedBuffer = GC.AllocateArray<byte>(1000, pinned: true);

// –¶–µ–π –º–∞—Å–∏–≤ –≤—ñ–¥—Ä–∞–∑—É —É POH, –Ω–µ –ø–æ—Ç—Ä–µ–±—É—î GCHandle!
```

::

**–ü–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è Heaps:**

| Heap              | –†–æ–∑–º—ñ—Ä –û–±'—î–∫—Ç—ñ–≤ | Compaction | –ü–æ–∫–æ–ª—ñ–Ω–Ω—è | Use Case                   |
| :---------------- | :-------------- | :--------- | :-------- | :------------------------- |
| **SOH**           | < 85 KB         | –¢–∞–∫        | Gen0/1/2  | –ó–≤–∏—á–∞–π–Ω—ñ –æ–±'—î–∫—Ç–∏           |
| **LOH**           | ‚â• 85 KB         | –ó–∞ –∑–∞–ø–∏—Ç–æ–º | Gen2      | –í–µ–ª–∏–∫—ñ –±—É—Ñ–µ—Ä–∏, –º–∞—Å–∏–≤–∏      |
| **POH** (.NET 5+) | –ë—É–¥—å-—è–∫–∏–π       | –ù—ñ         | Gen2      | Pinned –æ–±'—î–∫—Ç–∏ –¥–ª—è interop |

---

### –¢–∏–ø–∏ Garbage Collection

.NET –Ω–∞–¥–∞—î —Ä—ñ–∑–Ω—ñ —Ä–µ–∂–∏–º–∏ —Ä–æ–±–æ—Ç–∏ GC –¥–ª—è —Ä—ñ–∑–Ω–∏—Ö —Å—Ü–µ–Ω–∞—Ä—ñ—ó–≤ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è.

#### Workstation GC (–î–µ—Å–∫—Ç–æ–ø–Ω–∏–π –†–µ–∂–∏–º)

**–ü—Ä–∏–∑–Ω–∞—á–µ–Ω–Ω—è**: –û–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω–∏–π –¥–ª—è –∫–ª—ñ—î–Ω—Ç—Å—å–∫–∏—Ö –¥–æ–¥–∞—Ç–∫—ñ–≤ (desktop, mobile).

**–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:**

-   üñ•Ô∏è –í–∏–∫–æ–Ω—É—î—Ç—å—Å—è –Ω–∞ **—Ç–æ–º—É –∂ —Ç—Ä–µ–¥—ñ**, —â–æ —ñ application code
-   ‚è±Ô∏è –ú—ñ–Ω—ñ–º—ñ–∑–∞—Ü—ñ—è **–ø–∞—É–∑** (–Ω–∏–∑—å–∫–∞ latency)
-   üí° –ú–µ–Ω—à–µ —Å–ø–æ–∂–∏–≤–∞–Ω–Ω—è –ø–∞–º'—è—Ç—ñ
-   üîÑ –ü—ñ–¥—Ç—Ä–∏–º—É—î **concurrent/background GC** (–∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º)

**–ö–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—è:**

::code-group

```xml [.csproj]
<PropertyGroup>
    <ServerGarbageCollection>false</ServerGarbageCollection>
</PropertyGroup>
```

```json [runtimeconfig.json]
{
    "runtimeOptions": {
        "configProperties": {
            "System.GC.Server": false
        }
    }
}
```

::

**Use Case:**

```csharp
// WPF/WinForms Desktop Application
public partial class MainWindow : Window
{
    // Workstation GC - –Ω–∏–∑—å–∫—ñ –ø–∞—É–∑–∏ –¥–ª—è responsive UI
    private async void LoadData_Click(object sender, RoutedEventArgs e)
    {
        // GC –º–æ–∂–µ –≤—ñ–¥–±—É—Ç–∏—Å—å –ø—ñ–¥ —á–∞—Å —Ä–æ–±–æ—Ç–∏,
        // –∞–ª–µ –ø–∞—É–∑–∏ –∫–æ—Ä–æ—Ç–∫—ñ -> UI responsive
        var data = await DataService.FetchLargeDataset();
        DataGrid.ItemsSource = data;
    }
}
```

---

#### Server GC (–°–µ—Ä–≤–µ—Ä–Ω–∏–π –†–µ–∂–∏–º)

**–ü—Ä–∏–∑–Ω–∞—á–µ–Ω–Ω—è**: –û–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω–∏–π –¥–ª—è –≤–∏—Å–æ–∫–æ–ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–∏—Ö —Å–µ—Ä–≤–µ—Ä–Ω–∏—Ö –¥–æ–¥–∞—Ç–∫—ñ–≤.

**–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:**

-   üöÄ **–ë–∞–≥–∞—Ç–æ–ø–æ—Ç–æ—á–Ω–∏–π GC** - –ø–æ –æ–¥–Ω–æ–º—É —Ç—Ä–µ–¥—É –Ω–∞ –∫–æ–∂–Ω–µ logical core
-   ‚ö° –í–∏—â–∏–π **throughput** (–±—ñ–ª—å—à–µ –æ–ø–µ—Ä–∞—Ü—ñ–π –∑–∞ –æ–¥–∏–Ω–∏—Ü—é —á–∞—Å—É)
-   üíæ –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î **–±—ñ–ª—å—à–µ –ø–∞–º'—è—Ç—ñ** (–∫–æ–∂–µ–Ω —Ç—Ä–µ–¥ –º–∞—î —Å–≤—ñ–π heap segment)
-   ‚è≥ –ü–æ—Ç–µ–Ω—Ü—ñ–π–Ω–æ **–¥–æ–≤—à—ñ –ø–∞—É–∑–∏**, –∞–ª–µ —Ä—ñ–¥—à–µ

**–Ø–∫ –ø—Ä–∞—Ü—é—î:**

::mermaid

```mermaid
graph TD
    subgraph "Server GC - Multicore"
        A[Application Threads] -->|Object Allocation| B[Heap Segment 1]
        A -->|Object Allocation| C[Heap Segment 2]
        A -->|Object Allocation| D[Heap Segment 3]
        A -->|Object Allocation| E[Heap Segment 4]
    end

    subgraph "GC Triggered"
        F[GC Thread 1] -->|Collect| B
        G[GC Thread 2] -->|Collect| C
        H[GC Thread 3] -->|Collect| D
        I[GC Thread 4] -->|Collect| E
    end

    B --> F
    C --> G
    D --> H
    E --> I

    style A fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style F fill:#f59e0b,stroke:#b45309,color:#ffffff
    style G fill:#f59e0b,stroke:#b45309,color:#ffffff
    style H fill:#f59e0b,stroke:#b45309,color:#ffffff
    style I fill:#f59e0b,stroke:#b45309,color:#ffffff
```

::

**–ö–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—è:**

```xml
<PropertyGroup>
    <ServerGarbageCollection>true</ServerGarbageCollection>

    <!-- –û–ø—Ü—ñ–æ–Ω–∞–ª—å–Ω–æ: –∫—ñ–ª—å–∫—ñ—Å—Ç—å GC heaps (–∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º = logical cores) -->
    <GCHeapCount>8</GCHeapCount>
</PropertyGroup>
```

**Use Case:**

```csharp
// ASP.NET Core Web API
public class OrdersController : ControllerBase
{
    // Server GC - throughput –≤–∞–∂–ª–∏–≤—ñ—à–∏–π –∑–∞ latency
    [HttpPost]
    public async Task<IActionResult> ProcessBulkOrders([FromBody] List<Order> orders)
    {
        // –û–±—Ä–æ–±–∫–∞ —Ç–∏—Å—è—á orders –ø–∞—Ä–∞–ª–µ–ª—å–Ω–æ
        var tasks = orders.Select(ProcessOrder);
        await Task.WhenAll(tasks);

        // Server GC –µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ –ø—Ä–∞—Ü—é—î –∑ –±–∞–≥–∞—Ç–æ–ø–æ—Ç–æ–∫–æ–≤–∏–º –Ω–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è–º
        return Ok();
    }
}
```

**–ü–æ—Ä—ñ–≤–Ω—è–ª—å–Ω–∞ –¢–∞–±–ª–∏—Ü—è:**

| –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞         | Workstation GC                    | Server GC                         |
| :--------------------- | :-------------------------------- | :-------------------------------- |
| **Threads**            | –û–¥–∏–Ω GC thread                    | –ü–æ thread –Ω–∞ –∫–æ–∂–Ω–µ core           |
| **Heap Segments**      | –û–¥–∏–Ω —Å–µ–≥–º–µ–Ω—Ç                      | –ö—ñ–ª—å–∫–∞ —Å–µ–≥–º–µ–Ω—Ç—ñ–≤ (per core)       |
| **Latency (–ü–∞—É–∑–∏)**    | –ö–æ—Ä–æ—Ç–∫—ñ                           | –ü–æ—Ç–µ–Ω—Ü—ñ–π–Ω–æ –¥–æ–≤—à—ñ                  |
| **Throughput**         | –ù–∏–∂—á–∏–π                            | –í–∏—â–∏–π (–¥–æ 2-3x)                   |
| **Memory Consumption** | –ú–µ–Ω—à–µ                             | –ë—ñ–ª—å—à–µ (~20-30% –±—ñ–ª—å—à–µ)           |
| **Best For**           | UI –¥–æ–¥–∞—Ç–∫–∏, –∫–ª—ñ—î–Ω—Ç—Å—å–∫—ñ –∑–∞—Å—Ç–æ—Å—É–Ω–∫–∏ | Web —Å–µ—Ä–≤–µ—Ä—ã, background processes |
| **Overhead**           | –ú—ñ–Ω—ñ–º–∞–ª—å–Ω–∏–π                       | –í–∏—â–∏–π —á–µ—Ä–µ–∑ multiple heaps        |

::tip
**–Ø–∫ –≤–∏–±—Ä–∞—Ç–∏?**

-   **Workstation GC**: WPF, WinForms, Xamarin, Blazor WASM, short-lived processes
-   **Server GC**: ASP.NET Core, Worker Services, batch processors, long-running services

**–ü—Ä–∞–≤–∏–ª–æ**: –Ø–∫—â–æ —É –≤–∞—Å >4 cores —ñ –∑–∞—Å—Ç–æ—Å—É–Ω–æ–∫ –æ–±—Ä–æ–±–ª—è—î –±–∞–≥–∞—Ç–æ requests - –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ Server GC.
::

---

#### Background GC (Concurrent GC)

**Background GC** (—Ä–∞–Ω—ñ—à–µ –≤—ñ–¥–æ–º–∏–π —è–∫ Concurrent GC) –¥–æ–∑–≤–æ–ª—è—î application threads –ø—Ä–æ–¥–æ–≤–∂—É–≤–∞—Ç–∏ —Ä–æ–±–æ—Ç—É –ø—ñ–¥ —á–∞—Å Gen2 collection.

**–Ø–∫ –ø—Ä–∞—Ü—é—î:**

::mermaid

```mermaid
sequenceDiagram
    participant App as Application Threads
    participant BG as Background GC Thread
    participant Heap as Managed Heap

    Note over App: Working normally
    App->>Heap: Allocate objects

    Note over BG: Gen2 GC Triggered
    BG->>BG: Suspend app threads briefly
    BG->>Heap: Mark roots
    BG->>BG: Resume app threads

    par Background Collection
        App->>Heap: Continue allocating
    and
        BG->>Heap: Mark objects (concurrent)
    end

    BG->>BG: Suspend app threads
    BG->>Heap: Final marking & compaction
    BG->>BG: Resume app threads

    Note over App: Minimal pause experienced

    style App fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style BG fill:#f59e0b,stroke:#b45309,color:#ffffff
```

::

**–§–∞–∑–∏ Background GC:**

1. **Initial Suspend** (~1-5ms): –ó—É–ø–∏–Ω–∏—Ç–∏ app threads, –∑—ñ–±—Ä–∞—Ç–∏ roots
2. **Concurrent Marking** (–æ—Å–Ω–æ–≤–Ω–∞ —á–∞—Å—Ç–∏–Ω–∞): App threads –ø—Ä–∞—Ü—é—é—Ç—å, GC –º–∞—Ä–∫—É—î –æ–±'—î–∫—Ç–∏ –ø–∞—Ä–∞–ª–µ–ª—å–Ω–æ
3. **Final Suspend** (~10-50ms): –§—ñ–Ω–∞–ª—å–Ω–µ –º–∞—Ä–∫—É–≤–∞–Ω–Ω—è –Ω–æ–≤–∏—Ö –æ–±'—î–∫—Ç—ñ–≤ —Ç–∞ compaction

**–ö–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—è:**

```xml
<PropertyGroup>
    <!-- –ó–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º —É–≤—ñ–º–∫–Ω–µ–Ω–æ, –∞–ª–µ –º–æ–∂–Ω–∞ –≤–∏–º–∫–Ω—É—Ç–∏ -->
    <ConcurrentGarbageCollection>true</ConcurrentGarbageCollection>
</PropertyGroup>
```

**–í–∏–º–∫–Ω—É—Ç–∏ Background GC:**

```csharp
// –£ –∫–æ–¥—ñ (–¥–æ –∑–∞–ø—É—Å–∫—É GC):
System.Runtime.GCSettings.LatencyMode = GCLatencyMode.Batch;
// Batch mode - –±–µ–∑ background, –∫–æ–º–ø–∞–∫—Ç—É—î –∞–≥—Ä–µ—Å–∏–≤–Ω—ñ—à–µ
```

**–ü–µ—Ä–µ–≤–∞–≥–∏:**

-   ‚úÖ –ú–µ–Ω—à—ñ –ø–∞—É–∑–∏ –¥–ª—è application
-   ‚úÖ –ö—Ä–∞—â–∞ responsiveness
-   ‚úÖ –ü—ñ–¥—Ö–æ–¥–∏—Ç—å –¥–ª—è UI —Ç–∞ interactive –¥–æ–¥–∞—Ç–∫—ñ–≤

**–ù–µ–¥–æ–ª—ñ–∫–∏:**

-   ‚ùå –î–æ–¥–∞—Ç–∫–æ–≤–∏–π CPU overhead
-   ‚ùå –ë—ñ–ª—å—à–µ —Å–ø–æ–∂–∏–≤–∞–Ω–Ω—è –ø–∞–º'—è—Ç—ñ –ø—ñ–¥ —á–∞—Å GC
-   ‚ùå –ù–µ –≥–∞—Ä–∞–Ω—Ç—É—î –º—ñ–Ω—ñ–º–∞–ª—å–Ω–∏—Ö –ø–∞—É–∑ –¥–ª—è Gen0/Gen1

::note
**Background GC —Ç–∞ Generations**: Background GC –∑–∞—Å—Ç–æ—Å–æ–≤—É—î—Ç—å—Å—è —Ç—ñ–ª—å–∫–∏ –¥–æ Gen2. Gen0 —Ç–∞ Gen1 –≤—Å–µ —â–µ –∑–±–∏—Ä–∞—é—Ç—å—Å—è –≤ "stop-the-world" —Ä–µ–∂–∏–º—ñ, –∞–ª–µ –≤–æ–Ω–∏ –¥—É–∂–µ —à–≤–∏–¥–∫—ñ (<1ms –∑–∞–∑–≤–∏—á–∞–π).
::

---

### GC Triggers (–¢—Ä–∏–≥–µ—Ä–∏ –ó–±–∏—Ä–∞–Ω–Ω—è)

#### 1. Allocation Budget –í–∏—á–µ—Ä–ø–∞–Ω–æ

–ù–∞–π—á–∞—Å—Ç—ñ—à–∞ –ø—Ä–∏—á–∏–Ω–∞ - –≤–∏—á–µ—Ä–ø–∞–Ω–æ budget (–ª—ñ–º—ñ—Ç —Ä–æ–∑–º—ñ—Ä—É) –¥–ª—è –ø–æ–∫–æ–ª—ñ–Ω–Ω—è:

```csharp
void AllocateTillGC()
{
    int collectionsBefore = GC.CollectionCount(0);

    // –ü—Ä–æ–¥–æ–≤–∂—É—î–º–æ –∞–ª–æ–∫—É–≤–∞—Ç–∏, –ø–æ–∫–∏ –Ω–µ —Å–ø—Ä–∞—Ü—é—î Gen0 GC
    while (GC.CollectionCount(0) == collectionsBefore)
    {
        var obj = new byte[1024];  // 1 KB
        // Gen0 budget –∑–º–µ–Ω—à—É—î—Ç—å—Å—è...
    }

    Console.WriteLine("Gen0 GC triggered!");
}
```

**–Ø–∫ CLR –≤–∏–∑–Ω–∞—á–∞—î budget:**

-   Gen0: –ó–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ heap size —Ç–∞ —ñ—Å—Ç–æ—Ä—ñ—ó GC
-   –î–∏–Ω–∞–º—ñ—á–Ω–æ –∞–¥–∞–ø—Ç—É—î—Ç—å—Å—è (—è–∫—â–æ –±–∞–≥–∞—Ç–æ garbage - –∑–±—ñ–ª—å—à—É—î budget)
-   –ó–∞–∑–≤–∏—á–∞–π 256 KB - 4 MB –¥–ª—è Gen0

---

#### 2. –Ø–≤–Ω–∏–π –í–∏–∫–ª–∏–∫ GC.Collect()

```csharp
// ‚ùå –ü–û–ì–ê–ù–ê –ø—Ä–∞–∫—Ç–∏–∫–∞ —É –±—ñ–ª—å—à–æ—Å—Ç—ñ –≤–∏–ø–∞–¥–∫—ñ–≤
GC.Collect();

// –ó–±—ñ—Ä –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –ø–æ–∫–æ–ª—ñ–Ω–Ω—è
GC.Collect(0);  // –¢—ñ–ª—å–∫–∏ Gen0
GC.Collect(1);  // Gen0 + Gen1
GC.Collect(2);  // Full GC (Gen0 + Gen1 + Gen2)

// –ó –¥–æ–¥–∞—Ç–∫–æ–≤–∏–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
GC.Collect(2,
    GCCollectionMode.Optimized,  // –û–ø—Ç–∏–º–∞–ª—å–Ω–∏–π —á–∞—Å –¥–ª—è –∑–±–æ—Ä—É
    blocking: true,               // –ß–µ–∫–∞—Ç–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è
    compacting: true);            // –ó –∫–æ–º–ø–∞–∫—Ç—É–≤–∞–Ω–Ω—è–º
```

::warning
**–ö–æ–ª–∏ –ù–ï –≤–∏–∫–ª–∏–∫–∞—Ç–∏ GC.Collect():**

-   ‚ùå –£ production –∫–æ–¥—ñ "–Ω–∞ –≤—Å—è–∫–∏–π –≤–∏–ø–∞–¥–æ–∫"
-   ‚ùå –ü—ñ—Å–ª—è –∫–æ–∂–Ω–æ—ó –æ–ø–µ—Ä–∞—Ü—ñ—ó –∑ –ø–∞–º'—è—Ç—Ç—é
-   ‚ùå –î–ª—è "–∑–≤—ñ–ª—å–Ω–µ–Ω–Ω—è –ø–∞–º'—è—Ç—ñ" –±–µ–∑ —Ä–µ–∞–ª—å–Ω–æ—ó –ø–æ—Ç—Ä–µ–±–∏
-   ‚ùå –£ performance-critical —Å–µ–∫—Ü—ñ—è—Ö

**–ö–æ–ª–∏ –º–æ–∂–Ω–∞:**

-   ‚úÖ –ü—ñ—Å–ª—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –≤–µ–ª–∏–∫–æ—ó –∫—ñ–ª—å–∫–æ—Å—Ç—ñ –¥–∞–Ω–∏—Ö, —è–∫—ñ –±—ñ–ª—å—à–µ –Ω–µ –ø–æ—Ç—Ä—ñ–±–Ω—ñ
-   ‚úÖ –£ tests –¥–ª—è –¥–µ—Ç–µ—Ä–º—ñ–Ω–æ–≤–∞–Ω–æ—ó –ø–æ–≤–µ–¥—ñ–Ω–∫–∏
-   ‚úÖ –£ batch –ø—Ä–æ—Ü–µ—Å–∞—Ö –º—ñ–∂ –µ—Ç–∞–ø–∞–º–∏ –æ–±—Ä–æ–±–∫–∏
-   ‚úÖ –ü—ñ—Å–ª—è —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó –¥–æ–¥–∞—Ç–∫—É (—Ä–∞–∑–æ–º –∑ Gen2 compacting)
    ::

---

#### 3. Low Memory Notification (–ù–µ—Å—Ç–∞—á–∞ –ü–∞–º'—è—Ç—ñ)

–û–° –ø–æ–≤—ñ–¥–æ–º–ª—è—î CLR –ø—Ä–æ –Ω–∏–∑—å–∫–∏–π —Ä—ñ–≤–µ–Ω—å –¥–æ—Å—Ç—É–ø–Ω–æ—ó –ø–∞–º'—è—Ç—ñ:

```csharp
// –°–∏–º—É–ª—è—Ü—ñ—è: —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—è –Ω–∞ memory pressure
AppDomain.CurrentDomain.MonitoringIsEnabled = true;

void MonitorMemory()
{
    long before = GC.GetTotalMemory(forceFullCollection: false);

    // –ü—Ä–∏ –Ω–∏–∑—å–∫–æ–º—É —Ä—ñ–≤–Ω—ñ –ø–∞–º'—è—Ç—ñ –û–° –ø–æ–≤—ñ–¥–æ–º–∏—Ç—å CLR
    // CLR –º–æ–∂–µ –≤–∏–∫–ª–∏–∫–∞—Ç–∏ aggressive Gen2 GC

    long after = GC.GetTotalMemory(forceFullCollection: false);

    Console.WriteLine($"Memory: {before / 1024 / 1024} MB -> {after / 1024 / 1024} MB");
}
```

CLR –æ—Ç—Ä–∏–º—É—î notifications —á–µ—Ä–µ–∑:

-   Windows: `CreateMemoryResourceNotification` / `QueryMemoryResourceNotification`
-   Linux: memory cgroups, `/proc/meminfo`

---

#### 4. No GC Region (–°–ø–µ—Ü—ñ–∞–ª—å–Ω–∏–π –†–µ–∂–∏–º)

–ú–æ–∂–Ω–∞ –∑–∞–ø—Ä–æ—Å–∏—Ç–∏ CLR **–Ω–µ –≤–∏–∫–ª–∏–∫–∞—Ç–∏ GC** –ø—Ä–æ—Ç—è–≥–æ–º –∫—Ä–∏—Ç–∏—á–Ω–æ—ó —Å–µ–∫—Ü—ñ—ó:

```csharp
bool TryNoGCRegion()
{
    long totalMemory = 10 * 1024 * 1024;  // 10 MB budget

    try
    {
        // –ó–∞–ø–∏—Ç—É—î–º–æ CLR: "–ù–µ –≤–∏–∫–ª–∏–∫–∞–π GC, –ø–æ–∫–∏ —î 10 MB"
        if (GC.TryStartNoGCRegion(totalMemory))
        {
            // –ö—Ä–∏—Ç–∏—á–Ω–∞ —Å–µ–∫—Ü—ñ—è - GC –Ω–µ —Å–ø—Ä–∞—Ü—é—î (—è–∫—â–æ –≤–∏—Å—Ç–∞—á–∏—Ç—å budget)
            PerformLatencySensitiveOperation();

            return true;
        }

        return false;
    }
    finally
    {
        if (GC.TryStartNoGCRegion(0))  // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞, —á–∏ –≤ no-gc —Ä–µ–∂–∏–º—ñ
            GC.EndNoGCRegion();
    }
}

void PerformLatencySensitiveOperation()
{
    // –ù–∞–ø—Ä–∏–∫–ª–∞–¥: real-time audio processing, high-frequency trading
    for (int i = 0; i < 1000; i++)
    {
        ProcessFrame();  // –ù–µ–º–∞—î GC –ø–∞—É–∑–∏!
    }
}
```

::caution
**–û–±–º–µ–∂–µ–Ω–Ω—è No-GC Region:**

-   –Ø–∫—â–æ budget –≤–∏—á–µ—Ä–ø–∞–Ω–æ, CLR –∫–∏–Ω–µ `InvalidOperationException`
-   –ü—Ä–∞—Ü—é—î —Ç—ñ–ª—å–∫–∏ –¥–ª—è –∫–æ—Ä–æ—Ç–∫–æ—á–∞—Å–Ω–∏—Ö –æ–ø–µ—Ä–∞—Ü—ñ–π
-   –ù–µ –ø—ñ–¥—Ö–æ–¥–∏—Ç—å –¥–ª—è –¥–æ–≤–≥–∏—Ö processes
-   –ü–æ—Ç—Ä–µ–±—É—î accurate estimation –±—é–¥–∂–µ—Ç—É –ø–∞–º'—è—Ç—ñ
    ::

---

### GC API —Ç–∞ –ú–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥

#### –û—Å–Ω–æ–≤–Ω—ñ –ú–µ—Ç–æ–¥–∏ GC –ö–ª–∞—Å—É

::field-group
::field{name="GC.Collect()" type="void"}
–ü—Ä–∏–º—É—Å–æ–≤–∏–π –∑–±—ñ—Ä —Å–º—ñ—Ç—Ç—è. –ü–∞—Ä–∞–º–µ—Ç—Ä–∏: `generation` (0-2), `mode`, `blocking`, `compacting`.
::

::field{name="GC.GetGeneration(object)" type="int"}
–ü–æ–≤–µ—Ä—Ç–∞—î –ø–æ–∫–æ–ª—ñ–Ω–Ω—è –æ–±'—î–∫—Ç–∞ (0, 1, –∞–±–æ 2).
::

::field{name="GC.GetTotalMemory(bool)" type="long"}
–ü–æ–≤–µ—Ä—Ç–∞—î –ø—Ä–∏–±–ª–∏–∑–Ω—É –∫—ñ–ª—å–∫—ñ—Å—Ç—å –±–∞–π—Ç —É managed heap. –Ø–∫—â–æ `forceFullCollection=true`, –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è Full GC –ø–µ—Ä–µ–¥ –ø—ñ–¥—Ä–∞—Ö—É–Ω–∫–æ–º.
::

::field{name="GC.CollectionCount(int)" type="int"}
–ü–æ–≤–µ—Ä—Ç–∞—î –∫—ñ–ª—å–∫—ñ—Å—Ç—å –∑–±—ñ—Ä–æ–∫ –¥–ª—è –≤–∫–∞–∑–∞–Ω–æ–≥–æ –ø–æ–∫–æ–ª—ñ–Ω–Ω—è –∑ –º–æ–º–µ–Ω—Ç—É –∑–∞–ø—É—Å–∫—É –ø—Ä–æ—Ü–µ—Å—É.
::

::field{name="GC.WaitForPendingFinalizers()" type="void"}
–û—á—ñ–∫—É—î –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –≤—Å—ñ—Ö finalizers —É —á–µ—Ä–∑—ñ. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –ø—ñ—Å–ª—è `GC.Collect()` –¥–ª—è –≥–∞—Ä–∞–Ω—Ç—ñ—ó, —â–æ finalizers –≤–∏–∫–æ–Ω–∞–ª–∏—Å—å.
::

::field{name="GC.SuppressFinalize(object)" type="void"}
–í–∫–∞–∑—É—î GC, —â–æ –æ–±'—î–∫—Ç –Ω–µ –ø–æ—Ç—Ä–µ–±—É—î —Ñ—ñ–Ω–∞–ª—ñ–∑–∞—Ü—ñ—ó. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è —É Dispose pattern.
::

::field{name="GC.ReRegisterForFinalize(object)" type="void"}
–ü–æ–≤—Ç–æ—Ä–Ω–æ —Ä–µ—î—Å—Ç—Ä—É—î –æ–±'—î–∫—Ç –¥–ª—è —Ñ—ñ–Ω–∞–ª—ñ–∑–∞—Ü—ñ—ó (—Ä—ñ–¥–∫–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è).
::

::field{name="GC.KeepAlive(object)" type="void"}
–ì–∞—Ä–∞–Ω—Ç—É—î, —â–æ –æ–±'—î–∫—Ç –∑–∞–ª–∏—à–∞—î—Ç—å—Å—è –¥–æ—Å—è–∂–Ω–∏–º –¥–æ —Ü—å–æ–≥–æ –º–æ–º–µ–Ω—Ç—É –≤ –∫–æ–¥—ñ. –ó–∞–ø–æ–±—ñ–≥–∞—î –ø–µ—Ä–µ–¥—á–∞—Å–Ω–æ–º—É –∑–±–æ—Ä—É.
::

::field{name="GC.AddMemoryPressure(long)" type="void"}
–ü–æ–≤—ñ–¥–æ–º–ª—è—î GC –ø—Ä–æ –¥–æ–¥–∞—Ç–∫–æ–≤–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –Ω–µ–∫–µ—Ä–æ–≤–∞–Ω–æ—ó –ø–∞–º'—è—Ç—ñ. –ó–±—ñ–ª—å—à—É—î –π–º–æ–≤—ñ—Ä–Ω—ñ—Å—Ç—å –∑–±–æ—Ä—É.
::

::field{name="GC.RemoveMemoryPressure(long)" type="void"}
–ü–æ–≤—ñ–¥–æ–º–ª—è—î GC –ø—Ä–æ –∑–≤—ñ–ª—å–Ω–µ–Ω–Ω—è –Ω–µ–∫–µ—Ä–æ–≤–∞–Ω–æ—ó –ø–∞–º'—è—Ç—ñ.
::
::

**–ü—Ä–∏–∫–ª–∞–¥ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É:**

```csharp
class GCMonitor
{
    static void Main()
    {
        Console.WriteLine("=== GC Statistics ===\n");

        // –ó–∞–≥–∞–ª—å–Ω–∞ –ø–∞–º'—è—Ç—å
        long totalMemory = GC.GetTotalMemory(forceFullCollection: false);
        Console.WriteLine($"Total Memory: {totalMemory / 1024 / 1024} MB");

        // –ö—ñ–ª—å–∫—ñ—Å—Ç—å –∑–±—ñ—Ä–æ–∫ –ø–æ –ø–æ–∫–æ–ª—ñ–Ω–Ω—è—Ö
        Console.WriteLine($"Gen0 Collections: {GC.CollectionCount(0)}");
        Console.WriteLine($"Gen1 Collections: {GC.CollectionCount(1)}");
        Console.WriteLine($"Gen2 Collections: {GC.CollectionCount(2)}");

        // –°—Ç–≤–æ—Ä—é—î–º–æ –æ–±'—î–∫—Ç —ñ –≤—ñ–¥—Å–ª—ñ–¥–∫–æ–≤—É—î–º–æ –π–æ–≥–æ –ø–æ–∫–æ–ª—ñ–Ω–Ω—è
        var obj = new object();
        Console.WriteLine($"\nObject generation: {GC.GetGeneration(obj)}");

        GC.Collect();
        Console.WriteLine($"After GC(0): {GC.GetGeneration(obj)}");

        GC.Collect();
        Console.WriteLine($"After GC(1): {GC.GetGeneration(obj)}");

        // GC Settings
        Console.WriteLine($"\n=== GC Configuration ===");
        Console.WriteLine($"GC Mode: {(GCSettings.IsServerGC ? "Server" : "Workstation")}");
        Console.WriteLine($"Latency Mode: {GCSettings.LatencyMode}");
        Console.WriteLine($"LOH Compaction: {GCSettings.LargeObjectHeapCompactionMode}");

        // GC Max Generation
        Console.WriteLine($"Max Generation: {GC.MaxGeneration}");  // –ó–∞–∑–≤–∏—á–∞–π 2
    }
}
```

**Output:**

```
=== GC Statistics ===

Total Memory: 2 MB
Gen0 Collections: 0
Gen1 Collections: 0
Gen2 Collections: 0

Object generation: 0
After GC(0): 1
After GC(1): 2

=== GC Configuration ===
GC Mode: Workstation
Latency Mode: Interactive
LOH Compaction: Default
Max Generation: 2
```

---

## –ù–µ–∫–µ—Ä–æ–≤–∞–Ω—ñ –†–µ—Å—É—Ä—Å–∏ —Ç–∞ –£–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è –ù–∏–º–∏

### –©–æ —Ç–∞–∫–µ Unman aged Resources?

**Unmanaged resources** (–Ω–µ–∫–µ—Ä–æ–≤–∞–Ω—ñ —Ä–µ—Å—É—Ä—Å–∏) - —Ü–µ —Ä–µ—Å—É—Ä—Å–∏ –æ–ø–µ—Ä–∞—Ü—ñ–π–Ω–æ—ó —Å–∏—Å—Ç–µ–º–∏, —è–∫—ñ **–Ω–µ —É–ø—Ä–∞–≤–ª—è—é—Ç—å—Å—è Garbage Collector**:

::field-group
::field{name="File Handles" type="System.IO.FileStream"}
–î–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∏ —Ñ–∞–π–ª—ñ–≤, –≤—ñ–¥–∫—Ä–∏—Ç–∏—Ö –¥–ª—è —á–∏—Ç–∞–Ω–Ω—è/–∑–∞–ø–∏—Å—É.
::

::field{name="Network Connections" type="System.Net.Sockets.Socket"}
TCP/UDP —Å–æ–∫–µ—Ç–∏, HTTP connections.
::

::field{name="Database Connections" type="System.Data.SqlClient.SqlConnection"}
–ó'—î–¥–Ω–∞–Ω–Ω—è –∑ –±–∞–∑–∞–º–∏ –¥–∞–º–∏.
::

::field{name="Native Memory" type="IntPtr, void\*"}
–ü–∞–º'—è—Ç—å, –≤–∏–¥—ñ–ª–µ–Ω–∞ —á–µ—Ä–µ–∑ `Marshal.AllocHGlobal()`, `malloc()` –≤ C/C++.
::

::field{name="Window Handles (GDI Objects)" type="IntPtr"}
–í—ñ–∫–Ω–∞, brushes, pens, fonts –≤ Windows API.
::

::field{name="COM Objects" type="System.Runtime.InteropServices.ComTypes"}
Component Object Model –æ–±'—î–∫—Ç–∏ –¥–ª—è interop.
::

::field{name="Mutexes, Semaphores" type="System.Threading"}
–°–∏—Å—Ç–µ–º–Ω—ñ –ø—Ä–∏–º—ñ—Ç–∏–≤–∏ —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—ó.
::
::

### –ß–æ–º—É GC –ù–µ –ú–æ–∂–µ –á—Ö –û—á–∏—Å—Ç–∏—Ç–∏?

GC –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î **—Ç—ñ–ª—å–∫–∏ –∑–∞ managed heap**. –í—ñ–Ω –Ω–µ –∑–Ω–∞—î –ø—Ä–æ:

-   –°–∫—ñ–ª—å–∫–∏ –ø–∞–º'—è—Ç—ñ –∑–∞–π–º–∞—î –≤—ñ–¥–∫—Ä–∏—Ç–∏–π —Ñ–∞–π–ª –≤ kernel space
-   –ß–∏ –ø–æ—Ç—Ä—ñ–±–Ω–æ –≤–∏–∫–ª–∏–∫–∞—Ç–∏ `close()` –¥–ª—è —Å–æ–∫–µ—Ç–∞
-   –Ø–∫ –∑–≤—ñ–ª—å–Ω–∏—Ç–∏ native memory pointer

```csharp
class ProblematicCode
{
    void OpenFile()
    {
        FileStream fs = new FileStream("data.txt", FileMode.Open);
        byte[] buffer = new byte[1024];
        fs.Read(buffer, 0, buffer.Length);

        // ‚ùå –ü–û–ú–ò–õ–ö–ê: –ù–µ –∑–∞–∫—Ä–∏–ª–∏ —Ñ–∞–π–ª!
        // fs.Dispose() –Ω–µ –≤–∏–∫–ª–∏–∫–∞–Ω–æ

    } // fs –≤–∏–π—à–æ–≤ –∑ scope, –∞–ª–µ FILE HANDLE —â–µ –≤—ñ–¥–∫—Ä–∏—Ç–∏–π!
      // GC –∑—ñ–±–µ—Ä–µ FileStream –æ–±'—î–∫—Ç, –∞–ª–µ handle –∑–∞–ª–∏—à–∏—Ç—å—Å—è!
}
```

**–ù–∞—Å–ª—ñ–¥–∫–∏:** File handle leak ‚Üí —á–µ—Ä–µ–∑ —è–∫–∏–π—Å—å —á–∞—Å –û–° –∑–∞–±–æ—Ä–æ–Ω–∏—Ç—å –≤—ñ–¥–∫—Ä–∏–≤–∞—Ç–∏ –Ω–æ–≤—ñ —Ñ–∞–π–ª–∏.

::warning
**Windows**: –ó–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º –ø—Ä–æ—Ü–µ—Å –º–æ–∂–µ –º–∞—Ç–∏ –º–∞–∫—Å–∏–º—É–º ~10,000 handles. –Ø–∫—â–æ –Ω–µ –∑–∞–∫—Ä–∏–≤–∞—Ç–∏ - –¥–æ—Å—è–≥–Ω–µ—Ç–µ –ª—ñ–º—ñ—Ç—É —Ç–∞ –æ—Ç—Ä–∏–º–∞—î—Ç–µ `IOException: Too many open files`.

**Linux**: –õ—ñ–º—ñ—Ç –º–æ–∂–Ω–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏: `ulimit -n`. –ó–∞–∑–≤–∏—á–∞–π 1024-65535.
::

---

## IDisposable Pattern: –ü—Ä–∞–≤–∏–ª—å–Ω–µ –£–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è –†–µ—Å—É—Ä—Å–∞–º–∏

### –Ü–Ω—Ç–µ—Ä—Ñ–µ–π—Å IDisposable

**IDisposable** - —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏–π –º–µ—Ö–∞–Ω—ñ–∑–º .NET –¥–ª—è —è–≤–Ω–æ–≥–æ –∑–≤—ñ–ª—å–Ω–µ–Ω–Ω—è —Ä–µ—Å—É—Ä—Å—ñ–≤:

```csharp
public interface IDisposable
{
    void Dispose();
}
```

**–ö–æ–Ω—Ç—Ä–∞–∫—Ç:**

-   –ú–µ—Ç–æ–¥ `Dispose()` –º–∞—î –∑–≤—ñ–ª—å–Ω–∏—Ç–∏ **–≤—Å—ñ** –Ω–µ–∫–µ—Ä–æ–≤–∞–Ω—ñ —Ä–µ—Å—É—Ä—Å–∏
-   –ü—ñ—Å–ª—è –≤–∏–∫–ª–∏–∫—É `Dispose()` –æ–±'—î–∫—Ç —Å—Ç–∞—î **unusable** (–Ω–µ –º–æ–∂–Ω–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏)
-   –ú–æ–∂–Ω–∞ –≤–∏–∫–ª–∏–∫–∞—Ç–∏ `Dispose()` **–∫—ñ–ª—å–∫–∞ —Ä–∞–∑—ñ–≤** –±–µ–∑–ø–µ—á–Ω–æ (idempotent)
-   `Dispose()` **–Ω–µ –≤–∏–∫–ª–∏–∫–∞—î—Ç—å—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ** - –≤—ñ–¥–ø–æ–≤—ñ–¥–∞–ª—å–Ω—ñ—Å—Ç—å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –∫–ª–∞—Å—É

### –ë–∞–∑–æ–≤–∞ –†–µ–∞–ª—ñ–∑–∞—Ü—ñ—è

–ù–∞–π–ø—Ä–æ—Å—Ç—ñ—à–∏–π –≤–∏–ø–∞–¥–æ–∫ - –∫–ª–∞—Å –∑ –æ–¥–Ω–∏–º unmanaged resource:

```csharp {8,11-14,17-19} showLineNumbers
class FileLogger : IDisposable
{
    private FileStream _fileStream;

    public FileLogger(string path)
    {
        _fileStream = new FileStream(path, FileMode.Append);
    }

    public void Dispose()
    {
        // –ó–≤—ñ–ª—å–Ω–∏—Ç–∏ unmanaged resource
        _fileStream?.Dispose();
        _fileStream = null;
    }

    public void Log(string message)
    {
        if (_fileStream == null)
            throw new ObjectDisposedException(nameof(FileLogger));

        byte[] data = Encoding.UTF8.GetBytes(message + Environment.NewLine);
        _fileStream.Write(data, 0, data.Length);
    }
}

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
using (var logger = new FileLogger("app.log"))
{
    logger.Log("Application started");
    logger.Log("Processing data");
} // Dispose() –≤–∏–∫–ª–∏–∫–∞—î—Ç—å—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ
```

::note
**Null-Conditional Operator**: `_fileStream?.Dispose()` –±–µ–∑–ø–µ—á–Ω–æ –≤–∏–∫–ª–∏–∫–∞—î Dispose –Ω–∞–≤—ñ—Ç—å —è–∫—â–æ `_fileStream` –≤–∂–µ `null`. –¶–µ –∑–∞–±–µ–∑–ø–µ—á—É—î idempotency.
::

---

### –ü–æ–≤–Ω–∏–π Dispose Pattern (Full Pattern)

–î–ª—è **—Å–∫–ª–∞–¥–Ω—ñ—à–∏—Ö** —Å—Ü–µ–Ω–∞—Ä—ñ—ó–≤ (–Ω–∞—Å–ª—ñ–¥—É–≤–∞–Ω–Ω—è, –∫–æ–º–±—ñ–Ω–∞—Ü—ñ—è managed + unmanaged resources) –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è **–ø–æ–≤–Ω–∏–π dispose pattern**:

```csharp {showLineNumbers}
class ResourceManager : IDisposable
{
    // Unmanaged resource
    private IntPtr _nativePtr;

    // Managed resource (—Ç–∞–∫–æ–∂ IDisposable)
    private FileStream _fileStream;

    // Flag –¥–ª—è –≤—ñ–¥—Å—Ç–µ–∂–µ–Ω–Ω—è disposed —Å—Ç–∞–Ω—É
    private bool _disposed = false;

    public ResourceManager(string filePath)
    {
        // –ê–ª–æ–∫—É—î–º–æ unmanaged memory
        _nativePtr = Marshal.AllocHGlobal(1024);

        // –í—ñ–¥–∫—Ä–∏–≤–∞—î–º–æ —Ñ–∞–π–ª
        _fileStream = new FileStream(filePath, FileMode.Create);
    }

    // Public Dispose method
    public void Dispose()
    {
        // –í–∏–∫–ª–∏–∫–∞—î–º–æ protected Dispose –∑ disposing=true
        Dispose(disposing: true);

        // –í–∫–∞–∑—É—î–º–æ GC: –Ω–µ –≤–∏–∫–ª–∏–∫–∞—Ç–∏ finalizer
        GC.SuppressFinalize(this);
    }

    // Protected virtual Dispose method
    protected virtual void Dispose(bool disposing)
    {
        // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞: —á–∏ –≤–∂–µ disposed?
        if (_disposed)
            return;

        if (disposing)
        {
            // –ó–≤—ñ–ª—å–Ω—è—î–º–æ MANAGED resources
            _fileStream?.Dispose();
        }

        // –ó–≤—ñ–ª—å–Ω—è—î–º–æ UNMANAGED resources (–∑–∞–≤–∂–¥–∏!)
        if (_nativePtr != IntPtr.Zero)
        {
            Marshal.FreeHGlobal(_nativePtr);
            _nativePtr = IntPtr.Zero;
        }

        _disposed = true;
    }

    // Destructor (Finalizer)
    ~ResourceManager()
    {
        // –í–∏–∫–ª–∏–∫–∞—î—Ç—å—Å—è GC, —è–∫—â–æ Dispose() –Ω–µ –±—É–≤ –≤–∏–∫–ª–∏–∫–∞–Ω–∏–π
        // disposing=false -> —Ç—ñ–ª—å–∫–∏ unmanaged cleanup
        Dispose(disposing: false);
    }

    // Helper method –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ disposed —Å—Ç–∞–Ω—É
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(GetType().Name);
    }

    public void WriteData(byte[] data)
    {
        ThrowIfDisposed();
        _fileStream.Write(data, 0, data.Length);
    }
}
```

**–†–æ–∑–±—ñ—Ä –∫–ª—é—á–æ–≤–∏—Ö –º–æ–º–µ–Ω—Ç—ñ–≤:**

::steps

### `Dispose(bool disposing)` - –°–µ—Ä—Ü–µ Pattern

–ü–∞—Ä–∞–º–µ—Ç—Ä `disposing`:

-   `true`: –≤–∏–∫–ª–∏–∫–∞–Ω–æ –∑ `Dispose()` (managed context) ‚Üí –æ—á–∏—â–∞—î–º–æ —ñ managed, —ñ unmanaged
-   `false`: –≤–∏–∫–ª–∏–∫–∞–Ω–æ –∑ finalizer (–Ω–µ–¥–µ—Ç–µ—Ä–º—ñ–Ω–æ–≤–∞–Ω–æ) ‚Üí –æ—á–∏—â–∞—î–º–æ –¢–Ü–õ–¨–ö–ò unmanaged

**–ß–æ–º—É?** –ü—ñ–¥ —á–∞—Å finalization managed –æ–±'—î–∫—Ç–∏ –º–æ–∂—É—Ç—å –≤–∂–µ –±—É—Ç–∏ –∑—ñ–±—Ä–∞–Ω—ñ GC!

### `GC.SuppressFinalize(this)`

–Ø–∫—â–æ `Dispose()` –≤–∏–∫–ª–∏–∫–∞–Ω–æ —è–≤–Ω–æ, finalizer –Ω–µ –ø–æ—Ç—Ä—ñ–±–µ–Ω ‚Üí –µ–∫–æ–Ω–æ–º–∏–º–æ —Ä–µ—Å—É—Ä—Å–∏ GC.

### `_disposed` Flag

–ó–∞—Ö–∏—Å—Ç –≤—ñ–¥ –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –≤–∏–∫–ª–∏–∫—É. –ë–µ–∑ —Ü—å–æ–≥–æ –º–æ–∂–Ω–∞ –¥–≤—ñ—á—ñ –∑–≤—ñ–ª—å–Ω–∏—Ç–∏ —Ä–µ—Å—É—Ä—Å ‚Üí crash!

### Finalizer `~ResourceManager()`

Fallback –Ω–∞ –≤–∏–ø–∞–¥–æ–∫, —è–∫—â–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á –∑–∞–±—É–≤ –≤–∏–∫–ª–∏–∫–∞—Ç–∏ `Dispose()`. –ù–µ —ñ–¥–µ–∞–ª—å–Ω–æ, –∞–ª–µ –∫—Ä–∞—â–µ –Ω—ñ–∂ leak.
::

::mermaid

```mermaid
graph TD
    A[Object Created] --> B{User Called Dispose?}
    B -->|Yes| C[Dispose disposing=true]
    B -->|No| D[Object Unreachable]

    C --> E[Release Managed Resources]
    E --> F[Release Unmanaged Resources]
    F --> G[GC.SuppressFinalize]
    G --> H[Object Fully Disposed]

    D --> I[GC Finalizer Queue]
    I --> J[Finalizer ~Class]
    J --> K[Dispose disposing=false]
    K --> L[Release ONLY Unmanaged]
    L --> H

    style A fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style C fill:#f59e0b,stroke:#b45309,color:#ffffff
    style K fill:#f59e0b,stroke:#b45309,color:#ffffff
    style H fill:#64748b,stroke:#334155,color:#ffffff
```

::

---

### Dispose Pattern –∑ –ù–∞—Å–ª—ñ–¥—É–≤–∞–Ω–Ω—è–º

–Ø–∫—â–æ –∫–ª–∞—Å —É—Å–ø–∞–¥–∫–æ–≤—É—î —ñ–Ω—à–∏–π disposable –∫–ª–∞—Å:

::code-group

```csharp [Base Class]
class BaseResource : IDisposable
{
    private IntPtr _baseHandle;
    protected bool _disposed = false;

    public BaseResource()
    {
        _baseHandle = Marshal.AllocHGlobal(512);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
        GC.SuppressFinalize(this);
    }

    // VIRTUAL - –¥–æ–∑–≤–æ–ª—è—î–º–æ override –≤ derived
    protected virtual void Dispose(bool disposing)
    {
        if (_disposed)
            return;

        if (disposing)
        {
            // Managed resources (—è–∫—â–æ —î)
        }

        // Unmanaged cleanup
        if (_baseHandle != IntPtr.Zero)
        {
            Marshal.FreeHGlobal(_baseHandle);
            _baseHandle = IntPtr.Zero;
        }

        _disposed = true;
    }

    ~BaseResource()
    {
        Dispose(disposing: false);
    }
}
```

```csharp [Derived Class]
class DerivedResource : BaseResource
{
    private FileStream _derivedFile;

    public DerivedResource(string path)
    {
        _derivedFile = new FileStream(path, FileMode.Create);
    }

    protected override void Dispose(bool disposing)
    {
        if (_disposed)
            return;

        if (disposing)
        {
            // –û—á–∏—â–∞—î–º–æ –°–í–û–á managed resources
            _derivedFile?.Dispose();
        }

        // Unmanaged resources derived –∫–ª–∞—Å—É (—è–∫—â–æ —î)
        // ...

        // –ö–†–ò–¢–ò–ß–ù–û: –í–∏–∫–ª–∏–∫–∞—Ç–∏ base.Dispose()
        base.Dispose(disposing);

        // –ù–ï –≤—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ _disposed —Ç—É—Ç - —Ü–µ —Ä–æ–±–∏—Ç—å base
    }

    // Finalizer –ù–ï –ø–æ—Ç—Ä—ñ–±–µ–Ω - base –≤–∂–µ –º–∞—î
}
```

```csharp [Usage]
class Program
{
    static void Main()
    {
        using (var resource = new DerivedResource("data.bin"))
        {
            // –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è resource
        }

        // –ü—Ä–∏ –≤–∏—Ö–æ–¥—ñ –∑ using:
        // 1. resource.Dispose() –≤–∏–∫–ª–∏–∫–∞—î—Ç—å—Å—è
        // 2. DerivedResource.Dispose(true) –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è
        // 3. base.Dispose(true) –≤–∏–∫–ª–∏–∫–∞—î—Ç—å—Å—è
        // 4. –û—á–∏—â–µ–Ω—ñ –æ–±–∏–¥–≤–∞ —Ä—ñ–≤–Ω—ñ —ñ—î—Ä–∞—Ä—Ö—ñ—ó
    }
}
```

::

::tip
**Best Practice –¥–ª—è –ù–∞—Å–ª—ñ–¥—É–≤–∞–Ω–Ω—è:**

-   Base class: Dispose method `virtual`
-   Derived class: `override` Dispose, –≤–∏–∫–ª–∏–∫–∞—Ç–∏ `base.Dispose(disposing)` –≤ –∫—ñ–Ω—Ü—ñ
-   Finalizer –ø–æ—Ç—Ä—ñ–±–µ–Ω —Ç—ñ–ª—å–∫–∏ –≤ base class
-   `_disposed` flag –º–æ–∂–Ω–∞ –∑—Ä–æ–±–∏—Ç–∏ `protected` –¥–ª—è –¥–æ—Å—Ç—É–ø—É –≤ derived
    ::

---

### IAsyncDisposable (.NET Standard 2.1+, C# 8.0+)

–î–ª—è **–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∏—Ö** —Ä–µ—Å—É—Ä—Å—ñ–≤ (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, network streams, async file I/O):

```csharp {showLineNumbers}
class AsyncResourceManager : IAsyncDisposable
{
    private NetworkStream _networkStream;
    private SemaphoreSlim _semaphore = new SemaphoreSlim(1);
    private bool _disposed = false;

    public async ValueTask DisposeAsync()
    {
        if (_disposed)
            return;

        await DisposeAsyncCore().ConfigureAwait(false);

        // Cleanup synchronous resources
        Dispose(disposing: false);

        GC.SuppressFinalize(this);
        _disposed = true;
    }

    protected virtual async ValueTask DisposeAsyncCore()
    {
        // –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–µ –æ—á–∏—â–µ–Ω–Ω—è
        if (_networkStream != null)
        {
            await _networkStream.FlushAsync().ConfigureAwait(false);
            await _networkStream.DisposeAsync().ConfigureAwait(false);
        }

        _semaphore?.Dispose();
    }

    protected virtual void Dispose(bool disposing)
    {
        // –°–∏–Ω—Ö—Ä–æ–Ω–Ω—ñ unmanaged resources (—è–∫—â–æ —î)
    }
}

// –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –∑ await using
async Task ProcessAsync()
{
    await using var manager = new AsyncResourceManager();

    // –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞ —Ä–æ–±–æ—Ç–∞
    await manager.ProcessDataAsync();

} // DisposeAsync() –≤–∏–∫–ª–∏–∫–∞—î—Ç—å—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ
```

**–ö–æ–ª–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ IAsyncDisposable:**

-   Network streams –∑ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∏–º flush
-   Database connections –∑ async cleanup
-   File streams –∑ async flush (–æ—Å–æ–±–ª–∏–≤–æ –¥–ª—è –≤–µ–ª–∏–∫–∏—Ö –±—É—Ñ–µ—Ä—ñ–≤)
-   Resources, –¥–µ cleanup –º–æ–∂–µ –±–ª–æ–∫—É–≤–∞—Ç–∏ thread

::note
**IAsyncDisposable + IDisposable**: –ú–æ–∂–Ω–∞ —Ä–µ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ –æ–±–∏–¥–≤–∞ —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∏. `D ispose()` –±—É–¥–µ fallback –¥–ª—è synchronous context, `DisposeAsync()` - –¥–ª—è async.

```csharp
class DualDisposable : IDisposable, IAsyncDisposable
{
    public void Dispose() { /* sync path */ }
    public ValueTask DisposeAsync() { /* async path */ }
}
```

::

---

## using Statement: –ì–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–∏–π Dispose

### –¢—Ä–∞–¥–∏—Ü—ñ–π–Ω–∏–π using Statement

`using` statement –∑–∞–±–µ–∑–ø–µ—á—É—î **–∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π –≤–∏–∫–ª–∏–∫ Dispose** –Ω–∞–≤—ñ—Ç—å –ø—Ä–∏ exceptions:

```csharp
using (FileStream fs = new FileStream("data.txt", FileMode.Open))
{
    // –†–æ–±–æ—Ç–∞ –∑ —Ñ–∞–π–ª–æ–º
    byte[] buffer = new byte[1024];
    fs.Read(buffer, 0, buffer.Length);

    // –ù–∞–≤—ñ—Ç—å —è–∫—â–æ exception -> Dispose() –≤–∏–∫–ª–∏–∫–∞—î—Ç—å—Å—è!
}
// fs.Dispose() –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–æ –≤–∏–∫–ª–∏–∫–∞–Ω–æ
```

**–ö–æ–º–ø—ñ–ª—è—Ü—ñ—è –≤ IL (—Å–ø—Ä–æ—â–µ–Ω–æ):**

```csharp
FileStream fs = new FileStream("data.txt", FileMode.Open);
try
{
    byte[] buffer = new byte[1024];
    fs.Read(buffer, 0, buffer.Length);
}
finally
{
    if (fs != null)
        ((IDisposable)fs).Dispose();
}
```

::mermaid

```mermaid
sequenceDiagram
    participant Code as Application Code
    participant Res as IDisposable Resource
    participant GC as Garbage Collector

    Code->>Res: using (var res = new Resource())
    Note over Code,Res: Try block begins

    Code->>Res: Use resource
    Res-->>Code: Data/Operations

    alt Exception Occurs
        Code->>Code: Exception thrown
        Note over Code,Res: Finally block executes
        Code->>Res: Dispose()
        Res->>Res: Cleanup resources
        Code->>Code: Re-throw exception
    else Normal Execution
        Note over Code,Res: End of using scope
        Note over Code,Res: Finally block executes
        Code->>Res: Dispose()
        Res->>Res: Cleanup resources
    end

    Res->>GC: SuppressFinalize (if pattern used)
    Note over Res,GC: Object becomes garbage

    style Code fill:#3b82f6,stroke:#1d4ed8,color:#ffffff
    style Res fill:#f59e0b,stroke:#b45309,color:#ffffff
```

::

---

### using Declaration (C# 8.0+)

**Scope-based disposal** –±–µ–∑ —Ñ—ñ–≥—É—Ä–Ω–∏—Ö –¥—É–∂–æ–∫:

```csharp
void ProcessFile()
{
    using FileStream fs = new FileStream("data.txt", FileMode.Open);
    using StreamReader reader = new StreamReader(fs);

    // –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è fs —Ç–∞ reader
    string content = reader.ReadToEnd();
    Console.WriteLine(content);

    // Dispose –≤–∏–∫–ª–∏–∫–∞—î—Ç—å—Å—è –ø—Ä–∏ –≤–∏—Ö–æ–¥—ñ –∑ –º–µ—Ç–æ–¥—É (–≤ –ó–í–û–†–û–¢–ù–û–ú–£ –ø–æ—Ä—è–¥–∫—É):
    // 1. reader.Dispose()
    // 2. fs.Dispose()
}
```

**–ü–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è:**

::code-group

```csharp [Traditional using]
void TraditionalUsing()
{
    using (var resource1 = new Resource())
    {
        using (var resource2 = new Resource())
        {
            using (var resource3 = new Resource())
            {
                // –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
                DoWork();
            }
        }
    }

    // –í–∫–ª–∞–¥–µ–Ω—ñ –±–ª–æ–∫–∏ -> "Pyramid of Doom"
}
```

```csharp [using Declaration]
void UsingDeclaration()
{
    using var resource1 = new Resource();
    using var resource2 = new Resource();
    using var resource3 = new Resource();

    // –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è - —á–∏—Å—Ç—ñ—à–∏–π –∫–æ–¥!
    DoWork();

    // –ü—Ä–∏ –≤–∏—Ö–æ–¥—ñ –∑ –º–µ—Ç–æ–¥—É dispose –≤ reverse order:
    // resource3, resource2, resource1
}
```

::

::tip
**–ö–æ–ª–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ using declaration:**

-   –†–µ—Å—É—Ä—Å –ø–æ—Ç—Ä—ñ–±–µ–Ω –¥–æ –∫—ñ–Ω—Ü—è –º–µ—Ç–æ–¥—É
-   –ö—ñ–ª—å–∫–∞ —Ä–µ—Å—É—Ä—Å—ñ–≤ –æ–¥–Ω–æ—á–∞—Å–Ω–æ (—É–Ω–∏–∫–∞—î nesting)
-   –ü–æ–∫—Ä–∞—â—É—î —á–∏—Ç–∞–±–µ–ª—å–Ω—ñ—Å—Ç—å

**–ö–æ–ª–∏ traditional using:**

-   –†–µ—Å—É—Ä—Å –ø–æ—Ç—Ä—ñ–±–µ–Ω —Ç—ñ–ª—å–∫–∏ –¥–ª—è —á–∞—Å—Ç–∏–Ω–∏ –º–µ—Ç–æ–¥—É
-   –Ø–≤–Ω–∏–π –∫–æ–Ω—Ç—Ä–æ–ª—å –Ω–∞–¥ disposal scope
    ::

---

### await using (Async Disposal)

–î–ª—è `IAsyncDisposable`:

```csharp
async Task ProcessDataAsync()
{
    // Traditional await using
    await using (var stream = new NetworkStream(...))
    {
        await stream.WriteAsync(data);
        await stream.FlushAsync();
    } // await stream.DisposeAsync()

    // await using declaration
    await using var connection = new AsyncDatabaseConnection();
    await connection.ExecuteQueryAsync("SELECT * FROM Users");

} // await connection.DisposeAsync()
```

**–ö–æ–º–ø—ñ–ª—è—Ü—ñ—è:**

```csharp
// await using (var res = new AsyncResource())
var res = new AsyncResource();
try
{
    // Use resource
}
finally
{
    if (res != null)
        await res.DisposeAsync().ConfigureAwait(false);
}
```

---

### Multiple Resources –≤ using

**–ö—ñ–ª—å–∫–∞ —Ä–µ—Å—É—Ä—Å—ñ–≤ –æ–¥–Ω–æ–≥–æ —Ç–∏–ø—É:**

```csharp
// –¢—Ä–∞–¥–∏—Ü—ñ–π–Ω–∏–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å (—Ä—ñ–¥–∫–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è)
using (FileStream input = File.OpenRead("input.txt"),
       output = File.OpenWrite("output.txt"))
{
    input.CopyTo(output);
}

// –ö—Ä–∞—â–µ: using declarations
void CopyFile()
{
    using var input = File.OpenRead("input.txt");
    using var output = File.OpenWrite("output.txt");

    input.CopyTo(output);
}
```

**–†—ñ–∑–Ω—ñ —Ç–∏–ø–∏:**

```csharp
async Task ProcessWithMultipleResources()
{
    using var connection = new SqlConnection(connectionString);
    await using var transaction = await connection.BeginTransactionAsync();
    using var semaphore = new SemaphoreSlim(1);

    await semaphore.WaitAsync();
    try
    {
        // –†–æ–±–æ—Ç–∞ –∑ resources
        await ExecuteInTransactionAsync(connection, transaction);
        await transaction.CommitAsync();
    }
    finally
    {
        semaphore.Release();
    }

    // Dispose order (reverse):
    // 1. semaphore.Dispose()
    // 2. await transaction.DisposeAsync()
    // 3. connection.Dispose()
}
```

::warning
**–í–∞–∂–ª–∏–≤–æ**: using declaration –≤–∏–∫–ª–∏–∫–∞—î Dispose —É **–∑–≤–æ—Ä–æ—Ç–Ω–æ–º—É –ø–æ—Ä—è–¥–∫—É** –æ–≥–æ–ª–æ—à–µ–Ω–Ω—è. –¶–µ –∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è –∑–∞–ª–µ–∂–Ω–∏—Ö —Ä–µ—Å—É—Ä—Å—ñ–≤ (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, transaction –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ connection).
::

---

## Finalizers (–î–µ—Å—Ç—Ä—É–∫—Ç–æ—Ä–∏): Safety Net –∑ –û–±–º–µ–∂–µ–Ω–Ω—è–º–∏

### –°–∏–Ω—Ç–∞–∫—Å–∏—Å —Ç–∞ –°–µ–º–∞–Ω—Ç–∏–∫–∞

**Finalizer** (–¥–µ—Å—Ç—Ä—É–∫—Ç–æ—Ä) - —Ü–µ —Å–ø–µ—Ü—ñ–∞–ª—å–Ω–∏–π –º–µ—Ç–æ–¥, —è–∫–∏–π –≤–∏–∫–ª–∏–∫–∞—î—Ç—å—Å—è GC **–ø–µ—Ä–µ–¥** –∑–≤—ñ–ª—å–Ω–µ–Ω–Ω—è–º –ø–∞–º'—è—Ç—ñ –æ–±'—î–∫—Ç–∞. –î–µ—Ç–∞–ª—å–Ω–∏–π —Ä–æ–∑–±—ñ—Ä –º–µ—Ö–∞–Ω—ñ–∑–º—É:

#### –ë–∞–∑–æ–≤–∏–π –ü—Ä–∏–∫–ª–∞–¥

```csharp {showLineNumbers}
class ResourceHolder
{
    private IntPtr _handle;

    public ResourceHolder()
    {
        _handle = AllocateResource();
    }

    // Finalizer (–¥–µ—Å—Ç—Ä—É–∫—Ç–æ—Ä)
    ~ResourceHolder()
    {
        // Cleanup –∫–æ–¥
        if (_handle != IntPtr.Zero)
        {
            FreeResource(_handle);
            _handle = IntPtr.Zero;
        }
    }
}
```

**–ü—ñ–¥ –∫–∞–ø–æ—Ç–æ–º –∫–æ–º–ø—ñ–ª—è—Ç–æ—Ä** –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—î `~ClassName()` —É –º–µ—Ç–æ–¥ `Finalize()`:

```csharp
// –©–æ –≥–µ–Ω–µ—Ä—É—î –∫–æ–º–ø—ñ–ª—è—Ç–æ—Ä:
protected override void Finalize()
{
    try
    {
        // –í–∞—à cleanup –∫–æ–¥ —Ç—É—Ç
        if (_handle != IntPtr.Zero)
        {
            FreeResource(_handle);
            _handle = IntPtr.Zero;
        }
    }
    finally
    {
        base.Finalize();  // –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π –≤–∏–∫–ª–∏–∫ finalizer –±–∞–∑–æ–≤–æ–≥–æ –∫–ª–∞—Å—É
    }
}
```

### –ú–µ—Ö–∞–Ω—ñ–∑–º Finalization

GC –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î –¥–≤—ñ —Å–ø–µ—Ü—ñ–∞–ª—å–Ω—ñ —á–µ—Ä–≥–∏ –¥–ª—è —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è –æ–±'—î–∫—Ç–∞–º–∏ –∑ finalizers. –ü—Ä–æ—Ü–µ—Å —Å–∫–ª–∞–¥–Ω–∏–π —ñ —Ü—ñ–∫–∞–≤–∏–π - —Ä–æ–∑–±–µ—Ä–µ–º–æ –¥–µ—Ç–∞–ª—å–Ω–æ.

**–ü—Ä–æ–±–ª–µ–º–∞:** –û–±'—î–∫—Ç–∏ –∑ finalizers –∂–∏–≤—É—Ç—å **–º—ñ–Ω—ñ–º—É–º 2 GC cycles**, —â–æ –∑–∞—Ç—Ä–∏–º—É—î –∑–≤—ñ–ª—å–Ω–µ–Ω–Ω—è –ø–∞–º'—è—Ç—ñ.

::warning
**Performance Impact**: –Ø–∫—â–æ –≤–∞—à –¥–æ–¥–∞—Ç–æ–∫ —Å—Ç–≤–æ—Ä—é—î –±–∞–≥–∞—Ç–æ –æ–±'—î–∫—Ç—ñ–≤ –∑ finalizers, —Ü–µ –º–æ–∂–µ –∑–Ω–∞—á–Ω–æ —É–ø–æ–≤—ñ–ª—å–Ω–∏—Ç–∏ GC —Ç–∞ –∑–±—ñ–ª—å—à–∏—Ç–∏ memory pressure, –æ—Å–∫—ñ–ª—å–∫–∏ –æ–±'—î–∫—Ç–∏ –∑–∞–ª–∏—à–∞—é—Ç—å—Å—è —É –ø–∞–º'—è—Ç—ñ –¥–æ–≤—à–µ.
::

---

## WeakReference: –ö–µ—à—É–≤–∞–Ω–Ω—è –±–µ–∑ Memory Leaks

### –û—Å–Ω–æ–≤–∏ WeakReference\<T\>

**WeakReference** –¥–æ–∑–≤–æ–ª—è—î –ø–æ—Å–∏–ª–∞—Ç–∏—Å—è –Ω–∞ –æ–±'—î–∫—Ç –±–µ–∑ –∑–∞–ø–æ–±—ñ–≥–∞–Ω–Ω—è –π–æ–≥–æ –∑–±–æ—Ä—É GC - —ñ–¥–µ–∞–ª—å–Ω–æ –¥–ª—è –∫–µ—à—ñ–≤.

```csharp {showLineNumbers}
class ImageCache
{
    private Dictionary<string, WeakReference<Image>> _cache = new();

    public Image GetImage(string path)
    {
        if (_cache.TryGetValue(path, out var weakRef) &&
            weakRef.TryGetTarget(out var image))
        {
            return image;  // Cache hit
        }

        // Cache miss - –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏
        var newImage = Image.Load(path);
        _cache[path] = new WeakReference<Image>(newImage);
        return newImage;
    }
}
```

---

## Memory Layout: –î–µ—Ç–∞–ª—å–Ω–∞ –°—Ç—Ä—É–∫—Ç—É—Ä–∞

### Object Header —É 32/64-bit

–ö–æ–∂–µ–Ω –æ–±'—î–∫—Ç –º–∞—î overhead:

```
64-bit –ø—Ä–æ—Ü–µ—Å:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Sync Block 8B‚îÇMethodTable 8B‚îÇ Fields...   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
–ú—ñ–Ω—ñ–º—É–º: 24 –±–∞–π—Ç–∏ –¥–ª—è –ø–æ—Ä–æ–∂–Ω—å–æ–≥–æ –æ–±'—î–∫—Ç–∞

32-bit –ø—Ä–æ—Ü–µ—Å:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Sync Block 4B‚îÇMethodTable 4B‚îÇ Fields...   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
–ú—ñ–Ω—ñ–º—É–º: 12 –±–∞–π—Ç
```

### Field Padding –ü—Ä–∏–∫–ª–∞–¥

```csharp
struct BadLayout
{
    byte b1;    // 1 byte
    long l1;    // 8 bytes
    byte b2;    // 1 byte
}
// Actual size: 24 bytes (–∑ padding!)

struct GoodLayout
{
    long l1;    // 8 bytes
    byte b1;    // 1 byte
    byte b2;    // 1 byte
}
// Actual size: 16 bytes
```

::tip
**–û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è**: –†–æ–∑—Ç–∞—à–æ–≤—É–π—Ç–µ –ø–æ–ª—è –≤—ñ–¥ –Ω–∞–π–±—ñ–ª—å—à–∏—Ö –¥–æ –Ω–∞–π–º–µ–Ω—à–∏—Ö –¥–ª—è –º—ñ–Ω—ñ–º—ñ–∑–∞—Ü—ñ—ó padding —Ç–∞ –ø–æ–∫—Ä–∞—â–µ–Ω–Ω—è cache locality.
::

---

## Best Practices —Ç–∞ –í–∏—Å–Ω–æ–≤–∫–∏

### –ö–ª—é—á–æ–≤—ñ –ü—Ä–∞–≤–∏–ª–∞

::tip
**Golden Rules –¥–ª—è Memory Management:**

1. **–î–æ–≤—ñ—Ä—è–π—Ç–µ GC** - –Ω–µ –≤–∏–∫–ª–∏–∫–∞–π—Ç–µ `GC.Collect()` –±–µ–∑ –≤–∞–≥–æ–º–æ—ó –ø—Ä–∏—á–∏–Ω–∏
2. **–ó–∞–≤–∂–¥–∏ Dispose** - –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ `using` –¥–ª—è –≤—Å—ñ—Ö IDisposable —Ä–µ—Å—É—Ä—Å—ñ–≤
3. **–£–Ω–∏–∫–∞–π—Ç–µ Finalizers** - –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ SafeHandle –∞–±–æ IDisposable
4. **–ü—Ä–æ—Ñ—ñ–ª—é–π—Ç–µ** - –≤–∏–º—ñ—Ä—é–π—Ç–µ memory usage, –Ω–µ –∑–¥–æ–≥–∞–¥—É–π—Ç–µ—Å—å
5. **–û–ø—Ç–∏–º—ñ–∑—É–π—Ç–µ Layout** - –ø–æ—Ä—è–¥–æ–∫ –ø–æ–ª—ñ–≤ –≤–ø–ª–∏–≤–∞—î –Ω–∞ —Ä–æ–∑–º—ñ—Ä —Ç–∞ performance
   ::

### –ö–æ–ª–∏ –ù–ï –í–∏–∫–ª–∏–∫–∞—Ç–∏ GC.Collect()

```csharp
// ‚ùå –ü–û–ì–ê–ù–û - –ø—ñ—Å–ª—è –∫–æ–∂–Ω–æ—ó –æ–ø–µ—Ä–∞—Ü—ñ—ó
void ProcessItems()
{
    foreach (var item in items)
    {
        ProcessItem(item);
        GC.Collect();  // –ö–∞—Ç–∞—Å—Ç—Ä–æ—Ñ–∞ –¥–ª—è performance!
    }
}

// ‚úÖ –î–û–ë–†–ï - –¥–æ–≤—ñ—Ä—è–π—Ç–µ GC
void ProcessItems()
{
    foreach (var item in items)
    {
        ProcessItem(item);
    }
    // GC —Å–∞–º –≤–∏—Ä—ñ—à–∏—Ç—å, –∫–æ–ª–∏ –∑–±–∏—Ä–∞—Ç–∏
}
```

**–í–∏–Ω—è—Ç–∫–∏ (–∫–æ–ª–∏ –º–æ–∂–Ω–∞ –≤–∏–∫–ª–∏–∫–∞—Ç–∏):**

-   Unit tests –¥–ª—è –¥–µ—Ç–µ—Ä–º—ñ–Ω–æ–≤–∞–Ω–æ—ó –ø–æ–≤–µ–¥—ñ–Ω–∫–∏
-   –ü—ñ—Å–ª—è initialization –∑ –±–∞–≥–∞—Ç—å–º–∞ temp –æ–±'—î–∫—Ç–∞–º–∏
-   –£ batch processes –º—ñ–∂ –≤–µ–ª–∏–∫–∏–º–∏ –µ—Ç–∞–ø–∞–º–∏
-   –ü—Ä–∏ –≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—ñ memory usage

---

## –ü—Ä–∞–∫—Ç–∏—á–Ω—ñ –ó–∞–≤–¥–∞–Ω–Ω—è

::badge[Beginner]

### –ó–∞–≤–¥–∞–Ω–Ω—è 1: Implement Dispose Pattern

–°—Ç–≤–æ—Ä—ñ—Ç—å –∫–ª–∞—Å `FileLogger`, —è–∫–∏–π:

-   –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î `FileStream` (managed resource)
-   –†–µ–∞–ª—ñ–∑—É—î –ø–æ–≤–Ω–∏–π Dispose Pattern
-   –ú–∞—î finalizer —è–∫ safety net
-   –ö–∏–¥–∞—î `ObjectDisposedException` –ø—ñ—Å–ª—è dispose

**–û—á—ñ–∫—É–≤–∞–Ω–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç:**

```csharp
using (var logger = new FileLogger("app.log"))
{
    logger.Write("Test");
} // Dispose –≤–∏–∫–ª–∏–∫–∞—î—Ç—å—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ
```

---

::badge[Intermediate]

### –ó–∞–≤–¥–∞–Ω–Ω—è 2: WeakReference Cache

–†–µ–∞–ª—ñ–∑—É–π—Ç–µ thread-safe cache –¥–ª—è images:

-   –í–∏–∫–æ—Ä–∏—Å—Ç–æ –≤—É–π—Ç–µ `WeakReference<Bitmap>`
-   –î–æ–¥–∞–π—Ç–µ metrics (hits/misses)
-   Cleanup –º–µ—Ç–æ–¥ –¥–ª—è dead entries
-   –ü—Ä–æ—Ç–µ—Å—Ç—É–π—Ç–µ –ø—ñ–¥ memory pressure

---

::badge[Advanced]

### –ó–∞–≤–¥–∞–Ω–Ω—è 3: Memory Layout Analyzer

–°—Ç–≤–æ—Ä—ñ—Ç—å utility, —è–∫–∏–π –∞–Ω–∞–ª—ñ–∑—É—î —Å—Ç—Ä—É–∫—Ç—É—Ä–∏:

-   –û–±—á–∏—Å–ª—é—î actual size –∑ padding
-   –ü–æ–∫–∞–∑—É—î memory layout –≤—ñ–∑—É–∞–ª—å–Ω–æ
-   –ü—Ä–æ–ø–æ–Ω—É—î –æ–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω–∏–π –ø–æ—Ä—è–¥–æ–∫ –ø–æ–ª—ñ–≤
-   –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î `Marshal.SizeOf()` —Ç–∞ `Unsafe.SizeOf()`

---

::badge[Expert]

### –ó–∞–≤–¥–∞–Ω–Ω—è 4: GC Profiler

–ü–æ–±—É–¥—É–π—Ç–µ GC monitoring tool:

-   –í—ñ–¥—Å–ª—ñ–¥–∫–æ–≤—É—î Gen0/1/2 collections
-   –í–∏–º—ñ—Ä—é—î GC –ø–∞—É–∑–∏
-   –í–∏–∑–Ω–∞—á–∞—î hot allocation paths
-   –ì–µ–Ω–µ—Ä—É—î –∑–≤—ñ—Ç –∑ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—è–º–∏

---

## –†–µ–∑—é–º–µ

### –©–æ –í–∏ –í–∏–≤—á–∏–ª–∏

‚úÖ **Managed Heap** - —à–≤–∏–¥–∫–∞ –∞–ª–æ–∫–∞—Ü—ñ—è —á–µ—Ä–µ–∑ pointer bumping  
‚úÖ **GC Phases** - marking, compaction, reference updating  
‚úÖ **Generations** - Gen0/1/2 –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è –Ω–∞ –æ—Å–Ω–æ–≤—ñ object lifetime  
‚úÖ **LOH/SOH/POH** - —Ä—ñ–∑–Ω—ñ heaps –¥–ª—è —Ä—ñ–∑–Ω–∏—Ö —Å—Ü–µ–Ω–∞—Ä—ñ—ó–≤ (>85KB, pinned objects)  
‚úÖ **GC Modes** - Workstation (low latency) vs Server (high throughput)  
‚úÖ **Background GC** - concurrent –∑–±—ñ—Ä –¥–ª—è –∑–º–µ–Ω—à–µ–Ω–Ω—è –ø–∞—É–∑  
‚úÖ **IDisposable Pattern** - –ø—Ä–∞–≤–∏–ª—å–Ω–µ —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è unmanaged resources  
‚úÖ **using Statement** - –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π dispose –∑ –≥–∞—Ä–∞–Ω—Ç—ñ—î—é cleanup  
‚úÖ **Finalizers** - safety net –∑ –∑–∞—Ç—Ä–∏–º–∫–æ—é –∑–≤—ñ–ª—å–Ω–µ–Ω–Ω—è –ø–∞–º'—è—Ç—ñ  
‚úÖ **WeakReference** - –∫–µ—à—É–≤–∞–Ω–Ω—è –±–µ–∑ memory leaks  
‚úÖ **Memory Layout** - object header, padding, alignment –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è

### –ù–∞–π–≤–∞–∂–ª–∏–≤—ñ—à—ñ –ö–æ–Ω—Ü–µ–ø—Ü—ñ—ó

| –ö–æ–Ω—Ü–µ–ø—Ü—ñ—è             | –ö–ª—é—á –¥–æ –†–æ–∑—É–º—ñ–Ω–Ω—è                                               |
| :-------------------- | :-------------------------------------------------------------- |
| **Generational GC**   | –ë—ñ–ª—å—à—ñ—Å—Ç—å –æ–±'—î–∫—Ç—ñ–≤ –∂–∏–≤—É—Ç—å –∫–æ—Ä–æ—Ç–∫–æ ‚Üí Gen0 –∑–±–∏—Ä–∞—î—Ç—å—Å—è —á–∞—Å—Ç–æ       |
| **Dispose Pattern**   | `Dispose(bool)` - managed cleanup —è–∫—â–æ `true`, unmanaged –∑–∞–≤–∂–¥–∏ |
| **LOH Fragmentation** | –û–±'—î–∫—Ç–∏ ‚â•85KB –Ω–µ –∫–æ–º–ø–∞–∫—Ç—É—é—Ç—å—Å—è ‚Üí –º–æ–∂–ª–∏–≤—ñ gaps                   |
| **WeakReference**     | –ü–æ—Å–∏–ª–∞–Ω–Ω—è –Ω–µ –∑–∞–ø–æ–±—ñ–≥–∞—î GC ‚Üí ideal –¥–ª—è caches                    |
| **Memory Overhead**   | –ú—ñ–Ω—ñ–º—É–º 12-24 –±–∞–π—Ç–∏ –Ω–∞ –æ–±'—î–∫—Ç (header)                          |

**–ù–∞—Å—Ç—É–ø–Ω—ñ –∫—Ä–æ–∫–∏:**

üìñ [Threading and Async Programming](/csharp/system-internals-concurrency/threading-async) - –î—ñ–∑–Ω–∞–π—Ç–µ—Å—å –ø—Ä–æ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω—ñ—Å—Ç—å  
üìñ [.NET Performance Tips](https://learn.microsoft.com/en-us/dotnet/framework/performance/) - –û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è –¥–æ–¥–∞—Ç–∫—ñ–≤  
üîß [PerfView](https://github.com/microsoft/perfview) - GC profiling tool  
üîß [dotMemory](https://www.jetbrains.com/dotmemory/) - Memory profiler

::note
**–ü–∞–º'—è—Ç–∞–π—Ç–µ**: Memory management —É .NET - —Ü–µ –±–∞–ª–∞–Ω—Å –º—ñ–∂ developer productivity (–∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π GC) —Ç–∞ performance (—Ä–æ–∑—É–º—ñ–Ω–Ω—è, —è–∫ –ø—Ä–∞—Ü—é—î GC). –†–æ–∑—É–º—ñ–Ω–Ω—è fundamentals –¥–∞—î –≤–∞–º –º–æ–∂–ª–∏–≤—ñ—Å—Ç—å –ø–∏—Å–∞—Ç–∏ –µ—Ñ–µ–∫—Ç–∏–≤–Ω–∏–π –∫–æ–¥ –±–µ–∑ –∂–µ—Ä—Ç–≤—É–≤–∞–Ω–Ω—è –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω—ñ—Å—Ç—é —Ä–æ–∑—Ä–æ–±–∫–∏.
::

```

```
