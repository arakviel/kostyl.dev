# Логування в ASP.NET Core: Основи

Уявіть, що ви ведете щоденник. Коли все добре, ви записуєте туди дрібні радощі. Коли виникає проблема — ви описуєте її детально, щоб потім проаналізувати. Логування (Logging) у програмуванні — це ведення такого "щоденника" вашим додатком.

Коли додаток розгорнуто на реальному сервері (Production), ви не можете підключити до нього дебаггер (Visual Studio) і подивитися, чому сталася помилка. Логи — це _єдине_ вікно у внутрішній світ вашої програми.

ASP.NET Core має потужну вбудовану систему логування, яка підтримує різні рівні деталізації та різні місця зберігання записів (Консоль, Файл, База даних, Хмарні сервіси).

## Інтерфейс `ILogger`

Взаємодія із системою логування завжди відбувається через інтерфейс `ILogger` (або узагальнену версію `ILogger<T>`).

Цей інтерфейс вже автоматично доданий у контейнер залежностей (DI), тому ми можемо легко отримати його у будь-якій кінцевій точці:

```csharp [Program.cs]
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapGet("/", (ILogger<Program> logger) =>
{
    logger.LogInformation("Хтось щойно зайшов на головну сторінку!");
    return "Hello logging!";
});

app.Run();
```

**Анатомія коду:**

- Ми інжектуємо `ILogger<Program>`. Категорія логера `<Program>` означає, що цей запис у журналі буде підписаний іменем "Program". Сюди зазвичай передають тип класу, де викликається логер, щоб легше було знайти, звідки прийшло повідомлення.
- Метод `LogInformation()` робить запис із відповідним рівнем.

## Рівні логування (Log Levels)

Не всі події однаково важливі. Наприклад, успішне відкриття сторінки — це просто "Інформація", а от падіння бази даних — це "Критична помилка".

ASP.NET Core має 6 стандартних рівнів логування (від найнижчого до найвищого):

1. **Trace (0):** Найбільш детальні повідомлення. Використовуються лише у рідкісних випадках для глибокого дебагу.
2. **Debug (1):** Для налагодження в процесі розробки. (Наприклад: "Почали обробку масиву з 500 елементів").
3. **Information (2):** Загальний потік роботи програми. (Наприклад: "Користувача John123 авторизовано").
4. **Warning (3):** Попередження про нетипову, але не критичну ситуацію. Програма продовжує працювати без збоїв. (Наприклад: "Таймаут підключення до стороннього API, спробуймо ще раз...").
5. **Error (4):** Помилка, через яку певна операція не вдалася, але весь додаток ще живий. (Наприклад: "Не вдалося зберегти замовлення #5 у базу").
6. **Critical (5):** Система повністю зламалася і потребує негайного втручання. (Наприклад: "Бракує пам'яті (Out of Memory)" або "Диск переповнено").

### Як вибрати метод?

Інтерфейс `ILogger` має зручні методи-розширення для кожного з рівнів:

```csharp
logger.LogTrace("...");
logger.LogDebug("...");
logger.LogInformation("...");
logger.LogWarning("...");
logger.LogError(new Exception("Oops"), "...");
logger.LogCritical("...");
```

::note

> Якщо у вас є об'єкт винятку (`Exception`), **завжди** передавайте його першим аргументом у `LogError` або `LogCritical`. Так система логування зможе правильно розпарсити (Stack Trace) і красиво відобразити його.
> ::

## Конфігурація: що писати в лог?

Логування споживає ресурси (процесор і пам'ять). Тому на Production ніхто не логує рівні `Trace` чи `Debug`.

Ви можете контролювати, події якого рівня має записувати логер, змінюючи `appsettings.json`.

```json [appsettings.json]
{
    "Logging": {
        "LogLevel": {
            "Default": "Information",
            "Microsoft.AspNetCore": "Warning"
        }
    }
}
```

**Що це означає?**

- `"Default": "Information"` — глобальне правило: записувати всі повідомлення рівнів `Information`, `Warning`, `Error` та `Critical`. `Trace` і `Debug` ігноруватимуться.
- `"Microsoft.AspNetCore": "Warning"` — це перевизначення (override). Фреймворк ASP.NET Core сам по собі генерує тисячі логів. Це правило каже: "Для всіх компонентів від Microsoft, пишіть лише `Warning` і вище". Іншими словами — не спамте нас повідомленнями про те, який роут було викликано (бо це рівень Information).

## Провайдери логування (Log Providers)

"Провайдер" — це те, _куди_ фізично записуються логи.
Метод `WebApplication.CreateBuilder` автоматично налаштовує чотири провайдери:

1. **Console:** Виводить кольоровий текст у вікно консолі (терміналу).
2. **Debug:** Виводить у вікно "Debug" у Visual Studio під час налагодження.
3. **EventSource:** Інтеграція з Windows ETW.
4. **EventLog:** Логування в системний журнал Windows.

### Керування провайдерами з коду

Хоча стандартні налаштування покривають 90% потреб під час розробки, іноді вам потрібно додати новий провайдер або очистити старі.

```csharp [Program.cs]
var builder = WebApplication.CreateBuilder(args);

// Очищаємо всі стандартні провайдери
builder.Logging.ClearProviders();

// Вмикаємо лише вивід у консоль
builder.Logging.AddConsole();
// Або додаємо вивід у вікно дебагу Visual Studio
builder.Logging.AddDebug();

var app = builder.Build();
```

---

## Структуроване логування (Semantic Logging)

Раніше логи записували як звичайний текст:

```csharp
// Погано: Звичайна конкатенація рядків (інтерполяція)
logger.LogInformation($"Користувач {username} змінив пароль о {DateTime.Now}");
```

Сучасні системи логування (наприклад, ELK Stack: Elasticsearch, Logstash, Kibana) вміють шукати і фільтрувати логи не як текст, а як об'єкти! ASP.NET Core підтримує цей формат.

```csharp
// Добре: Структуроване логування (Semantic Logging)
logger.LogInformation("Користувач {UserId} оновив профіль з IP {IpAddress}", user.Id, ip);
```

**Анатомія коду:**

- Зверніть увагу: ми **не** використовуємо `$` перед рядком (це не інтерполяція C#).
- Ми передаємо "шаблон повідомлення" зі змінними в дужках `{...}`, а потім перераховуємо фактичні значення як аргументи через кому.
- Система логування збереже це не лише як текст, а і як JSON словник:
  `{"Message": "Користувач 45 оновив профіль з IP 192.168.1.1", "UserId": 45, "IpAddress": "192.168.1.1"}`.
- Пізніше у спеціальних програмах адміністратор зможе написати запит: `Знайти всі логи, де UserId = 45`.

---

## Практичні завдання

::tabs
::tabs-item{label="Рівень 1 (Базовий)" icon="i-heroicons-paper-clip"}
**Рівні і фільтрація**
Створіть роут `/test-logs`, інжектуйте туди `ILogger` і викличте 5 методів логування для різних рівнів (від `LogTrace` до `LogError`).
Запустіть програму. Скільки записів ви бачите в консолі? Чому `Trace` та `Debug` не з'явилися?
Відкрийте `appsettings.json` та змініть `Default` рівень так, щоб у консоль виводилися абсолютно всі 5 повідомлень.
::
::tabs-item{label="Рівень 2 (Помилки)" icon="i-heroicons-puzzle-piece"}
**Логування Exception**
Створіть маршрут, в якому ви штучно створюєте виняток:

```csharp
try {
  int x = 0; int y = 10 / x;
} catch (Exception ex) {
  // Ваш код логування тут
}
```

Використайте правильний метод `Log...` і обов'язково передайте `ex` як перший параметр. Перевірте, чи відобразився Stack Trace у консолі.
::
::
