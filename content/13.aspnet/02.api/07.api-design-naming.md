---
title: "Правила дизайну: іменування та стандарти"
description: "Принципи дизайну API: явне краще за неявне, конкретні імена, стандарти дат (ISO 8601), валют, дробових чисел, консистентність інтерфейсів та підходи до іменування."
---

# Правила дизайну: іменування та стандарти

::note
Дотепер ми розбирали _структуру_ HTTP API. Тепер переходимо до **стилістики** — як називати поля, форматувати дати, передавати гроші та дробові числа. Ці правила не зафіксовані в жодному RFC, але від їхнього дотримання залежить, чи буде ваш API зрозумілим і безпечним.
::

## 1. Принцип: Явне краще за неявне

::warning
**Головний принцип дизайну API:** якщо з інтерфейсу не зрозуміло, що саме означає поле, параметр чи відповідь — його потрібно перейменувати або доповнити.
::

Порівняйте два варіанти:

::tabs

::tabs-item{label="❌ Неявне"}
```json
{
  "time": 1708934400,
  "value": 10.5,
  "status": 1
}
```

Що таке `time`? Час створення? Оновлення? Доставки? `value` — це що? Ціна? Об'єм? Рейтинг? `status: 1` — 1 означає «активний»? «Створений»? «Помилка»?
::

::tabs-item{label="✅ Явне"}
```json
{
  "created_at": "2024-02-26T14:00:00Z",
  "price": "10.50",
  "currency": "UAH",
  "status": "processing"
}
```

Самодокументований JSON. Кожне поле однозначно зрозуміле без документації.
::

::

### Правила явного іменування

::steps

### Ім'я поля повинно однозначно описувати його зміст

```csharp
// ❌ Неоднозначне
app.MapGet("/v1/orders/{id}", (int id) =>
    Results.Ok(new
    {
        id,
        time = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
        value = 10.5,
        type = 1
    }));

// ✅ Самодокументоване
app.MapGet("/v1/orders/{id}", (int id) =>
    Results.Ok(new
    {
        id,
        created_at = "2024-02-26T14:00:00Z",
        price = "10.50",
        currency = "UAH",
        status = "processing"
    }));
```

### Булеві поля: is_, has_, can_

```json
{
  "is_active": true,
  "has_discount": false,
  "can_be_cancelled": true
}
```

### Колекції: завжди множина

```json
{
  "orders": [...],
  "items": [...],
  "attachments": [...]
}
```

### Уникайте абревіатур

```
❌ qty, amt, desc, addr, cfg, msg
✅ quantity, amount, description, address, config, message
```

::

---

## 2. Стандарти форматів даних

### 2.1. Дата і час: ISO 8601

::caution
**Ніколи** не передавайте дату як Unix-timestamp, рядок у довільному форматі або окремі поля (рік, місяць, день). Використовуйте **ISO 8601** — єдиний міжнародний стандарт.
::

```
Формат:           2024-02-26T14:30:00Z
З часовою зоною:  2024-02-26T16:30:00+02:00
Тільки дата:      2024-02-26
Тільки час:       14:30:00
Тривалість:       P1DT12H30M (1 день 12 годин 30 хв)
```

```csharp [ISO 8601 у Minimal API]
app.MapGet("/v1/orders/{id}", (int id) =>
{
    var order = new
    {
        id,
        // ISO 8601 з UTC — завжди "Z" в кінці
        created_at = DateTime.UtcNow
            .ToString("o"), // "2024-02-26T14:30:00.0000000Z"
        
        // Або DateTimeOffset для зони
        updated_at = DateTimeOffset.Now
            .ToString("o"), // "2024-02-26T16:30:00+02:00"
        
        // Тривалість
        estimated_preparation = "PT5M30S" // 5 хв 30 сек
    };
    return Results.Ok(order);
});
```

::tip
**Порада:** ASP.NET Core за замовчуванням серіалізує `DateTime` та `DateTimeOffset` у формат ISO 8601. Використовуйте `DateTime.UtcNow` (а не `DateTime.Now`) для API, щоб уникнути плутанини з часовими зонами.
::

### 2.2. Грошові суми: рядок або цілі числа

::caution
**Критична помилка:** передача грошових сум як `double` або `float`. Через обмеження IEEE 754 (floating point), `0.1 + 0.2 = 0.30000000000000004`.
::

::tabs

::tabs-item{label="❌ Числа з плаваючою точкою"}
```json
{
  "price": 10.5,
  "total": 0.30000000000000004
}
```

Втрата точності! У фінансових розрахунках — катастрофа.
::

::tabs-item{label="✅ Рядки"}
```json
{
  "price": "10.50",
  "total": "0.30",
  "currency": "UAH"
}
```

Рядок зберігає точне представлення числа.
::

::tabs-item{label="✅ Мінімальні одиниці (центи)"}
```json
{
  "price_minor_units": 1050,
  "currency": "UAH"
}
```

10.50 UAH = 1050 копійок. Ціле число — ідеальна точність.
::

::

```csharp [Грошові суми у Minimal API]
app.MapPost("/v1/orders", (OrderRequest req) =>
{
    // Ціна — рядок, парсимо у decimal
    // decimal має 28-29 значущих цифр
    if (!decimal.TryParse(req.Price, out var price))
        return Results.BadRequest(
            new { error = "Invalid price format" });

    // Або використовуємо мінімальні одиниці
    var priceMinorUnits = (int)(price * 100);

    return Results.Created("/v1/orders/42", new
    {
        id = 42,
        price = req.Price,        // "10.50" — рядок
        currency = req.Currency,  // "UAH"
        price_minor_units = priceMinorUnits // 1050
    });
});

record OrderRequest(string Price, string Currency);
```

### 2.3. Валюта: ISO 4217

Для позначення валюти використовуйте **ISO 4217** — тризначний код:

| Код | Валюта |
|:---|:---|
| `UAH` | Українська гривня |
| `USD` | Долар США |
| `EUR` | Євро |
| `GBP` | Фунт стерлінгів |

```json
{
  "price": "10.50",
  "currency": "UAH"
}
```

::warning
**Не** кодуйте валюту як число (`1 = UAH, 2 = USD`) або скорочення (`грн`, `$`). Використовуйте тільки ISO 4217.
::

### 2.4. Мова та локалізація: ISO 639 та IETF BCP 47

```json
{
  "language": "uk",
  "locale": "uk-UA"
}
```

Заголовок `Accept-Language` дозволяє клієнту вказати бажану мову:

```http
GET /v1/menu HTTP/1.1
Accept-Language: uk-UA, uk;q=0.9, en;q=0.5
```

### 2.5. Країна: ISO 3166-1 alpha-2

```json
{
  "country": "UA",
  "phone_prefix": "+380"
}
```

---

## 3. Стандарти іменування

### 3.1. URL: kebab-case

```
✅ /v1/coffee-machines/{id}
✅ /v1/long-term-orders/{id}
❌ /v1/coffeeMachines/{id}
❌ /v1/coffee_machines/{id}
```

### 3.2. Query-параметри: snake_case

```
✅ /v1/orders?user_id=42&sort_by=created_at
❌ /v1/orders?userId=42&sortBy=createdAt
```

### 3.3. JSON-тіло: snake_case або camelCase

::tabs

::tabs-item{label="snake_case (рекомендовано книгою)"}
```json
{
  "user_id": 42,
  "first_name": "Олексій",
  "coffee_machine_id": 123
}
```

**Перевага:** легко переносити параметр з query у тіло й навпаки.
::

::tabs-item{label="camelCase (популярно у C#/.NET)"}
```json
{
  "userId": 42,
  "firstName": "Олексій",
  "coffeeMachineId": 123
}
```

**Перевага:** відповідає конвенціям JavaScript та .NET.
::

::

```csharp [Налаштування camelCase у ASP.NET Core]
var builder = WebApplication.CreateBuilder(args);

// За замовчуванням ASP.NET Core
// вже використовує camelCase
builder.Services.ConfigureHttpJsonOptions(options =>
{
    // Якщо потрібен snake_case:
    options.SerializerOptions.PropertyNamingPolicy = 
        System.Text.Json.JsonNamingPolicy.SnakeCaseLower;
});

var app = builder.Build();

app.MapGet("/v1/orders/{id}", (int id) =>
    Results.Ok(new OrderResponse(
        id, 
        "lungo", 
        "10.50", 
        "UAH")));

app.Run();

// C# використовує PascalCase для властивостей
// але JSON серіалізується у обраний кейсинг
record OrderResponse(
    int Id,
    string Recipe,
    string Price,
    string Currency);
// → camelCase: {"id":1,"recipe":"lungo","price":"10.50","currency":"UAH"}
// → snake_case: {"id":1,"recipe":"lungo","price":"10.50","currency":"UAH"}
```

### 3.4. Заголовки: Train-Case

```
✅ Content-Type, Authorization, Accept-Language
✅ X-CoffeeAPI-Request-Id (кастомний)
```

### Зведена таблиця

| Де | Кейсинг | Приклад |
|:---|:---|:---|
| URL path | `kebab-case` | `/v1/coffee-machines` |
| Query params | `snake_case` | `?user_id=42` |
| JSON body | `snake_case` або `camelCase` | `"user_id"` або `"userId"` |
| Заголовки | `Train-Case` | `Content-Type` |
| Домен | `lowercase` | `api.coffee-service.com` |

---

## 4. Принцип консистентності

**Консистентність** — найважливіший принцип дизайну API. Обрали одну конвенцію — дотримуйтесь її _всюди_:

::card-group

::card{title="Одна сутність — одне ім'я" icon="i-lucide-tag"}
Якщо замовлення називається `order` в одному місці, не називайте його `purchase`, `request` або `booking` в іншому.
::

::card{title="Однакова структура відповідей" icon="i-lucide-layout-template"}
Якщо список повертає `{ items: [...], total: N }`, то _всі_ списки мають повертати таку саму структуру.
::

::card{title="Однакові поля — однаковий тип" icon="i-lucide-check-circle"}
Якщо `id` — число в одному ендпоінті, воно має бути числом _всюди_. Не `"id": 42` в одному місці і `"id": "42"` в іншому.
::

::card{title="Одна помилка — одна структура" icon="i-lucide-alert-circle"}
Формат помилки (`{ error, message, details }`) однаковий для всіх ендпоінтів, незалежно від типу помилки.
::

::

```csharp [Консистентна структура відповідей]
// ✅ Консистентна «обгортка» для всіх списків
app.MapGet("/v1/orders", (int? limit, string? cursor) =>
{
    var orders = db.GetOrders(limit ?? 20, cursor);
    return Results.Ok(new ListResponse<Order>(
        orders.Items, orders.Total, orders.NextCursor));
});

app.MapGet("/v1/recipes", (int? limit, string? cursor) =>
{
    var recipes = db.GetRecipes(limit ?? 20, cursor);
    return Results.Ok(new ListResponse<Recipe>(
        recipes.Items, recipes.Total, recipes.NextCursor));
});

// Єдина структура для всіх списків
record ListResponse<T>(
    IEnumerable<T> Items,
    int Total,
    string? NextCursor);
```

---

## 5. Стандартні поля кожного ресурсу

Кожен ресурс у вашому API повинен мати набір стандартних полів:

```json
{
  "id": 42,
  "created_at": "2024-02-26T14:00:00Z",
  "updated_at": "2024-02-26T16:30:00Z",

  "recipe": "lungo",
  "status": "processing"
}
```

| Поле | Тип | Опис |
|:---|:---|:---|
| `id` | `int` чи `string` (UUID) | Унікальний ідентифікатор |
| `created_at` | ISO 8601 | Час створення |
| `updated_at` | ISO 8601 | Час останнього оновлення |

::tip
**Порада:** Якщо ресурс може бути видалений — додайте `deleted_at: null | ISO 8601` для soft delete. Якщо ресурс має автора — `created_by: int`.
::

---

## 6. Перерахування (enum): рядки, а не числа

::tabs

::tabs-item{label="❌ Числа"}
```json
{
  "status": 1,
  "type": 3,
  "priority": 2
}
```

Що означає `status: 1`? Без документації — нічого.
::

::tabs-item{label="✅ Рядки"}
```json
{
  "status": "processing",
  "type": "delivery",
  "priority": "high"
}
```

Самодокументований JSON. Зрозуміло без документації.
::

::

```csharp [Enum як рядки у ASP.NET Core]
var builder = WebApplication.CreateBuilder(args);

builder.Services.ConfigureHttpJsonOptions(options =>
{
    // Серіалізувати enum як рядки
    options.SerializerOptions.Converters.Add(
        new System.Text.Json.Serialization
            .JsonStringEnumConverter());
});

var app = builder.Build();

app.MapGet("/v1/orders/{id}", (int id) =>
    Results.Ok(new
    {
        id,
        status = OrderStatus.Processing,
        priority = Priority.High
    }));
// → {"id":1,"status":"Processing","priority":"High"}

app.Run();

enum OrderStatus { Created, Processing, Completed, Cancelled }
enum Priority { Low, Medium, High }
```

---

## 7. Практичні завдання

### Рівень 1: Рефакторинг

::accordion

::accordion-item{label="Завдання 7.1: Виправте іменування" icon="i-lucide-circle-help"}
Перепишіть JSON-відповідь, дотримуючись усіх правил іменування:

```json
{
  "ts": 1708934400,
  "val": 10.5,
  "curr": "uah",
  "stat": 1,
  "usrNm": "Олексій",
  "is_deleted": 0,
  "Items": ["latte", "lungo"]
}
```
::

::accordion-item{label="Завдання 7.2: Стандартизуйте формати" icon="i-lucide-circle-help"}
Визначте правильний тип та формат для кожного поля:

1. Дата народження
2. Ціна товару
3. Координати GPS (широта/довгота)
4. Статус замовлення
5. Кількість товарів
6. Мова інтерфейсу
7. Країна реєстрації
8. Тривалість приготування кави
::

::

### Рівень 2: Проєктування

::accordion

::accordion-item{label="Завдання 7.3: API Style Guide" icon="i-lucide-circle-help"}
Створіть Style Guide для вашого API — документ, що описує:

1. Кейсинг для URL, query, JSON
2. Формат дати, грошей, enum
3. Структуру списків та помилок
4. Стандартні поля кожного ресурсу
5. Правила іменування (булеві поля, колекції)

Реалізуйте 3 ендпоінти (GET список, GET за id, POST створення), що повністю дотримуються вашого Style Guide.
::

::

---

## 8. Резюме

::card-group

::card{title="Явне > Неявне" icon="i-lucide-eye"}
Кожне поле самодокументоване. Ніяких `time`, `value`, `type` без контексту. Булеві — з `is_`/`has_`/`can_`.
::

::card{title="Стандарти форматів" icon="i-lucide-calendar"}
Дати: ISO 8601. Гроші: рядок або мінімальні одиниці. Валюта: ISO 4217. Enum: рядки, не числа.
::

::card{title="Кейсинг за конвенцією" icon="i-lucide-text-cursor-input"}
URL: `kebab-case`. Query: `snake_case`. JSON: `snake_case` або `camelCase` (обрати одне!). Заголовки: `Train-Case`.
::

::card{title="Консистентність" icon="i-lucide-equal"}
Одна сутність — одне ім'я. Одна структура для списків. Однакові типи полів у всіх ендпоінтах.
::

::

**Далі:** у наступній статті ми розберемо **валідацію, ліміти та обробку помилок** — технічні обмеження, валідацію вхідних даних та формування інформативних повідомлень про помилки.
