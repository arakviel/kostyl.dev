---
title: "Валідація, ліміти та обробка помилок"
description: "Технічні обмеження API, валідація вхідних даних, структуровані помилки, RFC 9457 Problem Details, розділення помилок на клієнтські та серверні, та моніторинг."
---

# Валідація, ліміти та обробка помилок

::note
Попередні статті покривали «happy path» — стандартний процес роботи з API без помилок. Але в реальності **більшість коду** — це обробка помилок. У цій статті ми розберемо: скільки помилок може виникнути навіть у найпростішому запиті, як правильно про них повідомляти, і чому одного статус-коду недостатньо.
::

## 1. Скільки помилок ховається в одному запиті?

Здавалося б, запит на створення замовлення — проста річ:

```http
POST /v1/orders?user_id=42 HTTP/1.1
Authorization: Bearer <token>
If-Match: <ревізія>

{
  "recipe": "lungo",
  "coffee_machine_id": 123,
  "volume": "300ml"
}
```

Але з книги Константинова ми дізнаємося, що навіть цей єдиний запит може **зазнати невдачі 13 різними способами**. Розберемо кожну помилку:

### Помилки формату

| # | Що сталося | Приклад | Статус-код |
|:---|:---|:---|:---|
| 1 | Тіло запиту неможливо прочитати | JSON із зайвою комою: `{"recipe": "lungo",}` | `400` |

Сервер навіть не може розпарсити запит — дані «побиті». Клієнт повинен виправити формат.

### Помилки аутентифікації та авторизації

| # | Що сталося | Приклад | Статус-код |
|:---|:---|:---|:---|
| 2 | Токен авторизації відсутній | Заголовок `Authorization` не передано | `401` |
| 3 | Токен невалідний | Рядок `Bearer abcde` — не є справжнім JWT | `401` |
| 4 | Токен валідний, але прав немає | Користувач намагається створити замовлення для іншого | `403` |
| 5 | Користувач деактивований | Акаунт заблоковано адміністратором | `403` |

**Різниця між 401 і 403**: `401` означає «я не знаю хто ти» (немає токена або він зламаний). `403` означає «я знаю хто ти, але тобі _заборонено_» (токен валідний, але прав немає).

### Помилки ресурсів і ревізій

| # | Що сталося | Приклад | Статус-код |
|:---|:---|:---|:---|
| 6 | Користувач не існує | `user_id=999` — такого немає у БД | `404` |
| 7 | Ревізія не передана | Заголовок `If-Match` відсутній | `428` |
| 8 | Ревізія застаріла | Клієнт передав `If-Match: "rev1"`, а актуальна — `"rev5"` | `412` |

**Нагадування:** ревізія (ETag) — це мітка версії даних. Ми вивчили її у статті 05. Якщо ревізія не збігається, значить хтось інший вже змінив дані, і наш запит "застарів".

### Помилки валідації полів

| # | Що сталося | Приклад | Статус-код |
|:---|:---|:---|:---|
| 9 | Обов'язкове поле відсутнє | Немає поля `recipe` | `400` |
| 10 | Поле має некоректне значення | `"volume": "-100ml"` — від'ємний об'єм | `400` або `422` |

**Різниця між 400 і 422**: `400` — «я не можу навіть прочитати, що ти хочеш» (зламаний JSON, відсутні поля). `422` — «я зрозумів запит, але він безглуздий» (JSON валідний, але значення некоректні).

### Технічні обмеження та серверні помилки

| # | Що сталося | Приклад | Статус-код |
|:---|:---|:---|:---|
| 11 | Перевищено ліміт запитів | Клієнт зробив 1000 запитів за хвилину | `429` |
| 12 | Сервер перевантажений | БД не відповідає через пікове навантаження | `503` |
| 13 | Невідома серверна помилка | Непередбачений баг в коді | `500` |

::warning
**Ключове запитання з книги** для кожної помилки:
1. **Хто** допустив помилку — користувач, клієнтський додаток чи сервер?
2. **Чи можна** виправити проблему повторним запитом?
3. **Як** саме виправити запит?
4. **Що робити**, якщо виправити неможливо?

Якщо API не дає відповіді на ці питання — розробник клієнта змушений **вгадувати**, що пішло не так.
::

---

## 2. Маппінг помилок на статус-коди

Отже, ми маємо 13 типів помилок. Чи потрібно для кожної вигадувати окремий статус-код? Ні — стандартних кодів **не вистачає** для всіх бізнес-сценаріїв. Книга рекомендує обмежений набір:

| Статус-код | Що він означає | Які помилки зверху покриває |
|:---|:---|:---|
| `400 Bad Request` | Запит неможливо обробити | #1 (невалідний JSON), #9 (немає поля), #10 (некоректне значення) |
| `401 Unauthorized` | Хто ви? Аутентифікуйтесь | #2 (немає токена), #3 (токен зламаний) |
| `403 Forbidden` | Знаю хто ви, але — ні | #4 (немає прав), #5 (деактивований) |
| `404 Not Found` | Ресурс не існує | #6 (немає user_id) |
| `409 Conflict` | Конфлікт стану | Дублікат ресурсу |
| `412 Precondition Failed` | Ревізія не збігається | #8 (дані змінились) |
| `422 Unprocessable Entity` | Зрозумів, але безглуздо | #10 (некоректні значення) |
| `428 Precondition Required` | Потрібна передумова | #7 (немає If-Match) |
| `429 Too Many Requests` | Забагато запитів | #11 (rate limit) |

::tip
**З книги:** Запам'ятайте правило першої цифри. Невідомий код `4xy` клієнт за специфікацією обробляє як `400`. Тому формат помилки `400` повинен бути **максимально загальним** — він стане "fallback" для будь-якої клієнтської помилки.
::

---

## 3. Порядок валідації

Валідація — це **не одна перевірка**, а ціла послідовність. Порядок має значення: немає сенсу перевіряти поля запиту, якщо токен невалідний.

::steps

### Крок 1: Формат запиту

Чи можна прочитати запит? Чи це валідний JSON?

Якщо ні → `400 Bad Request`. Далі нема сенсу перевіряти — дані зламані.

### Крок 2: Аутентифікація

Чи є токен авторизації? Чи валідний він?

Якщо ні → `401 Unauthorized`. Ми не знаємо, хто робить запит — решта перевірок безглузда.

### Крок 3: Авторизація

Чи має автор запиту право виконувати цю операцію?

Якщо ні → `403 Forbidden`. Навіть якщо дані ідеальні — операція заборонена.

### Крок 4: Існування ресурсів

Чи існують усі сутності, на які посилається запит? (user_id, coffee_machine_id і т.д.)

Якщо ні → `404 Not Found`.

### Крок 5: Передумови (ревізія)

Чи передано заголовок `If-Match`? Чи збігається ревізія з актуальною?

Якщо не передано → `428 Precondition Required`. Якщо не збігається → `412 Precondition Failed`.

### Крок 6: Валідація значень полів

Чи заповнені всі обов'язкові поля? Чи мають значення сенс?

Якщо ні → `400` (відсутнє поле) або `422` (некоректне значення).

### Крок 7: Бізнес-правила

Чи дозволена ця операція за бізнес-логікою? (наприклад, не можна замовити 10 літрів кави)

Якщо ні → `409 Conflict` або `422 Unprocessable Entity`.

::

### Реалізація у Minimal API

```csharp [Повна валідація — крок за кроком]
app.MapPost("/v1/orders", 
    (OrderRequest? req, HttpContext ctx) =>
{
    // Крок 1: Формат
    if (req is null)
        return Results.BadRequest(new ApiError(
            Status: 400,
            Reason: "invalid_request_body",
            LocalizedMessage: "Не вдалося прочитати запит.",
            DeveloperMessage: "Request body is null or " +
                "invalid JSON",
            Details: null));

    // Крок 2: Аутентифікація
    if (!ctx.User.Identity?.IsAuthenticated ?? true)
        return Results.Json(new ApiError(
            Status: 401,
            Reason: "authentication_required",
            LocalizedMessage: "Увійдіть у систему.",
            DeveloperMessage: "Bearer token is missing " +
                "or invalid",
            Details: null), statusCode: 401);

    // Крок 3: Авторизація
    var tokenUserId = int.Parse(
        ctx.User.FindFirst("user_id")!.Value);
    if (tokenUserId != req.UserId)
        return Results.Json(new ApiError(
            Status: 403,
            Reason: "forbidden",
            LocalizedMessage: "У вас немає прав " + 
                "на цю операцію.",
            DeveloperMessage: "Token user_id does not " +
                "match request user_id",
            Details: null), statusCode: 403);

    // Крок 4: Існування ресурсів
    var machine = db.GetMachine(req.CoffeeMachineId);
    if (machine is null)
        return Results.NotFound(new ApiError(
            Status: 404,
            Reason: "machine_not_found",
            LocalizedMessage: "Кавова машина не знайдена.",
            DeveloperMessage: $"Coffee machine " +
                $"{req.CoffeeMachineId} not found",
            Details: null));

    // Крок 5: Передумова (ревізія)
    var ifMatch = ctx.Request.Headers
        .IfMatch.FirstOrDefault();
    if (ifMatch is null)
        return Results.Json(new ApiError(
            Status: 428,
            Reason: "precondition_required",
            LocalizedMessage: "Оновіть дані перед " +
                "створенням замовлення.",
            DeveloperMessage: "If-Match header required",
            Details: null), statusCode: 428);

    var currentRevision = db.GetOrdersRevision(
        req.UserId);
    if (ifMatch != $"\"{currentRevision}\"")
        return Results.Json(new ApiError(
            Status: 412,
            Reason: "revision_mismatch",
            LocalizedMessage: "Дані змінилися. " +
                "Оновіть список і спробуйте знову.",
            DeveloperMessage: $"Expected revision " +
                $"{ifMatch}, current is \"{currentRevision}\"",
            Details: new { 
                current_revision = currentRevision 
            }), statusCode: 412);

    // Крок 6: Валідація полів
    var errors = new List<ValidationError>();

    if (string.IsNullOrWhiteSpace(req.Recipe))
        errors.Add(new("recipe", "required", 
            "Recipe is required"));

    if (req.Volume is not null && req.Volume <= 0)
        errors.Add(new("volume", "constraint_violation",
            "Volume must be positive"));

    if (errors.Count > 0)
        return Results.BadRequest(new ApiError(
            Status: 400,
            Reason: "validation_failed",
            LocalizedMessage: "Перевірте правильність " +
                "введених даних.",
            DeveloperMessage: $"{errors.Count} validation " +
                "error(s) found",
            Details: new { checks_failed = errors }));

    // Крок 7: Бізнес-правила
    if (!machine.IsAvailable)
        return Results.Json(new ApiError(
            Status: 422,
            Reason: "machine_unavailable",
            LocalizedMessage: "Ця кавова машина " +
                "зараз недоступна.",
            DeveloperMessage: "Machine is offline " +
                "or under maintenance",
            Details: null), statusCode: 422);

    // ✅ Усі перевірки пройдені — створюємо!
    var order = db.CreateOrder(req);
    return Results.Created(
        $"/v1/orders/{order.Id}", order);
});

record OrderRequest(
    int UserId,
    string? Recipe, 
    int CoffeeMachineId, 
    int? Volume);

record ValidationError(
    string Field, 
    string ErrorType, 
    string Message);
```

---

## 4. Структура помилки: що саме повертати?

### Проблема: одного статус-коду недостатньо

Уявіть: клієнт отримав `400 Bad Request`. Що саме пішло не так?

- Невалідний JSON?
- Відсутнє поле `recipe`?
- Некоректний об'єм `"-100ml"`?
- Невідомий рецепт `"lngo"` (помилка друку)?

Один статус-код `400` **не відповідає** на ці питання. Тому потрібна **структурована відповідь** з деталями помилки.

### RFC 9457: Problem Details for HTTP APIs

Стандарт **RFC 9457** визначає єдиний формат JSON для помилок. Ідея: замість довільного формату кожного API, використовуємо спільну структуру:

```json [Приклад Problem Details]
{
  "type": "https://api.example.com/errors/validation",
  "title": "Validation failed",
  "status": 400,
  "detail": "One or more fields have invalid values",
  "instance": "/v1/orders"
}
```

::field-group

::field{name="type" type="string"}
URI, що ідентифікує **тип** помилки. Може вести на сторінку документації, де описано цю помилку. Якщо не вказано, за замовчуванням `"about:blank"`.
::

::field{name="title" type="string"}
Короткий людиночитаємий опис типу помилки. **Однаковий** для всіх помилок цього типу. Наприклад, `"Validation failed"` — для будь-якої валідаційної помилки.
::

::field{name="status" type="number"}
HTTP статус-код. Дублює код з HTTP-відповіді для зручності — щоб не потрібно було парсити заголовки.
::

::field{name="detail" type="string"}
Людиночитаємий опис **конкретної** ситуації. На відміну від `title`, `detail` унікальний для кожного випадку: `"Field 'recipe' has unknown value 'lngo'"`.
::

::field{name="instance" type="string"}
URI ресурсу, де сталася помилка. Допомагає при дебагінгу: якщо сервер обробляє тисячі запитів, `instance` вказує на конкретний.
::

::

### Розширення: три аудиторії помилки

::warning
**З книги Константинова:** RFC 9457 покриває лише базовий сценарій. Для реального API потрібно розділити повідомлення для **трьох різних аудиторій**:

1. **Кінцевий користувач** — бачить повідомлення в інтерфейсі додатку
2. **Розробник клієнта** — дебажить проблему в консолі
3. **Код клієнта** — автоматично реагує на тип помилки
::

Книга рекомендує розширену структуру:

```json [Розширена структура помилки]
{
  "status": 400,
  "reason": "wrong_parameter_value",
  "localized_message": "Перевірте правильність введених даних.",
  "developer_message": "Field 'recipe' has unknown value 'lngo'. Did you mean 'lungo'?",
  "details": {
    "checks_failed": [
      {
        "field": "recipe",
        "error_type": "wrong_value",
        "message": "Value 'lngo' unknown. Did you mean 'lungo'?"
      }
    ]
  }
}
```

Розберемо кожне поле:

| Поле | Хто читає | Навіщо | Приклад |
|:---|:---|:---|:---|
| `reason` | **Код** клієнта | Машиночитаємий підтип для `switch/case` | `"wrong_parameter_value"` |
| `localized_message` | **Користувач** | Показується у UI додатку | `"Перевірте дані"` |
| `developer_message` | **Розробник** | Для дебагінгу (НЕ показувати користувачу!) | `"Field 'recipe' unknown: 'lngo'"` |
| `details` | **Код** клієнта | Структуровані дані для автоматичного виправлення | Масив помилок з полями |

**Навіщо розділяти?** Уявіть, що `developer_message` потрапить до кінцевого користувача: «Field 'recipe' has unknown value 'lngo'. Did you mean 'lungo'?» Англійське технічне повідомлення зовсім не те, що хоче бачити українськомовний користувач кавового додатку.

```csharp [ApiError record у Minimal API]
record ApiError(
    int Status,
    string Reason,
    string LocalizedMessage,
    string DeveloperMessage,
    object? Details);
```

### Приклад валідації з детальними помилками

```csharp [Кілька помилок одночасно]
app.MapPost("/v1/orders", (OrderRequest? req) =>
{
    if (req is null)
        return Results.BadRequest(new ApiError(
            Status: 400,
            Reason: "invalid_request_body",
            LocalizedMessage: "Не вдалося обробити запит. " +
                "Спробуйте ще раз.",
            DeveloperMessage: "Request body is null or " +
                "contains invalid JSON",
            Details: null));

    // Збираємо ВСІ помилки одразу,
    // а не повертаємо після першої
    var errors = Validate(req);
    if (errors.Count > 0)
        return Results.BadRequest(new ApiError(
            Status: 400,
            Reason: "validation_failed",
            LocalizedMessage: "Перевірте правильність " +
                "введених даних.",
            DeveloperMessage: $"{errors.Count} validation " +
                "error(s) found",
            Details: new { checks_failed = errors }));

    var order = db.CreateOrder(req);
    return Results.Created(
        $"/v1/orders/{order.Id}", order);
});
```

::tip
**Важливо:** повертайте **всі** помилки валідації одразу, а не по одній. Якщо в запиті 5 невалідних полів — клієнт повинен побачити всі 5 помилок з першого разу, а не виправляти їх одну за одною через 5 запитів.
::

---

## 5. Серверні помилки (5xx): два обличчя

Серверні помилки принципово відрізняються від клієнтських: **клієнт не винен** і не може їх виправити. Але є нюанс: рівень деталізації повинен бути **різним** для зовнішніх і внутрішніх споживачів.

### Внутрішній формат (між мікросервісами)

Коли один мікросервіс повідомляє про помилку іншому всередині системи, потрібна **максимальна деталізація** для діагностики:

```http
HTTP/1.1 500 Internal Server Error
X-CoffeeAPI-Error-Kind: db_timeout

{
  "reason": "db_timeout",
  "details": {
    "host": "db-replica-03.internal",
    "timeout_ms": 5000,
    "query": "SELECT * FROM orders WHERE user_id = 42"
  }
}
```

Тут є ім'я хоста, час таймауту, навіть SQL-запит. Це все потрібно для **моніторингу та дебагінгу**.

### Зовнішній формат (для клієнтів)

Але ту саму помилку для зовнішнього клієнта потрібно **«очистити»**:

```http
HTTP/1.1 503 Service Unavailable
Retry-After: 5

{
  "reason": "service_unavailable",
  "localized_message": "Сервіс тимчасово недоступний. Спробуйте через 5 секунд.",
  "developer_message": "Upstream service timeout",
  "details": {
    "can_be_retried": true,
    "retry_after": 5
  }
}
```

Клієнт не бачить ні хостів, ні SQL-запитів, ні внутрішньої архітектури. Натомість отримує **інструкцію**: можна повторити через 5 секунд.

::caution
**Критично з книги:** Ніколи не розкривайте деталі серверних помилок зовнішнім клієнтам! Інформація про хости, запити до БД, стек-трейси — це **вектор атаки**. Зловмисник може використати цю інформацію для пошуку вразливостей. Гейтвей повинен замінити внутрішню помилку на безпечну інструкцію.
::

### Middleware для обробки серверних помилок

```csharp [Middleware — «фільтр» серверних помилок]
app.Use(async (ctx, next) =>
{
    try
    {
        await next(ctx);
    }
    catch (TimeoutException ex)
    {
        // ✅ Повна інформація — тільки в логи
        logger.LogError(ex, 
            "Database timeout for {Path}", 
            ctx.Request.Path);

        // ✅ Клієнту — безпечна інструкція
        ctx.Response.StatusCode = 503;
        ctx.Response.Headers.RetryAfter = "5";
        await ctx.Response.WriteAsJsonAsync(
            new ApiError(
                Status: 503,
                Reason: "service_unavailable",
                LocalizedMessage: "Сервіс тимчасово " + 
                    "недоступний. Спробуйте через 5 секунд.",
                DeveloperMessage: "Upstream service timeout",
                Details: new { can_be_retried = true }));
    }
    catch (Exception ex)
    {
        // ❌ НЕ відправляємо ex.Message клієнту!
        logger.LogError(ex, "Unhandled exception");

        ctx.Response.StatusCode = 500;
        await ctx.Response.WriteAsJsonAsync(
            new ApiError(
                Status: 500,
                Reason: "internal_server_error",
                LocalizedMessage: "Внутрішня помилка " +
                    "сервера.",
                DeveloperMessage: "An unexpected error " +
                    "occurred",
                Details: null));
    }
});
```

---

## 6. Ліміти: захист від зловживань

Кожен API **повинен** мати технічні обмеження. Без них один клієнт може «покласти» весь сервіс:

| Що обмежуємо | Навіщо | Приклад ліміту |
|:---|:---|:---|
| Кількість запитів за хвилину | Захист від DDoS і зловживань | 100 req/min |
| Розмір тіла запиту | Захист від переповнення пам'яті | 1 MB |
| Кількість елементів у відповіді | Захист від «вибуху» даних | max 100 items |
| Глибина вкладеності JSON | Захист від «бомби» JSON | max 10 рівнів |

### Rate limiting у ASP.NET Core

```csharp [Rate limiting — обмеження кількості запитів]
var builder = WebApplication.CreateBuilder(args);

// .NET 7+ має вбудований rate limiter
builder.Services.AddRateLimiter(options =>
{
    // "Fixed window" — фіксоване вікно часу
    // 100 запитів за 1 хвилину
    options.AddFixedWindowLimiter("api", config =>
    {
        config.PermitLimit = 100;     // скільки дозволено
        config.Window = TimeSpan
            .FromMinutes(1);          // за який період
        config.QueueLimit = 0;        // без черги
    });

    // Що повертати при перевищенні ліміту
    options.OnRejected = async (context, token) =>
    {
        context.HttpContext.Response.StatusCode = 429;
        context.HttpContext.Response.Headers
            .RetryAfter = "60";
        
        await context.HttpContext.Response
            .WriteAsJsonAsync(new ApiError(
                Status: 429,
                Reason: "rate_limit_exceeded",
                LocalizedMessage: "Забагато запитів. " 
                    + "Спробуйте через хвилину.",
                DeveloperMessage: "Rate limit: " +
                    "100 req/min exceeded",
                Details: new 
                { 
                    limit = 100, 
                    window = "1m",
                    retry_after = 60 
                }), token);
    };
});

var app = builder.Build();
app.UseRateLimiter();

// Застосовуємо ліміт до ендпоінту
app.MapGet("/v1/orders", (int? limit, string? cursor) =>
{
    // Ліміт пагінації — клієнт не може запросити
    // більше 100 записів за раз
    var safeLimit = Math.Clamp(limit ?? 20, 1, 100);

    var orders = db.GetOrders(safeLimit, cursor);
    return Results.Ok(new
    {
        items = orders.Items,
        total = orders.Total,
        next_cursor = orders.NextCursor,
        limit = safeLimit
    });
}).RequireRateLimiting("api");
```

---

## 7. Моніторинг: навіщо потрібен `reason`

Один статус-код `403 Forbidden` може приховувати **дуже різні ситуації**:

- Користувач не має прав → нормальна ситуація
- Неправильний пароль → нормальна ситуація
- 1000 неправильних паролів за хвилину → **brute-force атака!**

Якщо API повертає тільки `403` без підтипу, моніторинг **не зможе** відрізнити нормальну помилку від атаки. Тому поле `reason` — критично для безпеки.

### Приклад: логін з різними підтипами

```csharp [Один статус-код, різні причини]
app.MapPost("/v1/auth/login", (LoginRequest req) =>
{
    var user = db.FindUser(req.Email);
    
    if (user is null)
    {
        // Моніторинг бачить: reason = "user_not_found"
        return Results.Json(
            new ApiError(403, "user_not_found", 
                "Невірний email або пароль.", 
                "User not found", null),
            statusCode: 403);
    }

    if (!VerifyPassword(req.Password, user.PasswordHash))
    {
        // Моніторинг бачить: reason = "wrong_password"
        // Аномальна кількість → можлива атака!
        return Results.Json(
            new ApiError(403, "wrong_password", 
                "Невірний email або пароль.", 
                "Invalid password", null),
            statusCode: 403);
    }

    var token = GenerateJwt(user);
    return Results.Ok(new { token });
});
```

::tip
**Зверніть увагу на важливу деталь:** `localized_message` для обох випадків **однакове** — «Невірний email або пароль». Це **навмисно**! Ми не повідомляємо клієнту, _що саме_ неправильне — email чи пароль. Якщо ми скажемо «такого email не існує», зловмисник зможе перебрати існуючі email-адреси. Але **reason** різний — щоб наш моніторинг міг відрізнити ці ситуації.
::

---

## 8. Практичні завдання

### Рівень 1: Базовий

::accordion

::accordion-item{label="Завдання 8.1: Повна валідація" icon="i-lucide-circle-help"}
Реалізуйте ендпоінт `POST /v1/products` з валідацією у правильному порядку:

1. Тіло запиту обов'язкове → `400`
2. Поле `name` обов'язкове, 3-100 символів → `400`
3. Поле `price` обов'язкове, рядок, парсити у decimal → `400`
4. Поле `category_id` → перевірити існування → `404`
5. Поле `sku` → перевірити унікальність → `409`
6. Повертайте `ApiError` з полем `details.checks_failed` для всіх помилок одразу
::

::accordion-item{label="Завдання 8.2: Error middleware" icon="i-lucide-circle-help"}
Створіть middleware, який:

1. Ловить всі необроблені винятки
2. Логує повний стек-трейс у консоль
3. Повертає клієнту `ApiError` **без** деталей стек-трейсу
4. Для `TimeoutException` → `503` + заголовок `Retry-After: 5`
5. Для `HttpRequestException` → `502 Bad Gateway`
6. Для решти → `500 Internal Server Error`
::

::

### Рівень 2: Проєктування

::accordion

::accordion-item{label="Завдання 8.3: Система помилок для магазину" icon="i-lucide-circle-help"}
Спроєктуйте та реалізуйте повну систему помилок для API інтернет-магазину:

1. Визначте `ApiError` record з усіма полями
2. Створіть `ErrorCatalog` — статичний клас з методами для кожного типу помилки (`NotFound()`, `ValidationFailed()`, `RateLimitExceeded()` тощо)
3. Реалізуйте 3 ендпоінти, що повертають різні типи помилок
4. Напишіть middleware для `5xx`
5. Забезпечте, щоб `reason` був **унікальним** — для кожної причини свій підтип
::

::

---

## 9. Резюме

::card-group

::card{title="13 потенційних помилок" icon="i-lucide-alert-triangle"}
Навіть один POST-запит може зазнати невдачі 13 способами — від зламаного JSON до перевантаження серверу. Для кожної помилки повинен бути свій статус-код і зрозумілий опис.
::

::card{title="Три аудиторії помилки" icon="i-lucide-users"}
localized_message — для користувача (українською). developer_message — для розробника (деталі). reason — для коду та моніторингу (машиночитаємий). Не змішуйте їх!
::

::card{title="5xx — без деталей назовні" icon="i-lucide-shield"}
SQL-запити, хости, стек-трейси — тільки в логи. Клієнт отримує лише інструкцію: чи можна повторити запит і через який час.
::

::card{title="Валідація за порядком" icon="i-lucide-list-ordered"}
Формат → аутентифікація → авторизація → існування → передумови → поля → бізнес-логіка. Кожен крок — свій статус-код. Повертайте всі помилки одразу.
::

::

**Далі:** у наступній статті ми розберемо **ідемпотентність та синхронізацію стану** — токени ідемпотентності, чернетки, оптимістичний контроль та безпечне повторення запитів.
