# 📺 Повний посібник з HLS (HTTP Live Streaming)

## Зміст

1. [Вступ до HLS](#вступ-до-hls)
2. [Історія та еволюція HLS](#історія-та-еволюція-hls)
3. [Теорія потокової передачі відео](#теорія-потокової-передачі-відео)
4. [Архітектура HLS](#архітектура-hls)
5. [Структура HLS: Плейлісти та Сегменти](#структура-hls-плейлісти-та-сегменти)
6. [Формат M3U8 детально](#формат-m3u8-детально)
7. [Adaptive Bitrate Streaming (ABR)](#adaptive-bitrate-streaming-abr)
8. [Кодеки та транскодування](#кодеки-та-транскодування)
9. [Live vs VOD стрімінг](#live-vs-vod-стрімінг)
10. [CDN та доставка контенту](#cdn-та-доставка-контенту)
11. [Буферизація та відтворення](#буферизація-та-відтворення)
12. [Шифрування та DRM](#шифрування-та-drm)
13. [Оптимізація та найкращі практики](#оптимізація-та-найкращі-практики)
14. [Порівняння HLS з іншими протоколами](#порівняння-hls-з-іншими-протоколами)

---

## Вступ до HLS

### Що таке HLS?

**HLS (HTTP Live Streaming)** — це **протокол потокової передачі відео та аудіо** через HTTP, розроблений компанією Apple у 2009 році.

**Простими словами:** HLS дозволяє дивитися відео онлайн без повного завантаження файлу, розбиваючи його на маленькі шматочки (сегменти) та завантажуючи їх по черзі через звичайний HTTP.

### Ключові характеристики HLS:

1. **Базується на HTTP** — працює через звичайний веб-протокол
2. **Адаптивний bitrate** — автоматично змінює якість відповідно до швидкості інтернету
3. **Сегментована передача** — відео розбивається на маленькі файли (2-10 секунд)
4. **M3U8 плейлісти** — індексні файли, що вказують на відео-сегменти
5. **Універсальна сумісність** — працює на iOS, Android, веб-браузерах
6. **CDN-friendly** — легко кешується та розповсюджується через CDN
7. **Підтримка шифрування** — вбудована підтримка AES-128 та інших

### Візуальне представлення HLS:

```
           Користувач
              │
              ↓
        [Веб-браузер]
              │
              ↓ HTTP запити
        ┌─────────────┐
        │ M3U8 Playlist│  ← Індекс усіх сегментів
        └─────────────┘
              │
         ┌────┴────┬────────┬────────┐
         ↓         ↓        ↓        ↓
    [segment1] [segment2] [segment3] [segment4]
     (0-10s)   (10-20s)   (20-30s)   (30-40s)
      .ts       .ts        .ts        .ts
```

### Чому HLS популярний?

✅ **Використовує HTTP** — працює через firewall, не потребує спеціальних серверів  
✅ **Adaptive streaming** — автоматична адаптація до швидкості з'єднання  
✅ **Масштабованість** — легко розподіляється через CDN  
✅ **Підтримка Apple** — нативна підтримка на всіх Apple пристроях  
✅ **Широка сумісність** — працює майже скрізь  

---

## Історія та еволюція HLS

### Передумови створення (до 2009)

**Проблеми традиційного стрімінгу:**

```
Старі протоколи (RTMP, RTSP):
❌ Потребували спеціальних серверів
❌ Не працювали через firewall
❌ Немає адаптивного bitrate
❌ Проблеми на мобільних пристроях
```

**Apple вирішила ці проблеми, створивши HLS.**

### 2009 — Народження HLS

**Apple анонсувала HLS** на WWDC 2009 разом з iPhone 3GS.

**Перші характеристики:**
- HTTP-based streaming
- Сегментація відео на .ts файли
- M3U8 плейлісти
- Базова підтримка adaptive bitrate

**Початкова специфікація:**
```
Версія: HLS Version 1
Формат сегментів: MPEG-2 Transport Stream (.ts)
Довжина сегменту: 10 секунд (рекомендовано)
Плейліст: M3U8 (Extended M3U)
```

### 2011 — Стандартизація

**RFC 8216 (HTTP Live Streaming)** — HLS став офіційним інтернет-стандартом.

**Що додали:**
- Детальна специфікація протоколу
- Розширені теги M3U8
- Правила для серверів та клієнтів
- Вимоги до сумісності

### 2012-2016 — Розширення можливостей

**HLS Version 4-7:**

```
✅ Підтримка fMP4 (fragmented MP4)
✅ Байтові діапазони (byte-range)
✅ I-Frame плейлісти (для швидкої перемотки)
✅ Альтернативні аудіо/субтитри
✅ Покращене шифрування
✅ Server-side ad insertion
```

### 2017 — HLS Low Latency

**Проблема:** Стандартний HLS має затримку 20-30 секунд.

**Рішення:** Apple представила **Low-Latency HLS (LL-HLS)**.

**Покращення:**
```
Стандартний HLS: 20-30 сек затримка
LL-HLS: 2-3 сек затримка

Як досягли?
- Часткові сегменти (partial segments)
- HTTP/2 Server Push
- Попереднє завантаження
- Blocking playlist reload
```

### 2020-2024 — Сучасність

**Нові можливості:**
- HDR підтримка (HDR10, Dolby Vision)
- Spatial audio (просторовий звук)
- 4K та 8K streaming
- WebAssembly декодери для браузерів
- Інтеграція з Web APIs

**Поточний стан (2024):**
```
HLS використовується на:
- YouTube
- Netflix (частково)
- Twitch
- Twitter/X
- Facebook Live
- Apple TV+
- Більшість CDN провайдерів
```

---

## Теорія потокової передачі відео

### Що таке стрімінг?

**Стрімінг (Streaming)** — це технологія передачі мультимедійного контенту в реальному часі, без необхідності повного завантаження файлу.

### Традиційне завантаження vs Стрімінг

**Традиційне завантаження (Progressive Download):**

```
Сервер                     Клієнт
  │                           │
  │═══ Відправка файлу ══════>│
  │       (весь файл)          │
  │                           ↓
  │                    Чекаємо 100%
  │                           ↓
  │                    [Відтворення]
  
Переваги: Проста реалізація
Недоліки: Довге очікування, неможливо адаптувати якість
```

**Стрімінг:**

```
Сервер                     Клієнт
  │                           │
  │── Сегмент 1 (2-10s) ────>│
  │                           ↓ Відтворення
  │── Сегмент 2 ────────────>│
  │                           ↓ Відтворення
  │── Сегмент 3 ────────────>│
  │                           ↓ Відтворення
  
Переваги: Швидкий старт, адаптивна якість
```

### Основні концепції потокового відео

#### 1. Сегментація (Segmentation)

**Що це:** Розбиття відео на маленькі частини.

```
Оригінальне відео (60 хвилин):
[═══════════════════════════════════════]

        ↓ Сегментація (по 10 секунд)

[Seg1][Seg2][Seg3][Seg4]...[Seg360]
 10s   10s   10s   10s  ...  10s

Загалом: 360 сегментів
```

**Чому сегментація?**
- ✅ Швидкий початок відтворення
- ✅ Можливість змінювати якість
- ✅ Легше кешувати
- ✅ Стійкість до помилок (якщо один сегмент пошкоджений)

#### 2. Битрейт (Bitrate)

**Битрейт** — кількість даних за одиницю часу (біт/секунду).

```
Низька якість:  500 Kbps  (0.5 Mbps)
Середня якість: 2000 Kbps (2 Mbps)
Висока якість:  5000 Kbps (5 Mbps)
4K якість:      15000 Kbps (15 Mbps)

Битрейт впливає на:
- Якість картинки
- Розмір файлу
- Вимоги до швидкості інтернету
```

#### 3. Буферизація (Buffering)

**Буфер** — попередньо завантажені дані для безперервного відтворення.

```
Часова лінія відтворення:

[Відтворюється][═ Буфер ═][Ще не завантажено]
     ↑             2-3 сегменти
  Поточний час    наперед

Розмір буфера: 20-30 секунд зазвичай
```

**Як працює буферизація:**

```
1. Початок відтворення:
   Завантажити 2-3 сегменти → Почати відтворення

2. Під час відтворення:
   Якщо буфер < 10s → Завантажити наступний сегмент
   
3. Швидке з'єднання:
   Буфер збільшується → Можна перейти на вищу якість
   
4. Повільне з'єднання:
   Буфер зменшується → Перейти на нижчу якість
```

#### 4. Адаптивний битрейт (Adaptive Bitrate)

**ABR** — автоматична зміна якості відео залежно від умов мережі.

```
Швидкість інтернету змінюється в реальному часі:

10 Mbps ──┐     ┌── 5 Mbps ──┐     ┌── 10 Mbps
          │     │             │     │
          ↓     ↓             ↓     ↓
Якість:  [1080p][720p────────][1080p]
         Висока  Середня       Висока
```

**Алгоритм адаптації:**

```
Кожні N секунд:
1. Виміряти швидкість завантаження останнього сегмента
2. Оцінити доступну пропускну здатність
3. Перевірити розмір буфера
4. Вибрати оптимальний bitrate для наступного сегмента

Правила:
- Якщо буфер < 10s → Зменшити якість
- Якщо буфер > 30s + швидкість висока → Збільшити якість
- Уникати частих перемикань (hysteresis)
```

#### 5. Затримка (Latency)

**Latency** — час від події до її показу на екрані глядача.

```
Типи стрімінгу за затримкою:

┌─────────────────┬────────────────┬──────────────┐
│ Тип             │ Затримка       │ Використання │
├─────────────────┼────────────────┼──────────────┤
│ Ultra Low       │ < 1s           │ Відеодзвінки│
│ Low Latency HLS │ 2-6s           │ Спорт Live   │
│ Standard HLS    │ 20-40s         │ Звичайне VOD │
│ Traditional     │ 60s+           │ Трансляції   │
└─────────────────┴────────────────┴──────────────┘
```

**Звідки береться затримка в HLS:**

```
1. Кодування відео:           2-5s
2. Створення сегменту:        2-10s (довжина сегменту)
3. Завантаження сегменту:     1-3s
4. Буферизація:               10-20s
5. Декодування та рендеринг:  0.1-0.5s
   ────────────────────────────────
   Загальна затримка:         15-40s

LL-HLS скорочує це до 2-6s завдяки:
- Коротші сегменти (1-2s)
- Partial segments (0.2-0.5s)
- HTTP/2 Push
- Менший буфер
```

### Фрагментація відео: Technical Deep Dive

#### Як відео розбивається на сегменти?

```
Оригінальне відео:
├─[Keyframe]────[P-frame]─[P-frame]─[Keyframe]────[P-frame]─[P-frame]─┤
   0s           0.3s      0.6s       1s           1.3s      1.6s
   
        ↓ Розбиття на сегменти (по keyframe)

Сегмент 1:                    Сегмент 2:
[Keyframe][P][P][...]        [Keyframe][P][P][...]
0s - 10s                     10s - 20s
```

**Важливо:** Сегменти завжди починаються з **Keyframe (I-frame)** для можливості незалежного декодування.

#### Типи кадрів у відео:

```
I-frame (Intra-coded):
- Повний кадр (як JPEG зображення)
- Великий розмір
- Не залежить від інших кадрів
- Використовується як початок сегменту

P-frame (Predicted):
- Зберігає тільки зміни від попереднього кадру
- Малий розмір
- Залежить від попередніх кадрів

B-frame (Bi-directional):
- Зберігає зміни від попереднього ТА наступного
- Найменший розмір
- Найскладніше декодувати
```

**Приклад GOП (Group of Pictures):**

```
[I][B][B][P][B][B][P][B][B][P][B][B][I]
 │  └─────┘  └─────┘  └─────┘  └─────┘
 │    ↓         ↓         ↓         ↓
 │  Залежать  Залежать  Залежать  Нова
 │  від I та P від P    від P     група
 └─ Keyframe (початок сегменту)

GOP Size: 12 кадрів (типово 2-4 секунди при 30 fps)
```

---

## Архітектура HLS

### Компоненти HLS системи

```
┌─────────────────────────────────────────────────────┐
│                   HLS Екосистема                    │
└─────────────────────────────────────────────────────┘

1. ДЖЕРЕЛО (Source)
   ├── Live: Камера, мікрофон
   └── VOD: Відео файл

2. КОДУВАННЯ (Encoder)
   ├── Транскодування в різні bitrate
   ├── Сегментація на файли
   └── Створення M3U8 плейлістів

3. ЗБЕРІГАННЯ (Storage/Origin)
   ├── Файловий сервер
   ├── Object Storage (S3, Azure Blob)
   └── Зберігає .ts/.m4s сегменти та .m3u8

4. РОЗПОВСЮДЖЕННЯ (CDN)
   ├── Кешування сегментів
   ├── Географічне розподілення
   └── Масштабування навантаження

5. КЛІЄНТ (Client/Player)
   ├── Завантажує M3U8
   ├── Парсить плейліст
   ├── Завантажує сегменти
   ├── Декодує та відтворює
   └── Адаптує bitrate
```

### Детальна схема роботи HLS

```
┌──────────────┐
│  Відео       │
│  Камера/Файл │
└──────┬───────┘
       │ Raw Video
       ↓
┌──────────────────────────┐
│      ENCODER             │
│  ┌────────────────────┐  │
│  │ Транскодування     │  │
│  │ - H.264 / H.265    │  │
│  │ - Multiple bitrates│  │
│  └─────────┬──────────┘  │
│            ↓              │
│  ┌────────────────────┐  │
│  │ Сегментація        │  │
│  │ - Розбиття на 10s  │  │
│  │ - Створення .ts    │  │
│  └─────────┬──────────┘  │
│            ↓              │
│  ┌────────────────────┐  │
│  │ Плейлісти          │  │
│  │ - Master.m3u8      │  │
│  │ - Media.m3u8       │  │
│  └────────────────────┘  │
└─────────┬────────────────┘
          │
          ↓
┌─────────────────────────┐
│   ORIGIN SERVER         │
│                         │
│  master.m3u8            │
│  ├── low/index.m3u8     │
│  │   ├── seg0.ts        │
│  │   ├── seg1.ts        │
│  │   └── seg2.ts        │
│  ├── med/index.m3u8     │
│  │   ├── seg0.ts        │
│  │   ├── seg1.ts        │
│  │   └── seg2.ts        │
│  └── high/index.m3u8    │
│      ├── seg0.ts        │
│      ├── seg1.ts        │
│      └── seg2.ts        │
└──────────┬──────────────┘
           │
           ↓ HTTP/HTTPS
┌──────────────────────────┐
│      CDN NETWORK         │
│  (Кеш у багатьох точках) │
└──────────┬───────────────┘
           │
           ↓ HTTP GET запити
┌──────────────────────────┐
│    VIDEO PLAYER          │
│  (HLS.js, AVPlayer)      │
│                          │
│  1. GET master.m3u8      │
│  2. Обрати якість        │
│  3. GET media.m3u8       │
│  4. GET segment.ts       │
│  5. Decode + Play        │
│  6. Адаптувати bitrate   │
└──────────────────────────┘
```

### Потік даних у HLS

#### Початок відтворення:

```
Крок 1: Запит Master Playlist
──────────────────────────────
Client → Server: GET /video/master.m3u8

Server → Client:
#EXTM3U
#EXT-X-STREAM-INF:BANDWIDTH=500000,RESOLUTION=640x360
low/index.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=2000000,RESOLUTION=1280x720
med/index.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=5000000,RESOLUTION=1920x1080
high/index.m3u8


Крок 2: Вибір якості (автоматично)
──────────────────────────────────
Player аналізує:
- Доступну пропускну здатність
- Розмір екрану
- Батарею (на мобільних)

Вибирає: med/index.m3u8 (720p)


Крок 3: Запит Media Playlist
─────────────────────────────
Client → Server: GET /video/med/index.m3u8

Server → Client:
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:10
#EXTINF:10.0,
seg0.ts
#EXTINF:10.0,
seg1.ts
#EXTINF:10.0,
seg2.ts
...


Крок 4: Завантаження сегментів
───────────────────────────────
Паралельно завантажує перші 2-3 сегменти:

Client → Server: GET /video/med/seg0.ts
Client → Server: GET /video/med/seg1.ts
Client → Server: GET /video/med/seg2.ts

Сегменти додаються до буфера


Крок 5: Відтворення
────────────────────
Як тільки seg0.ts декодований → Почати відтворення

Під час відтворення:
- Моніторинг буфера
- Завантаження наступних сегментів
- Адаптація bitrate якщо потрібно
```

### Адаптивний алгоритм в деталях

```csharp
// C# реалізація ABR алгоритму

public class HLSPlayer
{
    private double bufferSize = 0; // секунди відео в буфері
    private string currentBitrate = "medium";
    private List<double> downloadSpeeds = new List<double>(); // історія швидкостей
    private bool isPlaying = true;
    
    public async Task UpdateLoopAsync()
    {
        while (isPlaying)
        {
            // 1. Завантажити наступний сегмент
            var segment = await DownloadNextSegmentAsync(currentBitrate);
            double downloadSpeed = MeasureSpeed(segment);
            downloadSpeeds.Add(downloadSpeed);
            
            // 2. Оновити буфер
            bufferSize += segment.Duration;
            bufferSize -= GetTimeElapsed();
            
            // 3. Адаптувати bitrate
            AdaptBitrate();
            
            await Task.Delay(100); // Пауза між ітераціями
        }
    }
    
    private void AdaptBitrate()
    {
        // Середня швидкість за останні 5 вимірів
        double avgSpeed = downloadSpeeds.TakeLast(5).Average();
        
        // Правило 1: Критичний буфер - знизити якість
        if (bufferSize < 5)
        {
            currentBitrate = Downgrade(currentBitrate);
            return;
        }
        
        // Правило 2: Хороший буфер + швидкість - підвищити
        if (bufferSize > 20 && avgSpeed > GetThresholdUp())
        {
            if (CanUpgrade(currentBitrate, avgSpeed))
            {
                currentBitrate = Upgrade(currentBitrate);
            }
            return;
        }
        
        // Правило 3: Повільна швидкість - знизити
        if (avgSpeed < GetThresholdDown())
        {
            currentBitrate = Downgrade(currentBitrate);
        }
    }
    
    private string Upgrade(string current)
    {
        return current switch
        {
            "low" => "medium",
            "medium" => "high",
            "high" => "ultra",
            _ => current
        };
    }
    
    private string Downgrade(string current)
    {
        return current switch
        {
            "ultra" => "high",
            "high" => "medium",
            "medium" => "low",
            _ => current
        };
    }
}
```

---

## Структура HLS: Плейлісти та Сегменти

### Два типи плейлістів

HLS використовує **два рівні плейлістів**:

```
┌─────────────────────────────┐
│   Master Playlist           │
│   (master.m3u8)             │
│   "Індекс усіх якостей"     │
└────────┬────────────────────┘
         │
    ┌────┴────┬────────┐
    │         │        │
    ↓         ↓        ↓
┌───────┐ ┌───────┐ ┌───────┐
│ Media │ │ Media │ │ Media │
│ 360p  │ │ 720p  │ │ 1080p │
│.m3u8  │ │.m3u8  │ │.m3u8  │
└───┬───┘ └───┬───┘ └───┬───┘
    │         │         │
 ┌──┴──┐   ┌──┴──┐   ┌──┴──┐
 │Seg  │   │Seg  │   │Seg  │
 │ments│   │ments│   │ments│
 └─────┘   └─────┘   └─────┘
```

### Master Playlist (Головний плейліст)

**Призначення:** Каталог усіх доступних якостей (варіантів) відео.

**Приклад master.m3u8:**

```m3u8
#EXTM3U
#EXT-X-VERSION:3

# Низька якість (мобільні, повільний інтернет)
#EXT-X-STREAM-INF:BANDWIDTH=500000,RESOLUTION=640x360,CODECS="avc1.42c01e,mp4a.40.2"
low/index.m3u8

# Середня якість (стандарт)
#EXT-X-STREAM-INF:BANDWIDTH=2000000,RESOLUTION=1280x720,CODECS="avc1.4d401f,mp4a.40.2"
medium/index.m3u8

# Висока якість (HD)
#EXT-X-STREAM-INF:BANDWIDTH=5000000,RESOLUTION=1920x1080,CODECS="avc1.640028,mp4a.40.2"
high/index.m3u8

# 4K якість
#EXT-X-STREAM-INF:BANDWIDTH=15000000,RESOLUTION=3840x2160,CODECS="hvc1.1.6.L150.90,mp4a.40.2"
uhd/index.m3u8
```

**Розбір тегів:**

```
#EXTM3U
└─> Обов'язковий перший рядок (ідентифікатор M3U8)

#EXT-X-VERSION:3
└─> Версія HLS протоколу

#EXT-X-STREAM-INF:
├─ BANDWIDTH=500000    → Бітрейт (біт/сек) = 500 Kbps
├─ RESOLUTION=640x360  → Роздільна здатність
├─ CODECS="avc1..."    → Відео та аудіо кодеки
│   ├─ avc1.42c01e → H.264 (відео)
│   └─ mp4a.40.2   → AAC (аудіо)
└─ Наступний рядок: шлях до media playlist
```

### Media Playlist (Медіа плейліст)

**Призначення:** Список усіх сегментів для конкретної якості.

**Приклад medium/index.m3u8:**

```m3u8
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:10
#EXT-X-MEDIA-SEQUENCE:0

#EXTINF:10.0,
segment0.ts
#EXTINF:10.0,
segment1.ts
#EXTINF:10.0,
segment2.ts
#EXTINF:10.0,
segment3.ts
#EXTINF:10.0,
segment4.ts
#EXTINF:9.5,
segment5.ts

#EXT-X-ENDLIST
```

**Розбір тегів:**

```
#EXT-X-TARGETDURATION:10
└─> Максимальна тривалість сегменту (секунди)

#EXT-X-MEDIA-SEQUENCE:0
└─> Номер першого сегменту в плейлісті

#EXTINF:10.0,
└─> Точна тривалість наступного сегменту
    (може бути менше, але не більше TARGETDURATION)

segment0.ts
└─> Ім'я файлу сегменту

#EXT-X-ENDLIST
└─> Кінець плейлісту (тільки для VOD)
    Для Live streaming цього тегу немає!
```

### Сегменти відео

#### Формати сегментів

**1. MPEG-2 Transport Stream (.ts)**

```
Традиційний формат HLS:
- Розширення: .ts
- Контейнер: MPEG-2 TS
- Переваги: Добра підтримка, стійкість до помилок
- Недоліки: Більший розмір, старіший формат
```

**Структура .ts файлу:**

```
┌─────────────────────────────────┐
│   Transport Stream Packet #1    │ 188 байт
│  ┌──────────┬────────────────┐  │
│  │ Header   │  Payload (data)│  │
│  │ (4 bytes)│  (184 bytes)   │  │
│  └──────────┴────────────────┘  │
├─────────────────────────────────┤
│   Transport Stream Packet #2    │ 188 байт
├─────────────────────────────────┤
│   Transport Stream Packet #3    │ 188 байт
├─────────────────────────────────┤
│            ...                  │
└─────────────────────────────────┘

Кожен пакет: 188 байт
Містить: Відео, Аудіо, Метадані
```

**2. Fragmented MP4 (.m4s)**

```
Сучасний формат (fMP4):
- Розширення: .m4s або .mp4
- Контейнер: ISO BMFF (MP4)
- Переваги: Менший розмір, кращі кодеки (HEVC, AV1)
- Недоліки: Менша стійкість до помилок
```

**Структура fMP4:**

```
┌───────────────────────────┐
│  Initialization Segment   │ (init.mp4)
│  ┌─────────────────────┐  │
│  │ ftyp (File Type)    │  │
│  │ moov (Movie Header) │  │ Метадані:
│  │  - Codec info       │  │ - Роздільність
│  │  - Duration         │  │ - Частота кадрів
│  │  - Track info       │  │ - Кодеки
│  └─────────────────────┘  │
└───────────────────────────┘

┌───────────────────────────┐
│   Media Segment #1        │ (segment1.m4s)
│  ┌─────────────────────┐  │
│  │ moof (Movie Frag)   │  │ Метадані фрагменту
│  │ mdat (Media Data)   │  │ Відео/Аудіо дані
│  └─────────────────────┘  │
└───────────────────────────┘

┌───────────────────────────┐
│   Media Segment #2        │
└───────────────────────────┘
```

### Live Streaming Playlist

**Відмінності від VOD:**

```
VOD (Video on Demand):
- Фіксована кількість сегментів
- Є тег #EXT-X-ENDLIST
- Плейліст не змінюється

Live Streaming:
- Динамічний плейліст
- Немає #EXT-X-ENDLIST
- Плейліст оновлюється кожні N секунд
- Старі сегменти видаляються
```

**Приклад Live playlist (t=0s):**

```m3u8
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:10
#EXT-X-MEDIA-SEQUENCE:100

#EXTINF:10.0,
segment100.ts
#EXTINF:10.0,
segment101.ts
#EXTINF:10.0,
segment102.ts

# Немає EXT-X-ENDLIST → це Live!
```

**Через 10 секунд (t=10s) - плейліст оновився:**

```m3u8
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:10
#EXT-X-MEDIA-SEQUENCE:101  ← Збільшився!

#EXTINF:10.0,
segment101.ts  ← segment100 видалено
#EXTINF:10.0,
segment102.ts
#EXTINF:10.0,
segment103.ts  ← Новий сегмент!
```

**Як клієнт працює з Live:**

```
1. Завантажити playlist
2. Отримати останні N сегментів (зазвичай 3)
3. Почати відтворення
4. Періодично оновлювати playlist:
   - Якщо MEDIA-SEQUENCE змінився → є нові сегменти
   - Завантажити нові сегменти
5. Repeat step 4
```

### DVR (Time-Shifting) у Live

**DVR** дозволяє перемотувати Live стрім назад.

```
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:10
#EXT-X-MEDIA-SEQUENCE:50
#EXT-X-PLAYLIST-TYPE:EVENT  ← EVENT type для DVR

# Зберігаємо останні 30 сегментів (5 хвилин DVR)
#EXTINF:10.0,
segment50.ts   ← Можна перемотати до цього моменту
#EXTINF:10.0,
segment51.ts
...
#EXTINF:10.0,
segment79.ts   ← Поточний Live

┌─────────────────────────────────┐
│ Timeline:                       │
│                                 │
│ [50]───────────[79]             │
│  ↑              ↑               │
│  5 хв назад    Live edge        │
│                                 │
│ Користувач може перемотати      │
│ на будь-яке місце в цьому       │
│ діапазоні                       │
└─────────────────────────────────┘
```

---

## Формат M3U8 детально

### Історія формату M3U

```
M3U (MP3 URL):
- Створено в 1996 для Winamp
- Простий текстовий формат
- Розширення: .m3u

M3U8:
- Розширення M3U
- UTF-8 кодування (звідси "8")
- Додані Extended теги (#EXT-)
- Використовується в HLS
```

### Базова структура M3U8

```m3u8
#EXTM3U                    ← ОБОВ'ЯЗКОВИЙ перший рядок
#EXT-X-VERSION:3           ← Версія HLS (1-7)
#EXT-X-TARGETDURATION:10   ← Макс. довжина сегменту

#EXTINF:10.0,              ← Тривалість наступного сегменту
segment1.ts                ← URL/шлях до сегменту

#EXTINF:9.5,
segment2.ts
```

### Усі основні теги M3U8

#### Базові теги

```m3u8
#EXTM3U
└─> ОБОВ'ЯЗКОВИЙ. Перший рядок файлу.

#EXT-X-VERSION:7
└─> Версія HLS:
    Version 1: Базова підтримка
    Version 3: AES-128 шифрування
    Version 4: I-Frame плейлісти, byte-range
    Version 5: EXT-X-MAP для fMP4
    Version 6: Покращення для VOD
    Version 7: Server-side ad insertion
```

#### Теги Media Playlist

```m3u8
#EXT-X-TARGETDURATION:10
└─> Максимальна тривалість будь-якого сегменту (секунди)
    Клієнт використовує для оптимізації буферизації

#EXT-X-MEDIA-SEQUENCE:42
└─> Номер першого сегменту в плейлісті
    Для Live: збільшується з кожним оновленням

#EXT-X-DISCONTINUITY-SEQUENCE:3
└─> Номер для відстеження точок розриву

#EXTINF:10.416667,
└─> Тривалість наступного сегменту (секунди)
    Може бути дробовим числом

#EXT-X-BYTERANGE:1024@2048
└─> Діапазон байтів для сегменту в одному файлі
    Формат: довжина@offset

#EXT-X-DISCONTINUITY
└─> Розрив у послідовності (зміна кодека, реклама)
    
#EXT-X-KEY:METHOD=AES-128,URI="https://key.server/key",IV=0x...
└─> Інформація про шифрування

#EXT-X-MAP:URI="init.mp4"
└─> Initialization segment для fMP4

#EXT-X-PROGRAM-DATE-TIME:2024-12-23T15:30:00.000Z
└─> Абсолютний час для Live синхронізації

#EXT-X-DATERANGE:
└─> Часові діапазони (для реклами, метаданих)

#EXT-X-ENDLIST
└─> Кінець плейлісту (тільки VOD)
```

#### Теги Master Playlist

```m3u8
#EXT-X-STREAM-INF:BANDWIDTH=2000000,RESOLUTION=1280x720
└─> Інформація про варіант стріму:
    - BANDWIDTH: бітрейт (біт/сек)
    - RESOLUTION: роздільна здатність
    - CODECS: список кодеків
    - FRAME-RATE: частота кадрів
    - AUDIO: ID аудіо групи
    - SUBTITLES: ID субтитрів
    - CLOSED-CAPTIONS: скриті субтитри

#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID="audio",NAME="English"
└─> Альтернативні медіа (аудіо доріжки, субтитри):
    - TYPE: AUDIO, VIDEO, SUBTITLES, CLOSED-CAPTIONS
    - GROUP-ID: ідентифікатор групи
    - NAME: назва доріжки
    - LANGUAGE: мова (en, uk, ru)
    - DEFAULT: чи це за замовчуванням
    - AUTOSELECT: автовибір
    - URI: посилання на playlist

#EXT-X-I-FRAME-STREAM-INF:
└─> Playlist тільки з I-frames (для швидкої перемотки)
```

### Повний приклад: Master Playlist з альтернативними медіа

```m3u8
#EXTM3U
#EXT-X-VERSION:6

# ═══════════════════════════════
# Аудіо доріжки
# ═══════════════════════════════

#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID="audio",NAME="Українська",LANGUAGE="uk",DEFAULT=YES,AUTOSELECT=YES,URI="audio/ukrainian.m3u8"
#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID="audio",NAME="English",LANGUAGE="en",URI="audio/english.m3u8"
#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID="audio",NAME="Русский",LANGUAGE="ru",URI="audio/russian.m3u8"

# ═══════════════════════════════
# Субтитри
# ═══════════════════════════════

#EXT-X-MEDIA:TYPE=SUBTITLES,GROUP-ID="subs",NAME="Українські",LANGUAGE="uk",URI="subtitles/uk.m3u8"
#EXT-X-MEDIA:TYPE=SUBTITLES,GROUP-ID="subs",NAME="English",LANGUAGE="en",URI="subtitles/en.m3u8"

# ═══════════════════════════════
# Відео варіанти
# ═══════════════════════════════

# 4K Ultra HD
#EXT-X-STREAM-INF:BANDWIDTH=15000000,AVERAGE-BANDWIDTH=12000000,RESOLUTION=3840x2160,FRAME-RATE=60.000,CODECS="hvc1.2.4.L150.90,mp4a.40.2",AUDIO="audio",SUBTITLES="subs"
4k/index.m3u8

# 1080p Full HD
#EXT-X-STREAM-INF:BANDWIDTH=5000000,AVERAGE-BANDWIDTH=4500000,RESOLUTION=1920x1080,FRAME-RATE=30.000,CODECS="avc1.640028,mp4a.40.2",AUDIO="audio",SUBTITLES="subs"
1080p/index.m3u8

# 720p HD
#EXT-X-STREAM-INF:BANDWIDTH=2000000,AVERAGE-BANDWIDTH=1800000,RESOLUTION=1280x720,FRAME-RATE=30.000,CODECS="avc1.4d401f,mp4a.40.2",AUDIO="audio",SUBTITLES="subs"
720p/index.m3u8

# 480p SD
#EXT-X-STREAM-INF:BANDWIDTH=1000000,AVERAGE-BANDWIDTH=900000,RESOLUTION=854x480,FRAME-RATE=30.000,CODECS="avc1.4d401e,mp4a.40.2",AUDIO="audio",SUBTITLES="subs"
480p/index.m3u8

# 360p Mobile
#EXT-X-STREAM-INF:BANDWIDTH=500000,AVERAGE-BANDWIDTH=450000,RESOLUTION=640x360,FRAME-RATE=30.000,CODECS="avc1.42c01e,mp4a.40.2",AUDIO="audio",SUBTITLES="subs"
360p/index.m3u8

# ═══════════════════════════════
# I-Frame плейлісти (для перемотки)
# ═══════════════════════════════

#EXT-X-I-FRAME-STREAM-INF:BANDWIDTH=500000,RESOLUTION=1920x1080,CODECS="avc1.640028",URI="1080p/iframes.m3u8"
#EXT-X-I-FRAME-STREAM-INF:BANDWIDTH=200000,RESOLUTION=1280x720,CODECS="avc1.4d401f",URI="720p/iframes.m3u8"
```

### Приклад Media Playlist з шифруванням

```m3u8
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:10
#EXT-X-MEDIA-SEQUENCE:0

# Ключ для розшифровки (AES-128)
#EXT-X-KEY:METHOD=AES-128,URI="https://keys.example.com/key.php?id=123",IV=0x12345678901234567890123456789012

# Сегменти (зашифровані)
#EXTINF:10.0,
segment0.ts

#EXTINF:10.0,
segment1.ts

# Зміна ключа (для безпеки)
#EXT-X-KEY:METHOD=AES-128,URI="https://keys.example.com/key.php?id=124",IV=0x98765432109876543210987654321098

#EXTINF:10.0,
segment2.ts

#EXTINF:10.0,
segment3.ts

#EXT-X-ENDLIST
```

### Приклад fMP4 Media Playlist

```m3u8
#EXTM3U
#EXT-X-VERSION:7
#EXT-X-TARGETDURATION:6
#EXT-X-MEDIA-SEQUENCE:1
#EXT-X-INDEPENDENT-SEGMENTS

# Initialization Segment (містить метадані)
#EXT-X-MAP:URI="init.mp4"

# Media Segments
#EXTINF:6.006,
segment1.m4s

#EXTINF:6.006,
segment2.m4s

#EXTINF:6.006,
segment3.m4s

#EXTINF:5.005,
segment4.m4s

#EXT-X-ENDLIST
```

---

## Adaptive Bitrate Streaming (ABR)

### Що таке ABR?

**Adaptive Bitrate Streaming (ABR)** — технологія автоматичної адаптації якості відео в реальному часі залежно від умов мережі та можливостей пристрою.

### Навіщо потрібен ABR?

```
Проблема без ABR:
┌──────────────────────────────────────┐
│ Користувач з повільним інтернетом   │
│ намагається дивитись 1080p відео    │
│                                      │
│ Результат:                           │
│ - Постійна буферизація               │
│ - Зупинки відтворення                │
│ - Погана якість перегляду            │
└──────────────────────────────────────┘

Рішення з ABR:
┌──────────────────────────────────────┐
│ Відео автоматично переключається    │
│ на 480p або 360p                     │
│                                      │
│ Результат:                           │
│ ✅ Безперервне відтворення           │
│ ✅ Оптимальна якість для з'єднання   │
│ ✅ Хороший user experience           │
└──────────────────────────────────────┘
```

### Як працює ABR в HLS

#### 1. Підготовка контенту (Encoding)

**Відео кодується в кілька варіантів якості:**

```
Оригінальне відео (4K, 60fps, 100 Mbps)
           │
           ↓ Транскодування
           │
    ┌──────┴──────┬──────────┬──────────┬──────────┐
    ↓             ↓          ↓          ↓          ↓
[360p]       [480p]      [720p]     [1080p]     [4K]
500 Kbps     1 Mbps      2 Mbps     5 Mbps      15 Mbps
640x360      854x480     1280x720   1920x1080   3840x2160
```

**Лестница якості (Quality Ladder):**

```
┌─────────────────────────────────────────────────────┐
│ Типова лестница якості для HLS:                    │
├──────┬──────────┬────────────┬───────────┬─────────┤
│ Якість│Роздільність│ Bitrate  │ Framerate │ Codec  │
├──────┼──────────┼────────────┼───────────┼─────────┤
│ 4K   │ 3840x2160│ 12-20 Mbps │ 30-60 fps │ HEVC   │
│ 1080p│ 1920x1080│ 4-8 Mbps   │ 30-60 fps │ H.264  │
│ 720p │ 1280x720 │ 2-4 Mbps   │ 30 fps    │ H.264  │
│ 480p │ 854x480  │ 1-1.5 Mbps │ 30 fps    │ H.264  │
│ 360p │ 640x360  │ 400-800 Kb │ 30 fps    │ H.264  │
│ 240p │ 426x240  │ 200-400 Kb │ 24 fps    │ H.264  │
└──────┴──────────┴────────────┴───────────┴─────────┘
```

#### 2. Моніторинг умов

**Player постійно відстежує:**

```
┌─────────────────────────────────┐
│ Параметри для ABR рішень:       │
├─────────────────────────────────┤
│ 1. Пропускна здатність          │
│    - Швидкість завантаження     │
│    - Стабільність з'єднання     │
│                                 │
│ 2. Розмір буфера                │
│    - Скільки секунд в буфері    │
│    - Тренд (зростає/падає)      │
│                                 │
│ 3. Можливості пристрою          │
│    - Роздільність екрану        │
│    - CPU потужність             │
│    - Заряд батареї              │
│                                 │
│ 4. Мережеві умови               │
│    - Тип з'єднання (WiFi/4G)    │
│    - Затримка (latency)         │
│    - Втрата пакетів             │
└─────────────────────────────────┘
```

#### 3. Алгоритми адаптації

**A. Rate-Based Algorithm (На основі швидкості)**

```
Принцип: Вимірювати швидкість завантаження сегментів

Алгоритм:
1. Завантажити сегмент
2. Виміряти: download_speed = segment_size / download_time
3. Вибрати якість:
   - Якщо download_speed > 1.5 * current_bitrate → підвищити
   - Якщо download_speed < 0.8 * current_bitrate → знизити
   
Приклад:
Поточний bitrate: 2 Mbps (720p)
Download speed: 4 Mbps
→ 4 > 1.5 * 2 = 3
→ Можна підвищити до 1080p (5 Mbps потребує > 4 Mbps, тому залишаємо 720p)

Download speed: 1.2 Mbps
→ 1.2 < 0.8 * 2 = 1.6
→ Знижуємо до 480p (1 Mbps)
```

**B. Buffer-Based Algorithm (На основі буфера)**

```
Принцип: Орієнтуватись на розмір буфера

Алгоритм:
┌──────────────────────────────────────┐
│ Буфер > 30s → Максимальна якість     │
│ Буфер 20-30s → Висока якість         │
│ Буфер 10-20s → Середня якість        │
│ Буфер 5-10s → Низька якість          │
│ Буфер < 5s → Мінімальна якість       │
└──────────────────────────────────────┘

Переваги:
✅ Стабільніше (не реагує на короткострокові зміни)
✅ Менше перемикань якості
✅ Краще для Live стрімінгу
```

**C. Hybrid Algorithm (Гібридний)**

```csharp
// Поєднує обидва підходи:

public class HybridABR
{
    public string SelectQuality()
    {
        double bandwidth = MeasureBandwidth();
        double bufferSize = GetBufferSize();
        
        // Оцінка на основі bandwidth
        string bandwidthQuality = SelectByBandwidth(bandwidth);
        
        // Оцінка на основі buffer
        string bufferQuality = SelectByBuffer(bufferSize);
        
        // Фінальне рішення (консервативний підхід)
        return GetLowerQuality(bandwidthQuality, bufferQuality);
    }
    
    private string SelectByBandwidth(double bandwidthMbps)
    {
        return bandwidthMbps switch
        {
            >= 15 => "4k",
            >= 5 => "1080p",
            >= 2 => "720p",
            >= 1 => "480p",
            _ => "360p"
        };
    }
    
    private string SelectByBuffer(double bufferSeconds)
    {
        return bufferSeconds switch
        {
            > 30 => "4k",
            > 20 => "1080p",
            > 10 => "720p",
            > 5 => "480p",
            _ => "360p"
        };
    }
}

// Приклад:
// - Bandwidth дозволяє 1080p
// - Але buffer = 8s (низький)
// → Вибираємо 720p (безпечніше)
```

### ABR у дії: Реальний сценарій

```
Часова лінія відтворення відео:

T=0s: Початок
├─ Швидкість невідома
├─ Вибираємо середню якість: 720p
└─ Завантажуємо 3 сегменти (30s) в буфер

T=10s: Перший вимір
├─ Швидкість: 6 Mbps (добре!)
├─ Буфер: 25s (добре!)
└─ Рішення: Підвищити до 1080p ↗

T=30s: Стабільна робота
├─ Швидкість: 5.5 Mbps
├─ Буфер: 28s
└─ Рішення: Залишити 1080p →

T=45s: Погіршення з'єднання
├─ Швидкість падає: 2 Mbps
├─ Буфер зменшується: 18s → 15s → 12s
└─ Рішення: Знизити до 720p ↘

T=60s: З'єднання стабілізувалось
├─ Швидкість: 3 Mbps
├─ Буфер: 22s (відновлюється)
└─ Рішення: Залишити 720p →

T=90s: WiFi знову швидкий
├─ Швидкість: 8 Mbps
├─ Буфер: 35s
└─ Рішення: Підвищити до 1080p ↗
```

### Проблеми ABR та рішення

#### Проблема 1: Часті перемикання (Quality Switching)

```
Погана поведінка:
720p → 1080p → 720p → 1080p → 480p → 720p
↑ Дратує користувача!

Рішення: Hysteresis (Гістерезис)
- Для підвищення: Потрібно 2-3 позитивні вимірювання
- Для зниження: Реагувати швидше (1 негативне вимірювання)

def should_upgrade():
    if last_3_measurements_good():
        return True
    return False

def should_downgrade():
    if last_1_measurement_bad():
        return True
    return False
```

#### Проблема 2: Початковий вибір якості

```
Холодний старт (немає історії):
❌ Погано: Почати з максимальної якості
   → Висока ймовірність буферизації

✅ Добре: Почати з середньої якості
   → Швидкий старт, потім адаптація вгору

Варіанти стратегій:
1. Conservative: Почати з 480p
2. Moderate: Почати з 720p
3. Aggressive: Почати з 1080p (ризиковано)
```

#### Проблема 3: Network Variability

```
Мобільне з'єднання може змінюватись:
10 Mbps → 2 Mbps → 15 Mbps → 1 Mbps

Рішення: Експоненційне згладжування (Exponential Smoothing)

estimated_bandwidth = α * measured + (1-α) * estimated_bandwidth

де α = 0.2-0.3 (ваговий коефіцієнт нового вимірювання)

Приклад:
Попередня оцінка: 5 Mbps
Нове вимірювання: 10 Mbps
α = 0.25

Нова оцінка = 0.25 * 10 + 0.75 * 5 = 6.25 Mbps
↑ Плавна зміна замість різкого стрибка
```

### Метрики якості ABR

**Основні KPI для оцінки ABR алгоритму:**

```
1. Startup Time (Час початку)
   - Час до першого кадру
   Цільове значення: < 2s

2. Rebuffering Ratio
   - % часу на буферизації
   Цільове значення: < 0.5%

3. Average Bitrate
   - Середній bitrate протягом сесії
   Цільове значення: Максимально можливий

4. Quality Switches
   - Кількість перемикань якості
   Цільове значення: < 5 на годину

5. Join Time
   - Час від запиту до відтворення
   Цільове значення: < 1s
```

### Сучасні ABR алгоритми

#### 1. BOLA (Buffer Occupancy based Lyapunov Algorithm)

```
Використовується в: Dash.js

Принцип: Математична оптимізація на основі теорії Ляпунова

Переваги:
✅ Теоретично оптимальний
✅ Не потребує прогнозування bandwidth
✅ Стабільний
```

#### 2. MPC (Model Predictive Control)

```
Використовується в: Netflix

Принцип: Прогнозування майбутніх умов мережі

Як працює:
1. Будує модель мережі
2. Прогнозує наступні N секунд
3. Вибирає оптимальну стратегію
4. Оновлює модель після кожного сегменту
```

#### 3. Throughput-based ABR

```
Використовується в: YouTube

Принцип: Проста але ефективна оцінка throughput

Формула:
next_quality = current_throughput * safety_factor

safety_factor = 0.85-0.9 (запас безпеки)
```

---

## Кодеки та транскодування

### Що таке кодек?

**Кодек (Codec)** = **Co**der + **Dec**oder — алгоритм для стиснення та розпакування відео/аудіо.

```
Оригінальне відео (RAW):
┌────────────────────────────┐
│ 1920x1080, 30fps, 10-bit   │
│ Розмір: ~500 MB/секунда    │
│ Неможливо стрімити!        │
└────────────────────────────┘
           ↓ ENCODER (Стиснення)
┌────────────────────────────┐
│ H.264 відео                │
│ Розмір: ~5 MB/секунда      │
│ Стиснення: 100:1           │
└────────────────────────────┘
           ↓ Передача/Зберігання
┌────────────────────────────┐
│ Стиснуте відео             │
└────────────────────────────┘
           ↓ DECODER (Розпакування)
┌────────────────────────────┐
│ Відтворення на екрані      │
└────────────────────────────┘
```

### Відео кодеки для HLS

#### 1. H.264 / AVC (Advanced Video Coding)

```
Статус: ⭐ Найпопулярніший для HLS

Характеристики:
├─ Рік: 2003
├─ Стандарт: MPEG-4 Part 10
├─ Підтримка: Універсальна (всі браузери, пристрої)
├─ Ефективність: Базова (1x)
└─ Патенти: Є (але широкодоступні)

Профілі H.264:
┌──────────────┬─────────────────────────┐
│ Baseline     │ Мобільні пристрої       │
│ Main         │ SD/HD трансляції        │
│ High         │ HD/Full HD (1080p)      │
│ High 10      │ 10-bit колір            │
└──────────────┴─────────────────────────┘

Codec string в M3U8:
avc1.42c01e  → Baseline Profile, Level 3.0
avc1.4d401f  → Main Profile, Level 3.1
avc1.640028  → High Profile, Level 4.0
```

**Розшифровка codec string:**

```
avc1.42c01e
│    │ │ │
│    │ │ └─ Level (1e = 3.0)
│    │ └─── Constraint Set Flags
│    └───── Profile (42 = Baseline)
└────────── Codec (avc1 = H.264)
```

#### 2. H.265 / HEVC (High Efficiency Video Coding)

```
Статус: Сучасний стандарт

Характеристики:
├─ Рік: 2013
├─ Ефективність: 2x краще за H.264
├─ Підтримка: iOS (11+), Android, Edge, Safari
├─ Патенти: Складна ліцензійна ситуація
└─ Використання: 4K, HDR контент

Переваги:
✅ 50% менший розмір при тій же якості
✅ Підтримка 8K
✅ HDR (High Dynamic Range)
✅ 10-bit та 12-bit колір

Недоліки:
❌ Не підтримується в Chrome (патентні проблеми)
❌ Повільніше декодування
❌ Вищі вимоги до CPU

Codec string:
hvc1.1.6.L150.90  → HEVC Main Profile, Level 5.0
hvc1.2.4.L150.90  → HEVC Main 10 Profile, 4K
```

#### 3. AV1 (AOMedia Video 1)

```
Статус: Майбутнє відео стрімінгу

Характеристики:
├─ Рік: 2018
├─ Розробник: Alliance for Open Media (Google, Mozilla, Netflix, Amazon)
├─ Ефективність: 30% краще за HEVC
├─ Патенти: Royalty-free! (безкоштовний)
└─ Підтримка: Chrome 90+, Firefox 67+, Edge

Переваги:
✅ Безкоштовний (відкритий)
✅ Найкраще стиснення
✅ Оптимізований для інтернет-стрімінгу
✅ Підтримка HDR, 10-bit

Недоліки:
❌ Повільне кодування (20x повільніше за H.264)
❌ Обмежена підтримка на старих пристроях
❌ Висока обчислювальна складність

Codec string:
av01.0.04M.08  → AV1 Profile 0, Level 4.0
```

#### 4. VP9 (Google)

```
Статус: Альтернатива HEVC від Google

Характеристики:
├─ Рік: 2013
├─ Розробник: Google
├─ Ефективність: Подібна до HEVC
├─ Патенти: Безкоштовний
└─ Підтримка: Chrome, Firefox, Edge

Використання: YouTube

Codec string:
vp09.00.41.08  → VP9 Profile 0, Level 4.1
```

### Порівняння відео кодеків

```
┌────────┬─────────┬────────────┬──────────┬─────────┐
│ Кодек  │ Рік     │ Ефективність│ Підтримка│ Ліцензія│
├────────┼─────────┼────────────┼──────────┼─────────┤
│ H.264  │ 2003    │ 1x (база)  │ 100%     │ Платна  │
│ H.265  │ 2013    │ 2x         │ ~80%     │ Платна  │
│ VP9    │ 2013    │ 1.8x       │ ~85%     │ Вільна  │
│ AV1    │ 2018    │ 2.5x       │ ~70%     │ Вільна  │
└────────┴─────────┴────────────┴──────────┴─────────┘

Розмір файлу для однакової якості:
H.264:  100 MB
H.265:   50 MB (-50%)
VP9:     55 MB (-45%)
AV1:     40 MB (-60%)
```

### Аудіо кодеки для HLS

#### 1. AAC (Advanced Audio Coding)

```
Статус: Стандарт для HLS

Характеристики:
├─ Рік: 1997
├─ Якість: Краще за MP3 при тому ж bitrate
├─ Підтримка: Універсальна
└─ Bitrate: 96-320 kbps

Профілі:
- AAC-LC (Low Complexity): Стандарт
- HE-AAC (High Efficiency): Низькі bitrate
- HE-AAC v2: Ще нижчі bitrate (стерео)

Codec string:
mp4a.40.2  → AAC-LC
mp4a.40.5  → HE-AAC
```

#### 2. Opus

```
Статус: Сучасний відкритий кодек

Характеристики:
├─ Рік: 2012
├─ Якість: Краще за AAC
├─ Підтримка: Зростає
├─ Ліцензія: Вільна
└─ Bitrate: 6-510 kbps

Переваги:
✅ Низька затримка (для VoIP)
✅ Краща якість при низькихbitrate
✅ Адаптивний bitrate

Використання: WebRTC, Discord
```

#### 3. Dolby Audio

```
Dolby Digital (AC-3):
- 5.1 surround sound
- 384-640 kbps

Dolby Digital Plus (E-AC-3):
- 7.1 surround sound
- До 1.7 Mbps
- Використовується в Netflix, Amazon Prime

Dolby Atmos:
- Об'єктний звук (object-based audio)
- Висока якість
```

### Процес транскодування

```
┌─────────────────────────────────────────────────┐
│             Транскодування                      │
└─────────────────────────────────────────────────┘

Вхід: Оригінальне відео
├─ 4K, 60fps, 100 Mbps
└─ Формат: ProRes, DNxHD (mezzanine)

        ↓

┌─────────────────────┐
│  1. Декодування     │
│  (Розпакування)     │
└──────────┬──────────┘
           ↓
┌─────────────────────┐
│  2. Обробка         │
│  - Масштабування    │
│  - Deinterlace      │
│  - Color correction │
│  - Фільтри          │
└──────────┬──────────┘
           ↓
┌─────────────────────┐
│  3. Кодування       │
│  В кілька якостей:  │
│  - 4K (HEVC)        │
│  - 1080p (H.264)    │
│  - 720p (H.264)     │
│  - 480p (H.264)     │
│  - 360p (H.264)     │
└──────────┬──────────┘
           ↓
┌─────────────────────┐
│  4. Сегментація     │
│  - Розбиття на .ts  │
│  - Створення M3U8   │
└──────────┬──────────┘
           ↓
┌─────────────────────┐
│  5. Пакування       │
│  - Encryption (опц.)│
│  - Checksums        │
│  - Metadata         │
└─────────────────────┘
```

### Налаштування транскодування

#### Параметри якості

```
Bitrate (Бітрейт):
- Що це: Кількість даних на секунду
- Вплив: Більше = Краща якість, Більший розмір
- Типи:
  • CBR (Constant Bitrate): Фіксований
  • VBR (Variable Bitrate): Змінний (кращеефективність)

Resolution (Роздільність):
- 4K: 3840x2160
- 1080p: 1920x1080
- 720p: 1280x720
- 480p: 854x480
- 360p: 640x360

Frame Rate (Частота кадрів):
- 60 fps: Спорт, екшн
- 30 fps: Стандарт
- 24 fps: Кіно
- Більше fps = Плавніше, але більший розмір

GOP Size (Group of Pictures):
- Що це: Кількість кадрів між keyframes
- Типове: 2-4 секунди (60-120 кадрів при 30fps)
- HLS: GOP = segment duration
- Менше = Краща адаптація, більший розмір
```

#### Приклад FFmpeg команди

```bash
# Транскодування в HLS з adaptive bitrate

ffmpeg -i input.mp4 \
  # 1080p
  -vf scale=1920:1080 -c:v libx264 -b:v 5M \
  -c:a aac -b:a 192k -ac 2 \
  -f hls -hls_time 6 -hls_playlist_type vod \
  -hls_segment_filename "1080p_%03d.ts" 1080p.m3u8 \
  \
  # 720p
  -vf scale=1280:720 -c:v libx264 -b:v 2M \
  -c:a aac -b:a 128k -ac 2 \
  -f hls -hls_time 6 -hls_playlist_type vod \
  -hls_segment_filename "720p_%03d.ts" 720p.m3u8 \
  \
  # 480p
  -vf scale=854:480 -c:v libx264 -b:v 1M \
  -c:a aac -b:a 96k -ac 2 \
  -f hls -hls_time 6 -hls_playlist_type vod \
  -hls_segment_filename "480p_%03d.ts" 480p.m3u8

# Параметри:
# -vf scale: Масштабування
# -c:v: Відео кодек
# -b:v: Відео bitrate
# -c:a: Аудіо кодек
# -b:a: Аудіо bitrate
# -ac: Кількість аудіо каналів
# -hls_time: Тривалість сегменту
# -hls_playlist_type: vod або event
```

### Оптимізація транскодування

```
1. Preset (швидкість кодування):
   ultrafast → fast → medium → slow → veryslow
   ↑ Швидко           Якісно ↑
   
   Рекомендація: medium для VOD, fast для Live

2. Profile:
   - baseline: Стара сумісність
   - main: Стандарт
   - high: Найкраща якість

3. Level:
   - 3.0: До 720p
   - 4.0: До 1080p
   - 5.0: До 4K

4. Tune:
   - film: Для фільмів
   - animation: Для анімації
   - zerolatency: Низька затримка (Live)
```

---

## Live vs VOD стрімінг

### VOD (Video on Demand)

**VOD** — попередньо записане відео, доступне для перегляду в будь-який час.

```
Характеристики VOD:
┌────────────────────────────────────────┐
│ ✅ Відео вже готове                    │
│ ✅ Можна перемотувати на будь-яку позицію │
│ ✅ Стабільна якість                     │
│ ✅ Можна кешувати                       │
│ ⏱️ Немає реального часу                 │
└────────────────────────────────────────┘

Приклади: Netflix, YouTube (звичайні відео), Udemy
```

### Live Streaming

**Live** — трансляція в реальному часі.

```
Характеристики Live:
┌────────────────────────────────────────┐
│ ⚡ Реальний час (live edge)            │
│ ⏱️ Затримка 10-40 секунд (HLS)         │
│ 📡 Неможливо перемотати вперед          │
│ 🔄 Динамічний playlist                  │
│ 💾 Обмежений DVR (опціонально)          │
└────────────────────────────────────────┘

Приклади: Twitch, YouTube Live, спортивні події
```

### Порівняння M3U8 плейлістів

**VOD Playlist:**

```m3u8
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:10
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD

#EXTINF:10.0,
segment0.ts
#EXTINF:10.0,
segment1.ts
#EXTINF:10.0,
segment2.ts
...
#EXTINF:9.5,
segment100.ts

#EXT-X-ENDLIST  ← Кінець плейлісту
```

**Live Playlist (t=0):**

```m3u8
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:10
#EXT-X-MEDIA-SEQUENCE:1523  ← Динамічний номер

#EXTINF:10.0,
segment1523.ts
#EXTINF:10.0,
segment1524.ts
#EXTINF:10.0,
segment1525.ts

# Немає EXT-X-ENDLIST → це Live!
```

**Live Playlist (t=10s):**

```m3u8
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:10
#EXT-X-MEDIA-SEQUENCE:1524  ← Збільшився

#EXTINF:10.0,
segment1524.ts  ← Перший з попереднього списку видалено
#EXTINF:10.0,
segment1525.ts
#EXTINF:10.0,
segment1526.ts  ← Новий сегмент!
```

### C# приклад: HLS Player для VOD

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Threading.Tasks;

public class HLSVODPlayer
{
    private readonly HttpClient httpClient = new HttpClient();
    private List<string> segments = new List<string>();
    private string baseUrl;
    
    public async Task LoadPlaylistAsync(string m3u8Url)
    {
        baseUrl = GetBaseUrl(m3u8Url);
        string content = await httpClient.GetStringAsync(m3u8Url);
        
        ParseM3U8(content);
        
        Console.WriteLine($"Завантажено {segments.Count} сегментів");
    }
    
    private void ParseM3U8(string content)
    {
        var lines = content.Split('\n');
        
        foreach (var line in lines)
        {
            // Пропускаємо коментарі та теги
            if (line.StartsWith("#") || string.IsNullOrWhiteSpace(line))
                continue;
            
            // Це URL сегменту
            string segmentUrl = line.Trim();
            if (!segmentUrl.StartsWith("http"))
            {
                segmentUrl = baseUrl + "/" + segmentUrl;
            }
            
            segments.Add(segmentUrl);
        }
    }
    
    public async Task PlayAsync()
    {
        for (int i = 0; i < segments.Count; i++)
        {
            Console.WriteLine($"Відтворення сегменту {i + 1}/{segments.Count}");
            
            // Завантажити сегмент
            byte[] segmentData = await httpClient.GetByteArrayAsync(segments[i]);
            
            // Декодувати та відтворити
            await PlaySegmentAsync(segmentData);
        }
    }
    
    public async Task SeekAsync(TimeSpan position)
    {
        // Для VOD можна перейти на будь-яку позицію
        int segmentIndex = (int)(position.TotalSeconds / 10); // 10s на сегмент
        
        if (segmentIndex >= 0 && segmentIndex < segments.Count)
        {
            Console.WriteLine($"Перехід на {position.TotalSeconds}s (сегмент {segmentIndex})");
            // Почати відтворення з цього сегменту
        }
    }
    
    private string GetBaseUrl(string url)
    {
        var uri = new Uri(url);
        return $"{uri.Scheme}://{uri.Host}{System.IO.Path.GetDirectoryName(uri.AbsolutePath)}";
    }
    
    private async Task PlaySegmentAsync(byte[] data)
    {
        // Тут декодування та відтворення
        await Task.Delay(100); // Симуляція
    }
}
```

### C# приклад: HLS Player для Live

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;

public class HLSLivePlayer
{
    private readonly HttpClient httpClient = new HttpClient();
    private string playlistUrl;
    private HashSet<string> playedSegments = new HashSet<string>();
    private CancellationTokenSource cancellationToken;
    
    public async Task StartLiveStreamAsync(string m3u8Url)
    {
        playlistUrl = m3u8Url;
        cancellationToken = new CancellationTokenSource();
        
        Console.WriteLine("Початок Live стріму...");
        
        while (!cancellationToken.Token.IsCancellationRequested)
        {
            try
            {
                // 1. Завантажити playlist
                var segments = await FetchLivePlaylistAsync();
                
                // 2. Знайти нові сегменти
                var newSegments = segments.Where(s => !playedSegments.Contains(s)).ToList();
                
                // 3. Відтворити нові сегменти
                foreach (var segment in newSegments)
                {
                    await PlaySegmentAsync(segment);
                    playedSegments.Add(segment);
                    
                    Console.WriteLine($"Відтворено: {segment}");
                }
                
                // 4. Почекати перед оновленням playlist
                await Task.Delay(5000, cancellationToken.Token); // Оновлювати кожні 5s
            }
            catch (TaskCanceledException)
            {
                break;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Помилка: {ex.Message}");
                await Task.Delay(2000); // Почекати перед повторною спробою
            }
        }
    }
    
    private async Task<List<string>> FetchLivePlaylistAsync()
    {
        string content = await httpClient.GetStringAsync(playlistUrl);
        var segments = new List<string>();
        var lines = content.Split('\n');
        
        string baseUrl = GetBaseUrl(playlistUrl);
        
        foreach (var line in lines)
        {
            if (line.StartsWith("#") || string.IsNullOrWhiteSpace(line))
                continue;
            
            string segmentUrl = line.Trim();
            if (!segmentUrl.StartsWith("http"))
            {
                segmentUrl = baseUrl + "/" + segmentUrl;
            }
            
            segments.Add(segmentUrl);
        }
        
        return segments;
    }
    
    private async Task PlaySegmentAsync(string segmentUrl)
    {
        byte[] data = await httpClient.GetByteArrayAsync(segmentUrl);
        // Декодування та відтворення
        await Task.Delay(100); // Симуляція
    }
    
    public void Stop()
    {
        cancellationToken?.Cancel();
        Console.WriteLine("Live стрім зупинено");
    }
    
    private string GetBaseUrl(string url)
    {
        var uri = new Uri(url);
        return $"{uri.Scheme}://{uri.Host}{System.IO.Path.GetDirectoryName(uri.AbsolutePath)}";
    }
}
```

---

## CDN та доставка контенту

### Що таке CDN?

**CDN (Content Delivery Network)** — розподілена мережа серверів для швидкої доставки контенту користувачам.

```
Без CDN:
┌─────────┐                      ┌─────────┐
│ User UA │────── 5000 km ──────>│ Server  │
│ (Київ)  │                      │ (USA)   │
└─────────┘                      └─────────┘
           ↑ Повільно, висока затримка

З CDN:
┌─────────┐       ┌─────────┐       ┌─────────┐
│ User UA │──50km─>│ CDN Edge│       │ Origin  │
│ (Київ)  │       │ (Київ)  │───────│ (USA)   │
└─────────┘       └─────────┘       └─────────┘
           ↑ Швидко!    ↑ Кешування
```

### Архітектура HLS з CDN

```
┌──────────────────────────────────────────────────┐
│                Origin Server                     │
│  - Зберігає оригінальні файли                   │
│  - Генерує HLS сегменти                          │
│  - Master та Media playlists                     │
└─────────────────┬────────────────────────────────┘
                  │ Push/Pull
        ┌─────────┴─────────┬─────────────┐
        ↓                   ↓             ↓
┌─────────────┐      ┌─────────────┐  ┌─────────────┐
│ CDN Edge 1  │      │ CDN Edge 2  │  │ CDN Edge 3  │
│ (Європа)    │      │ (Азія)      │  │ (Америка)   │
└──────┬──────┘      └──────┬──────┘  └──────┬──────┘
       │                    │                 │
  ┌────┴───┐           ┌────┴───┐       ┌────┴───┐
  ↓        ↓           ↓        ↓       ↓        ↓
[User] [User]      [User]  [User]   [User]  [User]
```

### Стратегії кешування

#### 1. Cache-Control заголовки

```
HLS файли мають різний термін життя:

Master Playlist (master.m3u8):
Cache-Control: max-age=60
↑ Оновлюється рідко, але може змінюватись

Media Playlist (720p.m3u8):
VOD: Cache-Control: max-age=86400 (24 години)
Live: Cache-Control: max-age=6 (6 секунд)

Сегменти (.ts файли):
Cache-Control: max-age=31536000, immutable
↑ Ніколи не змінюються (1 рік)
```

#### 2. Purge (Очищення кешу)

```
Коли потрібно:
- Оновлення контенту
- Виправлення помилок
- Видалення контенту

Методи:
1. URL Purge: Видалити конкретний файл
2. Wildcard Purge: Видалити всі файли за шаблоном
3. Tag-based Purge: Видалити за тегами
```

### C# приклад: Генерація HLS з CDN URLs

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class HLSCDNGenerator
{
    private readonly string cdnBaseUrl;
    private readonly string originBaseUrl;
    
    public HLSCDNGenerator(string cdnUrl, string originUrl)
    {
        cdnBaseUrl = cdnUrl.TrimEnd('/');
        originBaseUrl = originUrl.TrimEnd('/');
    }
    
    public string GenerateMasterPlaylist(List<QualityVariant> variants)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("#EXTM3U");
        sb.AppendLine("#EXT-X-VERSION:3");
        sb.AppendLine();
        
        foreach (var variant in variants)
        {
            sb.AppendLine($"#EXT-X-STREAM-INF:BANDWIDTH={variant.Bandwidth}," +
                         $"RESOLUTION={variant.Width}x{variant.Height}," +
                         $"CODECS=\"{variant.Codecs}\"");
            
            // CDN URL для media playlist
            sb.AppendLine($"{cdnBaseUrl}/{variant.Name}/index.m3u8");
        }
        
        return sb.ToString();
    }
    
    public string GenerateMediaPlaylist(
        string qualityName, 
        int segmentCount, 
        bool isVOD = true)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("#EXTM3U");
        sb.AppendLine("#EXT-X-VERSION:3");
        sb.AppendLine("#EXT-X-TARGETDURATION:10");
        sb.AppendLine("#EXT-X-MEDIA-SEQUENCE:0");
        
        if (isVOD)
        {
            sb.AppendLine("#EXT-X-PLAYLIST-TYPE:VOD");
        }
        
        sb.AppendLine();
        
        for (int i = 0; i < segmentCount; i++)
        {
            sb.AppendLine("#EXTINF:10.0,");
            // CDN URL для сегменту
            sb.AppendLine($"{cdnBaseUrl}/{qualityName}/segment{i:D4}.ts");
        }
        
        if (isVOD)
        {
            sb.AppendLine();
            sb.AppendLine("#EXT-X-ENDLIST");
        }
        
        return sb.ToString();
    }
    
    public void SetCacheHeaders(Dictionary<string, string> headers, string fileType)
    {
        switch (fileType)
        {
            case "master.m3u8":
                headers["Cache-Control"] = "max-age=60";
                break;
                
            case "media.m3u8":
                headers["Cache-Control"] = "max-age=6";
                break;
                
            case ".ts":
                headers["Cache-Control"] = "max-age=31536000, immutable";
                headers["CDN-Cache-Control"] = "max-age=31536000";
                break;
        }
        
        // CDN-specific headers
        headers["X-CDN-Provider"] = "Cloudflare"; // або Akamai, Fastly тощо
        headers["Access-Control-Allow-Origin"] = "*";
    }
}

public class QualityVariant
{
    public string Name { get; set; }
    public int Bandwidth { get; set; }
    public int Width { get; set; }
    public int Height { get; set; }
    public string Codecs { get; set; }
}

// Використання:
var generator = new HLSCDNGenerator(
    "https://cdn.example.com/video123",
    "https://origin.example.com/video123"
);

var variants = new List<QualityVariant>
{
    new() { Name = "360p", Bandwidth = 500000, Width = 640, Height = 360, 
            Codecs = "avc1.42c01e,mp4a.40.2" },
    new() { Name = "720p", Bandwidth = 2000000, Width = 1280, Height = 720, 
            Codecs = "avc1.4d401f,mp4a.40.2" },
    new() { Name = "1080p", Bandwidth = 5000000, Width = 1920, Height = 1080, 
            Codecs = "avc1.640028,mp4a.40.2" }
};

string masterPlaylist = generator.GenerateMasterPlaylist(variants);
Console.WriteLine(masterPlaylist);
```

---

## Буферизація та відтворення

### Стратегії буферизації

```
Оптимальний розмір буфера:
┌──────────────────────────────────────┐
│ Початковий буфер: 2-3 сегменти      │
│ (20-30 секунд)                       │
│                                      │
│ Робочий буфер: 20-40 секунд         │
│                                      │
│ Максимальний буфер: 60 секунд       │
│ (щоб не витрачати bandwidth)         │
└──────────────────────────────────────┘
```

### C# приклад: Buffer Manager

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

public class BufferManager
{
    private Queue<VideoSegment> buffer = new Queue<VideoSegment>();
    private readonly int minBufferSeconds = 20;
    private readonly int maxBufferSeconds = 60;
    private readonly int segmentDuration = 10;
    
    public int CurrentBufferSeconds => buffer.Sum(s => s.Duration);
    public int CurrentBufferCount => buffer.Count;
    
    public bool NeedsMoreData => CurrentBufferSeconds < minBufferSeconds;
    public bool BufferFull => CurrentBufferSeconds >= maxBufferSeconds;
    
    public void AddSegment(VideoSegment segment)
    {
        if (!BufferFull)
        {
            buffer.Enqueue(segment);
            Console.WriteLine($"Буфер: {CurrentBufferSeconds}s ({CurrentBufferCount} сегментів)");
        }
    }
    
    public VideoSegment GetNextSegment()
    {
        if (buffer.Count > 0)
        {
            var segment = buffer.Dequeue();
            Console.WriteLine($"Відтворення сегменту. Буфер: {CurrentBufferSeconds}s");
            return segment;
        }
        
        return null;
    }
    
    public BufferState GetState()
    {
        int bufferSeconds = CurrentBufferSeconds;
        
        if (bufferSeconds < 5)
            return BufferState.Critical;
        else if (bufferSeconds < 10)
            return BufferState.Low;
        else if (bufferSeconds < 30)
            return BufferState.Good;
        else
            return BufferState.High;
    }
    
    public void Clear()
    {
        buffer.Clear();
        Console.WriteLine("Буфер очищено");
    }
}

public enum BufferState
{
    Critical, // < 5s - ризик зупинки
    Low,      // 5-10s - знизити якість
    Good,     // 10-30s - нормально
    High      // > 30s - можна підвищити якість
}

public class VideoSegment
{
    public int SequenceNumber { get; set; }
    public byte[] Data { get; set; }
    public int Duration { get; set; } = 10; // секунди
    public string Quality { get; set; }
}
```

---

## Шифрування та DRM

### Навіщо потрібно шифрування?

```
Проблеми без захисту:
┌────────────────────────────────────┐
│ ⚠️ Піратство та крадіжка контенту  │
│ ⚠️ Несанкціонований доступ          │
│ ⚠️ Втрата прибутків                 │
│ ⚠️ Порушення ліцензійних угод       │
└────────────────────────────────────┘

Рішення:
✅ Шифрування сегментів (AES-128)
✅ DRM системи (Widevine, FairPlay, PlayReady)
✅ Токени доступу та авторизація
```

### HLS шифрування (AES-128)

**Базове шифрування HLS** використовує AES-128 у режимі CBC.

```
Процес шифрування:
┌──────────────────────────────────────────────────┐
│ 1. Генерація ключа (128-bit/16 bytes)           │
│ 2. Шифрування кожного сегменту з AES-128        │
│ 3. Вказати URI ключа в playlist                 │
│ 4. Клієнт завантажує ключ та дешифрує сегменти  │
└──────────────────────────────────────────────────┘
```

### Приклад зашифрованого плейлісту

```m3u8
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:10

#EXT-X-KEY:METHOD=AES-128,URI="https://example.com/keys/key1.key",IV=0x12345678901234567890123456789012
#EXTINF:10.0,
segment0.ts
#EXTINF:10.0,
segment1.ts
#EXTINF:10.0,
segment2.ts

# Можна змінювати ключ:
#EXT-X-KEY:METHOD=AES-128,URI="https://example.com/keys/key2.key",IV=0x98765432109876543210987654321098
#EXTINF:10.0,
segment3.ts
```

### C# приклад: AES-128 шифрування сегментів

```csharp
using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

public class HLSEncryption
{
    private byte[] encryptionKey;
    private byte[] iv;
    
    public HLSEncryption()
    {
        // Генерувати випадковий ключ (128-bit = 16 bytes)
        encryptionKey = GenerateKey();
        
        // Генерувати випадковий IV (Initialization Vector)
        iv = GenerateIV();
    }
    
    public byte[] GenerateKey()
    {
        byte[] key = new byte[16]; // 128-bit
        using (var rng = RandomNumberGenerator.Create())
        {
            rng.GetBytes(key);
        }
        return key;
    }
    
    public byte[] GenerateIV()
    {
        byte[] iv = new byte[16]; // 128-bit
        using (var rng = RandomNumberGenerator.Create())
        {
            rng.GetBytes(iv);
        }
        return iv;
    }
    
    public byte[] EncryptSegment(byte[] segmentData)
    {
        using (var aes = Aes.Create())
        {
            aes.Key = encryptionKey;
            aes.IV = iv;
            aes.Mode = CipherMode.CBC;
            aes.Padding = PaddingMode.PKCS7;
            
            using (var encryptor = aes.CreateEncryptor())
            using (var ms = new MemoryStream())
            using (var cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))
            {
                cs.Write(segmentData, 0, segmentData.Length);
                cs.FlushFinalBlock();
                return ms.ToArray();
            }
        }
    }
    
    public byte[] DecryptSegment(byte[] encryptedData)
    {
        using (var aes = Aes.Create())
        {
            aes.Key = encryptionKey;
            aes.IV = iv;
            aes.Mode = CipherMode.CBC;
            aes.Padding = PaddingMode.PKCS7;
            
            using (var decryptor = aes.CreateDecryptor())
            using (var ms = new MemoryStream())
            using (var cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Write))
            {
                cs.Write(encryptedData, 0, encryptedData.Length);
                cs.FlushFinalBlock();
                return ms.ToArray();
            }
        }
    }
    
    public void SaveKeyToFile(string filePath)
    {
        File.WriteAllBytes(filePath, encryptionKey);
        Console.WriteLine($"Ключ збережено: {filePath}");
    }
    
    public string GetKeyUri(string baseUrl)
    {
        // URL для завантаження ключа
        return $"{baseUrl}/key.key";
    }
    
    public string GetIVHex()
    {
        // IV в hex форматі для M3U8
        return "0x" + BitConverter.ToString(iv).Replace("-", "").ToLower();
    }
    
    public string GenerateM3U8WithEncryption(string keyUri)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("#EXTM3U");
        sb.AppendLine("#EXT-X-VERSION:3");
        sb.AppendLine("#EXT-X-TARGETDURATION:10");
        sb.AppendLine();
        
        // Тег шифрування
        sb.AppendLine($"#EXT-X-KEY:METHOD=AES-128,URI=\"{keyUri}\",IV={GetIVHex()}");
        sb.AppendLine();
        
        // Сегменти
        for (int i = 0; i < 10; i++)
        {
            sb.AppendLine("#EXTINF:10.0,");
            sb.AppendLine($"segment{i:D4}.ts");
        }
        
        sb.AppendLine();
        sb.AppendLine("#EXT-X-ENDLIST");
        
        return sb.ToString();
    }
}

// Використання:
var encryption = new HLSEncryption();

// Зашифрувати сегмент
byte[] originalData = File.ReadAllBytes("segment0.ts");
byte[] encryptedData = encryption.EncryptSegment(originalData);
File.WriteAllBytes("segment0_encrypted.ts", encryptedData);

// Зберегти ключ
encryption.SaveKeyToFile("key.key");

// Згенерувати M3U8 з шифруванням
string playlist = encryption.GenerateM3U8WithEncryption("https://cdn.example.com/keys/key.key");
Console.WriteLine(playlist);
```

### DRM системи

**DRM (Digital Rights Management)** — більш просунутий захист контенту.

```
Порівняння DRM систем:

┌─────────────┬──────────────┬─────────────────┬──────────────┐
│ DRM         │ Платформа    │ Безпека         │ Складність   │
├─────────────┼──────────────┼─────────────────┼──────────────┤
│ FairPlay    │ Apple        │ Висока          │ Середня      │
│ Widevine    │ Google       │ Дуже висока     │ Висока       │
│ PlayReady   │ Microsoft    │ Висока          │ Висока       │
│ AES-128     │ Усі          │ Базова          │ Низька       │
└─────────────┴──────────────┴─────────────────┴──────────────┘

FairPlay (Apple):
- iOS, iPadOS, tvOS, macOS
- Потребує сертифікат від Apple
- Підтримка offline контенту

Widevine (Google):
- Android, Chrome, ChromeOS
- 3 рівні безпеки (L1, L2, L3)
- Hardware DRM на L1

PlayReady (Microsoft):
- Windows, Xbox, Edge
- Enterprise рішення
```

### Архітектура DRM

```
┌──────────────────────────────────────────────────────┐
│                     Клієнт                           │
│  1. Запит контенту                                   │
│  2. Отримання зашифрованого відео                    │
│  3. Запит ліцензії (з токеном авторизації)          │
│  4. Отримання ключа дешифрування                     │
│  5. Дешифрування та відтворення                      │
└────────────┬─────────────────────────┬───────────────┘
             │                         │
     ┌───────▼──────────┐      ┌───────▼──────────┐
     │   CDN/Origin     │      │ License Server   │
     │ (Зашифровані     │      │ (Widevine/       │
     │  сегменти)       │      │  FairPlay/       │
     └──────────────────┘      │  PlayReady)      │
                               └──────────────────┘
```

### C# приклад: DRM License Server (спрощений)

```csharp
using System;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;

public class DRMLicenseServer
{
    private Dictionary<string, UserLicense> licenses = new Dictionary<string, UserLicense>();
    private byte[] contentKey;
    
    public DRMLicenseServer()
    {
        // Головний ключ контенту
        contentKey = GenerateContentKey();
    }
    
    private byte[] GenerateContentKey()
    {
        byte[] key = new byte[16];
        using (var rng = RandomNumberGenerator.Create())
        {
            rng.GetBytes(key);
        }
        return key;
    }
    
    public LicenseResponse RequestLicense(LicenseRequest request)
    {
        // 1. Перевірка автентифікації
        if (!ValidateAuthToken(request.AuthToken))
        {
            return new LicenseResponse 
            { 
                Success = false, 
                Error = "Invalid auth token" 
            };
        }
        
        // 2. Перевірка прав доступу
        if (!CheckUserAccess(request.UserId, request.ContentId))
        {
            return new LicenseResponse 
            { 
                Success = false, 
                Error = "Access denied" 
            };
        }
        
        // 3. Створення ліцензії
        var license = new UserLicense
        {
            ContentId = request.ContentId,
            UserId = request.UserId,
            ExpiryDate = DateTime.UtcNow.AddDays(7),
            MaxPlayCount = 3,
            AllowOffline = request.AllowOffline
        };
        
        licenses[request.UserId + "_" + request.ContentId] = license;
        
        // 4. Зашифрувати ключ контенту для користувача
        byte[] encryptedKey = EncryptKeyForUser(contentKey, request.DeviceId);
        
        // 5. Повернути ліцензію
        return new LicenseResponse
        {
            Success = true,
            EncryptedKey = Convert.ToBase64String(encryptedKey),
            ExpiryDate = license.ExpiryDate,
            LicenseId = Guid.NewGuid().ToString()
        };
    }
    
    private bool ValidateAuthToken(string token)
    {
        // Тут перевірка JWT або іншого токена
        return !string.IsNullOrEmpty(token);
    }
    
    private bool CheckUserAccess(string userId, string contentId)
    {
        // Перевірка підписки, покупки тощо
        // Запит до бази даних
        return true; // Спрощено
    }
    
    private byte[] EncryptKeyForUser(byte[] key, string deviceId)
    {
        // Зашифрувати ключ для конкретного пристрою
        // Використовуючи публічний ключ пристрою
        using (var aes = Aes.Create())
        {
            aes.Key = Encoding.UTF8.GetBytes(deviceId.PadRight(16).Substring(0, 16));
            aes.IV = new byte[16];
            
            using (var encryptor = aes.CreateEncryptor())
            {
                return encryptor.TransformFinalBlock(key, 0, key.Length);
            }
        }
    }
    
    public bool ValidateLicense(string userId, string contentId)
    {
        string key = userId + "_" + contentId;
        
        if (!licenses.ContainsKey(key))
            return false;
        
        var license = licenses[key];
        
        // Перевірка терміну дії
        if (DateTime.UtcNow > license.ExpiryDate)
        {
            Console.WriteLine("License expired");
            return false;
        }
        
        // Перевірка кількості відтворень
        if (license.PlayCount >= license.MaxPlayCount)
        {
            Console.WriteLine("Max play count reached");
            return false;
        }
        
        license.PlayCount++;
        return true;
    }
}

public class LicenseRequest
{
    public string UserId { get; set; }
    public string ContentId { get; set; }
    public string DeviceId { get; set; }
    public string AuthToken { get; set; }
    public bool AllowOffline { get; set; }
}

public class LicenseResponse
{
    public bool Success { get; set; }
    public string Error { get; set; }
    public string EncryptedKey { get; set; }
    public DateTime ExpiryDate { get; set; }
    public string LicenseId { get; set; }
}

public class UserLicense
{
    public string ContentId { get; set; }
    public string UserId { get; set; }
    public DateTime ExpiryDate { get; set; }
    public int MaxPlayCount { get; set; }
    public int PlayCount { get; set; }
    public bool AllowOffline { get; set; }
}

// Використання:
var licenseServer = new DRMLicenseServer();

var request = new LicenseRequest
{
    UserId = "user123",
    ContentId = "movie456",
    DeviceId = "device789",
    AuthToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    AllowOffline = true
};

var response = licenseServer.RequestLicense(request);

if (response.Success)
{
    Console.WriteLine($"License granted: {response.LicenseId}");
    Console.WriteLine($"Expires: {response.ExpiryDate}");
}
else
{
    Console.WriteLine($"Error: {response.Error}");
}
```

### Найкращі практики безпеки

```
1. Ротація ключів:
   - Змінювати ключі шифрування регулярно
   - Використовувати різні ключі для різного контенту

2. HTTPS обов'язково:
   - Всі запити через HTTPS
   - Захист ключів при передачі

3. Токени авторизації:
   - JWT токени з коротким TTL
   - Refresh tokens для продовження сесії

4. Географічні обмеження:
   - Перевірка IP адреси
   - Geo-blocking для ліцензованого контенту

5. Device fingerprinting:
   - Прив'язка ліцензії до пристрою
   - Обмеження кількості пристроїв

6. Watermarking:
   - Додавання водяних знаків
   - Ідентифікація джерела витоку
```

---

## Оптимізація та найкращі практики

### 1. Оптимізація розміру сегментів

```
Вибір тривалості сегменту:
┌──────────────────────────────────────────────────┐
│ Короткі (2-4s):                                  │
│  ✅ Швидший старт                                │
│  ✅ Краща адаптація до змін bandwidth            │
│  ❌ Більше HTTP запитів                          │
│  ❌ Гірше кешування                              │
│  💡 Ідеально для: Live стрімінг                  │
│                                                  │
│ Середні (6-10s):                                 │
│  ✅ Баланс між якістю та продуктивністю          │
│  ✅ Добре кешується                              │
│  ✅ Менше overhead                               │
│  💡 Ідеально для: VOD, більшість випадків        │
│                                                  │
│ Довгі (10-15s):                                  │
│  ✅ Максимальна ефективність кешування           │
│  ✅ Менше запитів                                │
│  ❌ Повільніша адаптація                         │
│  ❌ Довший початковий буфер                      │
│  💡 Ідеально для: Стабільні мережі               │
└──────────────────────────────────────────────────┘

Рекомендація: 6-10 секунд для більшості випадків
```

### 2. Quality Ladder (Драбина якості)

```csharp
public class QualityLadderOptimizer
{
    public List<QualityLevel> GenerateOptimalLadder(int maxBitrate)
    {
        var ladder = new List<QualityLevel>();
        
        // Базова драбина якості
        ladder.Add(new QualityLevel 
        { 
            Name = "240p",
            Width = 426,
            Height = 240,
            Bitrate = 300_000,      // 300 kbps
            AudioBitrate = 64_000   // 64 kbps
        });
        
        ladder.Add(new QualityLevel 
        { 
            Name = "360p",
            Width = 640,
            Height = 360,
            Bitrate = 500_000,      // 500 kbps
            AudioBitrate = 96_000
        });
        
        ladder.Add(new QualityLevel 
        { 
            Name = "480p",
            Width = 854,
            Height = 480,
            Bitrate = 1_000_000,    // 1 Mbps
            AudioBitrate = 128_000
        });
        
        ladder.Add(new QualityLevel 
        { 
            Name = "720p",
            Width = 1280,
            Height = 720,
            Bitrate = 2_500_000,    // 2.5 Mbps
            AudioBitrate = 128_000
        });
        
        ladder.Add(new QualityLevel 
        { 
            Name = "1080p",
            Width = 1920,
            Height = 1080,
            Bitrate = 5_000_000,    // 5 Mbps
            AudioBitrate = 192_000
        });
        
        if (maxBitrate >= 15_000_000)
        {
            ladder.Add(new QualityLevel 
            { 
                Name = "1440p",
                Width = 2560,
                Height = 1440,
                Bitrate = 10_000_000,   // 10 Mbps
                AudioBitrate = 192_000
            });
            
            ladder.Add(new QualityLevel 
            { 
                Name = "4K",
                Width = 3840,
                Height = 2160,
                Bitrate = 20_000_000,   // 20 Mbps
                AudioBitrate = 256_000
            });
        }
        
        // Фільтрувати за максимальним bitrate
        return ladder.Where(q => q.Bitrate <= maxBitrate).ToList();
    }
    
    public void PrintLadder(List<QualityLevel> ladder)
    {
        Console.WriteLine("Quality Ladder:");
        Console.WriteLine("┌─────────┬──────────────┬─────────────┬──────────────┐");
        Console.WriteLine("│ Quality │ Resolution   │ Video (Mbps)│ Audio (kbps) │");
        Console.WriteLine("├─────────┼──────────────┼─────────────┼──────────────┤");
        
        foreach (var level in ladder)
        {
            Console.WriteLine(
                $"│ {level.Name,-7} │ {level.Width}x{level.Height,-7} │ " +
                $"{level.Bitrate / 1_000_000.0,11:F2} │ {level.AudioBitrate / 1000,12} │");
        }
        
        Console.WriteLine("└─────────┴──────────────┴─────────────┴──────────────┘");
    }
}

public class QualityLevel
{
    public string Name { get; set; }
    public int Width { get; set; }
    public int Height { get; set; }
    public int Bitrate { get; set; }
    public int AudioBitrate { get; set; }
}

// Використання:
var optimizer = new QualityLadderOptimizer();
var ladder = optimizer.GenerateOptimalLadder(20_000_000);
optimizer.PrintLadder(ladder);
```

### 3. Preloading та Prefetching

```csharp
public class SmartPreloader
{
    private readonly HttpClient httpClient = new HttpClient();
    private Dictionary<string, byte[]> cache = new Dictionary<string, byte[]>();
    
    public async Task PreloadNextSegmentsAsync(
        List<string> segmentUrls, 
        int currentIndex, 
        int preloadCount = 3)
    {
        var tasks = new List<Task>();
        
        // Завантажити наступні N сегментів
        for (int i = 1; i <= preloadCount; i++)
        {
            int nextIndex = currentIndex + i;
            
            if (nextIndex < segmentUrls.Count)
            {
                string url = segmentUrls[nextIndex];
                
                // Якщо ще не в кеші
                if (!cache.ContainsKey(url))
                {
                    tasks.Add(PreloadSegmentAsync(url));
                }
            }
        }
        
        await Task.WhenAll(tasks);
    }
    
    private async Task PreloadSegmentAsync(string url)
    {
        try
        {
            byte[] data = await httpClient.GetByteArrayAsync(url);
            cache[url] = data;
            Console.WriteLine($"Preloaded: {url}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Preload failed: {ex.Message}");
        }
    }
    
    public byte[] GetSegmentFromCache(string url)
    {
        if (cache.ContainsKey(url))
        {
            Console.WriteLine($"Cache HIT: {url}");
            return cache[url];
        }
        
        Console.WriteLine($"Cache MISS: {url}");
        return null;
    }
    
    public void ClearOldSegments(List<string> segmentUrls, int currentIndex)
    {
        // Видалити сегменти, які вже відтворили
        var toRemove = cache.Keys
            .Where(url => segmentUrls.IndexOf(url) < currentIndex - 5)
            .ToList();
        
        foreach (var url in toRemove)
        {
            cache.Remove(url);
            Console.WriteLine($"Removed from cache: {url}");
        }
    }
}
```

### 4. Bandwidth Measurement

```csharp
public class BandwidthMonitor
{
    private List<BandwidthSample> samples = new List<BandwidthSample>();
    private const int MaxSamples = 10;
    
    public void RecordDownload(long bytes, TimeSpan duration)
    {
        double bitsPerSecond = (bytes * 8) / duration.TotalSeconds;
        double mbps = bitsPerSecond / 1_000_000;
        
        samples.Add(new BandwidthSample
        {
            Timestamp = DateTime.UtcNow,
            Mbps = mbps
        });
        
        // Зберігати тільки останні N вимірів
        if (samples.Count > MaxSamples)
        {
            samples.RemoveAt(0);
        }
        
        Console.WriteLine($"Download speed: {mbps:F2} Mbps");
    }
    
    public double GetAverageMbps()
    {
        if (samples.Count == 0)
            return 0;
        
        return samples.Average(s => s.Mbps);
    }
    
    public double GetWeightedAverageMbps()
    {
        if (samples.Count == 0)
            return 0;
        
        // Останні виміри мають більшу вагу
        double totalWeight = 0;
        double weightedSum = 0;
        
        for (int i = 0; i < samples.Count; i++)
        {
            double weight = i + 1; // Лінійна вага
            weightedSum += samples[i].Mbps * weight;
            totalWeight += weight;
        }
        
        return weightedSum / totalWeight;
    }
    
    public double GetExponentialMovingAverage(double alpha = 0.3)
    {
        if (samples.Count == 0)
            return 0;
        
        double ema = samples[0].Mbps;
        
        for (int i = 1; i < samples.Count; i++)
        {
            ema = alpha * samples[i].Mbps + (1 - alpha) * ema;
        }
        
        return ema;
    }
    
    public string GetBandwidthCategory()
    {
        double mbps = GetExponentialMovingAverage();
        
        return mbps switch
        {
            >= 25 => "Excellent (>25 Mbps)",
            >= 10 => "Good (10-25 Mbps)",
            >= 5 => "Average (5-10 Mbps)",
            >= 2 => "Poor (2-5 Mbps)",
            _ => "Very Poor (<2 Mbps)"
        };
    }
}

public class BandwidthSample
{
    public DateTime Timestamp { get; set; }
    public double Mbps { get; set; }
}
```

---

