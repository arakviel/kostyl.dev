## Вступ до  Angular {#slide-1}

+ typescript

Викладач: Верещагін О.О.

## Вступ {#slide-2}

Angular   представляє фреймворк від компанії  Google  для  створення клієнтських додатків . Насамперед він націлений на розробку  SPA- рішень ( Single Page Application ),  тобто  односторінкових  додатків. У цьому плані  Angular  є спадкоємцем іншого фреймворку  AngularJS .  Водночас  Angular  це не нова версія  AngularJS,  а  принципово новий фреймворк .

Angular  надає таку функціональність, як  двостороннє зв\'язування , що дає змогу динамічно змінювати дані в одному місці інтерфейсу під час зміни даних  моделі  в іншому,  шаблони ,  маршрутизація  тощо.

Однією з ключових особливостей  Angular  є те, що  він використовує як мову програмування  TypeScript .

## Вступ {#slide-3}

Але ми не обмежені мовою  TypeScript.  За бажання можемо писати додатки на  Angular  за допомогою таких мов як  Dart   або  JavaScript .  Однак  TypeScript  все таки є основною мовою для  Angular .

Остання версія  Angular - Angular 17  вийшла в листопаді 2023 року. Офіційний репозиторій фреймворку на  гітхабі :  https://github.com/angular/angular   .  Там ви можете знайти самі вихідні файли, а також деяку додаткову інформацію.

https://angular.dev/  

## Вступ до  TypeScript {#slide-4}

TypeScript  являє собою мову програмування на основі  JavaScript.

Розвиток  TypeScript  почався наприкінці 2012 року. Хоча вона зародилася в компанії  Microsoft,  і її фактичним творцем є програміст  Андерс   Гейлсберг , так само відомий як творець таких мов, як  Delphi ,  C# ,  але цей проект одразу  став розвиватися як  OpenSource .  І вже з самого початку нова мова почала швидко поширюватися через свою гнучкість і продуктивність.  Чимало проектів, які були написані на  JavaScript,  стали переноситися на  TypeScript .  Популярність і актуальність ідей нової мови призвела до того, що низка з цих ідей згодом стали частиною нового стандарту  JavaScript .  Переваги  TypeScript  були підхоплені творцями низки поширених і широковживаних фреймворків. До речі, одні з найпопулярніших фреймворків для  Web -  Angular 2+   і  Vue3  -  повністю написані на  TypeScript .

Однак, здавалося б, навіщо потрібна ще одна мова програмування для клієнтської сторони в середовищі  Web,  якщо з усією тією ж самою роботою прекрасно справляється і традиційний  JavaScript,  який використовується практично на кожному сайті, яким володіє безліч розробників і підтримка якого в співтоваристві програмістів досить висока.  Але  TypeScript  це не просто новий  JavaScript .

## Вступ до  TypeScript {#slide-5}

По-перше , слід зазначити, що  TypeScript -  це суворо типізована та  компілювальна  мова, чим, можливо, буде ближчою до програмістів  Java, C#  та інших суворо типізованих мов . Хоча на виході компілятор створює все той же  JavaScript,  який потім виконується браузером. Однак сувора типізація зменшує кількість потенційних помилок, які могли б виникнути під час розробки на  JavaScript.

По-друге ,  TypeScript  реалізує багато концепцій, які притаманні об\'єктно-орієнтованим мовам, як, наприклад,  успадкування ,  поліморфізм ,  інкапсуляція  та  модифікатори доступу  тощо.

По-третє , потенціал  TypeScript  дає змогу швидше і простіше писати великі складні комплексні програми, відповідно їх легше підтримувати, розвивати, масштабувати і тестувати, ніж на стандартному  JavaScript.  ( спорно )

## Вступ до  TypeScript {#slide-6}

По-четверте ,  TypeScript  розвивається як  opensource- проект і, як і багато проєктів,  хоститься  на  гітхабі . Адреса репозиторію -  https://github.com/Microsoft/TypeScript   .  Крім того, він є  кросплатформеним , а це значить, що для розробки ми можемо використовувати як  Windows,  так і  MasOS   або  Linux.

Водночас  TypeScript  є типізованою  надмножиною   JavaScript ,  а це означає, що будь-яка програма на  JS  є програмою на  TypeScript.  У  TS  можна використовувати всі ті конструкції, які застосовуються в  JS -  ті самі оператори, умовні, циклічні конструкції. Ба більше, код на  TS  компілюється в  javascript .  Зрештою,  TS -  це всього лише інструмент, який покликаний полегшити розробку додатків .

## Вступ до  TypeScript {#slide-7}

Код  JS,  що генерується компілятором  TypeScript,  підтримується переважною більшістю браузерів . Хоча в процесі розробки ми можемо самі задати цільовий стандарт  ECMAScript.

Як використовувати  TypeScript?  Оскільки ця мова є  OpenSource ,  то всі її інструменти доступні для всіх охочих. Для роботи з  TypeScript  ми можемо використовувати як  Windows,  так і  Linux  і  MacOS.

Сам компілятор  TS  можна встановити за допомогою команди менеджера пакетів  npm ,  який використовується в  Node.js :

![](ppt/media/image1.png "Рисунок 4")

## Встановлення  та  компіляція  з командного рядка {#slide-8}

Для  перевірки   версії   необхідно  ввести команду

![](ppt/media/image2.png "Рисунок 4")

![](ppt/media/image3.png "Рисунок 6")

![](ppt/media/image4.png "Рисунок 8")

![](ppt/media/image5.png "Рисунок 10")

![](ppt/media/image6.png "Рисунок 12")

## \_ {#slide-9}

\_

![](ppt/media/image7.png "Рисунок 4")

![](ppt/media/image8.png "Рисунок 6")

![](ppt/media/image9.png "Рисунок 8")

## Налаштування компіляції {#slide-10}

Під час компіляції файлів  TypeScript  із командного рядка компілятор дає змогу встановити низку конфігураційних налаштувань.   https://www.typescriptlang.org/docs/handbook/compiler-options.html  

Автоматична перекомпіляція

Опція  \-- watch ,  а також її скорочена версія  - w   автоматично перекомпілює файли  typescript ,  якщо в них було  внесено  будь-які зміни. Завдяки чому не треба при кожній найменшій зміні вручну вводити команду в консоль для перекомпіляції.

Версія  ECMAScript

За допомогою параметра  \-- target   або його скороченої версії  - t   можна задати версію стандарту  JavaScript,  у яку буде компілюватися код  TypeScript.  Цей параметр може набувати таких значень: \" ES3 \" ( за замовчуванням), \" ES5 \", \" ES6 \" / \" ES2015 \", \" ES7 \" / \" ES2016 \", \" ES2017 \", \" ES2018 \", \" ES2019 \", \" ES2020 \"  або \" ESNext \":

![](ppt/media/image10.png "Рисунок 4")

![](ppt/media/image11.png "Рисунок 6")

## Налаштування компіляції {#slide-11}

Видалення коментарів

За замовчуванням у файли  javascript   переходять усі коментарі, якими забезпечений код у файлах  TS.  Видалення коментарів під час компіляції здійснюється за допомогою параметра  \-- removeComments :

Встановлення  каталогу

За  допомогою  параметра  \-- outDir   можна   задати  папку для  зберігання   скомпільованих   файлів   js :

Об\'єднання   файлів

Якщо  у нас  кілька   файлів  TS, то за  допомогою  параметра  \-- outFile   їх   можна   об\'єднати  в один файл  js :

![](ppt/media/image12.png "Рисунок 4")

![](ppt/media/image13.png "Рисунок 6")

![](ppt/media/image14.png "Рисунок 8")

## Налаштування компіляції {#slide-12}

Тип модуля

За допомогою параметра \-- module,  або - m  можна вказати тип модуля, який буде використовуватися для компіляції. Ця опція може набувати таких значень: \" None \", \" CommonJS \" ( значення за замовчуванням, якщо задано версію  ECMAScript \"ES3\"  або \" ES5\"), \" AMD \", \" System \", \" UMD \", \" ES2015 \", \" ES2020 \"  і \" ESNext \".

Кілька   параметрів

Якщо  треба  задати   кілька   параметрів , то вони та  їхні   значення   послідовно   перераховуються  через  пробіл .

![](ppt/media/image15.png "Рисунок 4")

![](ppt/media/image16.png "Рисунок 6")

![](ppt/media/image17.png "Рисунок 8")

## Змінні та константи {#slide-13}

Для компілятора  TS  можна за допомогою параметра  \-- noEmitOnError   можна вказати, що не треба генерувати файл  javascript ,  якщо під час компіляції виникли помилки. Цей параметр можна вказати безпосередньо під час виклику компілятора в консолі:

![](ppt/media/image18.png "Рисунок 4")

![](ppt/media/image19.png "Рисунок 6")

## \_ {#slide-14}

\_

![](ppt/media/image20.png "Рисунок 4")

![](ppt/media/image21.png "Рисунок 6")

![](ppt/media/image22.png "Рисунок 8")

![](ppt/media/image23.png "Рисунок 10")

## Файл конфігурації  tsconfig.json {#slide-15}

За допомогою файлу  tsconfig.json   можна налаштувати проєкт  TypeScript.  Зокрема, цей файл виконує такі завдання:

встановлює кореневий каталог проєкту  TypeScript

виконує  налаштування параметрів компіляції

встановлює файли проєкту

Для його використання достатньо вручну додати новий файл з іменем  tsconfig.json   у корінь проєкту.

![](ppt/media/image24.png "Рисунок 4")

## Структура файла {#slide-16}

tsconfig.json   являє собою стандартний файл у форматі  json ,  який містить низку секцій. Так, секція \" compilerOptions \"  налаштовує параметри компіляції . Тут можна вказати необхідні параметри та їхні значення. Наприклад:

![](ppt/media/image25.png "Рисунок 4")

## Структура файла {#slide-17}

Параметр \" target \"  вказує, який стандарт  JavaScript  застосовуватиметься під час  компіляції.Параметр  \" removeComments \"  видаляє коментарі. 

Параметр \" outDir \"  задає каталог для скомпільованих файлів. \" sourceMap \"  вказує, що треба згенерувати карту для зіставлення вихідних і скомпільованих файлів. І параметр \" outFile \"  задає назву вихідного файлу.

За потреби  можна   вмикати   інші   опції   компіляції .

За  допомогою   секції   files   можна   встановити   набір   файлів ,  що   включаються  в проект :

![](ppt/media/image26.png "Рисунок 4")

## Структура файла {#slide-18}

Якщо секція \" files \"  не вказана у файлі  tsconfig.json ,  то компілятор за замовчуванням включає всі файли  TypeScript ( файли з розширенням  \*. ts   і  \*. tsx ),  що містяться в каталозі та підкаталогах проєкту. Якщо ж вказано секцію \" files \",  то використовуються тільки файли з цієї секції.

Параметр  exclude ,  навпаки,  дає змогу виключити під час компіляції певні файли :

Під час компіляції компілятор не враховуватиме файли  TypeScript,  які знаходяться в каталогах із секції  exclude .  Водночас слід враховувати, що якщо у файлі одночасно буде задано обидві секції  files   і  exclude ,  то секцію  exclude  ігноруватимуть.

![](ppt/media/image27.png "Рисунок 4")

## Структура файла {#slide-19}

Усі файли, на які є посилання у файлах із секції \" files \",  також компілюються.

Параметр  compileOnSave   при значенні  true   вказує використовуваній  IDE  згенерувати всі файли  js   під час кожного збереження файлів  TypeScript :

![](ppt/media/image28.png "Рисунок 4")

## Використання файлу  tsconfig.json {#slide-20}

Файл  tsconfig.json   використовується під час компіляції в тому разі, якщо компілятору не передаються назви файлів, які треба скомпілювати. У цьому разі компілятор  TypeScript  переглядає поточний каталог, шукає в ньому файл  tsconfig.json   і потім під час компіляції використовує ті параметри, які визначені в цьому файлі.

Якщо ж компілятору передаються назви файлів, наприклад,  tsc   app.ts ,  то файл  tsconfig.json   ігнорується.

## Типи даних {#slide-21}

TypeScript  є строго типізованою мовою, і кожна змінна та константа в ній має певний тип . Водночас на відміну від  javascript   ми не можемо динамічно змінити раніше зазначений тип змінної.

У  TypeScript  є такі базові типи:

boolean :  логічне значення  true  або  false

number :  числове значення

string :  рядки

Array :  масиви

кортежі

Enum :  перерахування

Any :  довільний тип

Symbol

null   і  undefined :  відповідають значенням  null   і  undefined   у  javascript

Never :  також представляє відсутність значення і використовується як тип функцій, що повертається, які генерують або повертають помилку

Більшість із цих типів співвідносяться з примітивними типами з  JavaScript.

## Типи даних {#slide-22}

Для  встановлення  типу  застосовується  знак  двокрапки ,  після   якого   вказується   назва  типу .  Приклади   створення   змінних :

То в  процесі   компіляції   компілятор   TypeScript   видасть   помилку .

![](ppt/media/image29.png "Рисунок 4")

![](ppt/media/image30.png "Рисунок 6")

## Типи даних {#slide-23}

\_

![](ppt/media/image31.png "Рисунок 4")

![](ppt/media/image32.png "Рисунок 6")

![](ppt/media/image33.png "Рисунок 8")

![](ppt/media/image34.png "Рисунок 10")

## \_ {#slide-24}

Виведення типу

Але  можна  в  принципі  і не  вказувати  тип  змінної . 

У цьому разі  TypeScript  автоматично виведе тип із  присвоюваного  цій змінній значення . Так, на першому рядку компілятор  TS  побачить, що змінній  hello  присвоюється рядок, тому для неї буде використовуватися тип  string .  Однак у другому рядку знову ж таки компілятор  видасть  помилку , оскільки  hello   змінній уже визначено тип  string .  А нове значення передбачає тип  number .

![](ppt/media/image35.png "Рисунок 4")

![](ppt/media/image36.png "Рисунок 6")

![](ppt/media/image37.png "Рисунок 8")

## Тип  any {#slide-25}

Any   описує   дані , тип  яких   може  бути  невідомим  на момент  написання   програми .

Оскільки  тут  застосовується  тип  any , то  цей  код  скомпілюється  без  помилок ,  незважаючи  на  зміну  рядкового  значення  на  числове . І  також  ми  можемо   оголошувати   масиви   цього  типу:

![](ppt/media/image38.png "Рисунок 4")

![](ppt/media/image39.png "Рисунок 6")

![](ppt/media/image40.png "Рисунок 8")

## Перевірка типу {#slide-26}

За допомогою оператора  typeof   ми можемо перевірити тип змінної. Це може бути необхідно, коли ми хочемо виконати деякі операції зі змінною, але нам невідомий її точний тип (наприклад, змінна представляє тип  any ).  Ця функціональність ще називається  type guards   або захист типу:

![](ppt/media/image41.png "Рисунок 4")

![](ppt/media/image42.png "Рисунок 6")

## \_ {#slide-27}

Оператор  typeof   може повертати такі значення:

\"string\"

\"number\"

\" bigint \"

\" boolean \"

\"symbol\"

\"undefined\"

\"object\"

\"function\"

## Функції {#slide-28}

\_

![](ppt/media/image43.png "Рисунок 4")

![](ppt/media/image44.png "Рисунок 6")

![](ppt/media/image45.png "Рисунок 8")

## Результат функції {#slide-29}

У  принципі  ми  можемо  і не  вказувати  тип,  тоді   він  буде  виводитися  неявно на  основі   значення ,  що   повертається :

![](ppt/media/image46.png "Рисунок 4")

![](ppt/media/image47.png "Рисунок 6")

![](ppt/media/image48.png "Рисунок 8")

## Необов\'язкові параметри {#slide-30}

У  typescript   під  час  виклику  у  функцію   має   передаватися   рівно   стільки   значень ,  скільки  в  ній   визначено   параметрів :

![](ppt/media/image49.png "Рисунок 4")

![](ppt/media/image50.png "Рисунок 6")

## Функції {#slide-31}

\_

![](ppt/media/image51.png "Рисунок 4")

![](ppt/media/image52.png "Рисунок 6")

## Тип функції {#slide-32}

Кожна функція має тип, як і звичайні змінні.  Тип функції фактично являє собою комбінацію типів параметрів і типу значення, що повертається . У загальному вигляді визначення типу функції має такий вигляд:

Використовуючи  тип  функції ,  ми  можемо   визначити   змінні ,  константи  та  параметри   цього  типу . 

![](ppt/media/image53.png "Рисунок 4")

![](ppt/media/image54.png "Рисунок 6")

![](ppt/media/image55.png "Рисунок 8")

## \_ {#slide-33}

\_

![](ppt/media/image56.png "Рисунок 4")

![](ppt/media/image57.png "Рисунок 6")

## Функції  як  параметри   інших   функцій {#slide-34}

\_

![](ppt/media/image58.png "Рисунок 4")

## \_ {#slide-35}

\_

![](ppt/media/image59.png "Рисунок 4")

## Стрілочні функції {#slide-36}

\_

![](ppt/media/image60.png "Рисунок 4")

## Об\'єднання  union {#slide-37}

Об\'єднання або  union   не є власне типом даних, але вони  дають змогу комбінувати або об\'єднати інші типи . Так, за допомогою об\'єднань можна визначити змінну, яка може зберігати значення двох або більше типів:

![](ppt/media/image61.png "Рисунок 4")

![](ppt/media/image62.png "Рисунок 6")

## Об\'єднання  union {#slide-38}

\_

![](ppt/media/image63.png "Рисунок 4")

## Null  і  undefined {#slide-39}

Як і в  JavaScript,  у  TypeScript  є спеціальні типи  undefined   і  null ,  які приймають відповідні значення  undefined   і  null .

Використання  undefined   і  null   залежить від параметра компіляції  strictNullChecks .  За замовчуванням він має значення  false   і не використовується, а це означає, що за замовчуванням ми можемо застосовувати ці типи, як і в  javascript :

Але фактично ми можемо присвоювати значення  undefined   і  null   змінним інших типів, наприклад,  number :

![](ppt/media/image64.png "Рисунок 4")

![](ppt/media/image65.png "Рисунок 6")

## Null  і  undefined {#slide-40}

У цьому плані  null   і  undefined   виступають як підтипи інших типів і корисні переважно в якихось операціях, де невідомий результат - чи то це буде число або рядок, чи то це буде  null .  У цьому випадку, щоб уникнути можливої помилки, ми можемо перевірити значення на  undefined   або  null ,  власне як і в  javascript .

Водночас відсутність перевірки для цих типів з боку компілятора є потенційним джерелом багів, тому нерідко під час компіляції застосовується параметр  strictNullChecks .  Або під час встановлення прапора під час компіляції в консолі:

![](ppt/media/image66.png "Рисунок 4")

![](ppt/media/image67.png "Рисунок 6")

## Null  і  undefined {#slide-41}

У цьому разі при спробі присвоїти значення типу  undefined   або  null   змінній іншого типу компілятор під час компіляції викине помилку. Наприклад, під час компіляції попереднього прикладу коду:

![](ppt/media/image65.png "Рисунок 4")

![](ppt/media/image68.png "Рисунок 6")

## Null  і  undefined {#slide-42}

Також ми отримаємо помилку, якщо значення  undefined   присвоїмо змінній типу  null   або значення  null   змінній типу  undefined .

![](ppt/media/image69.png "Рисунок 4")

## Оператор ! {#slide-43}

Оператор !  ( non-null assertion operator)  дає змогу вказати, що об\'єкт не представляє значення  null   і  undefined .  Так, візьмемо такий приклад:

Вбудована функція  document.getElementById ()   повертає елемент веб-сторінки за  id ,  який представляє тип  HTMLElement\|null .  Тобто він може мати значення  null ,  якщо  html- елемента з подібним  id   немає на веб-сторінці. Отримавши елемент, ми намагаємося за допомогою його властивості  innerText   змінити його текстовий вміст.

Начебто все нормально, проте за замовчуванням з увімкненою опцією  strictNullChecks   під час компіляції ми отримаємо помилку:

![](ppt/media/image70.png "Рисунок 4")

![](ppt/media/image71.png "Рисунок 6")

## \_ {#slide-44}

Щоб   уникнути   помилки ,  використовуємо   оператор !

Оператор !  ставиться  після   об\'єкта ,  який  теоретично  може   приймати   значення   null  перед  зверненням  до  його   властивостей  і  методів :

Водночас  треба  враховувати ,  що   цей  оператор не  змінює   значення   об\'єкта .  Наприклад ,  якщо   об\'єкт   має   значення   null   або   undefined , то  цей  оператор не  допоможе .  Програма   скомпілюється , але  під  час  виконання  скрипта  програма  все одно  згенерує   помилку :

![](ppt/media/image72.png "Рисунок 4")

![](ppt/media/image73.png "Рисунок 6")

## \_ {#slide-45}

Тому  рекомендується   застосовувати   цей  оператор, коли ми  знаємо ,  що   об\'єкт  не  дорівнює   null   або   undefined .

![](ppt/media/image74.png "Рисунок 4")

## Оператор  опціональної  послідовності {#slide-46}

Оператор  опціональної  послідовності ?. дає змогу отримати значення властивості, що перебуває на будь-якому рівні вкладеності в ланцюжку пов\'язаних між собою об\'єктів,  без необхідності перевіряти кожну з проміжних властивостей у ній на існування . ?. працює подібно до оператора ., за винятком того, що  не викидає виняток, якщо об\'єкт, до властивості або методу якого йде звернення, дорівнює  null  або  undefined .  У цих випадках він повертає  undefined .

![](ppt/media/image75.png "Рисунок 4")

## Об\'єкти {#slide-47}

Крім простих типів даних, як і в  javascript ,  можна створювати складні комплексні об\'єкти , які складаються з інших об\'єктів і примітивних даних. Наприклад:

То на другому рядку ми отримаємо помилку, оскільки компілятор після першого рядка припускає, що об\'єкт  person   матиме дві властивості  name   і  age ,  які мають тип  string   і  number   відповідно. Тобто в даному випадку змінна  person   представляє тип  {  name: string; age: number } .

![](ppt/media/image76.png "Рисунок 4")

![](ppt/media/image77.png "Рисунок 6")

## Об\'єкти {#slide-48}

\_

![](ppt/media/image78.png "Рисунок 4")

![](ppt/media/image79.png "Рисунок 6")

## Необов\'язкові властивості {#slide-49}

TypeScript   дає   змогу   зробити   властивості   необов\'язковими . Для  цього   після   назви   властивості   вказується   знак  питання  ?

У  цьому   випадку   властивість   age  є  необов\'язковою , тому ми  можемо  не  надавати  для  неї   значення :

При  зверненні  до  невстановленої   властивості  ми  отримаємо   undefined :

![](ppt/media/image80.png "Рисунок 4")

![](ppt/media/image81.png "Рисунок 6")

## Необов\'язкові властивості {#slide-50}

Тому  під  час  операцій  з такою  властивістю  ми  можемо   перевіряти   її  на  значення   undefined :

![](ppt/media/image82.png "Рисунок 4")

![](ppt/media/image83.png "Рисунок 6")

## Об\'єкти у функціях {#slide-51}

\_

![](ppt/media/image84.png "Рисунок 4")

![](ppt/media/image85.png "Рисунок 6")

## Об\'єкти у функціях {#slide-52}

\_

![](ppt/media/image86.png "Рисунок 4")

## Декомпозиція об\'єктів-параметрів {#slide-53}

\_

![](ppt/media/image87.png "Рисунок 5")

![](ppt/media/image88.png "Рисунок 7")

## \_ {#slide-54}

\_

![](ppt/media/image89.png "Рисунок 4")

## Псевдоніми типів {#slide-55}

TypeScript   дає   змогу   визначати   псевдоніми   типів   за  допомогою   ключового  слова  type :

![](ppt/media/image90.png "Рисунок 8")

![](ppt/media/image91.png "Рисунок 10")

## Псевдоніми типів {#slide-56}

Особливо  корисними   можуть  бути  псевдоніми , коли ми  маємо  справу  зі   складними   об\'єктами :

![](ppt/media/image92.png "Рисунок 4")

## Розширення псевдонімів {#slide-57}

Одні   псевдоніми   можуть   запозичувати   або   розширювати  код  інших . Для  цього   застосовується   операція   & .  Наприклад :

![](ppt/media/image93.png "Рисунок 6")

![](ppt/media/image94.png "Рисунок 8")

## Type  assertion .  Перетворення  до типу {#slide-58}

Type assertion  представляє модель перетворення значення змінної до певного типу. Зазвичай у деяких ситуаціях одна змінна може представляти якийсь широкий тип, наприклад,  any   або  union ,  які за фактом допускають значення різних типів. Однак при цьому нам треба використовувати змінну як значення строго визначеного типу. І в цьому випадку ми можемо привести до цього типу.

Як приклад візьмемо найпростіше завдання - на веб-сторінці є  html- елемент з  id = header ,  і ми хочемо отримати цей елемент, наприклад, щоб змінити його текст. Для отримання елемента за  id   ми могли б використовувати вбудовану  js - функцію  document.getElementById () :

![](ppt/media/image95.png "Рисунок 4")

## Type  assertion .  Перетворення  до типу {#slide-59}

Але в  TypeScript  ця функція повертає об\'єднання  HTMLElement\|null .  Тобто значення, що повертається, може представляти  null ,  якщо відповідний  html- елемент відсутній на веб-сторінці. Унаслідок цього звернення до властивості  header . innerText  -  до властивості об\'єкта, який може бути  null,  містить потенційну помилку. Тому компілятор під час компіляції згенерує помилку.

Однак ситуація може бути така, що ми точно знаємо, що у нас на сторінці є такий елемент. Є різні способи розв\'язання цієї проблеми, щоб вказати компілятору, що все нормально. І одним із них є приведення типів за допомогою  type assertion .

Є дві форми приведення. Перша форма полягає у використанні  кутових дужок :

![](ppt/media/image96.png "Рисунок 4")

## Type  assertion .  Перетворення  до типу {#slide-60}

Друга форма  полягає  в  застосуванні  оператора  as ,  після   якого   вказується  тип, до  якого  треба  виконати   перетворення :

Однак   такі   перетворення   матимуть  силу,  якщо  ми точно  знаємо ,  що   значення   може  бути  перетворено  до  цільового  типу.  Наприклад , на  сторінці  є  елемент  з  id = header , тому ми  можемо   перетворити   значення  до типу  HTMLElement .  Однак   якщо  такого  елемента   немає , то  під  час  виконання  ми  знову  ж таки  отримаємо   помилку .

![](ppt/media/image97.png "Рисунок 4")

## Масиви {#slide-61}

Масиви   визначаються  за  допомогою   виразу   \[\]  і  також  є строго  типізованими .  Тобто   якщо   спочатку   масив   містить  рядки, то в  майбутньому   він   зможе   працювати   тільки  з рядками .

Як і в  JavaScript,  за допомогою індексів можна звертатися до елементів масиву.

Альтернативний спосіб визначення масивів представляє застосування типу  Array\<\> ,  де у фігурних дужках вказується тип елементів масиву:

![](ppt/media/image98.png "Рисунок 4")

![](ppt/media/image99.png "Рисунок 6")

## Масиви {#slide-62}

Але фактично такі форми масивів, як  number\[\]  або  string\[\]  є скороченням відповідно типів  Array\<number\>  або  Array\<string\>

## ReadonlyArray {#slide-63}

Масив  ReadonlyArray   підтримує більшість тих самих операцій, що і звичайні масиви, за тим винятком операцій, які змінюють масив і його елементи.  Так, ми не можемо змінювати окремі значення :

Також  ми не  можемо   додавати   нові   або   видаляти   вже   наявні   елементи :

![](ppt/media/image100.png "Рисунок 4")

![](ppt/media/image101.png "Рисунок 6")

![](ppt/media/image102.png "Рисунок 8")

## ReadonlyArray {#slide-64}

\_

![](ppt/media/image103.png "Рисунок 4")

## Декомпозиція масивів {#slide-65}

Вони такі самі

## Кортежи {#slide-66}

Кортежі ( Tuples)   також, як і масиви, являють собою набір елементів, для яких уже заздалегідь відомий тип. На відміну від масивів кортежі можуть зберігати значення різних типів. Для визначення  кортежа  застосовується синтаксис масиву:

У цьому випадку кортеж  user   представляє тип  \[ string, number\] ,  тобто такий кортеж, який складається з двох елементів, при чому перший елемент представляє тип  string ,  а другий елемент - тип  number .  Для присвоєння значення застосовується масив:

![](ppt/media/image104.png "Рисунок 4")

![](ppt/media/image105.png "Рисунок 6")

![](ppt/media/image106.png "Рисунок 8")

## Кортежи {#slide-67}

\_

![](ppt/media/image107.png "Рисунок 4")

![](ppt/media/image108.png "Рисунок 6")

## \_ {#slide-68}

\_

![](ppt/media/image109.png "Рисунок 4")

![](ppt/media/image110.png "Рисунок 6")

## Необов\'язкові елементи кортежів {#slide-69}

Кортежі   можуть   мати   необов\'язкові   елементи , для  яких   можна  не  надавати   значення .  Щоб   вказати ,  що   елемент  є  необов\'язковим ,  після  типу  елемента  ставиться знак  питання   ?

У цьому випадку останній елемент, який представляє тип  boolean ,  необов\'язковий. Причому необов\'язкові елементи повинні йти в самому кінці - після обов\'язкових елементів.

Кортеж з необов\'язковими елементами як параметр функції:

![](ppt/media/image111.png "Рисунок 4")

## \_ {#slide-70}

\_

![](ppt/media/image112.png "Рисунок 4")

## \_ {#slide-71}

\_

![](ppt/media/image113.png "Рисунок 4")

![](ppt/media/image114.png "Рисунок 6")

## \_ {#slide-72}

\_

![](ppt/media/image115.png "Рисунок 4")

![](ppt/media/image116.png "Рисунок 6")

## \_ {#slide-73}

\_

![](ppt/media/image117.png "Рисунок 4")

## \_ {#slide-74}

\_

![](ppt/media/image118.png "Рисунок 4")

## Перерахування  enum {#slide-75}

Тип  enum   або   перерахування   дозволяє   визначити   набір   іменованих  констант,  які   описують   певні   стани .

![](ppt/media/image119.png "Рисунок 4")

## Числові перерахування {#slide-76}

За  замовчуванням   константи   перерахування , як у  прикладі   вище ,  представляють   числові   значення .  Тобто   це  так  зване   числове   перерахування , в  якому   кожній   константі   зіставляється   числове   значення . Так,  створене   вище  в  прикладі   перерахування :

![](ppt/media/image120.png "Рисунок 6")

![](ppt/media/image121.png "Рисунок 8")

## Рядкові перерахування {#slide-77}

\_

![](ppt/media/image122.png "Рисунок 4")

## Змішані гетерогенні перерахування {#slide-78}

\_

![](ppt/media/image123.png "Рисунок 4")

## \_ {#slide-79}

\_

![](ppt/media/image124.png "Рисунок 4")

## ООП {#slide-80}

TypeScript  реалізує об\'єктно-орієнтований підхід, у ньому є повноцінна підтримка класів.  Клас представляє шаблон для створення об\'єктів та  інкапсулює  функціональність, яку повинен мати об\'єкт . Клас визначає стан і поведінку, якими володіє об\'єкт.

Поля  класса

![](ppt/media/image125.png "Рисунок 4")

![](ppt/media/image126.png "Рисунок 6")

## \_ {#slide-81}

\_

![](ppt/media/image127.png "Рисунок 4")

![](ppt/media/image128.png "Рисунок 6")

## Методи {#slide-82}

\_

![](ppt/media/image129.png "Рисунок 4")

## \_ {#slide-83}

\_

![](ppt/media/image130.png "Рисунок 4")

## Конструктори {#slide-84}

\_

![](ppt/media/image131.png "Рисунок 4")

## Поля для читання {#slide-85}

\_

![](ppt/media/image132.png "Рисунок 4")

## \_ {#slide-86}

\_

![](ppt/media/image133.png "Рисунок 4")

## \_ {#slide-87}

\_

![](ppt/media/image134.png "Рисунок 4")

## Перевизначення  конструктора {#slide-88}

\_

![](ppt/media/image135.png "Рисунок 4")

## Перевизначення  методів {#slide-89}

\_

![](ppt/media/image136.png "Рисунок 4")

## \_ {#slide-90}

\_

![](ppt/media/image137.png "Рисунок 4")

## \_ {#slide-91}

\_

![](ppt/media/image138.png "Рисунок 4")

## \_ {#slide-92}

Також   абстрактний   клас   може   мати   абстрактні  поля,  тобто  поля  визначені  з  модифікатором   abstract .  Під  час  успадкування   клас-спадкоємець   також   зобов\'язаний   надати  для них  реалізацію :

Клас   Rectangle   надає  для них  реалізацію  за  допомогою   визначення   полів  через  параметри  конструктора:

## \_ {#slide-93}

\_

![](ppt/media/image139.png "Рисунок 4")

## Модифікатори доступу {#slide-94}

Модифікатори доступу дають змогу приховати стан об\'єкта від зовнішнього доступу та керувати доступом до цього стану. У  TypeScript  три модифікатори:  public ,  protected   і  private .

![](ppt/media/image140.png "Рисунок 4")

## Методи  доступу  get  і  set {#slide-95}

У  стандарті  JavaScript  ECMAScript  5  було   запропоновано   концепцію   методів  доступу: для доступу до  властивості   визначається  пара  методів  -  get -метод для  отримання   значення   властивості  та  set -метод для  встановлення   значення .  Це   доволі   поширена   концепція ,  що   знайшла   своє   застосування ,  наприклад , у Java, де для  управління  доступом до  приватних   змінних   створюється  пара  методів  -  get / set ,  або  в C#, де для доступу до  приватних   змінних   створюється   властивість   із   двома  методами  get / set .

## \_ {#slide-96}

\_

![](ppt/media/image141.png "Рисунок 4")

## Статичні поля та методи {#slide-97}

Крім   звичайних   полів  і  методів   клас   може   мати   статичні .  Статичні  поля і  методи  належать не до  окремих   об\'єктів , а  загалом  до  класу . І для  звернення  до  статичних   полів  і  методів   застосовується   ім\'я   класу .

![](ppt/media/image142.png "Рисунок 4")

## \_ {#slide-98}

\_

![](ppt/media/image143.png "Рисунок 4")

## \_ {#slide-99}

\_

![](ppt/media/image144.png "Рисунок 4")

## Інтерфейси {#slide-100}

Інтерфейс  визначає властивості та методи, які об\'єкт має реалізувати. Іншими словами, інтерфейс - це визначення кастомного типу даних, але без реалізації. У цьому випадку інтерфейси в  TS  схожі на інтерфейси в мовах  Java  і  C#.  Інтерфейси визначаються за допомогою ключового слова  interface.  Для початку визначимо простенький інтерфейс:

![](ppt/media/image145.png "Рисунок 4")

## \_ {#slide-101}

\_

![](ppt/media/image146.png "Рисунок 4")

![](ppt/media/image147.png "Рисунок 6")

## \_ {#slide-102}

\_

![](ppt/media/image148.png "Рисунок 4")

## \_ {#slide-103}

\_

![](ppt/media/image149.png "Рисунок 4")

## \_ {#slide-104}

\_

![](ppt/media/image150.png "Рисунок 4")

## \_ {#slide-105}

\_

![](ppt/media/image151.png "Рисунок 5")

## Інтерфейси функцій {#slide-106}

Інтерфейси функцій  містять визначення типу функції. Потім їх має бути реалізовано об\'єктом, який представляє функцію даного типу:

![](ppt/media/image152.png "Рисунок 4")

## інтерфейси масивів {#slide-107}

\_

![](ppt/media/image153.png "Рисунок 4")

## \_ {#slide-108}

\_

![](ppt/media/image154.png "Рисунок 4")

## \_ {#slide-109}

\_

![](ppt/media/image155.png "Рисунок 4")

## \_ {#slide-110}

\_

![](ppt/media/image156.png "Рисунок 4")

## Узагальнення  Дженеріки {#slide-111}

\_

![](ppt/media/image157.png "Рисунок 4")

![](ppt/media/image158.png "Рисунок 6")

## Узагальнення  Дженеріки {#slide-112}

\_

![](ppt/media/image159.png "Рисунок 4")

## Узагальнення  Дженеріки {#slide-113}

\_

![](ppt/media/image160.png "Рисунок 4")

## Узагальнення  Дженеріки {#slide-114}

\_

![](ppt/media/image161.png "Рисунок 4")

## Узагальнення  Дженеріки {#slide-115}

\_

![](ppt/media/image162.png "Рисунок 4")

## \_ {#slide-116}

\_

![](ppt/media/image163.png "Рисунок 4")

## Простори імен {#slide-117}

\_

![](ppt/media/image164.png "Рисунок 4")

## \_ {#slide-118}

\_

![](ppt/media/image165.png "Рисунок 4")

## \_ {#slide-119}

\_

![](ppt/media/image166.png "Рисунок 4")

![](ppt/media/image167.png "Рисунок 6")

## Початок роботи з  Angular {#slide-120}

Для роботи з  Angular  необхідно встановити сервер  Node.js  і пакетний менеджер  npm ,  якщо вони відсутні на робочій машині. При цьому особливого якогось знання для роботи з  NodeJS  і  npm   не потрібно . 

Слід враховувати, що  Angular  підтримує ті версії  node.js,  які в поточний момент перебувають у статусі \" Active LTS\"  або \" Maintenance LTS\" . Тому, якщо  Node.js  уже раніше був встановлений, але має старішу або, навпаки, нову, але ще не підтримувану версію, то краще його оновити. Перевірити сумісність версій  node.js ( а також версій  typescript  і бібліотеки  RxJS )  для певних версій  Angular  можна за  адресою :  https://angular.dev/reference/versions  .  Так, для останньої на даний момент версії  Angular 17  вимоги такі:

Версія  Node.js  має бути або 18 починаючи з  підверсії  18.13.0, або 20 починаючи з  підверсії  20.9.0

Версія  TypeScript  має бути 4.9.3 і вищою, але нижчою за 5.3.0 (потрібну версію  TypeScript  встановлюють локально в проєкт).

Те ж саме стосується і  npm .  Якщо версія занадто стара або, навпаки, одна з останніх, то  Angular  може її не підтримувати. Під час роботи з  Angular  краще покладатися на ту версію  npm ,  яка встановлюється разом з  LTS- версією  Node.js.

## Установка  Angular CLI {#slide-121}

Для компіляції застосунку ми будемо використовувати  інфрастуктуру   Angular CLI . Angular CLI  спрощує створення додатка, його компіляцію.  Angular CLI  поширюється як пакет  npm ,  тому для його використання його необхідно спочатку встановити. Для встановлення  Angular CLI  відкриємо консоль/командний рядок і виконаємо в ньому таку команду:

Ця  команда  встановить  пакет  @angular/cli  як  глобальний  модуль, тому  надалі  при  створенні   нових  проєктів  Angular   його  не  потрібно  буде  встановлювати  заново.

Ту саму команду  можна   використовувати  для  оновлення   Angluar  CLI  під  час  виходу   нової   версії  фреймворка.  Перевірити   версію  CLI  можна  в командному рядку/ консолі  за  допомогою   команди :

![](ppt/media/image168.png "Рисунок 4")

![](ppt/media/image169.png "Рисунок 6")

## \_ {#slide-122}

Під час роботи на  Windows  і виконанні команд у  PowerShell  замість командного рядка варто враховувати, що за замовчуванням виконання скриптів у  PowerShell  вимкнено. Щоб дозволити виконання скриптів  PowerShell ( що потрібно для  npm ),  необхідно виконати таку команду:

Set- ExecutionPolicy  -Scope  CurrentUser  - ExecutionPolicy   RemoteSigned

h

## Hello World {#slide-123}

Потім створимо в папці проекту  підпапку , яку назвемо  src  -  вона міститиме всі вихідні файли. І далі в папці  src   створимо підкаталог  app .

![](ppt/media/image170.png "Рисунок 4")

## Hello World {#slide-124}

Компоненти  являють собою основні будівельні блоки додатка  Angular.  Кожен додаток  Angular  має щонайменше один компонент . Тому створимо в папці  src /app   новий файл, який назвемо  app.component.ts   і в якому визначимо такий код компонента:

![](ppt/media/image171.png "Рисунок 4")

## \_ {#slide-125}

На початку файлу визначається директива  import ,  яка імпортує функціональність модуля  angular/core ,  надаючи доступ до функції декоратора  @ Component .  І також імпортуємо модуль  FormsModule ,  який знадобиться для роботи з полями введення.

Далі власне йде функція-декоратор  @ Component ,  яка асоціює метадані з класом компонента  AppComponent .  У цю функцію передається конфігураційний об\'єкт із низкою параметрів:

параметр  selector   визначає селектор  css   для  HTML- елемента, який представлятиме компонент. У цьому випадку це селектор \" my-app \".  Тобто на веб-сторінці застосунку має бути елемент \" \< my-app\> \",  і в цей елемент завантажуватиметься застосунок  Angular

параметр  standalone: true   вказує, що компонент буде незалежним, тобто для нього не потрібно створювати додаткових модулів, що зменшує та спрощує код додатка

## \_ {#slide-126}

параметр  imports   імпортує в компонент інші модулі. Сторонні модулі можуть містити різний функціонал, який ми можемо використовувати. Наприклад, у нашому випадку ми будемо використовувати поле введення, куди користувач буде вводити ім\'я. І для роботи з цим полем введення імпортуємо в компонент модуль  FormsModule .

параметр  template   представляє шаблон або візуальну частину компонента - те, що ми власне побачимо в браузері. Зокрема, у шаблоні визначено поле введення, куди користувач вводитиме ім\'я. А в заголовку  h1  виводитиметься введене значення. Для зв\'язку поля введення і заголовка застосовується двостороння прив\'язка поля за допомогою виразів  \[( ngModel )\]=\"name\"   і  {{ name}}   до деякої моделі  name .

І наприкінці, власне, експортується клас компонента  AppComponent ,  у якому якраз визначається змінна  name  -  у цьому випадку це порожній рядок.

## Запуск програми {#slide-127}

Тепер нам треба вказати  Angular,  як запускати наш додаток. Для цього створимо в папці  src  ( на рівень вище, ніж розташований файл \" app.component.ts \")  файл  main.ts   з таким вмістом:

Цей  код  запускає   додаток  у  вигляді   раніше   визначеного  компонента  AppComponent . У  разі   виникнення   помилок  вони  виводяться  на консоль.

![](ppt/media/image172.png "Рисунок 4")

## Створення головної сторінки {#slide-128}

Далі визначимо в папці  src   головну сторінку  index.html  додатка:

А в  елементі   body   визначено   елемент   \< my-app \> , в  який   власне  і буде  завантажуватися   додаток .

![](ppt/media/image173.png "Рисунок 4")

## Визначення конфігурації {#slide-129}

Оскільки для визначення коду додатка застосовується мова  TypeScript,  тому також створимо в кореневій папці проєкту новий файл  tsconfig.json :

Цей файл визначає налаштування для компілятора  TypeScript.  Опція \" compilerOptions \"  встановлює параметри компіляції. А опція \" files\"  визначає файли, що компілюються. У нашому випадку це файл програми -  main.ts ,  який підтягує всі інші файли програми.

![](ppt/media/image174.png "Рисунок 4")

## Angular.json {#slide-130}

Для компіляції додатка ми використовуватимемо  Angular CLI ,  тому нам треба описати поведінку  CLI  за допомогою файлу  angular.json .  Отже,  додамо  в кореневу папку проєкту новий файл  angular.json   і визначимо в ньому такий вміст:

![](ppt/media/image175.png "Рисунок 4")

## Angular.json {#slide-131}

Коротенько пройдемося структурою файлу. Спочатку визначається параметр  version .  Він визначає версію конфігурації проєкту.

Далі йде секція  projects ,  яка визначає налаштування для кожного проекту. У нашому випадку у нас тільки один проєкт, який називається за назвою каталогу проєкту -  helloapp .

Проект визначає такі опції:

projectType :  тип проекту. Значення \" application \"  вказує, що проєкт буде представляти додаток, який можна буде запускати в браузері

root :  вказує на папку файлів проекту відносно робочого середовища. Порожнє значення відповідає кореневій папці проєкту, оскільки в цьому випадку робоче середовище і каталог проєкту збігаються

sourceRoot :  визначає кореневу папку файлів із вихідним кодом. У нашому випадку це папка  src ,  де власне визначено всі файли програми

architect :  задає налаштування для побудови проєкту. У файлі  package.json   визначено команди  build   і  serve ,  і для кожної з цих команд у секції  architect   задано свої налаштування.

## Angular.json {#slide-132}

Для кожної команди задається параметр  builder ,  який визначає інструмент для побудови проєкту. Так, для команди \" build \"  задано значення  \"@ angular-devkit/ build-angular:browser \" -  цей  білдер  для побудови використовує збирач пакетів  webpack .  А для команди \" serve\"  задано значення  \"@ angular-devkit/ build-angular:dev-server \" -  цей  білдер  запускає веб-сервер і розгортає на ньому скомпільований застосунок.

Параметр  options   задає параметри побудови файлів. Для команди \" build \"  тут визначено такі опції:

outputPath :  шлях, за яким буде публікуватися скомпільований додаток

index :  шлях до головної сторінки програми

main :  шлях до головного файлу програми, де власне запускається додаток  Angular

polyfills :  шлях до файлів  поліфілів , в якості якого виступає \" zone.js "

tsConfig :  шлях до файлу конфігурації  TypeScript

aot :  вказує, чи буде використовуватися компіляція  AOT (Ahead-Of-Time) ( попередня компіляція перед виконанням). У цьому випадку значення  true   означає, що вона використовується

## Angular.json {#slide-133}

Для команди \" serve \"  вказана тільки одна опція -  buildTarget ,  яка містить посилання на конфігурацію для команди  build - \" helloapp:build \" .  Тобто по суті ця команда використовує ту саму конфігурацію, що й команда  build .

Остання опція  defaultProject   вказує на проєкт за замовчуванням. У цьому випадку це наш єдиний проєкт.

Якщо ми використовуємо  TypeScript  для роботи з  Angular  і  Angular CLI  для компіляції, то ці файли  package.json ,  tsconfig.json   і  angular.json   фактично будуть присутніми в кожному проєкті . І їх можна переносити з проєкту в проєкт із мінімальними змінами. Наприклад, у файлі  angular.json   замість назви проєкту \" helloapp \"  буде відповідна назва проєкту. У файлі  package.json   можна буде задати якісь інші версії пакетів, якщо попередні версії застаріли. Можна буде змінити назву проєкту, версію. Можна підправити налаштування  TypeScript  або  Angular CLI,  але загалом загальна організація буде тією самою.

## Angular.json {#slide-134}

\_

![](ppt/media/image176.png "Рисунок 4")

## Запуск  проекта {#slide-135}

І  тепер , коли все готово, ми  можемо   запустити  проєкт. Для  цього  в командному рядку ( терміналі )  перейдемо  до папки проєкту за  допомогою   команди   cd  і  потім   виконаємо  команду  ng   serve :

![](ppt/media/image177.png "Рисунок 4")

![](ppt/media/image178.png "Рисунок 6")

## \_ {#slide-136}

\_

![](ppt/media/image179.png "Рисунок 4")

## Побудова проєкту {#slide-137}

Секція  build   описує конфігурацію команди побудови \" ng build \".  Зокрема, параметр \" outputPath \"  задає каталог для компільованих файлів додатка.

Тобто ми можемо ввести в командний рядок команду  ng build  для компіляції проєкту

![](ppt/media/image180.png "Рисунок 4")

## Побудова проєкту {#slide-138}

Після виконання цієї команди в каталозі проєкту з\'явиться папка  dist / helloapp ,  де ми зможемо побачити всі файли програми. Ми можемо розташувати ці файли на будь-якому веб-сервері і так само звертатися до головної сторінки застосунку.

![](ppt/media/image181.png "Рисунок 4")

## Налаштування побудови {#slide-139}

За замовчуванням  Angular CLI  використовує низку налаштувань під час побудови . Наприклад, файли компілюються в режимі  production ,  тобто в режимі, коли вони вже безпосередньо готові до розгортання. Але ми також можемо всі налаштування побудови задати явним чином. Так, змінимо файл  angular.json   таким чином:

![](ppt/media/image182.png "Рисунок 4")

## Налаштування побудови {#slide-140}

Тепер ми додали для команди  build   підсекцію \" configurations \",  яка задає додаткові конфігурації проєкту. І тут зазначено дві конфігурації - \" production \"  і \" development \" -  тобто набір налаштувань, які застосовуються до побудови додатка, коли він уже готовий до розгортання і повноцінного використання. І тут визначається наступний набір налаштувань:

optimization :  вказує, чи буде використовуватися оптимізація

outputHashing :  вказує, чи буде в назву файлу, що генерується, додаватися хеш-значення. Значення  all   говорить, що в назви всіх генерованих файлів додається хеш

sourceMap :  визначає, чи будуть генеруватися файли  sourceMap

namedChunks :  визначає, чи будуть використовуватися імена файлів для іменованих  чанків , що довантажуються

vendorChunk :  визначає, чи буде створюватися для сторонніх бібліотек, що використовуються в додатку, окремий файл

buildOptimizer :  підключає пакет  @ angular-devkit/build-optimizer   для оптимізації при використанні опції  aot

## \_ {#slide-141}

Тепер використовуємо конфігурацію  production  для компіляції. Для цього команді  build   треба передати прапор  \-- configuration production :

Після цього ми побачимо в папці  dist / helloapp   ті самі файли, але які були згенеровані за допомогою налаштувань із файлу  angular.json .  Змінюючи ці налаштування, ми можемо задати потрібні нам у конкретній ситуації параметри побудови проекту.

![](ppt/media/image183.png "Рисунок 4")

## Компоненти {#slide-142}

Одним із ключових елементів програми є компоненти.  Компонент  керує відображенням подання на екрані.

Так, при створенні першого додатка в минулому розділі було визначено такий компонент (файл  app.component.ts ):

![](ppt/media/image184.png "Рисунок 4")

## Компоненти {#slide-143}

Щоб клас міг використовуватися в інших модулях і компонентах, він визначається з ключовим словом  export .  У самому ж класі визначена лише одна змінна, яка як значення зберігає деякий рядок.

Для створення компонента необхідно імпортувати функцію декоратора  @ Component   з бібліотеки  @ angular/core .  Декоратор  @ Component  дозволяє ідентифікувати клас як компонент .

Якби ми не застосували декоратор  @ Component   до класу  AppComponent ,  то клас  AppComponent   компонентом би не вважався.

Декоратор  @ Component   як параметр  приймає об\'єкт із конфігурацією , яка вказує фреймворку, як працювати з компонентом і його представленням. Клас компонент приймає безліч параметрів, який можна подивитися в документації. Більша частина цих параметрів так чи інакше розглядається в подальших  уроках , тому в даному випадку розглянемо тільки ті, які використані в коді вище:

## Компоненти {#slide-144}

selector :  визначає  селектор  CSS .  В  елемент   із   цим  селектором  Angular  буде  додавати   подання  компонента.  Наприклад , у  прикладі   вище  селектор  має   значення   my-app .  Відповідно   html- сторінка   застосунку   має   містити   елемент   \< my-app\>\</my-app\> .  І  саме   цей   елемент  буде  використовуватися  для рендерингу  представлення  компонента.

standalone :  вказує ,  чи  буде компонент  автономним . За  значення   true   компонент є  автономним . За  замовчуванням   значення   false  ( компонент не  автономний ).  Далі  ми  трохи   докладніше   розглянемо   відмінність   між   автономними  та  неавтономними  компонентами .

imports :  вказує   набір   модулів ,  які  треба  імпортувати .  Якщо  компонент  використовує   якісь   модулі , то  ці   модулі   можна  тут  вказати . Так, у  прикладі   вище  в  коді  компонента  визначено   текстове  поле  введення . І для  роботи  з полями  введення  та  елементами   форми   призначений   спеціальний  модуль -  FormsModule .  І компонент  AppComponent   його   імпортує .

template :  шаблон  або   візуальна   частина  компонента . Шаблон  являє  собою шматок  розмітки   HTML  із   вкрапленнями  коду  Angular.  Фактично  шаблон  це  і є  уявлення , яке  побачить   користувач   під  час  роботи  з  додатком .

## Компоненти {#slide-145}

Кожен компонент повинен мати один шаблон. Однак необов\'язково визначати шаблон безпосередньо за допомогою властивості  template .  Можна винести шаблон у зовнішній файл із розміткою  html ,  а для його підключення використовувати властивість  templateUrl .

Шаблон може бути однорядковим або багаторядковим. Якщо шаблон багаторядковий, то він укладається в косі лапки ( \` ), які варто відрізняти від стандартних ординарних лапок ( \' ).

## Автономні компоненти {#slide-146}

У версії 14  фреймворка   Angular  було запропоновано концепцію автономних компонентів  ( standalone components ).  З версії 16 ця концепція вийшла з бета-версії і перейшла в стан релізу .  Автономні компоненти  Angular  відрізняються тим, що вони можуть не бути частиною модулів, тобто вони автономні та можуть використовуватися самі по собі. При визначенні таких компонентів застосовується властивість  standalone:true   декоратора  Component .

Такі компоненти самі керують своїми  залежностями  через властивість  imports   у декораторі  Component .  Крім того, автономні компоненти можуть імпортуватися в інші автономні компоненти.

Варто зазначити, що команда розробників фреймворку  Angular  для розробки нових застосунків під час використання версії 16 і вище  рекомендує використовувати саме автономні компоненти . Відповідно надалі ми також будемо керуватися цим підходом. Однак також подивимося на альтернативних підхід із використанням модулів і неавтономних компонентів.

## Загрузка  компонентов {#slide-147}

Незалежно від того, скільки у нас компонентів,  один із них є головним , і він, своєю чергою,  завантажує всі інші компоненти . Фреймворк  Angular  дає змогу безпосередньо завантажувати головний компонент.

![](ppt/media/image185.png "Рисунок 4")

## Загрузка  компонентов {#slide-148}

У папку  src / app   у  файлі   app.component.ts   визначимо  простенький компонент:

Тут порожній клас  AppComponent ,  для якого визначено тільки селектор - \" my-app \"  і шаблон у вигляді заголовка. На веб-сторінці  index.html   визначимо елемент  my-app :

![](ppt/media/image186.png "Рисунок 4")

![](ppt/media/image187.png "Рисунок 6")

## Загрузка  компонентов {#slide-149}

Для  завантаження  головного і  єдиного  компонента у  файлі   main.ts   використовуємо   такий  код:

Для завантаження компонента  AppComponent   застосовується  bootstrapApplication   API .  Так, першим рядком у файлі з модуля \" angular/platform-browser \"  імпортується функція  bootstrapApplication () .  Другим рядком імпортується головний компонент  AppComponent .

Потім виклик  bootstrapApplication ( AppComponent )   запускає екземпляр застосунку  Angular  і відображає автономний компонент як кореневий компонент застосунку.

![](ppt/media/image188.png "Рисунок 4")

## \_ {#slide-150}

\_

![](ppt/media/image189.png "Рисунок 4")

## \_ {#slide-151}

Варто зазначити, що ця функція повертає об\'єкт  проміс  -  Promise\< ApplicationRef \> .  З цього можна отримати об\'єкт  ApplicationRef ,  який і представляє власне додаток  Angular .

![](ppt/media/image190.png "Рисунок 4")

## \_ {#slide-152}

\_

## \_ {#slide-153}

\_

## \_ {#slide-154}

\_

## \_ {#slide-155}

\_

## \_ {#slide-156}

\_

## \_ {#slide-157}

\_

## \_ {#slide-158}

\_

## \_ {#slide-159}

\_

## \_ {#slide-160}

\_

## \_ {#slide-161}

\_
