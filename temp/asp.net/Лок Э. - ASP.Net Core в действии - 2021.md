Эндрю Лок
ASP .Net Core в действии

ASP.NET Core in Action
# SECOND EDITION
# ANDREW LOCK

ASP.Net Core в действии
# ЭНДРЮ ЛОК
Москва, 2021

# УДК 004.438.NET
# ББК 32.973.26-018.2
# Л73
Лок Э.
Л73 ASP .Net Core в действии / пер. с анг. Д. А. Беликова . – М.: ДМК Пресс, 2021. –
906 с.: ил.
# ISBN 978-5-97060-550-9
Эта книга знакомит читателей с основами фреймворка ASP .NET Core, такими как
промежуточное ПО, внедрение зависимостей и конфигурация. Автор показывает, как
настроить их в соответствии с пользовательскими требованиями. Речь пойдет о том,
как добавить аутентификацию и авторизацию в свои приложения, как повысить их
безопасность, а также как развертывать их и осуществлять мониторинг. Рассматри-
вается тестирование приложений с использованием модульных и интеграционных
тестов.
Основное внимание будет уделено тому, как создавать приложения с отрисовкой
на стороне сервера, используя страницы Razor и веб-API, а также контроллеры MVC.
Книга подойдет как тем, кто является новичком в веб-разработке, так и тем, кто
уже имеет опыт использования фреймворка ASP .NET.
# УДК 004.438.NET
# ББК 32.973.26-018.2
Original English language edition published by Manning Publications USA, USA. Russian-language
edition copyright © 2021 by DMK Press. All rights reserved.
Все права защищены. Любая часть этой книги не может быть воспроизведена в какой
бы то ни было форме и какими бы то ни было средствами без письменного разрешения вла -
дельцев авторских прав.
ISBN 978-1-6172-9830-1 (англ.) © Manning Publications, 2021
ISBN 978-5-97060-550-9 (рус.)  © Перевод, оформление, издание, ДМК Пресс, 2021

Оглавление
Часть I   НАЧАЛО РАБОТЫ С ASP .NET CORE  ....................................................... 31
1  Начало работы с ASP .NET Core  ...................................................................... 33
2  Ваше первое приложение  .............................................................................. 58
3  Обработка запросов с по мощью конвейера промежуточного ПО  ....... 95
4  Создание веб-сайта с помощью страниц Razor  ...................................... 130
5  Сопоставление URL-адресов с Razor Pages  с использованием
маршрутизации  ............................................................................................. 164
6  Модель привязки: получение и проверка пользовательского ввода  ....203
7  Визуализация HTML-кода с использованием представлений Razor  ....239
8  Создание форм с помощью тег-хелперов  ................................................ 278
9  Создание веб-API для мобильных и клиентских приложений
с по мощью MVC  ............................................................................................. 313
Часть II   СОЗДАНИЕ ПОЛНОЦЕННЫХ ПРИЛОЖЕНИЙ  ................................ 350
10  Конфигурация сервисов с по мощью внедрения зависимостей  ......... 352
11  Конфигурирование приложения ASP .NETCore  ....................................... 394
12  Cохраняем данные с Entity Framework Core   ........................................... 432
13  Конвейер фильтров MVC и Razor Pages  ................................................... 471
14  Аутентификация: добавляем пользователей в приложение
с по мощью ASP .NET Core Identity  ............................................................. 513
15  Авторизация: обеспечиваем защиту приложения  ............................... 553
16  Публикация и развертывание приложения  ............................................ 590
Часть III   РАСШИРЕНИЕ ПРИЛОЖЕНИЙ  .............................................................. 628
17  Мониторинг и устранение ошибок с помощью журналирования  ....630
18  Повышаем безопасность приложения  ..................................................... 667
19  Создание специальных компонентов  ...................................................... 710
20  Создание специальных компонентов MVC и Razor Pages  .................. 745
21  Вызов удаленных API с помощью IHttpClientFactory  .......................... 775
22  Создание фоновых задач и сервисов  ........................................................ 799
23  Тестирование приложения  .......................................................................... 827

Содержание
Предисловие  .......................................................................................................... 19
Благодарности  ....................................................................................................... 21
Об этой книге  ........................................................................................................ 23
Об авторе  ................................................................................................................ 29
Об иллюстрации на обложке  ............................................................................. 30
Часть I  НАЧАЛО РАБОТЫ С ASP.NET CORE  ..................... 31
1 Начало работы с ASP.NET Core  .................................................... 33
1.1 Введение в ASP .NET Core  ......................................................................... 34
1.1.1	 Использование	веб-фреймворка ........................................................ 35
1.1.2	 Что	такое	 ASP.NET	Core? ................................................................. 37
1.2 Когда следует отдать предпочтение ASP .NET Core  ............................ 40
1.2.1	 Какие	типы	приложений	можно	создавать? ................................... 40
1.2.2	 Если	вы	новичок	в разработке	на	 .NET ............................................. 43
1.2.3	 Если	вы	разработчик, 	создающий	новое	приложение	 ...................... 45
1.2.4	 Перенос 	существующего	 ASP.NET-приложения	на	 ASP.NET	Core .....50
1.3 Как работает ASP .NET Core?  .................................................................... 51
1.3.1	 Как	работает	веб-запрос 	по	протоколу	HTTP? .............................. 52
1.3.2	 Как	 ASP.NET	Core	обрабатывает	запрос? ....................................... 54
1.4 Что вы узнаете из этой книги  ................................................................ 56
Резюме  .................................................................................................................... 57
2 Ваше первое приложение  .................................................................... 58
2.1 Краткий обзор приложения ASP .NET Core  .......................................... 60
2.2 Создание вашего первого приложения ASP .NET Core  ...................... 62
2.2.1	 Использование	шаблона .................................................................... 63
2.2.2	 Сборка	приложения ........................................................................... 66
2.3 Запуск веб-приложения ........................................................................... 68
2.4 Разбираемся с макетом проекта  ........................................................... 70

7 Содержание
2.5 Файл проекта .csproj: определение зависимостей  ............................ 71
2.6 Класс Program: сборка веб-хоста  ........................................................... 74
2.7 Класс Startup: настройка вашего приложения  ................................... 77
2.7.1	 Добавление	и настройка	сервисов .................................................... 79
2.7.2	 Определяем, 	как	обрабатываются	запросы	с помощью
промежуточного	программного	обеспечения ................................... 81
2.8 Создание ответов с по мощью Razor Pages  .......................................... 86
2.8.1	 Создание	HTML	с по	 мощью	страниц	Razor ...................................... 87
2.8.2	 Логика	обработки	запросов	с по	 мощью	PageModels
и обработчиков ................................................................................. 89
Резюме  .................................................................................................................... 93
3 Обработка запросов с по мощью конвейера
промежуточного ПО  .............................................................................. 95
3.1 Что такое промежуточное ПО?  .............................................................. 97
3.2 Объединение компонентов в конвейер  ............................................ 102
3.2.1	 Простой	сценарий	конвейера	1:	страница приветствия .................. 102
3.2.2	 Простой	сценарий	конвейера	2:	обработка статических	файлов ...106
3.2.3	 Простой	сценарий	конвейера	3:	приложение	со страницами
Razor ...................................................................................................... 110
3.3 Обработка ошибок с по мощью промежуточного ПО  ..................... 116
3.3.1	 Просмотр	исключений	в окружении	разработки:
DeveloperExceptionPage .................................................................... 118
3.3.2	 Обработка	исключений	в промышленном	окружении:
ExceptionHandlerMiddleware ............................................................ 119
3.3.3	 Обработка	других	ошибок:	StatusCodePagesMiddleware ................ 124
3.3.4 Компонент обработки ошибок и веб-API  .......................................... 128
Резюме  .................................................................................................................. 129
4 Создание веб-сайта с помощью страниц Razor  ........... 130
4.1 Введение в Razor Pages  .......................................................................... 132
4.1.1	 Изучение	типичной	страницы	Razor .............................................. 132
4.1.2	 Паттерн	проектирования	MVC ..................................................... 134
4.1.3	 Применение	паттерна	проектирования	MVC	к Razor Pages ........ 137
4.1.4	 Добавление	Razor	Pages	в приложение ............................................ 145
4.2 Сравнение Razor Pages и MVC в ASP .NET Core  ................................. 149
4.2.1	 Контроллеры	MVC	в ASP.NET	Core ................................................. 149
4.2.2	 Преимущества	Razor	Pages ............................................................. 151
4.2.3	 Когда	выбирать	контроллеры	MVC	вместо	Razor	Pages ............... 154
4.3 Razor Pages и обработчики страниц  ................................................... 155
4.3.1	 Прием	параметров	в обработчиках	страниц ................................ 157
4.3.2	 Возврат	ответов	с помощью	 ActionResults .................................... 159
Резюме  .................................................................................................................. 163
5 Сопоставление URL-адресов с Razor Pages
с использованием маршрутизации  ......................................... 164
5.1 Что такое маршрутизация?  ................................................................... 165
5.2 Маршрутизация в ASP .NET Core  .......................................................... 169

8 Содержание
5.2.1	 Использование	маршрутизации	конечных	точек	в ASP.NET	Core ....169
5.2.2	 Маршрутизация	на	основе	соглашений	и маршрутизация
на	основе	атрибутов ...................................................................... 173
5.2.3	 Маршрутизация	и страницы	Razor ................................................ 176
5.3 Настройка шаблонов маршрутов для страницы Razor  .................. 178
5.3.1	 Добавление	сегмента	в шаблон	маршрута .................................... 180
5.3.2	 Полная	замена	шаблона	маршрута	страницы	Razor .................... 181
5.4 Изучение синтаксиса шаблона маршрута  ......................................... 182
5.4.1	 Использование	дополнительных	значений	и значений
по	умолчанию .................................................................................. 182
5.4.2	 Добавление	дополнительных	ограничений	к параметрам
маршрута ....................................................................................... 184
5.4.3	 Сопоставление	произвольных	URL-адресов	с помощью
универсального	параметра ............................................................. 186
5.5 Генерация URL-адресов из параметров маршрута  ......................... 188
5.5.1	 Создание	URL-адресов	для	страницы	Razor ................................... 189
5.5.2	 Создание	URL-адресов	для	контроллера	MVC ................................ 190
5.5.3	 Создание	URL-адресов	с по	 мощью	ActionResults ............................. 192
5.5.4	 Создание	URL-адресов	из	других	частей	вашего приложения ........ 193
5.6 Выбор обработчика страницы для вызова  ........................................ 194
5.7 Настройка соглашений с помощью Razor Pages  .............................. 197
Резюме  .................................................................................................................. 201
6 Модель привязки: получение и проверка
пользовательского ввода  ................................................................. 203
6.1 Модели в Razor Pages и MVC  ................................................................. 204
6.2 От запроса к модели: делаем запрос полезным  .............................. 208
6.2.1	 Связывание	простых	типов ............................................................ 212
6.2.2	 Привязка	сложных	типов ................................................................ 216
6.2.3	 Выбор	источника	привязки ............................................................. 221
6.3 Обработка пользовательского ввода с помощью
валидации модели  .................................................................................. 223
6.3.1	 Необходимость	валидации	модели ................................................. 223
6.3.2	 Использование	атрибутов	DataAnnotations	для валидации .......... 225
6.3.3	 Валидация	модели	на	сервере	в целях	безопасности ...................... 228
6.3.4	 Валидация	на	стороне	клиента	для улучшения
пользовательского	интерфейса ...................................................... 232
6.4 Организация моделей привязки в Razor Pages  ................................ 234
Резюме  .................................................................................................................. 237
7 Визуализация HTML-кода с использованием
представлений Razor  .......................................................................... 239
7.1 Представления: визуализация пользовательского интерфейса  .....241
7.2 Создание представлений Razor  ........................................................... 245
7.2.1	 Представления	Razor	и сопутствующий	код ................................. 245
7.2.2	 Знакомство	с шаблонами	Razor ..................................................... 247
7.2.3	 Передача	данных	в представления ................................................. 248
7.3 Создание динамических веб-страниц с помощью Razor  .............. 251
7.3.1	 Использование	C#	в шаблонах	Razor ............................................... 252

9 Содержание
7.3.2	 Добавление	циклов	и условий	в шаблоны	Razor .............................. 253
7.3.3	 Визуализация	HTML	с по	 мощью	метода	Raw ................................. 256
7.4 Макеты, частичные представления и _ViewStart  ............................ 259
7.4.1	 Использование	макетов	для	общей	разметки ................................ 260
7.4.2	 Переопределение	родительских	макетов	с помощью секций ......... 262
7.4.3	 Использование	частичных	представлений	для инкапсуляции
разметки ......................................................................................... 264
7.4.4	 Выполнение	кода	в каждом	представлении	с помощью
_ViewStart	и _ViewImports	 ............................................................... 267
7.5 Выбор представления из контроллера MVC  ..................................... 270
Резюме  .................................................................................................................. 276
8 Создание форм с помощью тег-хелперов  ........................... 278
8.1 Редакторы кода и тег-хелперы  ............................................................. 280
8.2 Создание форм с по мощью тег-хелперов  ......................................... 283
8.2.1	 Тег-хелпер	формы ............................................................................ 288
8.2.2	 Тег-хелпер	метки	(label) ................................................................. 291
8.2.3	 Тег-хелперы	ввода	(input)	и области	текста	(textarea) ................. 292
8.2.4	 Тег-хелпер	раскрывающегося	списка ............................................... 296
8.2.5	 Тег-хелперы	сообщений	валидации	и сводки	сообщений
(Validation	Summary) ....................................................................... 302
8.3 Создание ссылок с по мощью тег-хелпера якоря
(Anchor Tag Helper)  ................................................................................. 305
8.4 Сброс кеша с по мощью тег-хелпера добавления
версии (Append Version Tag Helper)  .................................................... 307
8.5 Использование условной разметки с помощью
тег-хелпера окружения  .......................................................................... 308
Резюме  .................................................................................................................. 310
9 Создание веб-API для мобильных и клиентских
приложений  с по мощью MVC  ........................................................ 313
9.1 Что такое веб-API, и когда его следует использовать?  ................... 314
9.2 Создание первого проекта веб-API  .................................................... 318
9.3 Применение паттерна проектирования MVC к веб-API  ................ 326
9.4 Маршрутизация на основе атрибутов: связывание
методов действий  с URL-адресами  ..................................................... 330
9.4.1	 Сочетание	атрибутов	маршрута, 	чтобы	ваши шаблоны
маршрутов	следовали	принципу	DRY ............................................. 333
9.4.2	 Использование	замены	маркера	для	уменьшения
дублирования	при	маршрутизации	на	основе	атрибутов ............. 334
9.4.3	 Обработка	HTTP-методов	с по	 мощью	маршрутизации
на	основе	атрибутов ...................................................................... 335
9.5 Использование общепринятых соглашений с атрибутом
[ApiController] ........................................................................................... 337
9.6 Генерация ответа от модели  ................................................................. 341
9.6.1	 Настройка	форматеров	по	умолчанию:	добавляем
поддержку	XML ............................................................................... 343
9.6.2	 Выбор	формата	ответа	с помощью	согласования	содержимого ....345
Резюме  .................................................................................................................. 347

10 Содержание
Часть II  СОЗДАНИЕ ПОЛНОЦЕННЫХ
# ПРИЛОЖЕНИЙ  .......................................................................... 350
10 Конфигурация сервисов с по мощью внедрения
зависимостей  ............................................................................................. 352
10.1 Введение во внедрение зависимостей ............................................... 353
10.1.1	 Преимущества	внедрения	зависимостей ....................................... 354
10.1.2	 Создание	слабосвязанного	кода ...................................................... 360
10.1.3	 Внедрение	зависимостей	в ASP.NET	Core ....................................... 362
10.2 Использование контейнера внедрения зависимостей  .................. 364
10.2.1	 Добавление	сервисов	фреймворка	ASP.NET	Core	в контейнер ....... 364
10.2.2	 Регистрация	собственных	сервисов	в контейнере ......................... 367
10.2.3	 Регистрация	сервисов	с использованием	объектов
и лямбда-функций ........................................................................... 369
10.2.4	 Многократная	регистрация	сервиса	в контейнере ....................... 374
10.2.5	 Внедрение	сервисов	в методы	действий, 	обработчики
страниц	и представления ............................................................... 378
10.3 Жизненный цикл: когда создаются сервисы?  ................................. 382
10.3.1	 Transient:	все	уникально .................................................................. 385
10.3.2	 Scoped:	давайте	держаться	вместе ............................................... 386
10.3.3	 Singleton:	может	быть	только	один .............................................. 387
10.3.4	 Следите	за	захваченными	зависимостями .................................... 388
Резюме  .................................................................................................................. 392
11 Конфигурирование приложения ASP.NETCore  ................ 394
11.1 Представляем модель конфигурации ASP .NET Core  ....................... 395
11.2 Конфигурирование приложения с по мощью метода
CreateDefaultBuilder  ................................................................................ 397
11.3 Создание объекта конфигурации для вашего приложения  .......... 399
11.3.1	 Добавление	поставщика	конфигурации	в файле Program.cs .......... 402
11.3.2	 Использование	нескольких	поставщиков
для переопределения	значений	конфигурации ................................ 405
11.3.3	 Безопасное	хранение	секретов	конфигурации ................................ 407
11.3.4	 Перезагрузка	значений	конфигурации	при	их	изменении ............... 412
11.4 Использование строго типизированных настроек
с паттерном Options  ............................................................................... 413
11.4.1	 Знакомство	с интерфейсом	IOptions ............................................. 415
11.4.2	 Перезагрузка	строго	типизированных	параметров
с помощью	IOptionsSnapshot ........................................................... 417
11.4.3	 Разработка	классов	параметров	для	автоматической	привязки ...418
11.4.4	 Связывание	строго	типизированных	настроек
без интерфейса	IOptions ................................................................. 420
11.5 Настройка приложения для нескольких окружений  ...................... 422
11.5.1	 Определение	окружения	размещения .............................................. 422
11.5.2	 Загрузка	файлов	конфигурации	для	конкретного	окружения .......... 424
11.5.3	 Задаем	окружение	размещения ...................................................... 426
Резюме  .................................................................................................................. 430

11 Содержание
12 Cохраняем данные с Entity Framework Core   ..................... 432
12.1 Знакомство с Entity Framework Core  ................................................... 434
12.1.1	 Что	такое	EF	Core? ......................................................................... 434
12.1.2	 Зачем	использовать	инструмент	объектно-реляционного
отображения? ................................................................................. 436
12.1.3	 Когда	следует	выбирать	EF	Core? .................................................. 437
12.1.4	 Отображение	базы	данных	в код	приложения ............................... 439
12.2 Добавляем EF Core в приложение  ....................................................... 441
12.2.1	 Выбор	провайдера	базы	данных	и установка	EF	Core .................... 443
12.2.2	 Создание	модели	данных ................................................................. 444
12.2.3	 Регистрация	контекста	данных .................................................... 447
12.3 Управление изменениями с помощью миграций  .......................... 448
12.3.1	 Создаем	первую	миграцию .............................................................. 449
12.3.2	 Добавляем	вторую	миграцию ......................................................... 452
12.4 Выполнение запроса к базе данных и сохранение в ней
данных  ....................................................................................................... 455
12.4.1	 Создание	записи .............................................................................. 455
12.4.2	 Загрузка	списка	записей .................................................................. 458
12.4.3	 Загрузка	одной	записи ..................................................................... 460
12.4.4	 Обновление	модели ......................................................................... 462
12.5  Использование EF Core в промышленных приложениях  ............... 466
Резюме  .................................................................................................................. 468
13 Конвейер фильтров MVC и Razor Pages  .............................. 471
13.1 Что такое фильтры, и когда их использовать  ................................... 473
13.1.1	 Конвейер	фильтров	MVC ................................................................ 474
13.1.2	 Конвейер	фильтров	Razor	Pages ..................................................... 476
13.1.3	 Фильтры	или	промежуточное	ПО:	что	выбрать? ........................ 478
13.1.4	 Создание	простого	фильтра .......................................................... 479
13.1.5	 Добавляем	фильтры	к действиям, 	контроллерам, 	страницам
Razor	Pages	и глобально ................................................................... 482
13.1.6	 Порядок	выполнения	фильтров ...................................................... 485
13.2 Создание фильтров для приложения  ................................................. 487
13.2.1	 Фильтры	авторизации:	защита	API ............................................. 490
13.2.2	 Фильтры 	ресурсов:	прерывание	выполнения	методов	действий ....492
13.2.3	 Фильтры	действий:	настройка	привязки	модели
и результатов	действий ................................................................ 494
13.2.4	 Фильтры	исключений:	собственная	обработка
исключений	для	методов	действий ................................................ 499
13.2.5	 Фильтры	результатов:	настройка	результатов
действий	перед	их	выполнением ..................................................... 501
13.2.6	 Фильтры	страниц:	настройка	привязки	модели
для Razor	Pages ................................................................................ 504
13.3 Прерывание выполнения конвейера  ................................................. 506
13.4 Использование внедрения зависимостей с атрибутами
фильтра  ...................................................................................................... 508
Резюме  .................................................................................................................. 511

12 Содержание
14 Аутентификация: добавляем пользователей
в приложение  с по мощью ASP.NET Core Identity  ......... 513
14.1 Знакомство с аутентификацией и авторизацией  ........................... 515
14.1.1	 Пользователи	и утверждения	в ASP.NET	Core ............................... 515
14.1.2	 Аутентификация	в ASP.NET	Core:	сервисы
и промежуточное	ПО ...................................................................... 517
14.1.3	 Аутентификация	для	API	и распределенных	приложений ............. 520
14.2 Что такое ASP .NET Core Identity?  ......................................................... 524
14.3 Создание проекта, в котором используется ASP .NET
Core Identity  .............................................................................................. 527
14.3.1	 Создание	проекта	из	шаблона ........................................................ 527
14.3.2	 Изучение	шаблона	в Обозревателе	решений .................................. 529
14.3.3	 Модель	данных	ASP.NET	Core	Identity ............................................. 533
14.3.4	 Взаимодействие	с ASP.NET	Core	Identity ........................................ 535
14.4 Добавляем ASP .NET Core Identity в существующий проект  .......... 538
14.4.1	 Настройка	сервисов	ASP.NET	Core	Identity
и промежуточного	ПО .................................................................... 539
14.4.2	 Обновление	модели	данных	EF	Core	для	поддержки	Identity ........... 541
14.4.3	 Обновление	представлений	Razor	для	связи
с пользовательским	интерфейсом	Identity ..................................... 542
14.5 Настройка страницы в пользовательском интерфейсе
ASP .NET Core Identity  по умолчанию  ................................................. 544
14.6 Управление пользователями: добавление
специальных данных для пользователей .......................................... 547
Резюме  .................................................................................................................. 550
15 Авторизация: обеспечиваем защиту
приложения ................................................................................................. 553
15.1 Знакомство с авторизацией  ................................................................. 555
15.2 Авторизация в ASP .NET Core  ................................................................ 558
15.2.1	 Предотвращение	доступа	анонимных	пользователей
к вашему	приложению ..................................................................... 560
15.2.2	 Обработка	запросов, 	не	прошедших	аутентификацию ................ 562
15.3 Использование политик для авторизации на основе
утверждений ............................................................................................. 565
15.4 Создание специальных политик авторизации  ................................ 569
15.4.1	 Требования	и обработчики:	строительные	блоки	политики ........ 569
15.4.2	 Создание	политики	со	специальным	требованием
и обработчиком .............................................................................. 571
15.5 Управление доступом с авторизацией на основе ресурсов  .......... 577
15.5.1	 Ручная	авторизация	запросов	с по	 мощью	интерфейса
IAuthorizationService ........................................................................ 579
15.5.2	 Создание	обработчика	AuthorizationHandler	на основе
ресурсов ........................................................................................... 582
15.6 Скрытие элементов в шаблонах Razor
от незарегистрированных пользователей  ........................................ 585
Резюме  .................................................................................................................. 588

13 Содержание
16 Публикация и развертывание приложения  ..................... 590
16.1 Модель хостинга ASP .NET Core  ............................................................ 592
16.1.1	 Запуск	и публикация	приложения	ASP.NET	Core ............................ 594
16.1.2	 Выбор	метода	развертывания	для	вашего	приложения ................ 598
16.2 Публикация приложения в IIS  ............................................................. 600
16.2.1	 Конфигурирование	IIS	для	ASP.NET	Core ........................................ 600
16.2.2	 Подготовка	и публикация	приложения	в IIS ................................... 603
16.3 Размещение приложения в Linux ........................................................ 606
16.3.1	 Запуск	приложения	ASP.NET	Core	за	обратным
прокси-сервером	в Linux .................................................................. 606
16.3.2	 Подготовка	приложения	к развертыванию	в Linux ....................... 609
16.4 Настройка URL-адресов приложения  ................................................. 611
16.5  Оптимизация клиентских ресурсов с помощью BundlerMinifier  ...615
16.5.1	 Ускорение	работы	приложения	с по	 мощью	упаковки
и минификации	кода ........................................................................ 618
16.5.2	 Добавляем	BundlerMinifier	в приложение ........................................ 620
16.5.3	 Использование	минифицированных	файлов	в промышленном
окружении	с по	 мощью	тег-хелпера	окружения .............................. 623
16.5.4	 Обслуживание	часто	используемых	файлов	из	сети
доставки	содержимого .................................................................... 624
Резюме  .................................................................................................................. 625
Часть III  РАСШИРЕНИЕ ПРИЛОЖЕНИЙ  ................................ 628
17 Мониторинг и устранение ошибок с помощью
журналирования  ..................................................................................... 630
17.1 Эффективное использование журналирования
в промышленном приложении  ........................................................... 632
17.1.1	 Выявление	проблем	с по	 мощью	специальных	сообщений
журнала ........................................................................................... 633
17.1.2	 Абстракции	журналирования	ASP.NET	Core .................................. 635
17.2 Добавление сообщений журнала в приложение  ............................. 636
17.2.1	 Уровень	сообщения	журнала:	насколько	важно	сообщение
журнала? ......................................................................................... 639
17.2.2	 Категория	сообщения	журнала:	какой	компонент	создал
журнал ............................................................................................. 642
17.2.3	 Форматирование	сообщений	и сбор	значений	параметров .............. 643
17.3 Контроль места записи журналов с помощью поставщиков
журналирования  ...................................................................................... 645
17.3.1	 Добавление	нового	поставщика	журналирования	в приложение ....646
17.3.2	 Замена	ILoggerFactory	по	умолчанию	на	Serilog ............................. 649
17.4 Изменение избыточности сообщений журналов
с по мощью фильтрации  ........................................................................ 653
17.5 Структурное журналирование: создание полезных
сообщений журналов  с возможностью поиска  ................................ 658
17.5.1	 Добавление	поставщика	структурного	журналирования
в приложение ................................................................................... 660

14 Содержание
17.5.2	 Использование	областей	журналирования	для добавления
дополнительных	свойств	в сообщения журнала ............................ 663
Резюме  .................................................................................................................. 665
18 Повышаем безопасность приложения  ................................. 667
18.1 Добавляем протокол HTTPS в приложение  ...................................... 669
18.1.1	 Использование	HTTPS-сертификатов	для	разработки ................ 672
18.1.2	 Настройка	Kestrel	для	использования	сертификата	HTTPS
в промышленном	окружении ........................................................... 674
18.1.3	 Делаем	так, 	чтобы	протокол	HTTPS	использовался
для всего	приложения ...................................................................... 676
18.2 Защита от межсайтового скриптинга  ................................................ 681
18.3 Защита от межсайтовой подделки запросов (CSRF)  ....................... 685
18.4 Вызов веб-API из других доменов с помощью CORS  ..................... 691
18.4.1	 Разбираемся	с CORS	и тем, 	как	он	работает ................................ 692
18.4.2	 Добавление	глобальной	политики	CORS	ко всему приложению .....694
18.4.3	 Добавляем	CORS	к определенным	действиям	веб-API
с помощью	атрибута	EnableCors ................................................... 697
18.4.4	 Настройка	политик	CORS .............................................................. 698
18.5 Изучение других векторов атак  ........................................................... 699
18.5.1	 Обнаружение	и предотвращение	атак	с открытым
перенаправлением ........................................................................... 700
18.5.2	 Предотвращение	атак	с использованием	внедрения
SQL-кода	с по	 мощью	EF	Core	и параметризации ........................... 702
18.5.3	 Предотвращение	небезопасных	прямых	ссылок	на объекты ......... 704
18.5.4	 Защита	паролей	и данных	пользователей ..................................... 705
Резюме  .................................................................................................................. 707
19 Создание специальных компонентов  .................................... 710
19.1 Настройка конвейера промежуточного ПО  ...................................... 711
19.1.1	 Создание	простых	конечных	точек	с по	 мощью	метода
расширения	Run .............................................................................. 713
19.1.2	 Ветвление	конвейера	с по	 мощью	метода	расширения Map .......... 714
19.1.3	 Добавление	в конвейер	с по	 мощью	метода	расширения Use .......... 718
19.1.4	 Создание	специального	компонента	промежуточного ПО ............ 721
19.2 Создание специальных конечных точек с помощью
маршрутизации  конечных точек  ........................................................ 724
19.2.1	 Создание	специального	компонента	маршрутизации
конечных	точек ............................................................................... 725
19.2.2	 Создание	простых	конечных	точек	с по	 мощью	MapGet
и WriteJsonAsync .............................................................................. 729
19.2.3	 Применение	авторизации	к конечным	точкам .............................. 731
19.3 Работа с требованиями к сложной конфигурации  ......................... 733
19.3.1	 Частичное	создание	конфигурации	для	настройки
дополнительных	поставщиков ....................................................... 734
19.3.2	 Использование	сервисов	для	настройки	IOptions
с помощью	IConfigureOptions ........................................................... 736
19.4 Использование стороннего контейнера внедрения
зависимостей  ........................................................................................... 739
Резюме  .................................................................................................................. 743

15 Содержание
20 Создание специальных компонентов MVC
и Razor Pages  .............................................................................................. 745
20.1 Создание специального тег-хелпера Razor  ....................................... 746
20.1.1	 Вывод	информации	об	окружении	с помощью
специального	тег-хелпера ............................................................... 747
20.1.2	 Создание	специального	тег-хелпера	для	условного
скрытия	элементов ........................................................................ 751
20.1.3	 Создание	тег-хелпера	для	преобразования	Markdown	в HTML ......... 753
20.2 Компоненты представления: добавление логики
в частичные представления  ................................................................. 755
20.3 Создание специального атрибута валидации  .................................. 761
20.4 Замена фреймворка валидации на FluentValidation  ...................... 766
20.4.1	 Сравнение	FluentValidation	и атрибутов	DataAnnotations ............ 767
20.4.2	 Добавляем	FluentValidation	в приложение ...................................... 771
Резюме  .................................................................................................................. 773
21 Вызов удаленных API с помощью
IHttpClientFactory  ................................................................................... 775
21.1 Вызов API для протокола HTTP: проблема с классом
HttpClient  .................................................................................................. 776
21.2 Создание экземпляров класса HttpClient с помощью
интерфейса IHttpClientFactory  ............................................................ 782
21.2.1	 Использование	IHttpClientFactory	для	управления
жизненным	циклом	HttpClientHandler ............................................ 783
21.2.2	 Настройка	именованных	клиентов	во	время	регистрации ........... 786
21.2.3	 Использование	типизированных	клиентов
для инкапсуляции	HTTP-вызовов .................................................... 788
21.3 Обработка временных ошибок HTTP с помощью
библиотеки Polly ...................................................................................... 791
21.4 Создание специального обработчика HttpMessageHandler  .......... 794
Резюме  .................................................................................................................. 797
22 Создание фоновых задач и сервисов  ........................................ 799
22.1 Запуск фоновых задач с по мощью интерфейса
IHostedService  ........................................................................................... 800
22.1.1	 Запуск	фоновых	задач	по	таймеру ................................................. 801
22.1.2	 Использование	сервисов	с жизненным	циклом	Scoped
в фоновых	задачах ........................................................................... 805
22.2 Создание сервисов рабочей роли без пользовательского
интерфейса  с использованием IHost .................................................. 807
22.2.1	 Создание	сервиса	рабочей	роли	из	шаблона .................................... 809
22.2.2	 Запуск	сервисов	рабочей	роли	в промышленном	окружении .......... 812
22.3 Координация фоновых задач с по мощью Quartz.NET  ................... 815
22.3.1	 Установка	Quartz.NET	в приложение	ASP.NET	Core ...................... 816
22.3.2	 Настройка	запуска	задания	по	расписанию	с по	 мощью
Quartz.NET ...................................................................................... 818

16 Содержание
22.3.3	 Использование	кластеризации	для	добавления	избыточности
в фоновые	задачи ............................................................................. 821
Резюме  .................................................................................................................. 825
23 Тестирование приложения  ............................................................. 827
23.1 Тестирование в ASP .NET Core  ............................................................... 829
23.2 Модульное тестирование с xUnit  ......................................................... 831
23.2.1	 Создание	первого	тестового	проекта ............................................ 831
23.2.2	 Запуск	тестов	командой	dotnet	test ............................................... 833
23.2.3	 Ссылка	на	приложение	из	тестового	проекта .............................. 835
23.2.4	 Добавление	модульных	тестов	с атрибутами	Fact	и Theory ........ 838
23.2.5	 Тестирование	условий	отказа ........................................................ 842
23.3 Модульное тестирование специального промежуточного ПО  ....843
23.4 Модульное тестирование API-контроллеров  ................................... 846
23.5 Интеграционное тестирование: тестирование всего
приложения в памяти  ............................................................................ 850
23.5.1	 Создание	TestServer	с по	 мощью	пакета	Test	Host ........................... 851
23.5.2	 Тестирование	приложения	с по	 мощью	класса
WebApplicationFactory ..................................................................... 854
23.5.3	 Замена	зависимостей	в классе	WebApplicationFactory ................... 857
23.5.4	 Уменьшение	дублирования	кода	за	счет	создания
специального	класса	WebApplicationFactory ................................... 859
23.6 Изоляция базы данных с по мощью поставщика EF Core
в памяти  .................................................................................................... 861
Резюме  .................................................................................................................. 866
Приложение	А. 	Подготовка	окружения разработки  .................................... 869
Приложение	В. 	Экосистема	 .NET  ...................................................................... 876
Приложение	C. 	Полезные	ссылки  ....................................................................... 895
Предметный	указатель  ..................................................................................... 901

Вступительное	слово
от сообщества
.NET уже много лет является одним из лидирующих фреймворков для
разработки веб-приложений. Пройдя длинный путь от ASP .NET до совре-
менного ASP .NET Core, он вобрал в себя все лучшие подходы к разработ -
ке приложений с отрисовкой на стороне сервера и веб-API-приложений.
ASP .NET Core – продукт с открытым исходным кодом, каждый может
изучить любой аспект его работы. Однако объем кода велик, и не так-
то просто сразу понять, что искать и как разбираться с ним. Microsoft
предоставляет отличную документацию по основам серверной веб-
разработки и ASP .NET Core на официальном сайте, однако этого может
быть недостаточно для выстраивания целостной картины.
Именно поэтому данная книга очень ценна. Автор превосходно зна-
ет ASP .NET Core, работал с ним с первых версий и как никто другой по-
нимает, какие аспекты фреймворка наиболее важны для его успешного
использования. Разработчику, помимо работы с основной логикой при-
ложения, важно понимать, как работать с настройками, журналировани-
ем, авторизацией, как обеспечивать безопасность приложений. Все эти
темы тщательно рассмотрены в книге. Автору удалось охватить широту
фреймворка, рассмотрев большое количество различных аспектов, и при
этом достаточно глубоко разобрать многие из них. Все это позволяет рас -
сматривать эту книгу как отличный способ подробного знакомства с раз-
работкой серверных приложений на .NET.
Систематизированной информации об ASP .NET Core на русском языке
мало. Фреймворк быстро развивается, постоянно появляются новые тер-
мины, и даже те, что давно используются, не всегда имеют устоявшийся
перевод. Мы обсуждали, спорили, думали о том, как читатели будут ис -
кать термины в сети интернет, как они звучат в неформальных беседах.
Что-то получилось хорошо, что-то не очень, но в целом мы довольны
результатом и рады, что такая интересная и полезная книга есть теперь
и на русском языке. Отдельная благодарность автору за простые и по-

18 Вступительное слово от сообщества
нятные примеры кода и отличные иллюстрации, наглядно демонстри-
рующие объясняемые концепции.
Добро пожаловать в мир ASP .NET Core, и приятного чтения!
Российское	сообщество	.NET	разработчиков	DotNet.Ru
Над переводом работали представители сообщества DotNet.Ru:
Игорь Лабутин;
Андрей Беленцов;
Максим Шошин;
Вадим Мингажев;
Сергей Бензенко;
Радмир Тагиров;
Эмиль Янгиров;
Анатолий Кулаков.

Предисловие
ASP .NET Core 5.0 появился в 2020 году, более чем через четыре года пос -
ле выпуска ASP .NET Core 1.0, но ASP .NET также имеет долгую историю,
которая послужила основой и стимулом для развития ASP .NET Core.
Microsoft выпустила первую версию ASP .NET в  2002 году как часть
платформы .NET Framework 1.0. С тех пор она прошла несколько выпус -
ков, в каждом из которых были добавлены функции и расширяемость.
Однако каждый выпуск был построен на основе .NET Framework, поэто-
му она предустановлена во всех версиях Windows.
Это приносит смешанные преимущества: с  одной стороны, сегодня
ASP .NET 4.x является надежной, проверенной в  боях платформой для
создания современных приложений для ОС Windows. С другой стороны,
она ограничена этой зависимостью – изменения в базовой платформе
.NET Framework имеют далеко идущие последствия, в  результате чего
наблю  дается замедление скорости развертывания, а  это оставляет за
бортом многих разработчиков, создающих и развертывающих приложе-
ния для Linux или macOS.
Когда я  впервые начал изучать ASP .NET Core, я  был одним из таких
разработчиков. Будучи в  душе пользователем Windows, я  получил от
свое го работодателя компьютер с macOS и поэтому все время работал на
виртуальной машине. ASP .NET Core обещал все это изменить, позволив
вести разработку и на компьютере с Windows, и на компьютере с macOS.
Можно сказать, что я опоздал во многих отношениях, проявляя актив-
ный интерес только перед выходом релиза-кандидата ASP .NET Core RC2.
К тому моменту существовало уже восемь бета-версий, многие из кото-
рых содержали существенные критические изменения. Не погружаясь во
все это полностью до выхода RC2, я избавился от сырых инструментов
и меняющихся API.
То, что я увидел в тот момент, меня очень впечатлило. ASP .NET Core
позволяет разработчикам использовать имеющиеся у  них знания
о платформе .NET и приложениях ASP .NET MVC, в частности используя
текущие передовые практики, такие как внедрение зависимостей, стро-
го типизированная конфигурация и журналирование. Кроме того, мож -

20 Предисловие
но было создавать и развертывать кросс-платформенные приложения.
Я не устоял.
Эта книга появилась во многом благодаря моему подходу к изучению
ASP .NET Core. Вместо того чтобы просто читать документацию и статьи
в блогах, я решил попробовать что-то новое и начать писать о том, что
я узнал. Каждую неделю я посвящал время изучению нового аспекта ASP .
NET Core и писал об этом сообщение в блоге. Когда появилась возмож -
ность написать книгу, я  ухватился за этот шанс – это еще один повод
подробно изучить фреймворк!
С тех пор, как я начал писать эту книгу, многое изменилось как в от -
ношении самой книги, так и  ASP .NET Core. Первый крупный выпуск
фреймворка в июне 2016 года по-прежнему имел много шероховатостей,
в частности что касалось работы с инструментами. С выпуском .NET 5.0
в ноябре 2020 года ASP .NET Core действительно стал самостоятельным:
API и инструменты достигли зрелого уровня. Данная книга нацелена на
версию .NET 5.0 для ASP .NET Core, но если вы используете хотя бы вер-
сию .NET Core 3.1, то сможете без проблем работать с этим изданием.
В этой книге рассказывается обо всем, что вам нужно для начала рабо-
ты с ASP .NET Core, независимо от того, новичок ли вы в веб-разработке
или уже являетесь разработчиком ASP .NET. В ней очень много внимания
уделяется самому фреймворку, поэтому я не буду вдаваться в подроб-
ности, касающиеся клиентских фреймворков, таких как Angular и React,
или таких технологий, как Docker. Я также не описываю все новые функ -
ции .NET 5.0, такие как Blazor и gRPC. Вместо этого я даю ссылки, по ко-
торым вы можете найти дополнительную информацию.
Мы сосредоточимся на создании приложений с отрисовкой на сторо-
не сервера, используя страницы Razor и веб-API, применяя контроллеры
MVC. Вы познакомитесь с основами ASP .NET Core, такими как промежу -
точное ПО, внедрение зависимостей и конфигурация, а также узнаете,
как настроить их в соответствии со своими требованиями. Вы узнаете,
как добавить аутентификацию и авторизацию в свои приложения, как
повысить их безопасность, а также как развертывать их и осуществлять
мониторинг. Наконец, вы узнаете, как тестировать приложения, исполь-
зуя модульные и интеграционные тесты.
Лично мне приятно работать с приложениями ASP .NET Core по срав-
нению с приложениями, использующими предыдущую версию ASP .NET,
и надеюсь, что эта страсть проявится в данной книге!

Благодарности
Хотя на обложке этой книги только одно имя, множество людей внесли
свой вклад как в ее написание, так и в публикацию. В этом разделе я хо-
тел бы поблагодарить всех, кто поддерживал меня, оказывал содействие
и терпел меня в течение прошлого года.
Прежде всего я хочу поблагодарить свою девушку Бекки. Твоя постоян-
ная поддержка и воодушевление – все для меня. Они помогли мне пере-
жить этот напряженный период. Ты приняла на себя всю тяжесть этого
стресса и давления, и я бесконечно благодарен тебе. Безмерно люблю тебя.
Я также хотел бы поблагодарить всю свою семью за их поддержку.
В частности, моих родителей, Жен и Боба, за то, что терпели мои разгла-
гольствования, и свою сестру, Аманду, за все ее веселые беседы.
На профессиональном уровне я хотел бы поблагодарить издательство
Manning за предоставленную мне возможность. Брайан Сойер «нашел»
меня в  первом издании этой книги и  побудил меня заняться вторым
изданием. Марина Майклс стала моим редактором-консультантом по
ауди тории второй раз подряд и снова была то дотошной, то критически
настроенной, то обнадеживающей и восторженной. Книга, несомненно,
стала лучше благодаря вашему участию. Я  также благодарю редакто-
ра проекта Дейдру Хиам, редактора Энди Кэрролла, своего корректора
Джейсона Эверетта и редактора-рецензента Михаэла Батиника.
Я благодарен техническому редактору Марку Элстону и  корректору
Тане Уилке. Марк оказал неоценимую поддержку, подчеркнув мои не-
верные предположения и технические предубеждения, касающиеся ра-
боты с хорошо знакомым мне фреймворком. Таня Уилке подтвердила,
что написанный мной код действительно работает и  что он не лишен
смысла.
Я сердечно благодарю всех сотрудников Manning, которые помогли
издать эту книгу и вывести ее на рынок. Я также хотел бы поблагодарить
всех рецензентов MEAP за их комментарии, которые помогли улучшить
книгу.
Я бы никогда не смог написать ее, если бы не отличный контент, соз-
данный сообществом .NET и теми пользователями, на которых я подпи-

22 Благодарности
сан в Twitter. В частности, спасибо Джону Гэллоуэю за регулярное раз-
мещение моего блога на форуме сообщества ASP .NET.
Наконец, спасибо всем друзьям, которые воодушевляли и поддержи-
вали меня и  в  целом проявляли интерес. Возможно, нам не удавалось
встречаться настолько часто, насколько нам хотелось бы, но я с нетер-
пением жду возможности как можно скорее собраться вместе и выпить.
Благодарю всех рецензентов: Эла Пезевски (Al Pezewski), Бена Мак -
намару (Ben McNamara), Даниэля Васкеса (Daniel Vásquez), Филипа Вой-
чешина (Filip Wojcieszyn), Фостера Хейнса (Foster Haines), Густаво Фили-
пе Рамоса Гомеса (Gustavo Filipe Ramos Gomes), Жана-Франсуа Морена
(Jean-François Morin), Джоэля Котарски (Joel Kotarski), Джона Гатри (John
Guthrie), Хуана Луиса Барреду (Juan Luis Barreda), Луиса Му (Luis Moux),
Майка Эриксона (Mike Erickson), Раушана Джа (Raushan Jha), Роба Ройт -
ча (Rob Ruetsch), Рона Лиза (Ron Lease), Рубена Вандегинсте (Ruben Van-
deginste), Сау Фай Фонг (Sau Fai Fong), Стива Лава (Steve Love), Таню
Уилке (Tanya Wilke), Винсента Делкойна (Vincent Delcoigne) и Уиллиса Г.
Хэмптона (Willis G. Hampton) – ваши предложения помогли сделать эту
книгу лучше.

Об	этой	книге
Данная книга посвящена фреймворку ASP .NET Core: в  ней рассказы-
вается о  том, что это такое и  как использовать его для создания веб-
приложений. Хотя часть этой информации уже доступна в  интернете,
она разбросана по сети в виде разрозненных документов и сообщений
в блогах. Эта книга показывает, как создать свое первое приложение, на-
ращивая сложность по мере того, как вы будете закреплять предыдущие
концепции.
Я представляю каждую тему на относительно небольших примерах,
вместо того чтобы создавать одно-единственное приложение на протя-
жении всей книги. У обоих подходов есть свои достоинства, но я хотел
убедиться, что основное внимание уделяется конкретным изучаемым
темам, без умственных затрат на навигацию по растущему проекту.
К концу книги вы должны иметь твердое представление о  том, как
создавать приложения с помощью ASP .NET Core, знать сильные и слабые
стороны фреймворка и как использовать его функции для безопасного
создания приложений. Хотя я  не трачу много времени на архитектуру
приложений, я непременно привожу передовые практики, особенно там,
где лишь поверхностно рассказываю об архитектуре для краткости.
Кому адресована эта книга
Данная книга рассчитана на разработчиков на языке C#, которые заин-
тересованы в изучении кросс-платформенного веб-фреймворка. Она не
предполагает, что у вас есть какой-либо опыт создания веб-приложений,
например вы можете разрабатывать приложения для мобильных
устройств или ПК, хотя предыдущий опыт работы с ASP .NET или другим
веб-фреймворком, несомненно, полезен.
Помимо практических знаний C# и .NET, предполагается наличие зна-
ния общих объектно-ориентированных практик и базового понимания
реляционных баз данных в общем. Я предполагаю, что вы немного знако-
мы с HTML и CSS, а также с тем, что Java Script является языком сценариев
на стороне клиента. Вам не нужно знать Java Script- или CSS-фреймворки

24 Об этой книге
для работы с этой книгой, хотя ASP .NET Core хорошо работает с ними,
если это ваша сильная сторона.
Веб-фреймворки естественным образом затрагивают широкий круг
тем, начиная с базы данных и сети и заканчивая визуальным дизайном
и написанием скриптов на стороне клиента. Я предоставляю как можно
больше контекста и включаю ссылки на сайты и книги, где можно полу -
чить более подробную информацию.
Как организована эта книга: дорожная карта
Эта книга состоит из трех частей, 23 глав и трех приложений. В идеале
вы должны прочитать ее от корки до корки, а затем использовать ее в ка-
чест ве справочника, но я понимаю, что такой вариант подойдет не всем.
Хотя я использую небольшие примеры приложений для демонстрации
той или иной темы, некоторые главы основаны на предыдущих, поэто-
му содержание книги будет иметь больше смысла, если вы будете читать
главы последовательно.
Я настоятельно рекомендую читать главы первой части последова-
тельно, поскольку каждая глава основывается на темах, представленных
в предыдущих главах. Вторую часть также лучше читать последователь-
но, хотя большинство глав независимы, если вы хотите перескакивать
от одной темы к другой. Главы в третьей части можно читать в произ-
вольном порядке, хотя я рекомендую делать это только после того, вы
прошли первую и вторую части.
Первая часть представляет собой общее введение в  ASP .NET Core
и дает общую архитектуру типичного веб-приложения. Изучив основы,
мы переходим к фреймворку Razor Pages, который составляет основную
часть веб-страниц, веб-приложений ASP .NET Core с отрисовкой на сто-
роне сервера и базовой архитектуры Модель–представление–контроллер
# (MVC):
глава 1 знакомит вас с ASP .NET Core и его местом в среде веб-раз ра-
ботки. В ней обсуждается, когда следует и когда не следует исполь-
зовать ASP .NET Core, основы веб-запросов в ASP .NET Core и вариан-
ты, доступные для окружения разработки;
в главе 2 рассматриваются все компоненты базового приложения
ASP .NET Core, обсуждаются их роли и то, как они сочетаются для ге-
нерации ответа на веб-запрос;
в главе 3 описывается конвейер промежуточного ПО, который явля-
ется основным конвейером приложения в ASP .NET Core. Он опреде-
ляет, как обрабатываются входящие запросы и как должен генери-
роваться ответ;
в главе 4 показано, как использовать Razor Pages для создания стра-
ничных веб-сайтов. Razor Pages – это рекомендуемый способ созда-
ния приложений с отрисовкой на стороне сервера в ASP .NET Core,
предназначенный для страничных приложений;
в главе 5 описана система маршрутизации Razor Pages. Маршрути-
зация – это процесс сопоставления URL-адресов входящих запросов

25 Об этой книге
с  определенным классом и  методом, который затем выполняется
для генерации ответа;
в главе 6 рассматривается привязка модели – процесс сопоставле-
ния данных формы и параметров URL-адреса, передаваемых в за-
просе, с конкретными объектами C#;
в главе 7 показано, как создавать HTML-страницы с помощью языка
шаблонов Razor;
глава 8 основывается на главе 7, вводя тег-хелперы, которые могут
значительно сократить объем кода, необходимого для создания
форм и веб-страниц;
в главе 9 описывается, как использовать контроллеры MVC для соз-
дания API-интерфейсов, которые могут вызываться клиентскими
приложениями.
Вторая часть охватывает важные темы для создания полнофункцио-
нальных веб-приложений, после того как вы разберетесь с основами:
в главе 10 описывается, как использовать встроенный контейнер
внедрения зависимостей ASP .NET Core для настройки сервисов ва-
шего приложения;
в главе 11 обсуждается, как считывать параметры и секреты в ASP .
NET Core и как отображать их в строго типизированные объекты;
глава 12 знакомит с библиотекой Entity Framework Core, которая ис -
пользуется для сохранения данных в реляционной базе данных;
глава 13 основывается на темах первой части, знакомя вас с конвейе-
ром фильтров MVC и Razor Pages;
в главе 14 описывается, как добавить профили пользователей
и  аутен тификацию в  свое приложение с  помощью ASP .NET Core
Identity;
глава 15 основывается на предыдущей главе, знакомя вас с автори-
зацией для пользователей, чтобы можно было ограничить страни-
цы, к которым может получить доступ зарегистрированный поль-
зователь;
в главе 16 рассматривается, как опубликовать приложение, настро-
ить его для промышленного окружения и как оптимизировать ре-
сурсы на стороне клиента.
Главы, составляющие третью часть, охватывают важные сквозные
аспекты разработки ASP .NET Core:
в главе 17 показано, как настроить журналирование в приложении
и как писать сообщения журнала в несколько мест;
в главе 18 исследуются соображения относительно безопасности,
которые нужно учитывать при разработке приложения, в том числе
настройка приложения для использования протокола HTTPS;
в главе 19 описывается, как создавать и  использовать различные
специальные компоненты, такие как специальное промежуточное
ПО, и как обрабатывать требования к комплексной конфигурации;
глава 20 расширяет предыдущую главу и показывает, как создавать
специальные компоненты Razor Page, такие как специальные тег-
хелперы и атрибуты валидации;

26 Об этой книге
в главе 21 обсуждается новый интерфейс IHttpClientFactory и то,
как использовать его для создания экземпляров HttpClient для вы-
зова удаленных API;
в главе 22 рассматривается обобщенная абстракция IHost, которую
можно использовать для создания служб Windows и демонов Linux.
Вы также научитесь запускать задачи в фоновом режиме;
в главе 23 показано, как протестировать приложение ASP .NET Core
с помощью фреймворка тестирования xUnit. В ней рассказывается
о модульных и интеграционных тестах с использованием Test Host.
В трех приложениях представлена дополнительная информация:
в приложении A описано, как настроить окружение разработки,
если вы используете Windows, Linux или macOS;
приложение B содержит сведения о .NET 5.0, .NET Core и .NET. Stan-
dard, обсуждает, как они вписываются в среду .NET, и объясняет, что
они значат для ваших приложений;
приложение C содержит ряд ссылок, которые я считаю полезными
при изучении ASP .NET Core.
Соглашения об оформлении программного кода
Данная книга содержит множество примеров исходного кода как в про-
нумерованных листингах, так и в обычном тексте. В обоих случаях исход-
ный код отформатирован шрифтом фиксированной ширины, подобным этому,
чтобы отделить его от обычного текста. Иногда также используется
жирный шрифт, чтобы выделить код, который изменился по сравнению
с предыдущими шагами, например когда в существующую строку кода
добавляется новая функция.
Во многих случаях оригинальный исходный код был переформати-
рован; мы добавили разрывы строк и переработали отступы, чтобы ис -
пользовать доступное пространство на страницах в книге. Кроме того,
комментарии в исходном коде часто удаляются из листингов, если опи-
сание кода приводится в тексте. Многие листинги сопровождаются ан-
нотациями к коду, выделяя важные концепции.
Исходный код предоставляется для всех глав, кроме первой. Исходный
код для каждой главы можно просмотреть в моем репозитории GitHub
на странице https://github.com/andrewlock/asp-dot-net-core-in-action-2e.
ZIP-файл, содержащий весь исходный код, также доступен на сайте из-
дателя: www.manning.com/books/asp-net-core-in-action-second-edition.
Все примеры кода в этой книге используют .NET 5.0 и были созданы
с применением Visual Studio и Visual Studio Code. Чтобы собрать и за-
пустить примеры, необходимо установить .NET SDK, как описано в при-
ложении A.
Автор онлайн
Приобретая книгу «ASP	 .Net	Core	в действии», вы получаете бесплат -
ный доступ на частный веб-форум издательства Manning Publications,

27 Об этой книге
где сможете оставлять отзывы о книге, задавать технические вопросы
и получать помощь от авторов и других пользователей. Чтобы полу -
чить доступ к форуму и зарегистрироваться на нем, откройте в брау -
зере страницу https://livebook.manning.com/book/asp-net-core-in-acti-
on second-edi tion/discussion. Подробнее о форумах Manning и правилах
поведения можно узнать на странице https://livebook.manning.com/#!/
discussion.
Издательство Manning обязуется предоставить своим читателям мес -
то встречи, где может состояться содержательный диалог между отдель-
ными читателями и между читателями и автором. Но со стороны автора
отсутствуют какие-либо обязательства уделять форуму какое-то опреде-
ленное внимание – его присутствие на форуме остается добровольным
(и неоплачиваемым). Мы предлагаем задавать автору стимулирующие
вопросы, чтобы его интерес не угасал!
Форум и архивы предыдущих дискуссий будут оставаться доступны-
ми, пока книга продолжает издаваться.
Об исходном коде
Весь используемый в  этой книге исходный код для книг издательства
«ДМК Пресс» можно найти на сайте www.dmkpress.com или www.дмк.рф
на странице с описанием соответствующей книги.
Отзывы и пожелания
Мы всегда рады отзывам наших читателей. Расскажите нам, что вы ду -
маете об этой книге, – что понравилось или, может быть, не понрави-
лось. Отзывы важны для нас, чтобы выпускать книги, которые будут для
вас максимально полезны.
Вы можете написать отзыв на нашем сайте www.dmkpress.com, зайдя
на страницу книги и  оставив комментарий в  разделе «Отзывы и  ре-
цензии». Также можно послать письмо главному редактору по адресу
dmkpress@gmail.com; при этом укажите название книги в теме письма.
Если вы являетесь экспертом в какой-либо области и заинтересованы
в написании новой книги, заполните форму на нашем сайте по адресу
http://dmkpress.com/authors/publish_book/ или напишите в издательство
по адресу dmkpress@gmail.com.
Список опечаток
Хотя мы приняли все возможные меры для того, чтобы обеспечить высо-
кое качество наших текстов, ошибки все равно случаются. Если вы най-
дете ошибку в одной из наших книг, мы будем очень благодарны, если
вы сообщите о ней главному редактору по адресу dmkpress@gmail.com.
Сделав это, вы избавите других читателей от недопонимания и поможе-
те нам улучшить последующие издания этой книги.

28 Об этой книге
Нарушение авторских прав
Пиратство в интернете по-прежнему остается насущной проблемой. Из-
дательства «ДМК Пресс» и Manning Publications очень серьезно относятся
к вопросам защиты авторских прав и лицензирования. Если вы столкне-
тесь в интернете с незаконной публикацией какой-либо из наших книг,
пожалуйста, пришлите нам ссылку на интернет-ресурс, чтобы мы могли
применить санкции.
Ссылку на подозрительные материалы можно прислать по адресу
элект ронной почты dmkpress@gmail.com.
Мы высоко ценим любую помощь по защите наших авторов, благо-
даря которой мы можем предоставлять вам качественные материалы.

Об	авторе
Эндрю Лок окончил Кембриджский университет со
степенью инженера по специальности «Разработка
программного обеспечения» и получил докторскую
степень в  области обработки цифровых изображе-
ний. Последние 10 лет он профессионально занима-
ется разработкой с использованием .NET , используя
широкий спектр технологий, включая WinForms,
ASP.NET WebForms, ASP.NET MVC и  ASP.NET Web -
pages. Он занимается созданием и сопровождением
приложений ASP.NET Core с момента выхода версии 1.0 в 2016 году. Энд-
рю ведет блог, https://andrewlock.net, посвященный ASP .NET. Core. Он
часто упоминается командой ASP .NET в Microsoft, в блоге .NET и в еже-
недельных выступлениях сообщества. С 2017 года Эндрю является обла-
дателем статуса Microsoft Valued Professional (MVP).

Об	иллюстрации
на обложке
Подпись к иллюстрации на обложке книги гласит: «Капитан Паша. Ка-
пудан-паша, адмирал турецкого флота». Капудан-паша – высшее воен-
ное звание Османского флота с 1567 по 1867 год. Позже этот пост был
упразднен и заменен министром военно-морского флота. Иллюстрация
взята из коллекции костюмов Османской империи, опубликованной
1  января 1802 года Уильямом Миллером с  Олд Бонд-стрит в  Лондоне.
Титульная страница отсутствует в  коллекции, и  нам не удалось отсле-
дить ее. В  оглавлении книги указаны рисунки как на английском, так
и на французском языках, и на каждой иллюстрации указаны имена двух
художников, которые работали над ней, и  оба, без сомнения, были бы
удивлены, обнаружив, что их работы украшают лицевую обложку кни-
ги по программированию... двести лет спустя. Коллекцию купил редак -
тор Manning на антикварном блошином рынке в  «Гараже» на 26-й  За-
падной улице в  Манхэттене. Продавцом был американец из Анкары,
и сделка состоялась, когда он собирал свой стенд. У редактора не было
при себе суммы наличных, необходимой для покупки, а кредитная карта
и чек были вежливо отклонены. В тот вечер продавец вылетал обратно
в Анкару, и ситуация становилась безнадежной. Какое же было принято
решение? Старомодного устного соглашения, скрепленного рукопожа-
тием, оказалось достаточно. Продавец просто предложил сделать ему
денежный перевод, и редактор ушел с клочком бумаги, на котором были
записаны банковские реквизиты, и портфелем изображений под мыш-
кой. Излишне говорить, что мы перевели деньги на следующий же день
и  по-прежнему благодарны и  впечатлены доверием этого неизвестно-
го человека, которое он выказал одному из нас. Мы в Manning высоко
ценим изобретательность, инициативу и, конечно, радость от компью-
терного бизнеса с книжными обложками, основанными на разнообра-
зии жизни в разных регионах два века назад, которое оживает благодаря
картинкам из этой коллекции.

Часть	I
Начало	работы
с ASP.NET Core
В  наши дни веб-приложения встречаются повсюду, от социальных се-
тей и новостных сайтов до приложений на вашем телефоне. За кулисами
почти всегда есть сервер, на котором запущено веб-приложение или API
для HTTP . Ожидается, что веб-приложения будут бесконечно масшта-
бируемыми, будут развертываться в  облаке и  будут высокопроизводи-
тельными. Приступить к работе, может быть, не так просто и в лучшие
времена, а сделать это с такими высокими ожиданиями может оказаться
еще более сложной задачей.
Хорошая новость для вас как читателей заключается в том, что ASP .NET
Core был разработан с учетом этих требований. Если вам нужен простой
веб-сайт, сложное веб-приложение для электронной коммерции или
распределенная сеть микросервисов, вы можете использовать свои зна-
ния в области ASP .NET Core для создания компактных веб-приложений,
соответствующих вашим потребностям. ASP .NET Core позволяет созда-
вать и запускать веб-приложения в Windows, Linux или macOS. Это очень
модульный фреймворк, поэтому вы используете только необходимые
компоненты, сохраняя при этом свое приложение как можно более ком-
пактным и производительным.
В первой части вы пройдете весь путь от самого начала до создания
первого веб-приложения и API. В главе 1 дается общий обзор ASP .NET
Core, который будет особенно полезен, если вы новичок в веб-разработке
в целом. Вы получите первое представление о полноценном приложе-

32 Начало работы с ASP .NET Core
нии ASP .NET Core в главе 2, и мы рассмотрим каждый компонент при-
ложения по очереди и увидим, как они работают вместе для генерации
ответа.
В главе 3 подробно рассматривается конвейер промежуточного ПО,
который определяет, как обрабатываются входящие веб-запросы и  ге-
нерируется ответ. Мы рассмотрим несколько стандартных компонентов
промежуточного ПО и увидим, как фреймворк Razor Pages вписывается
в конвейер. В главах с 4 по 8 мы сосредоточимся на Razor Pages, который
является основным подходом к генерации ответов в приложениях ASP .
NET Core. В главах с 4 по 6 мы исследуем поведение самого фреймвор-
ка Razor Pages, маршрутизацию и привязку модели. В главах 7 и 8 мы
рассмотрим, как создать пользовательский интерфейс для своего при-
ложения, используя синтаксис Razor и тег-хелперы, чтобы пользовате-
ли могли перемещаться по вашему приложению и  взаимодействовать
с ним. Наконец, в главе 9 мы рассмотрим особенности ASP .NET Core, по-
зволяющие создавать веб-API, и увидим, чем это отличается от создания
приложений на основе пользовательского интерфейса.
В первой части много информации, но к ее концу вы будете на пра-
вильном пути к созданию простых приложений с помощью ASP .NET Core.
Я  неизбежно вынужден буду пропустить некоторые сложные аспекты
конфигурации платформы, но вы должны получить хорошее понимание
структуры фреймворка Razor Pages и того, как можно использовать его
для создания динамических веб-приложений. В следующих частях книги
мы подробнее погрузимся в ASP .NET Core, и вы узнаете, как настроить
приложение и добавить дополнительные функции, такие как профили
пользователей.

1Начало	работы
с ASP.NET Core
В этой главе:
что такое ASP.NET Core;
что можно создать с помощью ASP.NET Core;
преимущества и ограничения .NET Core и .NET 5.0;
как работает ASP.NET Core.
Решение изучать новый фреймворк и использовать его для разработки –
это серьезные инвестиции, поэтому важно заранее определить, под-
ходит ли он вам. В этой главе рассказывается об ASP .NET Core: что это
такое, как он работает и почему следует использовать его для создания
своих веб-приложений.
Если вы новичок в том, что касается разработки на платформе .NET, то
эта глава поможет вам составить представление о ней. Для тех, кто уже
имеет опыт разработки на .NET, я даю рекомендации относительно того,
настало ли время подумать о том, чтобы переключить свое внимание на
.NET Core и .NET 5.0, а также о  преимуществах, которые ASP .NET Core
может предложить по сравнению с предыдущими версиями ASP .NET.
К концу этой главы вы должны вполне четко представлять себе, что
такое .NET, какова роль .NET 5.0, и знать основные механизмы работы
ASP .NET Core. Итак, не теряя времени, приступим!

34 Глава 1 Начало работы с ASP.NET Core
1.1 Введение в ASP.NET Core
ASP .NET Core – это кросс-платформенный фреймворк с  открытым ис -
ходным кодом для разработки веб-приложений, который можно исполь-
зовать для быстрого создания динамических приложений с отрисовкой
на стороне сервера. Его также можно применять, чтобы создавать HTTP
API для мобильных приложений, одностраничных приложений для брау -
зеров, например основанных на Angular и React, или других серверных
приложений.
ASP .NET Core предоставляет структуру, вспомогательные функции
и  фрейм ворк для создания приложений, что избавляет вас от необхо-
димости писать бóльшую часть кода самостоятельно. Затем код фрейм-
ворка ASP .NET Core вызывает «обработчиков», которые, в свою очередь,
вызывают методы бизнес-логики вашего приложения, как показано на
рис. 1.1. Эта бизнес-логика является ядром вашего приложения. Здесь вы
можете взаимодействовать с другими сервисами, такими как базы дан-
ных или удаленные API, но обычно бизнес-логика не зависит напрямую
от ASP .NET Core.
Приложения ASP .NET Core
могут обслуживать клиентов,
работающих в браузере, или
могут предоставлять
API-интерфейсы для
мобильных и других клиентовКод фреймворка ASP .NET
обрабатывает низкоуровневые
запросы и вызывает
«обработчиков» контроллеров
Razor Pages и веб-APIВы пишете эти обработчики,
используя примитивы,
предоставляемые
фреймворком. Обычно они
вызывают методы в логике
вашего доменаВаш домен может
использовать внешние
сервисы и базы данных
для выполнения своих
функций и для сохранения
данных
Клиенты,
работающие
в браузере
Мобильное,
одностраничное
приложение, backend-
серверы
Приложение ASP.NET Core
Фреймворк
ASP.Net
CoreRazor Pages
Контроллеры
веб-APIЛогика
домена
(классы C#) Уровень
доступа
к данным
(EF Core/
Dapper) Базы данных
Кеши
Удаленные сервисы
Клиентский уровень Уровень представления Слой
бизнес-логики  Уровень
доступа
к данным Уровень данных
Рис. 1.1 Типичное приложение ASP .NET Core состоит из нескольких уровней. Код фреймворка
ASP .NET Core обрабатывает запросы от клиента, работая со сложным сетевым кодом. Затем
фреймворк вызывает обработчики (Razor Pages и контроллеры веб-API), которые вы пишете
с использованием примитивов, предоставляемых фреймворком. В конце эти обработчики
вызывают логику предметной области вашего приложения, которая обычно представляет собой
классы и объекты C# без каких-либо зависимостей, специфичных для ASP .NET Core

35 Введение в ASP.NET Core
В этом разделе я  расскажу, для чего используется веб-фреймворк,
о  преимуществах и  ограничениях предыдущего фреймворка ASP .NET
и о том, что такое ASP .NET Core и каковы его цели.
В конце этого раздела вы должны иметь четкое представление о том,
почему и для чего был создан ASP .NET Core и почему вы, возможно, за-
хотите его использовать.
1.1.1 Использование веб-фреймворка
Если вы новичок в веб-разработке, то вам может быть непросто перейти
в область, где так много модных словечек и постоянно меняющихся про-
дуктов. Вам, наверное, интересно, неужели все это необходимо знать?
Что сложного в том, чтобы вернуть файл с сервера?
Что ж, вполне возможно создать статическое веб-приложение без ис -
пользования веб-фреймворка, но его возможности будут ограничены.
Как только у вас появится желание обеспечить хоть какую-то безопас -
ность или изменяемость, вы, скорее всего, столкнетесь с трудностями,
и  первоначальная простота, которая привлекала, исчезнет на ваших
глазах.
Подобно тому, как фреймворки для разработки приложений для ПК
и мобильных приложений могут помочь вам создавать нативные при-
ложения, ASP .NET Core может ускорить и  упростить написание веб-
при ло жений, по сравнению с  написанием приложения «с нуля». Он
содержит библиотеки для выполнения распространенных действий,
таких как:
создание динамически изменяющихся веб-страниц;
возможность входа пользователей в веб-приложение;
возможность для пользователей использовать свою учетную запись
Facebook для входа в ваше веб-приложение с помощью OAuth;
обеспечение общей структуры для создания поддерживаемых при-
ложений;
чтение конфигурационных файлов;
работа с изображениями;
журналирование запросов к вашему веб-приложению.
Ключом к любому современному веб-приложению является возмож -
ность создавать динамические веб-страницы. Динамическая	 веб-стра-
ни	ца может отображать разные данные в  зависимости от вошедшего
в  систему пользователя или отображать контент, предоставленный
пользователями. Без динамического фреймворка было бы невозможно
заходить на веб-сайты или отображать какие-либо персонализирован-
ные данные на странице. Существование таких сайтов, как Amazon, eBay
и Stack Overflow (см. рис. 1.2), было бы невозможным.

36 Глава 1 Начало работы с ASP.NET Core
Вопросы, отправленные
пользователями
Просмотр статистики
Голосование пользователей
обновляет результаты
на сервере
Ответы, отправленные
пользователями Рекламные объявления
и статьи в зависимости
от местоположения
и профиля пользователяПользовательские
уведомления Пользователь, вошедший
в систему
Рис. 1.2 Веб-сайт Stack Overflow (https://stackoverflow.com) создан с использованием
ASP .NET и почти полностью является динамическим
Преимущества и ограничения ASP .NET
ASP.NET Core – это новейшая версия популярного веб-фреймворка ASP.NET
от корпорации Microsoft, появившаяся в  июне 2016 года. В  предыдущих
версиях ASP.NET было много поэтапных обновлений, направленных на по-
вышение производительности разработчиков, хотя приоритет отдавался об-
ратной совместимости. ASP.NET Core ломает этот тренд, внося значительные
архитектурные изменения, ставшие результатом пересмотра способа про-
ектирования и построения веб-фреймворка.
ASP.NET Core во многом обязан своему предшественнику ASP.NET, и многие
функции, которые были перенесены в него, существовали и прежде, но ASP.
NET Core – это новый фреймворк. В данном случае был переписан весь стек
технологий, включая как веб-фреймворк, так и базовую платформу.
В основе изменений лежит философия, согласно которой ASP.NET должен
держаться на уровне других современных фреймворков, однако разработ -
чикам .NET по-прежнему должно быть здесь все знакомо.
Чтобы понять, почему корпорация Microsoft решила создать новый фрейм-
ворк, важно понимать преимущества и  недостатки предыдущего веб-
фреймворка ASP.NET.
Первая версия ASP.NET была выпущена в 2002 году как часть .NET Framework
1.0 в ответ на существовавшие тогда традиционные среды для написания
программных сценариев – ASP и PHP. Технология Web Forms позволила раз-
работчикам быстро создавать веб-приложения с  помощью графического
конструктора и простой модели событий, отражающей методы создания на-
стольных приложений.
Фреймворк ASP.NET позволил разработчикам быстро создавать новые при-
ложения, но со временем экосистема веб-разработки изменилась. Стало
очевидно, что у технологии Web Forms много проблем, которые особенно

37 Введение в ASP.NET Core
проявлялись при создании больших приложений. Отсутствие возможности
тестирования, сложная модель с отслеживанием состояния и ограниченное
влияние на сгенерированный HTML-код (что затрудняло разработку на сто-
роне клиента) заставляли разработчиков рассматривать другие варианты.
В ответ корпорация Microsoft выпустила первую версию ASP.NET MVC
в 2009 го  ду на базе паттерна веб-разработки Модель–представление–конт­
роллер , широко используемого в  других фреймворках, таких как Ruby on
Rails, Django и  Java Spring. Этот фреймворк позволил отделять элементы
пользовательского интерфейса от логики приложения, упростил тестирова-
ние и предоставил более полный контроль над процессом генерирования
HTML-кода.
ASP.NET MVC прошел еще четыре этапа с момента первого выпуска, но все
они были построены на одном и том же базовом фреймворке, предоставляе-
мом файлом System.Web.dll. Эта библиотека является частью .NET Framework,
поэтому она предустановлена во всех версиях Windows. Она содержит весь
основной код, используемый ASP.NET при создании веб-приложения.
У данной зависимости есть свои преимущества и недостатки. С одной сто-
роны, фреймворк ASP.NET – это надежная, проверенная в боях платформа,
которая отлично подходит для создания веб-приложений для Windows. Он
предоставляет широкий спектр функций, которые использовались в течение
многих лет, и хорошо известен практически всем веб-разработчикам, рабо-
тающим с этой ОС.
С другой стороны, такая зависимость ограничивает – изменения в базовом
файле System.Web.dll имеют далеко идущие последствия, что замедляет их
реализацию. Это ограничивало скорость развития ASP.NET, и новые выпуски
появлялись только раз в несколько лет. Также существует явная связь с веб-
хостом Windows, Internet Information Service (IIS), что исключает использова-
ние фреймворка на платформах, отличных от Windows.
Совсем недавно Microsoft заявила, что с .NET Framework «завершен». Его не
будут удалять или заменять, но и никакой новой функциональности он не
получит. Следовательно, ASP.NET на базе System.Web.dll также не получит
новую функциональность или обновления.
В последние годы многие веб-разработчики начали обращать внимание
на кросс-платформенные веб-фреймворки, которые могут работать как
в Windows, так и в Linux и macOS. Microsoft почувствовала, что пришло вре-
мя создать фреймворк, который больше не привязан к Windows. Так на свет
появился ASP.NET Core.
1.1.2 Что такое ASP.NET Core?
Разработка ASP .NET Core была обусловлена желанием создать веб-
фреймворк, удовлетворяющий четырем основным требованиям:
возможность кросс-платформенной разработки и запуск на разных
аппаратных платформах и операционных системах;
наличие модульной архитектуры для более простого обслуживания;

38 Глава 1 Начало работы с ASP.NET Core
фреймворк должен быть полностью разработан как программное
обеспечение с открытым исходным кодом;
соответствие текущим тенденциям в  веб-разработке, таким как
клиентские приложения и развертывание в облачной среде.
Для достижения всех этих целей Microsoft нужна была платформа, ко-
торая могла бы предоставить основные библиотеки для создания базо-
вых объектов, таких как списки и словари, а также выполнять, например,
простые операции с файлами. До этого момента разработка в ASP .NET
всегда была привязана к платформе .NET Framework, предназначенной
только для Windows и зависящей от нее. Для ASP .NET Core Microsoft соз-
дала .NET Core (а позже .NET 5.0) – легковесную платформу, работающую
в Windows, Linux и macOS, как показано на рис. 1.3.
ASP .NET Core работает как на .NET
Core, так и на .NET 5.0
.NET Core работает на нескольких
платформах ASP .NET 4.x работает только на
.NET Framework
.NET Framework работает только
в WindowsASP.NET Core
.NET Core / .NET 5.0
Windows
Linux
macOSASP.NET / ASP.NET MVC
.NET Framework
WindowsВеб-фреймворк
Платформа .NET
Операционная
система
Рис. 1.3 Связь между ASP .NET Core, ASP .NET, .NET Core / .NET 5.0 и .NET Framework.
ASP .NET Core работает на .NET Core и .NET 5.0, поэтому является
кросс-платформенным. И наоборот, ASP .NET работает только на .NET Framework,
поэтому она привязана к ОС Windows
ОПРЕДЕЛЕНИЕ  .NET	5.0 – это следующая версия .NET Core, вы-
шедшая после версии 3.1. Она представляет собой объединение
.NET Core и  других платформ .NET в  единую среду выполнения
и фреймворк. Термины .NET Core и .NET 5.0 часто используются
как взаимозаменяемые, но, чтобы следовать языку Microsoft, я ис -
пользую термин .NET 5.0 для обозначения последней версии .NET
Core, а .NET Core – для обозначения предыдущей.
В .NET Core (и ее преемнике .NET 5.0) используется множество тех же
API, что и в .NET Framework, но она более модульная и реализует толь-
ко подмножество функций .NET Framework для упрощения реализации
платформы и  программирования для нее. Это совершенно отдельная

39 Введение в ASP.NET Core
платформа, а не ответвление .NET Framework, хотя в ней используется
аналогичный код для многих ее API.
С помощью .NET 5.0 можно создавать консольные приложения, рабо-
тающие на разных платформах. Microsoft создала ASP .NET Core как до-
полнительный уровень поверх консольных приложений, поэтому преоб-
разование консольного приложения в веб-приложение включает в себя
добавление и организацию библиотек, как показано на рис. 1.4.
Консольное приложение ASP.NET Core
Веб-сервер Kestrel
Логика веб-приложения
Журналирование
Конфигурация  Статические
файлы
Генерирование
HTML-кодаВы пишете консольное приложение .NET 5.0, которое
запускает экземпляр веб-сервера ASP .NET Core
По умолчанию Microsoft предоставляет
кросс-платформенный веб-сервер под названием
Kestrel
Логика вашего веб-приложения управляется Kestrel.
Вы будете использовать различные библиотеки
для активации таких функций, как журналирование
и генерирование HTML-кода по мере необходимости
Рис. 1.4 Модель приложения ASP .NET Core. Платформа .NET 5.0 предоставляет
базовую модель консольного приложения для запуска приложений командной
строки. Добавляя библиотеку веб-сервера, вы преобразуете ее в веб-приложение
ASP .NET Core. Дополнительные функции, такие как конфигурация и журналирование,
добавляются посредством дополнительных библиотек
Добавив веб-сервер ASP .NET Core к своему приложению на .NET 5.0,
вы тем самым даете ему возможность работать как веб-приложение. ASP .
NET Core состоит из множества небольших библиотек. Вы можете вы-
бирать, какую функциональность предоставить своему приложению.
Вряд ли вам понадобятся все доступные библиотеки. Добавляйте только
то, что нужно. Здесь есть распространенные библиотеки, которые будут
присутствовать практически в каждом создаваемом вами приложении,
например библиотеки для чтения конфигурационных файлов или жур-
налирования. Другие библиотеки строятся на основе этих базовых воз-
можностей и используются для обеспечения конкретных функций при-
ложения, таких как вход с  использованием сторонних сервисов вроде
Facebook или Google.
Большинство библиотек, которые вы будете использовать в ASP .NET
Core, можно найти на GitHub в репозиториях Microsoft ASP .NET Core по
адресу https://github.com/dotnet/aspnetcore. Здесь вы найдете основные

40 Глава 1 Начало работы с ASP.NET Core
библиотеки, например для аутентификации и журналирования, а также
множество других внешних библиотек, например для аутентификации
с участием сторонних сервисов.
Все приложения ASP .NET Core будут следовать единому шаблону в ба-
зовой версии, как предлагается стандартными библиотеками, но в целом
фреймворк достаточно гибкий и позволяет создавать собственные стан-
дарты написания кода. Эти стандартные библиотеки, библиотеки рас -
ширений, построенные на их основе, и стандарты проектирования – все
это объединено под несколько расплывчатым термином ASP .NET Core.
1.2 Когда следует отдать предпочтение
ASP.NET Core
Надеюсь, теперь вы имеете общее представление о том, что такое ASP .
NET Core и как он был создан. Но остается вопрос: стоит ли его исполь-
зовать? Корпорация Microsoft рекомендует при работе с  новыми веб-
проектами на .NET использовать ASP .NET Core. Но переход на новый веб-
стек или его изучение – серьезный шаг для любого разработчика либо
компании. В этом разделе я расскажу о том, какие приложения можно
создавать с помощью ASP .NET Core, о некоторых основных характерис -
тиках этого фреймворка, почему следует подумать об использовании
ASP .NET Core при создании новых приложений, а также о том, что следу -
ет учитывать перед переносом уже существующих ASP .NET-приложений
на ASP .NET Core.
1.2.1 Какие типы приложений можно создавать?
ASP .NET Core  – универсальный веб-фреймворк, который можно ис -
пользовать для множества приложений. Совершенно очевидно, что его
можно применять для создания многофункциональных, динамических
веб-сайтов, будь то сайты электронной коммерции, сайты с контентом
или большие многоуровневые приложения – почти все то же самое, что
и в предыдущей версии ASP .NET.
Когда платформа .NET Core только появилась, для создания таких
сложных приложений было доступно всего несколько сторонних библио-
тек. После нескольких лет активной разработки ситуация изменилась.
Многие разработчики обновили свои библиотеки для работы с ASP .NET
Core, и  множество других библиотек создавалось специально для ASP .
NET Core. Например, система управления контентом с открытым исход-
ным кодом Orchard1 превратилась в Orchard Core2 для работы в ASP .NET
1 Исходный код проекта Orchard можно найти на странице https://github.com/
OrchardCMS.
2 Orchard Core (www.orchardcore.net). Исходный код можно найти на странице
https://github.com/OrchardCMS/OrchardCore.

41 Когда следует отдать предпочтение ASP.NET Core
Core, а проект cloudscribe1 (рис. 1.5) писался специально для ASP .NET Core
с момента создания фреймворка.
Рис. 1.5 Веб-сайт .NET Foundation (https://dotnetfoundation.org/) создан с использованием
CMS cloudcribe и ASP .NET Core
Традиционные веб-приложения с отрисовкой на стороне сервера, со-
стоящие из отдельных страниц, являются основой разработки на ASP .
NET. Это касается как предыдущей версии ASP .NET, так и ASP .NET Core.
Кроме того, с помощью ASP .NET Core можно легко создавать одностра-
ничные приложения (SPA), использующие фреймворк для создания поль-
зовательских интерфейсов, который обычно общается с REST-сервером.
Независимо от того, используете ли вы Angular, Vue, React или что-либо
иное, можно легко создать приложение ASP .NET Core, которое будет вы-
ступать в качестве серверного API.
ОПРЕДЕЛЕНИЕ  REST – это аббревиатура, образованная от англ.
Representational State Transfer — «передача состояния представле-
ния». Приложения RESTful обычно используют легковесные HTTP-
вызовы без сохранения состояния для чтения, создания, обновле-
ния и удаления данных.
ASP .NET Core не ограничивается созданием RESTful-сервисов. В  за-
висимости от требований можно легко создать веб-сервис или сервис
1 Проект cloudcribe (www.cloudscribe.com). Исходный код можно найти на стра-
нице https://github.com/cloudscribe.

42 Глава 1 Начало работы с ASP.NET Core
удаленного вызова процедур (RPC) для своего приложения, как показано
на рис. 1.6. В простейшем случае ваше приложение может предоставлять
только одну конечную точку, сужая его область действия до микросер-
виса. ASP .NET Core идеально подходит для создания простых сервисов
благодаря тому, что является кросс-платформенным и легковесным.
Клиент Сервер
Синхронный запрос
по протоколу HTTP
Асинхронный запрос
по протоколу HTTP
Синхронный или асинхронный
запрос по протоколу HTTPОтвет: веб-страница с HTML-кодом
Ответ: часть данных страницы
в формате JSON или XML
Ответ: данные в формате JSON,
XML или двоичного файла Традиционное
веб-приложение
# REST API
Служба RPC
Рис. 1.6 ASP .NET Core может выступать в роли серверного приложения для различных
клиентов: он может обслуживать HTML-страницы для традиционных веб-приложений,
действовать как REST API для клиентских одностраничных приложений или выступать
в качестве специальной службы RPC для клиентских приложений
ПРИМЕЧАНИЕ  В этой книге рассказывается о создании традици-
онных веб-приложений с отрисовкой на стороне сервера, состоя-
щих из отдельных страниц и RESTful веб-API.  В главе 22 я также
показываю, как создавать специальные приложения .NET Core, не
имеющие пользовательского интерфейса – worker service.
При выборе платформы нужно учитывать несколько факторов, не все
из которых являются техническими. Одним из таких факторов являет -

43 Когда следует отдать предпочтение ASP.NET Core
ся уровень поддержки, которую вы ожидаете от ее создателей. Для не-
которых организаций это может быть одним из основных препятствий
на пути внедрения программного обеспечения с  открытым исходным
кодом. К счастью, корпорация Microsoft пообещала обеспечить полную
поддержку версий .NET Core и ASP .NET Core с долгосрочной поддержкой
(LTS) в течение как минимум трех лет с момента их выпуска1. И посколь-
ку вся разработка идет открыто, иногда можно получить ответы на свои
вопросы от сообщества, а также напрямую от Microsoft.
При принятии решения об использовании ASP .NET Core необходимо
учитывать два основных аспекта: являетесь ли вы уже разработчиком
.NET и создаете ли вы новое приложение или хотите перенести сущест -
вующее.
1.2.2 Если вы новичок в разработке на .NET
Если вы новичок в  разработке на .NET и  рассматриваете возможность
использования ASP .NET Core, то добро пожаловать! Microsoft продвига-
ет ASP .NET Core как привлекательный вариант для новичков в веб-раз-
работке, а  переход на кросс-платформенность означает, что он конку -
рирует со многими другими фреймворками на их территории. ASP .NET
Core обладает множеством преимуществ по сравнению с другими кросс-
платформенными веб-фреймворками:
это современный высокопроизводительный веб-фреймворк с  от -
крытым исходным кодом;
он использует уже знакомые паттерны проектирования и  пара-
дигмы;
C# – прекрасный язык (если хотите, то можете использовать VB.NET
или F#);
можно выполнять сборку и запуск на любой платформе.
ASP .NET Core – это переосмысленная версия ASP .NET, созданная с ис -
пользованием современных принципов проектирования программно-
го обеспечения на основе новой платформы .NET Core / .NET 5.0. Хотя
в  каком-то смысле платформа .NET Core и  является новой, она широ-
ко используется уже на протяжении нескольких лет и  в  значительной
степени основана на зрелой, стабильной и  надежной платформе .NET
Framework, которой уже почти два десятилетия. Можете спать спокойно,
зная, что, выбрав ASP .NET Core и .NET 5.0, вы получите надежную плат -
форму, а также полнофункциональный веб-фреймворк.
Многие из доступных на сегодня веб-фреймворков используют ана-
логичные хорошо зарекомендовавшие себя паттерны проектирования,
и ASP .NET Core ничем от них не отстает. Например, Ruby on Rails извес -
тен тем, что использует концепцию Модель–представление–контроллер
(MVC). Node.js известен способом обработки запросов с  помощью не-
1 Ознакомьтесь с политикой поддержки на странице https://dotnet.microsoft.
com/platform/support/policy/dotnet-core.

44 Глава 1 Начало работы с ASP.NET Core
больших дискретных модулей (называемых конвейером), а внедрение за-
висимостей можно найти в самых разных фреймворках. Если эти методы
вам знакомы, то вам будет легко перенести их на ASP .NET Core. Если для
вас все это в новинку, то можете рассчитывать на использование передо-
вых отраслевых методик!
ПРИМЕЧАНИЕ  Вы познакомитесь с конвейером в главе 3, MVC –
в главе 4 и внедрением зависимостей – в главе 10.
Основным языком разработки на .NET и, в  частности, ASP .NET Core
является C#. У этого языка огромное количество поклонников, и не зря!
Будучи объектно-ориентированным языком из семейства C, он не будет
чужд тем, кто привык к C, Java и многим другим языкам. Кроме того, он
имеет множество мощных функций, таких как Language Integrated Query
(LINQ), замыкания и конструкции асинхронного программирования. На
GitHub можно найти репозиторий C#, а также компилятор для C# от кор-
порации Microsoft под кодовым названием Roslyn1.
ПРИМЕЧАНИЕ  В этой книге используется C#. Я выделю несколь-
ко новых его функций, но не буду обучать вас ему с нуля. Если вы
хотите изучить C#, то рекомендую четвертое издание книги «C#
in	Depth», написанной Джоном Скитом (Manning, 2019), и «Code	 as
a Pro	in	C#» Джорта Роденбурга (Manning, 2021).
Одним из основных преимуществ ASP .NET Core и .NET 5.0 является
возможность разработки и запуска на любой платформе. Независимо от
того, используете ли вы Mac, Windows или Linux, вы можете запускать
одни и  те же приложения ASP .NET Core и  вести разработку в  разных
окружениях.
Что касается пользователей Linux, то здесь поддерживается широкий
спектр дистрибутивов (RHEL, Ubuntu, Debian, CentOS, Fedora и openSUSE,
и это лишь некоторые из них), поэтому можете быть уверены, что вы-
бранная вами операционная система будет жизнеспособным вариантом.
ASP .NET Core работает даже в крошечном дистрибутиве Alpine для ком-
пактного развертывания в контейнерах.
Помним о контейнеризации
Традиционно веб-приложения развертывались непосредственно на сер-
вере, а в последнее время – в виртуальной машине. Виртуальные машины
позволяют устанавливать операционные системы на уровне виртуального
оборудования, абстрагируясь от реального аппаратного обеспечения. У этого
варианта есть несколько преимуществ по сравнению с прямой установкой,
например простота обслуживания, развертывания и восстановления. К со-
1 Репозиторий исходного кода GitHub для языка C# и .NET Compiler Platform
можно найти на странице https://github.com/dotnet/roslyn.

45 Когда следует отдать предпочтение ASP.NET Core
жалению, они тяжелы как с точки зрения размера файла, так и с точки зрения
использования ресурсов.
Вот тут-то и пригодятся контейнеры. Контейнеры намного легковеснее и не
имеют больших накладных расходов, как виртуальные машины. Они состоят
из нескольких уровней и не требуют загрузки новой операционной систе-
мы при запуске. Это означает, что они быстро запускаются и отлично под-
ходят для быстрого развертывания. Контейнеры (и, в частности, контейнеры
Docker) быстро становятся популярной платформой для сборки больших
масштабируемых систем.
Контейнеры никогда не были особенно привлекательным вариантом для
приложений ASP.NET, но с появлением ASP.NET Core, .NET 5.0 и Docker для
Windows все изменилось. Легковесное приложение ASP.NET Core, работаю-
щее на кросс-платформенном фреймворке .NET 5.0, идеально подходит для
«тонкого» развертывания контейнеров. Дополнительную информацию о па-
раметрах развертывания можно получить в главе 16.
Помимо работы на разных платформах, одним из преимуществ .NET
является возможность выполнять написание кода и компиляцию толь-
ко один раз. Ваше приложение компилируется в код на промежуточном
языке (IL), не зависящем от платформы. Если в  целевой системе уста-
новлена среда выполнения .NET 5.0, то можно запускать скомпилиро-
ванный код с  любой платформы. Это означает, что можно, например,
вести разработку на компьютере, где установлена ОС Mac или Windows,
и выполнять развертывание абсолютно	 тех	же	файлов на промышлен-
ных машинах с Linux. Такая возможность наконец-то была реализована
с помощью ASP .NET Core и .NET Core / .NET 5.0.
1.2.3 Если вы разработчик, создающий новое приложение
Если вы разработчик .NET, то выбор, вкладывать ли средства в изучение
ASP .NET Core для новых приложений, в значительной степени зависел от
времени. В ранних версиях .NET Core отсутствовали некоторые функции,
что затрудняло его использование. С выпуском .NET Core 3.1 и .NET 5.0
это больше не проблема; Microsoft теперь напрямую советует, что все но-
вые приложения .NET должны использовать .NET 5.0. Microsoft пообеща-
ла предоставить исправления ошибок и безопасности для старой плат -
формы ASP .NET, но больше не будет предоставлять никаких обновлений
функциональности. .NET Framework не будет удаляться, поэтому ваши
старые приложения продолжат работать, но не следует использовать ее
для новых разработок.
Основные преимущества ASP .NET Core по сравнению с предыдущим
фреймворком ASP .NET:
кросс-платформенная разработка и развертывание;
акцент на производительность;
упрощенная модель хостинга;

46 Глава 1 Начало работы с ASP.NET Core
регулярные выпуски с более коротким циклом;
открытый исходный код;
модульные функции.
Если вы разработчик .NET и не используете какие-либо специфичные
для Windows конструкции, такие как реестр, возможность сборки прило-
жений и развертывания их на разных платформах и операционных си-
стемах открывает двери для совершенно нового направления: восполь-
зуйтесь преимуществами более дешевого хостинга виртуальных машин
Linux в облаке, используйте контейнеры Docker для повторяемой непре-
рывной интеграции или пишите код на своем компьютере Mac без необ-
ходимости запускать виртуальную машину Windows. Все это становится
возможным благодаря ASP .NET Core в сочетании с .NET 5.0.
.NET Core и .NET 5.0 по своей сути кросс-платформенны, но при необ-
ходимости все равно можно использовать функции для каждой конкрет -
ной платформы. Например, функции для Windows, такие как реестр или
службы каталогов, можно активировать с помощью пакета совместимо-
сти, который делает эти API-интерфейсы доступными в .NET 5.01.
Они доступны только при запуске .NET 5.0 на Windows, а не Linux или
macOS, поэтому вам необходимо позаботиться о том, чтобы такие при-
ложения работали лишь в Windows или учитывали потенциально отсут -
ствующие API.
Модель хостинга для предыдущего фреймворка ASP .NET была относи-
тельно сложной. Она использовала Windows-сервис IIS для предоставле-
ния веб-хоста. В  кросс-платформенном окружении такие симбиотические
отношения невозможны, поэтому была принята альтернативная модель
хостинга, отделяющая веб-приложения от основного хоста. Эта возмож -
ность привела к  разработке Kestrel: быстрого кросс-платформенного
HTTP-сервера, на котором может работать ASP .NET Core.
Вместо предыдущего варианта, при котором IIS вызывает определен-
ные точки вашего приложения, приложения ASP .NET Core представля-
ют собой консольные приложения, которые самостоятельно размещают
веб-сервер и обрабатывают запросы напрямую, как показано на рис. 1.7.
Эта модель хостинга концептуально намного проще и позволяет тести-
ровать и отлаживать свои приложения из командной строки. Хотя в дан-
ном случае не обязательно избавляться от IIS (или его аналога) в про-
мышленном окружении, как вы увидите в разделе 1.3.
ПРИМЕЧАНИЕ  При желании также можно запустить ASP .NET
Core внутри IIS, как показано на рис. 1.7. Это может дать преиму -
щество в производительности по сравнению с версией с обратным
прокси-сервером. Прежде всего это касается развертывания и не
меняет способ построения приложений.
1 Пакет обеспечения совместимости с Windows предназначен для помощи в пе-
реносе кода с .NET Framework на .NET Core / .NET 5.0. См. https://docs.microsoft.
com/dotnet/core/porting/windows-compat-pack.

47 Когда следует отдать предпочтение ASP.NET CoreУстаревшие приложения ASP .NET используют IIS
для вызова методов непосредственно в вашем
приложенииПриложения ASP .NET Core работают
независимо от IIS и других проксиПриложения ASP .NET Core также могут
выполняться внутри IIS IIS получает
запрос
Запрос
Запрос
ЗапросОтвет
Ответ
ОтветIIS
Обратный
прокси-сервер
(IIS/Apache/
NGINX)IIS вызывает определенные методы
в приложении ASP .NET
Обратный прокси-сервер
передает низкоуровневый
запрос на веб-сервер Kestrel
Обратный
прокси-сервер
получает
запрос
IIS получает
запросПередача управления между
IIS и ASP .NET при возникновении
событий
Kestrel обрабатывает
входящий запрос и передает
его остальной части
приложения Приложение ASP.NET
Application_BeginRequest()  {}
Application_AuthenticateRequest  (){}
Application_AuthorizeRequest  (){}
Application_ProcessRequest()  {}
Application_EndRequest()  {}
Application_HandleError()  {}
Приложение ASP.NET Core
Приложение ASP.NET Core Веб-сервер Kestrel
Веб-сервер KestrelПриложение обрабатывает
запрос и генерирует ответ
Приложение обрабатывает
запрос и генерирует ответ IIS запускает
приложение
в процессе
IIS передает
низкоуровневый
запрос Kestrel
Kestrel обрабатывает входящий
запрос и передает его остальной
части приложения
Рис. 1.7  Разница между моделями размещения в ASP .NET (вверху) и ASP .NET Core (внизу).
В предыдущей версии ASP .NET IIS тесно связан с приложением. Модель размещения
в ASP .NET Core проще; IIS передает запрос на локальный веб-сервер в приложении ASP .NET
Core и получает ответ, но не имеет более детального представления о приложении
Изменение модели хостинга для использования встроенного веб-сер-
вера HTTP создало еще одну возможность. В прошлом производитель-

48 Глава 1 Начало работы с ASP.NET Core
ность была в  некоторой степени проблемой для приложений ASP .NET.
Конечно, можно создавать высокопроизводительные приложения  – Stack
Overflow (https://stackoverflow.com) является тому подтверждением, – но
производительность не является приоритетом самого веб-фреймворка,
поэтому в конечном итоге это может стать препятствием.
Чтобы быть конкурентоспособным среди кросс-платформенных ре-
шений, команда ASP .NET сосредоточилась на том, чтобы сделать HTTP-
сервер Kestrel как можно более быстрым. TechEmpower (www.techemp-
ower.com/benchmark) уже несколько лет проводит тесты для целого ряда
веб-фреймворков для разных языков. В 19-м раунде тестов в виде plain-
text TechEmpower объявила, что ASP .NET Core с Kestrel стал самым быст -
рым из более чем 400 протестированных фреймворков1!
Веб-серверы: проблемы с терминологией
Один из сложных аспектов веб-программирования – это набор часто проти-
воречащих друг другу терминов. Например, если в прошлом вы использовали
IIS, то могли называть его веб-сервером или, возможно, веб-хостом. И наобо-
рот, если вы когда-либо создавали приложение с использованием Node.js, то
могли назвать веб-сервером само приложение. Также веб-сервером можно
назвать физический компьютер, на котором работает ваше приложение!
Точно так же вы, возможно, создавали приложение для интернета и называ-
ли его веб-сайтом или веб-приложением, вероятно, несколько произвольно,
исходя из наличия изменяемого контента.
В этой книге, когда я говорю «веб-сервер» в контексте ASP.NET Core, я имею
в виду HTTP-сервер, который работает как часть вашего приложения ASP.
NET Core. По умолчанию это веб-сервер Kestrel, но это не является обяза-
тельным требованием. При желании можно было бы написать собственный
веб-сервер и использовать его вместо Kestrel.
Веб-сервер отвечает за получение HTTP-запросов и генерирование ответов.
В предыдущей версии ASP.NET эту роль выполнял IIS, но в ASP.NET Core веб-
сервер – это Kestrel.
В этой книге я буду использовать термин «веб-приложение» только для опи-
сания приложений ASP.NET Core, независимо от того, содержат ли они лишь
статический контент или являются полностью динамическими. В любом слу-
чае это приложения, доступ к которым осуществляется по сети, поэтому этот
термин кажется наиболее подходящим.
Многие улучшения производительности, внесенные в Kestrel, исходи-
ли не от самих членов команды ASP .NET, а от участников проекта с от -
1 Как это обычно бывает в веб-разработке, технологии постоянно меняются,
поэтому эти тесты со временем будут эволюционировать. Хотя ASP .NET Core
может и не входить в первую десятку, вы можете быть уверены, что произ-
водительность является одним из ключевых приоритетов команды ASP .NET
Core.

49 Когда следует отдать предпочтение ASP.NET Core
крытым исходным кодом на GitHub1. Открытая разработка означает, что
обычно вы видите, что исправления и новая функциональность внедря-
ются в промышленную эксплуатацию быстрее, чем в предыдущей вер-
сии ASP .NET, которая зависела от .NET Framework и Windows и поэтому
имела длительные циклы выпуска.
Напротив, .NET 5.0, а  следовательно, и  ASP .NET Core предполагают
регулярные небольшие изменения. Старшие версии будут выпускаться
с предсказуемой периодичностью: новая версия будет выходить ежегод-
но, а новая версия с долгосрочной поддержкой (LTS) – каждые два года2.
Кроме того, исправления ошибок и незначительные обновления можно
выпускать по мере необходимости. Дополнительная функциональность
предоставляется в виде пакетов NuGet, независимо от базовой платфор-
мы .NET 5.0.
ПРИМЕЧАНИЕ  NuGet – это менеджер пакетов для .NET, позво-
ляющий импортировать библиотеки в ваши проекты. Он аналоги-
чен Ruby Gems и npm в Java Script или Maven в Java.
ASP .NET Core спроектирован из слабо связанных модулей, что помо-
гает реализовать подобный подход к выпускам. Эта модульность позво-
ляет использовать в  отношении зависимостей принцип «плачу только
за нужное», когда вы начинаете с  «пустого» приложения и добавляете
только те дополнительные библиотеки, которые вам требуются, в отли-
чие от подхода «все сразу», использовавшегося в прежних приложениях
ASP .NET. Сейчас даже необязательно применять MVC! Но не волнуйтесь,
это не означает, что в ASP .NET Core мало функций; просто вам нужно
подключить их. Некоторые ключевые улучшения включают в себя:
«конвейер» с  компонентами, отвечающими за обработку запроса
(middleware pipeline) для определения поведения вашего прило-
жения;
встроенную поддержку внедрения зависимостей;
объединенную инфраструктуру UI (MVC) и API (Web API);
высокорасширяемую систему конфигурации;
масштабируемость для облачных платформ по умолчанию с  ис -
пользованием асинхронного программирования.
Каждая из этих функций была доступна в  предыдущей версии ASP .
NET, но требовала значительного объема дополнительной работы для
настройки. С ASP .NET Core все они уже готовы и ждут подключения!
Microsoft полностью поддерживает ASP .NET Core, поэтому, если вы
хотите создать новую программную систему, нет серьезных причин не
использовать его. Самое большое препятствие, с которым вы, вероятно,
столкнетесь, – это желание применить модели программирования, кото-
1 Проект HTTP-сервера Kestrel можно найти в репозитории ASP .NET Core на
странице https://github.com/dotnet/aspnetcore.
2 График выпуска .NET 5.0 и последующих версий: https://devblogs.microsoft.
com/dotnet/introducing-net-5/.

50 Глава 1 Начало работы с ASP.NET Core
рые больше не поддерживаются в ASP .NET Core, такие как Web Forms или
сервер WCF, о чем я расскажу в следующем разделе.
Надеюсь, этот раздел пробудил в вас желание использовать ASP .NET
Core для создания новых приложений. Но если вы уже работаете с ASP .
NET и рассматриваете возможность переноса существующего ASP .NET-
приложения в ASP .NET Core, то это уже совсем другой вопрос.
1.2.4 Перенос существующего ASP.NET-приложения
на ASP.NET Core
В отличие от новых приложений, существующее приложение, по-види-
мому, уже предоставляет ценность, поэтому переход на ASP .NET Core
в конечном итоге должен принести ощутимо большую пользу, чтобы на-
чать значительно переписывать приложение при миграции с ASP .NET на
ASP .NET Core. Преимущества внедрения ASP .NET Core во многом такие
же, как и  у  новых приложений: кросс-платформенное развертывание,
модульные функции и акцент на производительность. Насколько их до-
статочно, во многом будет зависеть от особенностей вашего приложе-
ния, но есть характеристики, которые являются явными индикаторами
не	в пользу перехода:
ваше приложение использует технологию Web Forms;
ваше приложение создано с использованием WCF;
ваше приложение большое, со множеством «продвинутых» функ -
ций MVC.
Если вы используете Web Forms, не рекомендуется переходить на ASP .
NET Core. Эта технология неразрывно связана с System.Web.dll и как та-
ковая, скорее всего, никогда не будет доступна в  ASP .NET Core. Такой
переход будет фактически включать в себя переписывание приложения
с  нуля. Это не только изменение фреймворков, но и  изменение пара-
дигм проектирования. Лучше было бы постепенно вводить концепции
веб-API и пытаться уменьшить зависимость от устаревших конструкций
Web Forms, таких как ViewData. В сети можно найти множество ресурсов,
которые помогут вам в  этом, в  частности сайт https://dotnet.microsoft.
com/apps/aspnet/apis1.
Фреймворк Windows Communication Foundation (WCF) только частич-
но поддерживается в ASP .NET Core2. Можно использовать какие-то сер-
висы WCF, но поддержка в лучшем случае будет неполноценной. Поддер-
живаемого способа хостинга сервисов WCF из приложения ASP .NET Core
нет, поэтому если вам непременно нужно поддерживать WCF, то лучше
избегать использования ASP .NET Core на данный момент.
1 В качестве альтернативы можно рассмотреть возможность преобразова-
ния своего приложения в Blazor, используя усилия сообщества по созданию
Blazor-версий распространенных компонентов WebForms: https://github.com/
FritzAndFriends/BlazorWebFormsComponents.
2 Клиентские библиотеки для использования WCF с .NET Core можно найти на
странице https://github.com/dotnet/wcf .

51 Как работает ASP.NET Core?
СОВЕТ  Если вам нравится программирование в  стиле RPC, но
у вас нет жестких требований к WCF, рассмотрите возможность ис -
пользования gRPC. gRPC – это современный фреймворк для вызо-
ва удаленных процедур со множеством концепций, аналогичных
WCF. Он поддерживается ASP .NET Core1.
Если у  вас сложное приложение и  оно широко использует предыду -
щие точки расширения MVC, или веб-API, или обработчики сообще-
ний, то его перенос в ASP .NET Core может оказаться более трудным. ASP .
NET Core имеет множество функций, аналогичных предыдущей версии
ASP .NET MVC, но базовая архитектура у  него иная. Некоторые ранее
су ществовавшие функции не имеют прямых заменителей, поэтому их
придется переосмыслить.
Чем крупнее приложение, тем труднее будет перейти на ASP .NET Core.
Microsoft предполагает, что перенос приложения из ASP .NET MVC в ASP .
NET Core – это, по крайней мере, такого же порядка изменение, как пере-
нос приложения из ASP .NET Web Forms в ASP .NET MVC. Если это вас не
пугает, тогда все в порядке!
Если приложение используется редко и не является частью основного
бизнеса или не требует значительного развития в ближайшем будущем,
то я настоятельно рекомендую вам не пытаться переходить на ASP .NET
Core. Microsoft будет поддерживать платформу .NET Framework в обозри-
мом будущем (от нее зависит сама Windows!), и отдача от переноса этих
«второстепенных» приложений вряд ли стоит затраченных усилий.
Итак, когда же следует переносить приложение на ASP .NET Core? Как
я  уже упоминал, наиболее подходящая возможность  – это небольшие
новые проекты с  нуля, а  не существующие приложения. Тем не менее
если существующее приложение невелико или потребует значительного
развития в будущем, перенос может быть хорошим вариантом. По воз-
можности всегда лучше работать небольшими этапами, чем пытаться
сделать все сразу. Но если ваше приложение состоит в основном из конт -
роллеров MVC или веб-API и связанных представлений Razor, переход на
ASP .NET Core может быть неплохим решением.
1.3 Как работает ASP.NET Core?
К настоящему времени вы должны иметь представление о том, что такое
ASP .NET Core и для каких приложений следует его использовать. В этом
разделе вы увидите, как работает приложение, созданное с  помощью
ASP .NET Core, от запроса пользователем URL до отображения страницы
в браузере. Сначала мы рассмотрим, как работает HTTP-запрос к любому
веб-серверу, а затем как ASP .NET Core расширяет этот процесс для созда-
ния динамических веб-страниц.
1 Электронную книгу от Microsoft по gRPC для разработчиков WCF можно найти
на странице https://docs.microsoft.com/en-us/dotnet/architecture/grpc-for-wcf-
developers/.

52 Глава 1 Начало работы с ASP.NET Core
1.3.1 Как работает веб-запрос по протоколу HTTP?
Как вы знаете, ASP .NET Core – это фреймворк для создания веб-прило-
жений, которые отдают данные с сервера. Один из наиболее распростра-
ненных сценариев для веб-разработчиков – создание веб-приложения,
которое можно просматривать в  браузере. Процесс запроса страницы
с любого веб-сервера показан на рис. 1.8.
# <HTML>
# <HEAD></HEAD
# <BODY></BODY>
</HTML>1. Пользователь запрашивает веб-страницу
по URL-адресу 5. Браузер отображает HTML на странице
2. Браузер отправляет
HTTP-запрос на серверhttp://thewebsite.com/the/page.html http://thewebsite.com/the/page.html
Welcome to the web page!
HTTP-запрос
HTTP-ответ4. Сервер отправляет HTML-код
в ответ браузеру
3. Сервер интерпретирует запрос
и генерирует соответствующий HTML-код
Рис. 1.8 Запрос веб-страницы. Пользователь начинает с запроса веб-страницы, что вызывает
отправку HTTP-запроса на сервер. Сервер интерпретирует запрос, генерирует необходимый
HTML и отправляет его обратно в HTTP-ответе. Затем браузер может отобразить веб-страницу

53 Как работает ASP.NET Core?
Процесс начинается, когда пользователь переходит на веб-сайт или вво-
дит URL-адрес в своем браузере. URL-адрес или веб-адрес состоит из имени
хоста и пути к некоему ресурсу в веб-приложении. При переходе по адресу
в браузере запрос с компьютера пользователя отправляется на сервер, на
котором размещено веб-приложение, с использованием протокола HTTP .
ОПРЕДЕЛЕНИЕ  Имя	хоста	веб-сайта однозначно определяет его
местоположение в  интернете путем сопоставления с  IP-адресом
с помощью системы доменных имен (DNS). В качестве примеров
можно упомянуть сайты microsoft.com, www.google.com и  face-
book.com.
Запрос проходит через интернет, возможно, на другую сторону света,
пока наконец не попадет на сервер, связанный с данным именем хоста,
на котором запущено веб-приложение. По пути запрос потенциально
может быть получен и ретранслирован несколькими маршрутизатора-
ми, но обрабатывается только после попадания на сервер, связанный
с именем хоста.
Краткое руководство по HTTP
Протокол передачи гипертекста (Hypertext Transfer Protocol – HTTP) – это
протокол прикладного уровня, обеспечивающий работу в сети. Это прото-
кол, работающий по схеме «запрос–ответ» без сохранения состояния. Кли-
ентский компьютер отправляет запрос на сервер, который, в свою очередь,
передает ответ.
Каждый HTTP-запрос состоит из метода, указывающего «тип» запроса,
и пути, указывающего ресурс, с которым нужно взаимодействовать. Обычно
они также содержат заголовки, представляющие собой пары «ключ-зна че-
ние», а в некоторых случаях тело, например содержимое формы при отправ-
ке данных на сервер.
Ответ содержит код состояния, указывающий на то, был ли запрос успешным,
а также, необязательно, заголовки и тело.
Для получения более подробной информации о  самом протоколе HTTP,
а  также чтобы увидеть другие примеры, см. раздел 1.3 («Краткое введе-
ние в  HTTP») в  книге «Go Web Programming» Сау Шонга Чанга (Manning,
2016), https://livebook.manning.com/book/go-web-programming/chapter-1/
point-9018-55-145-1.
Как только сервер получает запрос, он проверяет, имеет ли он смысл,
и если да, то генерирует ответ. В зависимости от запроса этот ответ мо-
жет быть веб-страницей, изображением, файлом Java Script или простым
подтверждением. В этом примере я предполагаю, что пользователь пе-
решел на домашнюю страницу веб-приложения, поэтому сервер в ответ
выдает некий HTML. Он добавляется к ответу, который затем отправля-
ется обратно через интернет в браузер, отправивший запрос.

54 Глава 1 Начало работы с ASP.NET Core
Как только браузер пользователя начинает получать ответ, он может
приступить к отображению содержимого на экране, но HTML-страница
может также ссылаться на другие страницы и ресурсы на сервере. Чтобы
отобразить веб-страницу целиком, вместо статического бесцветного не-
обработанного HTML-файла браузер должен повторить процесс запро-
са, получая каждый файл, на который есть ссылка. HTML, изображения,
CSS-стили и файлы Java Script, обеспечивающие дополнительное поведе-
ние, – все они получаются с использованием одного и того же процесса
HTTP-запроса.
Практически все взаимодействия, происходящие в  интернете, явля-
ются фасадом одного и того же базового процесса. Для полной отрисовки
базовой веб-страницы может потребоваться всего несколько простых за-
просов, тогда как для современной большой веб-страницы могут потре-
боваться сотни. На момент написания этой главы домашняя страница
Amazon.com (www.amazon.com), например, делает 606 запросов, включая
запросы 3 файлов CSS, 12 файлов Java Script и 402 файлов изображений!
Теперь, когда вы прочувствовали процесс, посмотрим, как ASP .NET
Core динамически генерирует ответ на сервере.
1.3.2 Как ASP.NET Core обрабатывает запрос?
Когда вы создаете веб-приложение с помощью ASP .NET Core, браузеры
по-прежнему будут использовать тот же протокол HTTP , что и раньше,
для обмена данными с вашим приложением. Сам ASP .NET Core охваты-
вает все, что происходит на сервере для обработки запроса, включая про-
верку действительности запроса, обработку данных для входа и генери-
рование HTML.
Как и в случае с примером веб-страницы, процесс запроса начинается,
когда браузер пользователя отправляет HTTP-запрос на сервер, как по-
казано на рис. 1.9.
Ваше приложение получает запрос из сети. Каждое приложение ASP .
NET Core имеет встроенный веб-сервер, по умолчанию это Kestrel, кото-
рый отвечает за получение необработанных запросов и создание внут -
реннего представления данных, объекта HttpContext, который может ис -
пользоваться остальной частью приложения.
Из этого представления ваше приложение может получить все дета-
ли, необходимые для создания соответствующего ответа на запрос. Оно
может использовать данные, хранящиеся в  HttpContext, для формирова-
ния соответствующего ответа. Это может быть генерирование некоего
HTML, возврат сообщения «Доступ запрещен» или отправка электронно-
го письма в зависимости от требований вашего приложения.
Как только приложение завершит обработку запроса, оно вернет от -
вет веб-серверу. Веб-сервер ASP .NET Core преобразует представление
в HTTP-ответ и отправит его в сеть, которая направит его в браузер поль-
зователя.
Для пользователя этот процесс выглядит так же, как и при обычном
HTTP-запросе, показанном на рис. 1.8: пользователь отправил запрос

55 Как работает ASP.NET Core?
и получил ответ. Все различия относятся к серверной части вашего при-
ложения.
Запрос Ответ
Веб-сервер ASP.NET Core
(Kestrel)
Инфраструктура ASP.NET Core
и логика приложения1.  HTTP-запрос отправляется
на сервер и принимается
веб-сервером ASP .NET
Core 5.  Веб-сервер отправляет
ответ браузеру
4.  Ответ проходит через
промежуточное ПО
обратно на веб-сервер2.  Веб-сервер ASP .NET Core
получает HTTP-запрос
и передает его
промежуточному
программному обеспечению
3.  Запрос обрабатывается приложением,
которое генерирует ответ
Рис. 1.9 Как приложение ASP .NET Core обрабатывает запрос. Приложение ASP .NET
Core получает запрос и запускает собственный веб-сервер. Веб-сервер обрабатывает
запрос и передает его телу приложения, которое генерирует ответ и возвращает его
веб-серверу. Веб-сервер отправляет этот ответ браузеру
ASP .NET Core и обратные прокси-серверы
Можно предоставлять доступ к приложениям ASP.NET Core напрямую из ин-
тернета, чтобы Kestrel получал запросы непосредственно из сети. Однако
чаще используется обратный прокси-сервер (reverse proxy-server) между
сетью  и вашим приложением. В Windows обратным прокси-сервером обычно
является IIS, а в Linux или macOS это может быть NGINX, HAProxy или Apache.
Обратный прокси-сервер – это программное обеспечение, отвечающее за
получение запросов и их пересылку на соответствующий веб-сервер. Обрат -
ный прокси-сервер доступен непосредственно из сети интернет, тогда как
базовый веб-сервер доступен только для прокси. Такая настройка имеет не-
сколько преимуществ, в первую очередь это безопасность и производитель-
ность веб-серверов.
Вы можете подумать, что наличие обратного прокси-сервера и веб-сервера
несколько излишне. Почему бы не использовать что-то одно? Что ж, одно из
преимуществ – возможность отделить ваше приложение от операционной
системы сервера. Один и тот же веб-сервер ASP.NET Core, Kestrel, может быть
кросс-платформенным и использоваться за различными прокси-серверами,
не накладывая каких-либо ограничений на конкретную реализацию. Если вы
написали новый веб-сервер, то можете использовать его вместо Kestrel, не
изменяя ничего другого в своем приложении.

56 Глава 1 Начало работы с ASP.NET Core
Еще одним преимуществом обратного прокси-сервера является то, что он
может быть защищен от потенциальных угроз из общедоступного интернета.
Часто прокси-серверы отвечают за дополнительные аспекты, такие как пере-
запуск сбойного процесса. Kestrel может оставаться простым HTTP-сервером,
не беспокоясь об этих дополнительных функциях, если используется за об-
ратным прокси-сервером. Считайте это простым разделением обязанностей:
Kestrel занимается генерированием ответов по протоколу HTTP, а обратный
прокси-сервер занимается обработкой подключения к интернету.
Вы видели, как запросы и ответы попадают в приложение и обратно,
но я еще не коснулся того, как генерируется ответ. В первой части книги
мы рассмотрим компоненты, из которых состоит типичное приложение
ASP .NET Core, и то, как все они сочетаются друг с другом. В создании от -
вета в ASP .NET Core участвует множество компонентов, обычно на все
это уходит доля секунды, но по ходу книги мы будем не спеша проходить
по приложению, подробно описывая каждый из компонентов.
1.4 Что вы узнаете из этой книги
В этой книге вы подробно изучите фреймворк ASP .NET Core. Чтобы из-
влечь пользу из книги, вы должны быть знакомы с C# или аналогичным
объектно-ориентированным языком. Также будет полезно базовое зна-
комство с такими веб-концепциями, как HTML и Java Script. Вы узнаете:
как создавать страничные приложения с помощью Razor Pages;
ключевые концепции ASP .NET Core, такие как привязка модели
(model-binding), валидация и маршрутизация;
как генерировать HTML для веб-страниц с  помощью синтаксиса
Razor и функции Tag Helpers;
как использовать такие функции, как внедрение зависимостей,
конфигурирование и журналирование, по мере того как ваши при-
ложения будут становиться более сложными;
как защитить свое приложение, используя лучшие практики обес -
печения безопасности.
На протяжении всей книги мы будем использовать множество приме-
ров, чтобы изучать и исследовать различные концепции. Приведенные
здесь примеры, как правило, небольшие и автономные, поэтому мы мо-
жем сосредоточиться на одной функции за раз.
Для большинства примеров в  этой книге я  буду использовать Visual
Studio, но вы можете использовать свой любимый редактор или интегри-
рованную среду разработки. В приложении A содержится подробная ин-
формация о настройке вашего редактора или интегрированной среды раз-
работки и установке набора средств разработки .NET 5.0. Несмотря на то
что в примерах этой книги показаны инструменты для Windows, все, что
вы видите, в одинаковой мере применимо для платформ Linux или Mac.

57 Резюме
СОВЕТ  .NET 5.0 можно скачать на странице https://dotnet.micro-
soft.com/download.
В приложении A содержатся дополнительные сведения о том, как на-
строить среду разработки для работы с ASP .NET Core и .NET 5.0.
В следующей главе вы создадите свое первое приложение на основе
шаблона и запустите его. Мы рассмотрим все основные компоненты, из
которых состоит ваше приложение, и увидим, как они все вместе рабо-
тают для отрисовки веб-страницы.
Резюме
ASP .NET Core – это новый фреймворк для разработки веб-приложений,
в  основе которого лежат современные практики архитектуры про-
граммного обеспечения и модульность.
Лучше всего использовать его для создания новых проектов с нуля.
Устаревшие технологии, такие как сервер WCF и Web Forms, нельзя ис -
пользовать с ASP .NET Core.
ASP .NET Core работает на кросс-платформенной платформе .NET 5.0.
Доступ к специфическим функциям Windows, таким как реестр, мож -
но получить с помощью пакета обеспечения совместимости Windows
Compatibility Pack.
.NET 5.0 – это следующая версия .NET Core после .NET Core 3.1.
Получение веб-страницы включает в себя отправку запроса и получе-
ние ответа по протоколу HTTP .
ASP .NET Core позволяет динамически создавать ответы на заданный
запрос.
Приложение ASP .NET Core содержит веб-сервер, который служит точ-
кой входа для запроса.
Приложения ASP .NET Core обычно защищены обратным прокси-сер-
вером, который перенаправляет запросы в приложение.

2Ваше	первое	приложение
В этой главе:
создание первого веб-приложения с использованием ASP.
NET Core;
запуск приложения;
разбор компонентов вашего приложения.
После прочтения первой главы у вас должно было сложиться представле-
ние о том, как работают приложения ASP .NET Core и когда их следует ис -
пользовать. Кроме того, вы должны были настроить среду разработки, ко-
торую можно использовать, чтобы приступить к созданию приложения.
СОВЕТ  См. приложение A, где содержатся инструкции по установ-
ке набора средств разработки .NET 5.0 и выбору редактора и IDE.
В этой главе вы займетесь созданием своего первого веб-приложения.
Вы на практике попробуете понять, как все работает, а в последующих
главах я покажу, как проводить настройку и сборку ваших собственных
приложений.
По мере прохождения этой главы у вас появится представление о ком-
понентах, из которых состоит приложение ASP .NET Core, и  об общем
процессе его построения. Большинство приложений, которые вы разра-

59 Ваше первое приложение
батываете, будут создаваться с использованием шаблона, поэтому реко-
мендуется как можно скорее ознакомиться с его настройкой.
ОПРЕДЕЛЕНИЕ  Шаблон предоставляет базовый код, необходи-
мый для создания приложения. Шаблон можно использовать в ка-
честве отправной точки для создания новых приложений.
Вначале я покажу, как создать простое приложение ASP .NET Core с по-
мощью одного из шаблонов Visual Studio. Если вы используете другие
инструменты, например интерфейс командной строки .NET, вам будут
доступны аналогичные шаблоны. В этой главе я использую Visual Studio
2019, ASP .NET Core 5.0 и .NET 5.0, но также дам советы по работе с интер-
фейсом командной строки .NET.
СОВЕТ  Код приложения для этой главы можно просмотреть в ре-
позитории GitHub по адресу https://github.com /andre wlock/asp-
dot-net -core-in-action-2e.
После создания приложения я покажу вам, как восстановить все необ-
ходимые зависимости, скомпилировать и запустить его, чтобы увидеть
вывод HTML-кода. В некотором смысле это простое приложение – у него
будет только две страницы, – но это будет полностью настроенное при-
ложение ASP .NET Core.
Следующий шаг после запуска вашего приложения  – разобраться
в том, что происходит! Мы пройдемся по всем основным частям прило-
жения, рассмотрим, как настроить веб-сервер, конвейер промежуточно-
го ПО и генерацию HTML-кода. На данном этапе мы не будем вдаваться
в  подробности, но вы увидите, как все компоненты работают сообща,
чтобы создать полноценное приложение.
Мы начнем с файлов, создаваемых при запуске нового проекта, и вы
узнаете, как устроено типичное приложение ASP .NET Core. В частности,
я остановлюсь на файлах Program.cs и Startup.cs. Практически вся кон-
фигурация вашего приложения происходит в этих двух файлах, поэтому
нелишним будет разобраться, для чего они нужны и как используются.
Вы увидите, как сформировать конвейер промежуточного программно-
го обеспечения для своего приложения и как его настроить.
Наконец, вы узнаете, как приложение генерирует HTML-код в ответ на
запрос, рассмотрев компоненты Razor Pages. Вы увидите, как осуществ-
ляется контроль над тем, какой код запускается в ответ на запрос, и как
сформировать HTML-код, который должен возвращаться по конкретному
запросу.
Пусть вас не беспокоит, если какие-то части проекта покажутся вам
запутанными или сложными; вы подробно изучите каждый раздел по
ходу чтения книги. К концу этой главы вы будете иметь общее представ-
ление о  том, как взаимодействуют компоненты приложения ASP .NET
Core, с момента первого запуска приложения до момента генерации от -
вета. Однако, прежде чем начать, мы рассмотрим, как приложения ASP .
NET Core обрабатывают запросы.

60 Глава 2 Ваше первое приложение
2.1 Краткий обзор приложения ASP.NET Core
В первой главе я описал, как браузер выполняет HTTP-запрос к серверу
и  получает ответ, который он использует для отображения HTML-кода
на странице. ASP .NET Core позволяет динамически генерировать этот
код в зависимости от содержимого запроса, чтобы вы могли, например,
отобра жать разные данные в зависимости от текущего пользователя.
Допустим, вы хотите создать веб-приложение, где будет показана ин-
формация о вашей компании. Для этого можно создать простое прило-
жение ASP .NET Core и затем добавить в него динамические функции. На
рис. 2.1 показано, как приложение будет обрабатывать запрос на отобра-
жение страницы.
ЗапросВеб-хост / обратный прокси-сервер
(IIS/Nginx/Apache)Ответ
Веб-сервер ASP.NET Core
Конвейер промежуточного ПО
Компонент конечной точки
Приложение ASP.NET Core 1.  На сервер отправляется
HTTP-запрос к домашней
странице
2.  Запрос перенаправляется
IIS/Nginx/Apache в ваше
приложение ASP .NET Core
3.  Веб-сервер ASP .NET Core
получает HTTP-запрос
и передает его
промежуточному ПО
4.  Промежуточное ПО
обрабатывает запрос
и передает его
промежуточному ПО
конечной точки
5.  Промежуточное ПО
конечной точки генерирует
HTML-код6.  Ответ проходит через
промежуточное ПО
обратно на веб-сервер 7.  Ответ в виде HTML-кода
отправляется в браузер
Рис. 2.1 Обзор приложения ASP.NET Core. Приложение получает входящий
HTTP-запрос от браузера. Каждый запрос передается в конвейер промежуточного
программного обеспечения, который потенциально изменяет его, а затем передает
компоненту конечной точки в конце конвейера для формирования ответа. Ответ
возвращается через промежуточное ПО на сервер и, наконец, в браузер

61 Краткий обзор приложения ASP.NET Core
Большая часть этой диаграммы должна быть вам знакома по рис. 1.8
из первой главы; запрос и ответ, обратный прокси-сервер и веб-сервер
ASP .NET Core – все на месте, но, как вы можете заметить, я  расширил
само приложение, чтобы показать конвейер промежуточного ПО и ком-
понент конечной точки. Это основная настраиваемая часть вашего при-
ложения, генерирующая ответ на запрос.
Первым адресатом, кому обратный прокси-сервер пересылает запрос,
является веб-сервер с ASP .NET Core. По умолчанию это кросс-плат  фор-
мен ный сервер Kestrel. Kestrel принимает низкоуровневый сетевой за-
прос и использует его для создания объекта HttpContext, который может
использоваться остальной частью приложения.
Объект HttpContext
Объект HttpContext, создаваемый веб-сервером ASP.NET Core, используется
приложением как своего рода ящик для хранения данных запроса. Все, что
относится к этому конкретному запросу и последующему ответу, может быть
связано с ним и сохранено в нем. Это могут быть свойства запроса, сервисы,
связанные с запросом, загруженные данные или возникшие ошибки. Веб-
сервер заполняет начальный объект HttpContext данными исходного HTTP-
запроса и другими деталями конфигурации и передает его остальной части
приложения.
ПРИМЕЧАНИЕ  Kestrel – не единственный HTTP-сервер, доступ-
ный в ASP .NET Core, но он кросс-платформенный и самый произ-
водительный. На протяжении всей книги я буду упоминать только
его. Основная его альтернатива, HTTP .sys, работает лишь в  Win-
dows. Его нельзя использовать с IIS.
Kestrel отвечает за получение данных запроса и построение представ-
ления запроса на языке C#, но не пытается сгенерировать ответ напря-
мую. Для этого Kestrel передает объект HttpContext конвейеру промежу -
точного ПО, который есть в каждом приложении ASP .NET Core. Это серия
компонентов, которые обрабатывают входящий запрос для выполнения
распространенных операций, таких как ведение журнала, обработка ис -
ключений или обслуживание статических файлов.
ПРИМЕЧАНИЕ  Подробно о  конвейере промежуточного ПО вы
узнаете в следующей главе.
В конце конвейера находится компонент конечной	 точки. Он отвечает
за вызов кода, который генерирует окончательный ответ. В большинстве
приложений это будет MVC или Razor Pages.
Razor Pages отвечает за создание HTML-кода, из которого состоят
страницы типичного веб-приложения ASP .NET Core. Кроме того, именно
в них обычно можно найти бóльшую часть бизнес-логики приложения,

62 Глава 2 Ваше первое приложение
которая обращается к различным службам, основываясь на данных ис -
ходного запроса. Не каждое приложение использует MVC или Razor Pag-
es, однако это типичный способ построения большинства приложений,
отображающих HTML-код для пользователя.
ПРИМЕЧАНИЕ  Я  расскажу о  Razor Pages и  контроллерах MVC
в главе 4, в ней же вы узнаете, что из них выбрать. О генерации
HTML-кода речь пойдет в главах 7 и 8.
Большинство приложений ASP .NET Core следуют этой базовой архи-
тектуре, и пример, приведенный в данной главе, ничем от них не отли-
чается. Сначала вы узнаете, как создать и запустить приложение, а затем
мы рассмотрим соответствие кода схеме, изображенной на рис. 2.1. Итак,
не тратя времени попусту, приступим к созданию приложения!
2.2 Создание вашего первого приложения
ASP.NET Core
Приложение ASP .NET Core можно создавать разными способами, это за-
висит от инструментов и операционной системы, которые вы используе-
те. Каждый набор инструментов будет иметь несколько разные шаблоны,
однако у них много общего. Пример, используемый в этой главе, основан
на шаблоне Visual Studio 2019, но вы легко можете использовать шабло-
ны из интерфейса командной строки .NET или Visual Studio для Mac.
НАПОМИНАНИЕ  В  этой главе используются Visual Studio 2019,
ASP .NET Core 5.0 и .NET 5.0.
Подготовка и запуск приложения обычно включают в себя четыре ос -
новных шага, которые мы рассмотрим в данной главе:
1  создание	 (new)  – для начала создаем базовое приложение на основе
шаблона;
2  восстановление ( restore) – восстанавливаем все пакеты и зависимо-
сти в локальную папку проекта с по мощью NuGet;
3  сборка	 (build) –	компилируем приложение и генерируем все необхо-
димые ресурсы;
4 запуск	(run) –	 запускаем скомпилированное приложение.
Visual Studio и интерфейс командной строки .NET содержат множест -
во шаблонов ASP .NET Core для создания различных типов приложений.
Например:

63 Создание вашего первого приложения ASP.NET Core
веб-приложение	 Razor	Pages – приложения Razor Pages генерируют
HTML-код на сервере и предназначены для просмотра пользовате-
лями непосредственно в веб-браузере;
приложение	 MVC	(Модель–представление–контроллер) – эти прило-
жения похожи на приложения Razor Pages в том смысле, что они
генерируют HTML-код на сервере и предназначены для просмотра
пользователями непосредственно в  веб-браузере. Вместо Razor
Pages они используют традиционные контроллеры MVC;
приложение	 веб-API  – приложения веб-API возвращают данные
в формате, который может потребляться одностраничными прило-
жениями (SPA) и API. Обычно они используются вместе с клиентски-
ми приложениями, написанными, например, на Angular и React.js,
или мобильными приложениями.
В книге мы рассмотрим каждый из этих типов, но в данной главе со-
средоточимся на шаблоне Razor Pages.
2.2.1 Использование шаблона
Использование шаблона может помочь вам быстро начать работу с при-
ложением, осуществляя автоматическую настройку многих основных
частей. И Visual Studio, и интерфейс командной строки .NET поставля-
ются с определенным набором стандартных шаблонов для создания веб-
приложений, консольных приложений и библиотек классов.
ПОДСКАЗКА  В .NET проект – 	это единица развертывания, кото-
рая будет компилироваться, например, в файл .dll или исполняе-
мый файл. Каждое отдельное приложение – это отдельный проект.
В одном решении можно осуществлять сборку и разработку сразу
нескольких проектов.
Чтобы создать свое первое веб-приложение, откройте Visual Studio
и выполните следующие действия:
1  выберите Create a New Project (Создать новый проект) на экране-
заставке или щелкните File > New > Project (Файл > Создать > Про-
ект) на главном экране Visual Studio;
2  из списка шаблонов выберите ASP.NET Core Web Application
(Веб-при ложение ASP .NET Core). Убедитесь, что выбран языковой
шаблон C#, как показано на рис. 2.2. Нажмите Next (Далее);

64 Глава 2 Ваше первое приложение
Недавно
использованные
шаблоны показаны
слеваИспользуйте фильтры
или поле поиска,
чтобы найти шаблон
Выберите шаблон C#
ASP .NET Core Web
Application
Нажмите Next, чтобы
настроить свой
шаблон
Рис. 2.2 Диалоговое окно нового проекта. Выберите шаблон веб-приложения ASP.NET Core
из списка справа. Когда вы создадите новый проект, то сможете выбрать то, что вам нужно, из
списка недавних шаблонов слева
3  на следующем экране введите имя проекта, расположение и  имя
решения и нажмите Create (Создать), как показано на рис. 2.3. На-
пример, используйте WebApplication1 в  качестве имени проекта
и решения;
Убедитесь, что выбрано
веб-приложение
ASP .NET Core
Введите имя
и местоположение
для вашего проекта
и решенияНажмите Create,
чтобы перейти к выбору
шаблона
Рис. 2.3 Диалоговое окно Configure Your New Project. Чтобы создать новое приложение
.NET 5.0, выберите веб-приложение ASP.NET Core на экране шаблона. На следующем экране
введите имя проекта, расположение и имя решения и нажмите Create
4  на следующем экране (рис. 2.4):
– убедитесь, что выбран .NET Core;
– выберите ASP .NET Core 5.0. Если этот параметр недоступен, убе-
дитесь, что у вас установлена .NET 5.0. См. приложение A для по-
лучения подробной информации о настройке окружения;
– выберите веб-приложение ASP .NET Core, чтобы создать веб-
приложение Razor Pages;

65 Создание вашего первого приложения ASP.NET Core
– убедитесь, что выбран пункт No Authentication (Без аутентифи-
кации). Вы узнаете, как добавлять пользователей в приложение,
в главе 14;
– проверьте, что установлен флажок Configure for HTTPS, а фла-
жок Enable Docker Support (Включить поддержку Docker) снят;
– щелкните Create (Создать);
Убедитесь, что выбран
.NET Core
Выберите
веб-приложение
ASP .NET CoreУбедитесь, что выбран ASP .NET Core 5.0Убедитесь, что для схемы
аутентификации установлено
значение No Authentication
Убедитесь, что параметр
Configure for HTTPS отмечен,
а параметр Enable Docker
Support – нет
Нажмите Create, чтобы
сгенерировать приложение
из выбранного шаблона
Рис. 2.4 Экран шаблона веб-приложения. Он появляется после диалогового окна Configure
Your Project и позволяет настроить шаблон, который будет генерировать ваше приложение.
Для этого начального проекта вы будете создавать веб-приложение Razor Pages без
аутентификации
5  подождите, пока Visual Studio создаст приложение из шаблона.
Когда Visual Studio завершит работу, перед вами откроется вводная
страница об ASP .NET Core, и вы сможете увидеть, что Visual Studio
создала и добавила несколько файлов в ваш проект, как показано
на рис. 2.5.
При первом
создании проекта
отображается
вводная страницаОбозреватель
решений
показывает
файлы в вашем
проекте
Рис. 2.5 Visual Studio после создания нового приложения ASP.NET Core из шаблона.
Обозреватель решений показывает ваш только что созданный проект. На вводной
странице есть полезные ссылки для ознакомления с ASP.NET Core

66 Глава 2 Ваше первое приложение
Если вы не используете Visual Studio, то можно создать аналогичное
приложение с по мощью интерфейса командной строки .NET . Создайте
папку для своего нового проекта. Откройте командную строку Power Shell
или cmd в папке (в Windows) или сеанс терминала (в Linux или macOS )
и выполните команды из этого листинга:
Листинг 2.1  Создание нового приложения Razor Page
с помощью интерфейса командной строки .NET
dotnet new sln -n WebApplication1
dotnet new webapp -o WebApplication1
dotnet sln add WebApplication1
Независимо от того, используете вы Visual Studio или интерфейс
команд ной строки .NET, теперь у вас есть основные файлы, необходи-
мые для создания и запуска вашего первого приложения ASP .NET Core.
2.2.2 Сборка приложения
На данный момент у вас есть основная часть кода, необходимого для за-
пуска вашего приложения, но осталось еще два шага. Во-первых, необ-
ходимо убедиться, что все зависимости, используемые вашим проектом,
копируются в локальный каталог, а во-вторых, нужно скомпилировать
приложение, чтобы можно было его запустить.
Первый шаг не является строго обязательным, поскольку и Visual Stu-
dio, и интерфейс командной строки .NET автоматически восстанавлива-
ют пакеты при первом создании вашего проекта, но будет полезно знать,
как здесь все работает. В более ранних версиях, до 2.0, нужно было вруч-
ную восстанавливать пакеты с по мощью команды dotnet restore.
Можно скомпилировать приложение, выбрав Build > Build Solution
(Сборка > Собрать решение), используя сочетание клавиш Ctrl+Shift+B,
или выполнить команду dotnet build из командной строки. При выпол-
нении сборки из Visual Studio ход сборки отображается в окне вывода,
и если все в порядке, то ваше приложение будет скомпилировано и го-
тово к запуску.
Консольную команду dotnet build  также можно запустить из консоли
диспетчера пакетов в Visual Studio.
ПОДСКАЗКА  Visual Studio и  инструменты интерфейса команд-
ной строки .NET автоматически выполнят сборку вашего прило-
жения при его запуске, если обнаружат, что файл был изменен, по-
этому обычно не нужно явно выполнять этот шаг самостоятельно.Создаем файл решения с именем
WebApplication1 в текущей папке.
Создаем проект Razor Pages во вложенной
папке WebApplication1.
Добавляем новый проект в файл решения.

67 Создание вашего первого приложения ASP.NET Core
Пакеты NuGet и интерфейс командной строки .NET
Одним из основополагающих компонентов кросс-платформенной разработ -
ки на .NET 5.0 является интерфейс командной строки (CLI) .NET. Он предо-
ставляет несколько базовых команд для создания, сборки и запуска прило-
жений .NET 5.0. Visual Studio фактически вызывает их автоматически, но их
также можно вызывать напрямую из командной строки, если вы используете
другой редактор. Наиболее распространенные команды, используемые во
время разработки:
 dotnet restore;
 dotnet build;
 dotnet run.
Каждую из них следует запускать внутри папки вашего проекта, и она будет
выполнена только для этого проекта.
Большинство приложений ASP.NET Core зависят от внешних библиотек,
управление которыми осуществляется с  по мощью менеджера пакетов
NuGet. Эти зависимости перечислены в проекте, но файлы самих библиотек
не включены. Прежде чем вы сможете собрать и запустить свое приложение,
необходимо убедиться, что в папке вашего проекта присутствуют локальные
копии каждой зависимости. Первая команда, dotnet restore, обеспечивает
копирование зависимостей NuGet вашего приложения в папку проекта.
Зависимости проектов ASP.NET Core перечислены в файле проекта .csproj.
Это XML-файл, в котором каждая зависимость перечисляется как узел  Pack-
ageReference. При запуске команды dotnet restore она использует этот
файл, чтобы определить, какие пакеты NuGet нужно загружать и копировать
в папку вашего проекта. Любые перечисленные зависимости доступны для
использования в вашем приложении.
Процесс восстановления пакетов обычно происходит неявно при сборке или
запуске приложения, но иногда может быть полезно запустить его явно, на-
пример в конвейерах сборки с непрерывной интеграцией.
Скомпилировать приложение можно, используя команду dotnet build. При-
ложение будет проверено на наличие ошибок, и если проблем нет, в резуль-
тате получится приложение, которое можно запустить с по мощью команды
dotnet run.
Каждая команда содержит ряд параметров, которые могут изменять ее по-
ведение. Чтобы увидеть полный список доступных команд, запустите
dotnet –help
Чтобы увидеть параметры, доступные для конкретной команды, например
new, запустите
dotnet new –help

68 Глава 2 Ваше первое приложение
2.3 Запуск веб-приложения
Теперь можно запустить наше первое приложение, и сделать это мож -
но несколькими способами. В Visual Studio можно щелкнуть по зеленой
стрелке на панели инструментов рядом с  IIS Express или нажать клави-
шу F5. Visual Studio автоматически откроет для вас окно веб-браузера
с  соответствующим URL-адресом, и  через секунду или две вы увидите
свое новое приложение, как показано на рис. 2.6. Кроме того, можно за-
пустить приложение из командной строки с  по мощью инструментов
интерфейса командной строки .NET, используя команду dotnet run, и от -
крыть URL-адрес в  веб-браузере вручную, используя адрес, указанный
в командной строке.
Рис. 2.6 Домашняя страница вашего нового приложения ASP.NET Core. Когда вы
запускаете его из Visual Studio, IIS Express по умолчанию выбирает случайный порт.
Если вы запускаете его из командной строки с по мощью команды dotnet run, ваше
приложение будет доступно по адресам http://localhost:5000 и https://localhost:5001
СОВЕТ  При первом запуске приложения из Visual Studio вам бу -
дет предложено установить сертификат разработки. Это нужно для
того, чтобы ваш браузер не отображал предупреждения о недей-
ствительном сертификате1. Подробнее о сертификатах HTTPS см.
главу 18.
1 Вы можете установить сертификат разработки в Windows и macOS. Шаги по
настройке доверенных сертификатов в Linux ищите в инструкциях к вашему
дистрибутиву. Не все браузеры (например, Mozilla Firefox) используют храни-
лище сертификатов, поэтому следуйте инструкциям браузера по добавлению
сертификата в список доверенных. Если у вас все еще есть проблемы, см. со-
веты по устранению неполадок по адресу ht tp://mng.bz/1rmy .

69 Запуск веб-приложения
По умолчанию на этой странице отображается простой баннер с при-
ветствием и ссылка на официальную документацию Microsoft по ASP .
NET Core. В  верхней части страницы есть две ссылки: Home (Главная
страница) и  Privacy (Конфиденциальность). Ссылка Главная страни-
ца – это страница, на которой вы находитесь. Щелкнув по ссылке Кон-
фиденциальность, вы перейдете на новую страницу, как показано на
рис. 2.7. Как вы вскоре увидите, для настройки этих двух страниц и соз-
дания отображаемого на них HTML-кода можно использовать функцию
Razor Pages.
Рис. 2.7  Страница Конфиденциальность. Вы можете перемещаться между двумя
страницами приложения, используя ссылки Главная страница и Конфиденциальность
в заголовке приложения. Приложение формирует содержимое страниц с по мощью
Razor Pages
На этом этапе нужно обратить внимание на пару вещей. Первое:
заголовок, содержащий ссылки, и название приложения «WebApplica-
tion1» на обеих страницах одинаковы. Второе: заголовок страницы,
отображаемый на вкладке браузера, изменяется в  соответствии с те-
кущей страницей. Вы увидите, как реализовать эти функции, в главе 7,
когда мы будем обсуждать отрисовку HTML-кода с  использованием
шаб  лонов Razor.
ПРИМЕЧАНИЕ  Вы можете просматривать приложение только
на том компьютере, на котором оно запущено в данный момент;
к  вашему приложению пока еще нельзя получить доступ через
интернет. О том, как опубликовать и развернуть приложение, вы
узнаете в главе 16.
На данном этапе это все, что касается пользовательского опыта. По-
щелкайте по ссылкам и, когда будете довольны тем, как ведет себя при-
ложение, закатайте рукава – пора взглянуть на код!

70 Глава 2 Ваше первое приложение
2.4 Разбираемся с макетом проекта
Создание приложения на основе шаблона имеет свои плюсы и минусы,
особенно если вы делаете это в первый раз. С одной стороны, вы можете
быстро запустить приложение, практически никакого участия с вашей
стороны при этом не требуется. С другой стороны, количество файлов
иногда может быть просто огромным, и вы будете ломать голову, пыта-
ясь понять, с чего начать. Базовый шаблон веб-приложения не содержит
много файлов и папок, как показано на рис. 2.8, я пробегусь по основ-
ным, чтобы вы сориентировались.
Обозреватель решений
из Visual StudioТак выглядят папки в проводнике
Windows или Visual Studio CodeКорневая папка проекта вложена
в каталог решения верхнего
уровня
Узлы Connected Services
и Dependencies не существуют на диске
Папки wwwroot и Properties показаны
в Visual Studio как специальные узлы,
но они есть на диске
Program.cs и Startup.cs управляют
запуском и настройкой
вашего приложения во время
выполнения
Файл с расширением .csproj
содержит всю необходимую информацию
для сборки вашего проекта, включая
пакеты NuGet Файлы управления версиями Git
и файлы с расширением .sln находятся
за пределами папки проекта
Рис. 2.8 Обозреватель решений и папка на диске для нового приложения ASP.NET Core.
Обозреватель решений также отображает узлы Connected Services и Dependencies, в которых
перечислены NuGet и другие зависимости, хотя сами папки не существуют на диске
Первое, на что следует обратить внимание, – это то, что основной про-
ект, WebApplication1, вложен в корневую папку, и само решение носит
то же имя – WebApplication1. В корневой папке вы также найдете файл
решения (.sln) для использования в  Visual Studio и  файлы, связанные
с системой контроля версий Git1, хотя они скрыты в окне обозревателя
решений Visual Studio.
1 Файлы Git будут добавлены только в том случае, если вы выберете пункт Add
to Source Control (Добавить в систему управления версиями) в Visual Studio.
Вам не обязательно использовать Git, но я настоятельно рекомендую исполь-
зовать систему контроля версий при создании приложений. Если вы немного
знакомы с Git, но все же находите ее немного сложной, а команду rebase пуга-
ющей, то настоятельно рекомендую прочитать Think	Like	(a)	Git, http://think -
like-a-git.net/. Это помогло мне достичь просветления при работе с Git.

71 Файл проекта .csproj: определение зависимостей
ПРИМЕЧАНИЕ  Visual Studio использует понятие «решение» для
работы с несколькими проектами. Решение, используемое в качест -
ве примера, состоит только из одного проекта, который указан
в файле .sln. Если вы используете шаблон CLI для создания своего
проекта, у вас не будет файлов .sln или Git, только если вы не соз-
дадите их явно с по мощью дополнительных шаблонов .NET CLI.
Внутри папки решения вы найдете папку проекта, которая, в  свою
очередь, содержит три вложенные папки: Pages, Properties и wwwroot.
В  папке Pages (что неудивительно) находятся файлы Razor Pages, ко-
торые вы будете использовать в  своем приложении. Папка Properties
содержит один файл, launchSettings.json, который управляет запуском
приложения из Visual Studio и его отладкой. Папка wwwroot особенная,
поскольку это единственная папка в  вашем приложении, к  которой
брау зерам разрешен прямой доступ при просмотре веб-приложения.
Здесь приложение может хранить свои файлы CSS, Java Script, изображе-
ния или статические HTML-файлы, а браузеры смогут получать к ним
доступ. Они не смогут получить доступ к файлам, находящимся за пре-
делами папки wwwroot.
Хотя папки wwwroot и Properties есть на диске, видно, что обозрева-
тель решений показывает их как специальные узлы, расположенные не
по алфавиту, в верхней части вашего проекта. У вас есть еще два специ-
альных узла в проекте, Dependencies и Connected Services, но у них нет
соответствующих папок на диске. Они показывают все зависимости про-
екта, такие как пакеты NuGet и удаленные службы.
В корне папки проекта вы найдете два файла JSON: appsettings.json
и appsettings.Development.json. Они предоставляют параметры конфигу -
рации, используемые во время выполнения для управления поведением
вашего приложения.
Самый важный файл в  вашем проекте – WebApplication1.csproj, по-
скольку он описывает, как осуществить сборку проекта. Visual Studio не
отображает файл .csproj явно, но его можно отредактировать, дважды
щелкнув по имени проекта в обозревателе решений. В следующем раз-
деле мы рассмотрим его подробнее.
Наконец, Visual Studio показывает два файла C# в папке проекта – Pro-
gram.cs и Startup.cs. В разделах 2.6 и 2.7 вы увидите, как эти фундамен-
тальные классы отвечают за конфигурирование и запуск вашего прило-
жения.
2.5 Файл проекта .csproj: определение
зависимостей
Файл .csproj представляет собой файл проекта .NET приложения и содер-
жит данные, необходимые инструментам .NET для сборки. Он опреде-
ляет тип создаваемого проекта (веб-приложение, консольное приложе-

72 Глава 2 Ваше первое приложение
ние или библиотека), целевую платформу (.NET Core 3.1, .NET 5.0 и т. д.),
а также то, от каких пакетов NuGet зависит проект.
Файл проекта был основой приложений .NET, но в  ASP .NET Core он
претерпел некоторые изменения, чтобы его было проще читать и редак -
тировать. Эти изменения включают в себя:
отсутствие	 глобально	 уникальных	 идентификаторов – раньше эти
идентификаторы использовались для самых разных вещей, но те-
перь они почти не встречаются в файле проекта;
неявное	 включение	 файла – прежде каждый файл в проекте должен
был быть указан в файле .csproj, чтобы его можно было включить
в сборку. Теперь файлы включаются в проект автоматически;
отсутствие	 путей	к файлам	 .dll	пакета	NuGet – раньше приходи-
лось указывать путь к файлам .dll, содержащимся в пакетах NuGet
в .csproj, а также перечислять зависимости в файле packages.config.
Теперь вы можете ссылаться на пакет NuGet напрямую в  файле
.csproj, и путь на диске указывать не нужно.
Все эти изменения делают файл проекта намного более компактным,
чем тот, который мы привыкли видеть в  предыдущих проектах .NET.
В  следующем листинге показан весь файл .csproj вашего приложения,
используемого в качестве примера.
Листинг 2.2  Файл проекта .csproj, показывающий набор средств
разработки, целевой фреймворк и ссылки
<Project Sdk="Microsoft.NET.Sdk.Web">
<PropertyGroup>
<TargetFramework>net5.0</TargetFramework>
</PropertyGroup>
</Project>
Для простых приложений вам, вероятно, не потребуется сильно ме-
нять файл проекта. Атрибут Sdk в элементе Project включает настройки
по умолчанию, которые описывают, как собрать проект, тогда как эле-
мент TargetFramework описывает фреймворк, на котором будет запус -
каться ваше приложение. Для проектов .NET Core 3.1 это будет значение
netcore-app3.1; если вы используете .NET 5.0, то это будет net5.0.
СОВЕТ  Благодаря новому стилю csproj пользователи Visual Studio
могут дважды щелкнуть по проекту в обозревателе решений, что-
бы отредактировать файл .csproj, не выгружая проект.
Наиболее частые изменения, которые вы будете вносить в файл про-
екта, – это добавление дополнительных пакетов NuGet с по мощью эле-
мента PackageReference. По умолчанию в приложении нет ссылок на па-
кеты NuGet.Атрибут SDK указывает на тип
проекта, который вы создаете.
TargetFramework – это фреймворк. В данном
случае вы будете работать на .NET 5.0.

73 Файл проекта .csproj: определение зависимостей
Использование пакетов NuGet в вашем проекте
Несмотря на то что все приложения в чем-то уникальны, у них есть общие
черты.
Например, большинству приложений требуется доступ к  базе данных или
обработка JSON и XML. Вместо того чтобы заново писать этот код в каждом
проекте, следует использовать существующие готовые библиотеки.
NuGet – это менеджер пакетов библиотек для .NET, где библиотеки упако-
ваны в пакеты NuGet и выложены на сайте https://nuget.org. Их можно ис -
пользовать в своем проекте, указав уникальное имя пакета в файле .csproj.
Таким образом пространство имен и классы пакета станут доступны в ваших
файлах кода. Вы можете публиковать (и размещать) пакеты NuGet в репо-
зиториях, отличных от тех, что находятся на сайте https://nuget.org,   – см.
https://docs.microsoft.com/nuget для получения подробной информации.
Вы можете добавить ссылку на NuGet в свой проект, запустив команду dotnet
add package <packagename> из папки проекта. После этого в файл проекта
будет добавлен узел <PackageReference>, и пакет NuGet будет восстановлен.
Например, чтобы установить популярную библиотеку Newtonsoft.Json, нужно
выполнить команду
dotnet add package Newtonsoft.Json
После этого в файл проекта будет добавлена ссылка на последнюю версию
библиотеки, как показано ниже, а пространство имен Newtonsoft.Json станет
доступным в файлах исходного кода.
<Project Sdk="Microsoft.NET.Sdk.Web">
<PropertyGroup>
<TargetFramework>netcoreapp3.1</TargetFramework>
</PropertyGroup>
<ItemGroup>
<PackageReference Include="NewtonSoft.Json" Version="12.0.3" />
</ItemGroup>
</Project>
Если вы используете Visual Studio, то можно управлять пакетами с по мощью
менеджера пакетов NuGet, щелкнув правой кнопкой мыши на имени реше-
ния или проекта и выбрав пункт Manage NuGet Packages.
Интересно отметить, что официально согласованного произношения NuGet
не существует. Можно спокойно использовать популярные варианты типа
«нугет» или «наггет», а если вы любитель гламура, тогда – «ну-джей»!
Упрощенный формат файла проекта намного легче редактировать
вручную, чем предыдущие версии, и это замечательно, если вы занимае-
тесь кросс-платформенной разработкой. Но если вы применяете Visual
Studio, то это, скорее всего, не ваш путь. Вы по-прежнему можете ис -
пользовать графический интерфейс, чтобы добавлять ссылки на проек -
ты, исключать файлы, управлять пакетами NuGet и т. д. Visual Studio сам
обновит файл проекта, как всегда это делал.

74 Глава 2 Ваше первое приложение
СОВЕТ  Для получения дополнительных сведений об изменениях
в формате csproj см. документацию на странице http://mng.bz/PPGg.
Файл проекта определяет все, что необходимо Visual Studio и интер-
фейсу командной строки .NET для сборки вашего приложения. Все, кро-
ме кода! В следующем разделе мы рассмотрим точку входа для вашего
приложения ASP .NET Core – класс Program.cs.
2.6 Класс Program: сборка веб-хоста
Все приложения ASP .NET Core запускаются так же, как и  приложения
.NET Console,  – с  по мощью файла Program.cs. Данный файл содержит
функцию static void Main, которая является стандартной точкой входа
для консольных приложений. Эта функция вызывается каждый раз, ког -
да вы запускаете свое веб-приложение.
СОВЕТ  В  .NET 5.0 и  C# 9 были введены «инструкции верхнего
уровня», которые неявно создают точку входа Main. В  этой книге
я их не использую, но они поддерживаются в ASP .NET Core 5.0. Под-
робности смотрите в документации по адресу http://mng.bz/JDaP .
В приложениях ASP .NET Core точка входа Main применяется для созда-
ния и запуска экземпляра IHost, что видно в следующем листинге, где по
умолчанию показан файл Program.cs.
IHost – это ядро приложения ASP .NET Core, содержащее конфигура-
цию приложения и сервер Kestrel, который обслуживает запросы и от -
правляет ответы.
Листинг 2.3  Файл Program.cs по умолчанию настраивает
и запускает IWebHost
public class Program
{
public static void Main(string[] args)
{
CreateHostBuilder(args)
.Build()
.Run();
}
public static IHostBuilder CreateHostBuilder(string[] args) =>
Host.CreateDefaultBuilder(args)
.ConfigureWebHostDefaults(webBuilder =>
{
webBuilder.UseStartup<Startup>();
};
}
} Создаем IHostBuilder с по мощью
метода CreateHostBuilder.
Создаем и возвращаем экземпляр
IHost из IHostBuilder.
Запускаем IHost
и начинаем
прослушивать запросы
и генерировать ответы.Создаем IHostBuilder,
используя
конфигурацию
по умолчанию.
Настраиваем приложение для использования
Kestrel и прослушивания HTTP-запросов.Класс Startup определяет большую часть
конфигурации вашего приложения.

75 Класс Program: сборка веб-хоста
Функция Main содержит весь основной код инициализации, необ-
ходимый для создания веб-сервера и  начала обработки запросов. Она
использует IHostBuilder, создаваемый вызовом CreateDefaultBuilder,
чтобы определить настройки IHost перед созданием экземпляра  IHost
с по мощью вызова Build() .
ПРИМЕЧАНИЕ  Паттерн Строитель для конфигурирования
сложного объекта широко используется в  ASP .NET Core. Это по-
лезный метод, позволяющий пользователям настраивать объект,
откладывая его создание до завершения всех настроек, и один из
паттернов, описанных в книге «Банды четырех» – «Паттерны	 про-
ектирования:	 элементы	 объектно-ориентированного	 программного
обеспечения	 многократного	 использования» Эриха Гаммы, Ричарда
Хелма, Ральфа Джонсона и  Джона Влиссидеса (Addison Wesley,
1994).
Большая часть настройки вашего приложения происходит в  IHost-
Builder, создаваемом вызовом метода CreateDefaultBuilder, однако
он делегирует часть ответственности отдельному классу Startup. Класс
Startup, указанный в  обобщенном методе UseStartup<>,  – это место,
в котором вы настраиваете сервисы своего приложения и определяете
конвейер промежуточного ПО. В разделе 2.7 мы немного подробнее рас -
смотрим этот важный класс.
На этом этапе вам, наверное, интересно, зачем нужны два класса для
настройки: Program и  Startup. Почему бы не включить всю настройку
приложения в один из них?
На рис. 2.9 показано типичное разделение компонентов конфигура-
ции между этими классами. Как правило, класс Program – это место, где
вы настраиваете инфраструктуру вашего приложения, такую как HTTP-
сервер, интеграцию с  IIS и  источники конфигурирования, а  в  классе
Startup вы определяете компоненты и функции, используемые вашим
приложением, и конвейер промежуточного ПО для вашего приложения.
Классы Program для двух разных приложений ASP .NET Core обычно бу -
дут похожи, а  вот классы Startup часто будут существенно отличаться
(хотя обычно они следуют схожей схеме, в чем вы скоро убедитесь).
Вы увидите, что вам редко нужно изменять класс Program, по мере того
как ваше приложение будет увеличиваться в размерах, тогда как класс
Startup обычно обновляется всякий раз, когда вы добавляете дополни-
тельные функции. Например, если вы добавите в проект новую зависи-
мость NuGet, то вам зачастую потребуется обновить класс Startup, чтобы
использовать ее.
В классе Program происходит бóльшая часть настройки приложения,
но в шаблонах по умолчанию это скрыто внутри метода CreateDefault-
Builder. CreateDefaultBuilder  – это статический вспомогательный метод,
упрощающий загрузку вашего приложения путем создания IHostBuild-
er с  некой распространенной конфигурацией. В  главе 11 мы заглянем
вглубь этого метода и  изучим систему настройки, но пока достаточно

76 Глава 2 Ваше первое приложение
учитывать рис. 2.9 и знать, что вы можете полностью изменить конфи-
гурацию IHost, если нужно.
Загружает параметры конфигурации
во время выполнения, такие
как строки подключения, имена
пользователей и пароли
Файл Program.cs используется
для настройки инфраструктуры,
которая редко меняется за время
существования проектаКласс Startup  используется
для настройки большей части
настраиваемого поведения вашего
приложения Чтобы правильно создавать
классы во время выполнения,
зависимости регистрируются
в контейнере
Конвейер промежуточного
ПО определяется в коде
класса StartupНастройки приложения
Журналирование
HTTP-сервер
ProgramВнедрение зависимости
StartupКорень содержимогоКонвейер
промежуточного ПО
Интеграция IISКонфигурация
конечной точки
Рис. 2.9 Разница в компонентах конфигурации классов Program и Startup. Класс
Program связан с настройкой инфраструктуры, которая обычно остается стабильной на
протяжении всего жизненного цикла проекта. Что касается класса Startup, то его часто
придется изменять, чтобы добавить новые функции и изменить поведение приложения
Другой вспомогательный метод, применяемый по умолчанию, – это
ConfigureWebHostDefaults. Он использует объект WebHostBuilder, чтобы
настроить Kestrel для обработки HTTP-запросов.
Создание служб с по мощью универсального узла
Может показаться странным, что нужно вызывать методы ConfigureWebHost-
Defaults и CreateDefaultBuilder, –  разве нельзя использовать только один
метод? Разве весь смысл ASP.NET Core – это не обработка HTTP-запросов?
И да, и нет! В ASP.NET Core 3.0 появилась концепция универсального узла.
Он позволяет использовать бóльшую часть того же фреймворка, что и при-
ложения ASP.NET Core, для написания приложений, не поддерживающих
протокол HTTP. Их можно запускать как консольные приложения или уста-
навливать как службы Windows (или как демоны systemd в Linux), например
для выполнения фоновых задач или чтения из очередей сообщений.
Kestrel и веб-платформа ASP.NET Core строятся поверх функциональности
универсального узла, появившейся в ASP.NET Core 3.0. Для настройки типич-
ного приложения ASP.NET Core вы настраиваете функции универсального
узла, общие для всех приложений, такие как конфигурация, журналирование
и  службы зависимостей. Для веб-приложений вы дополнительно настраи-
ваете службы, такие как Kestrel, необходимые для обработки веб-запросов.
В главе 22 вы увидите, как создавать приложения, используя универсальный
узел для выполнения запланированных задач и создания сервисов.

77 Класс Startup: настройка вашего приложения
Как только настройка IHostBuilder будет завершена, после вызова
Build  создается экземпляр IHost, но приложение еще не обрабатывает
HTTP-запросы. Прослушивание сервером HTTP-запросов запускается
после вызова Run. На данный момент ваше приложение находится пол-
ностью в рабочем состоянии и может отвечать на запросы от браузера.
2.7 Класс Startup: настройка вашего приложения
Как вы уже видели, класс Program отвечает за настройку большей части
инфраструктуры вашего приложения, однако некоторая часть поведе-
ния своего приложения настраивается в  классе Startup. Класс Startup
отвечает за настройку двух основных аспектов приложения:
регистрация	 сервисов – 	любые классы, от которых зависит ваше
приложение для обеспечения функциональности, – как те, что ис -
пользуются фреймворком, так и те, что относятся к вашему прило-
жению, – должны быть зарегистрированы, чтобы можно было кор-
ректно создать их экземпляры во время выполнения;
промежуточное	 ПО	и конечные	 точки – как ваше приложение обра-
батывает запросы и отвечает на них.
Каждый из этих аспектов настраивается в отдельном методе в  Startup:
регистрация сервисов в методе  ConfigureServices, а конфигурирование
промежуточного ПО в методе Configure. Типичная структура этого клас -
са показана в следующем листинге.
Листинг 2.4  Схема Startup.cs, показывающая, как настраивается
каждый аспект
public class Startup
{
public void ConfigureServices(IServiceCollection services)
{
//Детали метода;
}
public void Configure(IApplicationBuilder app)
{
//Детали метода;
}
IHostBuilder, созданный в классе Program, вызывает метод Configure-
Services, а  затем метод Configure, как показано на рис.  2.10. Каждый
вызов настраивает отдельную часть вашего приложения, делая ее до-
ступной для последующих вызовов методов. Все сервисы, зарегистриро-
ванные в методе ConfigureServices, доступны для метода Configure. Как
только настройка будет завершена, создается IHost путем вызова метода
Build() объекта IHostBuilder.Настраиваем конвейер
промежуточного ПО для
обработки HTTP-запросов.
Настраиваем сервисы,
зарегистрировав их
в IServiceCollection.

78 Глава 2 Ваше первое приложение
IHost создается в классе Program
с использованием паттерна
Построитель и вспомогательных
методов CreateDefaultBuilder
и CreateWebDefaultsHostBuilder обращается к классу
Startup , чтобы настроить ваше
приложение
Чтобы правильно создавать классы
во время выполнения, зависимости
регистрируются в контейнере в методе
ConfigureServices
Конвейер промежуточного ПО
определяется в методе Configure .
Он контролирует то, как ваше приложение
отвечает на запросы
После завершения настройки
создается IHost путем вызова
метода Build()  IHostBuilderConfigureServices()
Configure()
Startup
Build()
IHost
Program
Рис. 2.10 IHostBuilder создается в файле Program.cs и вызывает методы класса Startup для
настройки сервисов приложения и конвейера промежуточного ПО. Как только настройка будет
завершена, создается IHost путем вызова метода Build() объекта IHostBuilder
Что касается класса  Startup, то здесь есть один интересный момент:
он не реализует никаких интерфейсов. Методы вызываются с по мощью
отражения	 (reflection) для поиска методов с предопределенными имена-
ми Configure и  ConfigureServices. Это делает класс более гибким и по-
зволяет изменять сигнатуру метода, чтобы принимать дополнительные
параметры, которые передаются автоматически. Я  подробно расскажу
о том, как это работает, в главе 10; пока достаточно знать, что все, что
настраивается в методе ConfigureServices, доступно с по мощью метода
Configure.
ОПРЕДЕЛЕНИЕ  Отражение в  .NET позволяет получать инфор-
мацию о типах в  приложении во время выполнения. Отражение
можно использовать для создания экземпляров классов во время
выполнения, а также для их вызова и обращения к ним.
Поскольку класс Startup является фундаментальным для приложений
ASP .NET Core, в  оставшейся части раздела 2.7 вы познакомитесь с  ме-
тодами ConfigureServices и  Configure, чтобы понять, как они исполь-
зуются. Я не буду давать их подробное объяснение (для этого у нас есть
остальная часть книги!), но вы должны иметь в виду, что они следуют
друг за другом и вносят свою лепту в настройку приложения в целом.

79 Класс Startup: настройка вашего приложения
2.7.1 Добавление и настройка сервисов
ASP .NET Core использует небольшие модульные компоненты для каждой
отдельной функции, что позволяет этим функциям развиваться отдель-
но, при этом будучи слабо связанными с другими функциями. Обычно
это считается хорошей практикой проектирования. Обратная сторона
данного подхода состоит в том, что он возлагает ответственность за пра-
вильное создание функции на ее потребителя. В рамках вашего прило-
жения эти модульные компоненты представлены в виде одного или не-
скольких сервисов, используемых приложением.
ОПРЕДЕЛЕНИЕ  В контексте ASP .Net Core под словом сервис	под-
разумевается любой класс, предоставляющий функциональные
возможности приложению. Это могут быть классы, доступ к кото-
рым предоставляется библиотекой, или код, который вы написали
для своего приложения.
Например, в  приложении для онлайн-коммерции у  вас может быть
сервис TaxCalculator, который рассчитывает налог, причитающийся
с определенного продукта, с учетом местоположения пользователя. Или
же у вас может быть сервис ShippingCostService, рассчитывающий стои-
мость доставки к местоположению пользователя. Третий сервис, Order-
TotalCalculatorService, может использовать оба этих сервиса для рас -
чета общей стоимости, которую пользователь должен заплатить за заказ.
Каждый сервис предоставляет небольшую часть независимых функций,
но их можно объединить, чтобы создать законченное приложение. Этот
принцип известен как принцип	единственной	ответственности.
ОПРЕДЕЛЕНИЕ  Принцип	 единственной	 ответственности гла -
сит, что каждый класс должен отвечать только за одну часть функ -
ционала – его следует изменять лишь в случае изменения этого не-
обходимого функционала. Это один из пяти основных принципов
объектно-ориентированного проектирования, изложенных Ро-
бертом Мартином в книге «Быстрая	 разработка	 программ. 	Прин-
ципы,	примеры, 	практика».
Сервису OrderTotalCalculatorService требуется доступ к  экземпляру
сервисов ShippingCostService и  TaxCalculator. Использовать ключевое
слово new и создавать экземпляр сервиса всякий раз, когда он вам пона-
добится, – примитивный подход к этой проблеме. Это тесно привязыва-
ет ваш код к конкретной реализации, которую вы используете, и может
полностью свести на нет все достоинства модульного подхода к проек -
тированию. В  некоторых случаях это может нарушить принцип един-
ственной ответственности, заставляя вас выполнить код инициализации
в дополнение к использованию созданного вами сервиса.

80 Глава 2 Ваше первое приложение
Одно из решений этой проблемы – переложить ее на кого-то другого.
При написании сервиса вы можете объявить свои зависимости и позво-
лить другому классу разрешить эти зависимости за вас. Тогда ваш сервис
может сосредоточиться на функциональности, для которой он был раз-
работан, вместо того чтобы пытаться понять, как собрать свои зависи-
мости.
Этот метод называется внедрением зависимостей, или принципом
инверсии управления (IoC). Это хорошо известный и широко используе-
мый паттерн	проектирования.
ОПРЕДЕЛЕНИЕ  Паттерны	 проектирования – это решения рас -
пространенных проблем проектирования программного обеспе-
чения.
Обычно вы регистрируете зависимости своего приложения в «контей-
нере», который затем можно использовать для создания любого сервиса,
что справедливо как для ваших собственных сервисов приложения, так
и для сервисов фреймворка, используемых ASP .NET Core. Вы должны за-
регистрировать сервис, прежде чем его можно будет использовать в ва-
шем приложении.
ПРИМЕЧАНИЕ  Принцип инверсии зависимостей и  контейнер
IoC, используемый в ASP .NET Core, будут подробно описаны в гла-
ве 10.
В приложении ASP .NET Core эта регистрация выполняется в  методе
ConfigureServices. Каждый раз, когда вы добавляете новую функцию
ASP .NET Core в свое приложение, вам нужно зарегистрировать необхо-
димые сервисы в этом методе. Это не так сложно, как кажется, что видно
из следующего листинга, взятого из приложения, которое используется
в качестве примера.
Листинг 2.5  Startup.ConfigureServices: добавление сервисов
в контейнер IoC
public class Startup
{
// Этот метод вызывается средой выполнения;
// Используем этот метод для добавления сервисов в контейнер;
public void ConfigureServices(IServiceCollection services)
{
services.AddRazorPages();
}
}
Возможно, вас удивит, что готовое приложение Razor Pages включа-
ет в себя только один вызов для добавления необходимых сервисов, но
AddRazorPages() – это метод расширения, инкапсулирующий весь код,
необходимый для настройки сервисов Razor Pages. За кулисами он до-

81 Класс Startup: настройка вашего приложения
бавляет различные сервисы Razor для отрисовки HTML-кода, сервисы
форматирования, маршрутизации и многое другое.
Помимо регистрации сервисов, связанных с фреймворком, с по мощью
этого метода вы регистрируете любые специальные сервисы, которые
есть в  вашем приложении, как, например, рассмотренный ранее Tax-
Calculator. IServiceCollection,  – это список всех известных сервисов,
которые ваше приложение должно будет использовать. Добавляя туда
новый сервис, вы гарантируете, что всякий раз, когда класс объявляет за-
висимость для вашего сервиса, контейнер IoC знает, как ее предоставить.
Теперь, когда все ваши сервисы настроены, пора переходить к оконча-
тельной настройке: определить, как ваше приложение отвечает на HTTP-
запросы.
2.7.2 Определяем, как обрабатываются запросы с по-
мощью промежуточного программного обеспечения
Пока что в классах IHostBuilder  и Startup вы определили инфраструкту -
ру приложения и зарегистрировали свои сервисы в контейнере IoC. В по-
следнем методе конфигурации класса Startup, Configure, вы определяете
конвейер промежуточного ПО для приложения, указывающий, как ваше
приложение обрабатывает HTTP-запросы. Вот метод Configure для шаб-
лонного приложения.
Листинг 2.6  Startup.Configure: определение конвейера промежуточного
программного обеспечения
public class Startup
{
public void Configure(
IApplicationBuilder app,
IWebHostEnvironment env)
{
if (env.IsDevelopment())
{
app.UseDeveloperExceptionPage();
}
else
{
app.UseExceptionHandler("/Error");
app.UseHsts();
}
app.UseHttpsRedirection();
app.UseStaticFiles();
app.UseRouting();
app.UseAuthorization();  IApplicationBuilder используется для создания
конвейера промежуточного программного обеспечения.
В качестве параметров могут быть приняты
другие сервисы.
Разное поведение в зависимости от типа окружения:
окружение разработки или промышленное окружение.
Работает только в окружении разработки.
Работает только
в промышленном окружении.
Добавляет промежуточное ПО
статических файлов.
Добавляет промежуточное ПО маршрутизации
конечных точек, которое определяет, какую
конечную точку выполнить.
Добавляет промежуточное ПО авторизации, которое
при необходимости может блокировать доступ
к определенным страницам.

82 Глава 2 Ваше первое приложение
app.UseEndpoints(endpoints =>
{
endpoints.MapRazorPages();
}
}
}
Как я  писал ранее, промежуточное ПО состоит из небольших ком-
понентов, выполняемых последовательно, когда приложение получает
HTTP-запрос. Они могут выполнять целый ряд функций, таких как жур-
налирование, идентификация текущего пользователя для запроса, об-
служивание статических файлов и обработка ошибок.
IApplicationBuilder, передаваемый методу Configure, используется
для определения порядка, в котором выполняются компоненты. Порядок
вызовов в этом методе важен, поскольку порядок, в котором они добав-
ляются в построитель, – это порядок, в котором они будут выполняться
в конечном конвейере. Компонент может использовать только объекты,
созданные предыдущим компонентом в конвейере, – он не может полу -
чить доступ к объектам, созданным позднее.
ВНИМАНИЕ!  Важно учитывать порядок компонентов при добав-
лении их в конвейер. Компонент может использовать только объ-
екты, созданные предыдущим компонентом в конвейере.
Также следует отметить, что параметр  IWebHostEnvironment использу -
ется для обеспечения другого поведения, когда вы находитесь в окруже-
нии разработки. При запуске в окружении разработки (когда для Envi-
ronmentName задано значение "Development") метод Configure добавляет
в конвейер одну часть промежуточного программного обеспечения для
обработки исключений; в промышленном окружении он добавляет дру -
гую часть.
Объект IWebHostEnvironment содержит сведения о текущем окружении,
как определено IHostBuilder в  классе Program, и  предоставляет доступ
к ряду свойств:
ContentRootPath  – расположение рабочего каталога приложения,
обычно это папка, в которой запускается приложение;
WebRootPath – расположение папки wwwroot, содержащей статиче-
ские файлы;
EnvironmentName – является ли текущее окружение окружением раз-
работки или промышленным окружением.
К моменту вызова класса Startup объект IWebHostEnvironment уже за-
дан; эти значения нельзя изменить в настройках приложения в классе.
Значение свойства  EnvironmentName обычно задается извне с использо-
ванием переменной среды при запуске приложения.
ПРИМЕЧАНИЕ  Вы узнаете о среде размещения и о том, как из-
менить переменные среды, в главе 11. Добавляет промежуточное ПО конечной
точки, которое выполняет страницу Razor
для генерации HTML-кода.

83 Класс Startup: настройка вашего приложения
В окружении разработки DeveloperExceptionPageMiddleware (добав-
ленный в  результате вызова метода UseDeveloper-ExceptionPage()) га-
рантирует, что если ваше приложение выбросит исключение, которое не
было перехвачено, вам будет предоставлено как можно больше инфор-
мации в браузере для диагностики проблемы, как показано на рис. 2.11.
Это похоже на «желтый экран смерти» в предыдущей версии ASP .NET, но
на этот раз он белый, а не желтый.
Рис. 2.11 Страница исключений разработчика содержит множество различных источников
информации, которые помогут вам диагностировать проблему, включая трассировку стека
исключений и подробные сведения о запросе, вызвавшем исключение
ПРИМЕЧАНИЕ  Шаблоны по умолчанию также добавляют
HstsMiddleware в промышленном окружении. В ответе устанавли-
ваются заголовки безопасности в соответствии с передовыми от -
раслевыми практиками. См. главу 18 для получения более подроб-
ной информации об этом и другом промежуточном ПО, связанном
с безопасностью.
При работе в  промышленном окружении раскрытие такого объ-
ема данных пользователям было бы большим риском с точки зрения
безопас ности. Вместо этого регистрируется ExceptionHandlerMiddle-
ware, поэтому если пользователи обнаруживают исключение в вашем
методе, перед ними откроется удобная страница с ошибками, не рас -
крывающая источник проблем. Если вы запустите шаблон по умол-
чанию в промышленном режиме и вызовете ошибку, то вместо этого
увидите сообщение, показанное на рис. 2.12. Очевидно, вам нужно об-
новить эту страницу, чтобы сделать ее более привлекательной и удоб-

84 Глава 2 Ваше первое приложение
ной для пользователей, но, по крайней мере, она не раскрывает внут -
реннюю работу вашего приложения.
Рис. 2.12 Страница обработки исключений по умолчанию. В отличие от страницы исключений
для разработчиков, эта страница не раскрывает пользователям никаких подробностей о вашем
приложении. В реальности можно было бы изменить это сообщение на что-нибудь более
удобное
Следующий компонент, добавляемый в конвейер, – это HttpsRedirec-
tionMiddleware:
app.UseHttpsRedirection();
Этот компонент гарантирует, что ваше приложение отвечает только
на безопасные (HTTPS) запросы, что является общепринятой отраслевой
практикой. Подробнее об HTTPS мы поговорим в главе 18.
StaticFileMiddleware добавляется в конвейер следующим образом:
app.UseStaticFiles();
Этот компонент отвечает за обработку запросов к статическим фай-
лам, таким как файлы CSS, файлы Java Script и изображения. Когда запрос
поступает в компонент, он проверяет, относится ли этот запрос к сущест -
вующему файлу. Если это так, то компонент возвращает файл. Если нет,
то запрос игнорируется, и следующий компонент может попытаться об-
работать запрос. На рис. 2.13 показано, как обрабатывается запрос при
запросе статического файла.

85 Класс Startup: настройка вашего приложения
ЗапросВеб-хост / обратный прокси-сервер
(IIS/Nginx/Apache)Ответ
Веб-сервер ASP.NET Core
Компонент обработчика ошибок
Компонент перенаправления HTTP
Компонент статических файлов
Компонент маршрутизации
Компонент конечной точки1.  Выполняется HTTP-запрос
к статическому файлу по адресу
https://localhost:50714/css/site.css
2.  Запрос перенаправляется сервером
IIS/Nginx/Apache в ASP .NET Core
3.  Веб-сервер ASP .NET Core получает
HTTP-запрос и передает его
промежуточному ПО
4.  Запрос проходит через обработчик
ошибок и промежуточное ПО
перенаправления без изменений
в компонент статических файлов
5.  Компонент статических файлов
обрабатывает запрос, возвращая
соответствующий файл site.css,
замыкающий конвейер6.  Ответ проходит через
промежуточное ПО обратно
на веб-сервер
Поскольку компонент статических
файлов обработал запрос, все
последующее промежуточное ПО
в конвейере не выполняется
и не видит запрос7.  HTTP-ответ, содержащий страницу
site.css, отправляется в браузер
Приложение ASP.NET Core
Рис. 2.13 Обзор запроса к статическому файлу из /css/site.css для приложения ASP.NET Core.
Запрос проходит через конвейер промежуточного ПО, пока не будет обработан компонентом
статических файлов. После этого в качестве ответа возвращается запрошенный файл CSS,
который передается обратно на веб-сервер. Компонент конечной точки не вызывается
и не видит запрос
Когда компонент статических файлов обрабатывает запрос, другой
компонент, который находится в конвейере после него, например ком-
понент маршрутизации или компонент конечной точки, вообще не вы-
зывается.
Теперь мы подошли к наиболее важным составляющим промежуточ-
ного ПО в конвейере: компонентам маршрутизации и конечных точек.
Вместе эта пара отвечает за интерпретацию запроса, чтобы определить,
какую страницу Razor вызывать, за чтение параметров из запроса и за
генерацию финального HTML-кода. Требуется очень небольшая настрой-

86 Глава 2 Ваше первое приложение
ка – нужно только добавить промежуточное ПО в конвейер и указать, что
вы хотите использовать конечные точки страницы Razor, вызвав метод
MapRazorPages. Для каждого запроса компонент маршрутизации исполь-
зует URL-адрес запроса, чтобы определить, какую страницу Razor вы-
звать. Компонент конечной точки фактически выполняет страницу Ra-
zor для генерации ответа в виде HTML-кода.
ПРИМЕЧАНИЕ  В  шаблоны по умолчанию также добавляется
AuthorizationMiddleware между компонентами маршрутизации
и конечной точки. Это позволяет компоненту авторизации решать,
разрешить ли доступ до выполнения страницы Razor. Подробнее
об этом подходе вы узнаете в главе 5, посвященной маршрутиза-
ции, и главе 15, где рассказывается об авторизации.
Уф! Наконец-то вы закончили настройку своего приложения со все-
ми необходимыми параметрами, сервисами и промежуточным ПО. На-
стройка приложения затрагивает широкий спектр различных тем, кото-
рые мы будем рассматривать далее, поэтому не волнуйтесь, если вы еще
не полностью поняли все шаги.
Как только приложение будет настроено, оно может начать обработку
запросов. Но как оно это делает? Я уже упоминал StaticFileMiddleware,
который будет предоставлять пользователю изображения и файлы CSS,
но как насчет запросов, требующих ответа в виде HTML-кода? В остав-
шейся части этой главы я расскажу вам о Razor Pages и о том, как они
генерируют HTML-код.
2.8 Создание ответов с по мощью Razor Pages
Когда приложение ASP .NET Core получает запрос, он проходит через
конвейер промежуточного ПО до тех пор, пока компонент не сможет
его обработать, как вы видели на рис. 2.13. Обычно последняя часть кон-
вейе ра  – это компонент конечной точки. Он работает с  компонентом
маршрутизации, чтобы сопоставить путь URL-адреса запроса с настроен-
ным маршрутом, который определяет, какую страницу Razor вызывать.
ОПРЕДЕЛЕНИЕ  Путь  – это часть URL-адреса запроса, которая
остается, если убрать домен. Например, для запроса www.micro-
soft.com/account/manage путь будет иметь вид: /account/ manage.
После выбора страницы Razor компонент маршрутизации отмечает
выбранную страницу в  объекте HttpContext и  продолжает выполнение
конвейера промежуточного ПО. В конце концов запрос достигнет ком-
понента конечной точки. Компонент конечной точки выполняет стра-
ницу для генерации ответа в виде HTML-кода и отправляет его обратно
в браузер, как показано на рис. 2.14.

87 Создание ответов с по мощью Razor Pages
Рис. 2.14 Отрисовка шаблона Razor в HTML-код. Страница Razor выбирается на
основе URL-адреса страницы /Privacy и выполняется для генерации HTML-кода
В следующем разделе мы рассмотрим, как страницы Razor генерируют
HTML-код с  по мощью синтаксиса Razor, а  после этого посмотрим, как
можно использовать обработчики страниц для добавления бизнес-логи-
ки и поведения на страницы Razor.
2.8.1 Создание HTML с по мощью страниц Razor
Страницы Razor хранятся в файлах с расширением .cshtml (совокупность
файлов .cs и .html) в папке Pages вашего проекта. Как правило, проме-
жуточное ПО маршрутизации сопоставляет пути URL-адресов запросов
с одной страницей Razor, выполняя поиск страницы Razor с тем же путем
в  папке Pages. Например, на рис.  2.14 видно, что страница конфиден-
циальности вашего приложения соответствует пути /Privacy в адресной
строке браузера. Если вы заглянете в папку Pages, то найдете там файл
Privacy.cshtml, показанный в следующем листинге.
Листинг 2.7 Страница Privacy.cshtml Razor
@page
@model PrivacyModel
@{
ViewData["Title"] = "Privacy Policy";
}
<h1>@ViewData["Title"]</h1>
<p>Use this page to detail your site’s privacy policy.</p>
Страницы Razor используют синтаксис шаблонов под названием Ra-
zor, сочетающий статический HTML-код с динамическим кодом на языке
C# и генерацией HTML-кода. Директива @page  в первой строке страницы
Razor является самой важной. Она всегда должна размещаться в первой Указывает на то, что это страница Razor.
Связывает страницу Razor с определенной моделью PageModel.
Код C#, который не пишется в ответ.
HTML-код с динамическими значениями C#,
которые пишутся в ответ.
Автономный
статический HTML-код.

88 Глава 2 Ваше первое приложение
строке файла, поскольку сообщает ASP .NET Core, что файл .cshtml – это
страница Razor. Без нее вы не сможете правильно просматривать вашу
страницу.
Следующая строка определяет, с  какой моделью PageModel в  вашем
проекте ассоциирована страница Razor:
@model PrivacyModel
В данном случае PageModel называется PrivacyModel и  следует стан-
дартному соглашению по именованию моделей страниц Razor. Этот
класс можно найти в файле Privacy.cshtml.cs в папке Pages вашего про-
екта, как показано на рис. 2.15. Visual Studio размещает эти файлы под
файлами страницы Razor с расширением .cshtml в обозревателе реше-
ний. Мы рассмотрим модель страницы в следующем разделе.
Путь к файловой системе страницы
Razor соответствует URL-адресу,
на который она отвечает
Файлы модели страницы вложены
в соответствующую страницу Razor
в обозревателе решений
В файловой системе страницы
Razor и модели страниц находятся
в одной папке
Рис. 2.15 По соглашению модели страниц помещаются в файл с тем же именем,
что и страница Razor. При этом к имени добавляется суффикс .cs. Visual Studio размещает
эти файлы на странице Razor в Обозревателе решений
Помимо директив @page и  @model видно, что статический HTML-код
всегда является валидным на странице Razor и будет отображаться в от -
вете «как есть».
<p>Use this page to detail your site’s privacy policy.</p>
Вы также можете писать обычный код на языке C# в шаблонах Razor,
используя эту конструкцию:
@{ /* C# code here */ }
Любой код, заключенный в фигурные скобки, будет выполнен, но не
будет записан в ответ. В листинге вы устанавливаете заголовок страни-

89 Создание ответов с по мощью Razor Pages
цы, записывая значение ключа в словарь ViewData, но на данный момент
вы ничего не пишете в ответ:
@{
ViewData["Title"] = "Privacy Policy";
}
Еще одна функция, показанная в  этом шаблоне, заключается в том,
что вы можете динамически записывать переменные C# в HTML-поток
с по мощью символа @. Способность сочетать динамическую и статиче-
скую разметки – вот в чем сила страниц Razor. В этом примере вы полу -
чаете значение "Title" из словаря ViewData с последующей его записью
внутри тега <h1>:
<h1>@ViewData["Title"]</h1>
На этом этапе вас, возможно, немного может сбить с толку шаблон из
листинга 2.7, если сравнить его с выводом, показанным на рис. 2.14. За-
головок и статическое HTML-содержимое отображаются как в листинге,
так и на рисунке, но некоторые части конечной веб-страницы не видны
в шаблоне. Как такое может быть?
Страницы Razor имеют концепцию макетов, которые представляют
собой «базовые» шаблоны, определяющие распространенные элементы
вашего приложения, такие как верхний колонтитул (хедер) и  нижний
(футер). HTML-код макета в сочетании с шаблоном страницы Razor соз-
дает окончательный HTML-код, который отправляется в браузер. Это из-
бавляет вас от необходимости дублировать код хедера и футера на каж -
дой странице, а также означает, что если вам нужно что-то настроить,
достаточно сделать это только в одном месте.
ПРИМЕЧАНИЕ  Я подробно расскажу о шаблонах Razor, включая
макеты, в главе 7. Макеты можно найти в папке Pages/Shared ва-
шего проекта.
Как вы уже видели, вы можете включить код на языке C# в свои стра-
ницы Razor, используя фигурные скобки @{}, но, как правило, нужно
ограничивать код в  файле .cshtml только функциями, используемыми
в  представлении. Сложная логика, код для доступа к  таким сервисам,
как база данных, и манипулирование данными должны обрабатываться
в PageModel.
2.8.2 Логика обработки запросов с по мощью PageModels
и обработчиков
Как вы уже видели, директива @page  в файле с расширением .cshtml по-
мечает страницу как страницу Razor, но большинство страниц Razor так -
же имеют связанную модель	страницы. По соглашению она помещается
в файл, обычно известный как файл «кода программной части», который

90 Глава 2 Ваше первое приложение
имеет расширение .cs, как вы видели на рис. 2.15. Модели страниц долж -
ны наследовать от базового класса PageModel и  обычно содержат один
или несколько методов, которые называют обработчиками	 страниц. Они
определяют, как обрабатывать запросы к странице Razor.
ОПРЕДЕЛЕНИЕ  Обработчик	 страницы – это метод, который за-
пускается в ответ на запрос. Модели страниц Razor должны наследо-
вать от класса PageModel. Они могут содержать несколько обработ -
чиков страниц, хотя обычно там только один или два обработчика.
В следующем листинге показана модель страницы для Privacy.cshtml,
которая находится в файле Privacy.cshtml.cs.
Листинг 2.8  PrivacyModel в Privacy.cshtml.cs – модель страницы
Razor Page
public class PrivacyModel: PageModel
{
private readonly ILogger<PrivacyModel> _logger;
public PrivacyModel(ILogger<PrivacyModel> logger)
{
_logger = logger;
}
public void OnGet()
{
}
}
Эта очень простая модель страницы, но она демонстрирует несколько
важных моментов:
обработчики страниц управляются соглашением;
модели страниц могут использовать внедрение зависимостей для
взаимодействия с другими сервисами.
Обработчики страниц обычно именуются по соглашению, на основе
HTTP-метода, на который они отвечают. Они возвращают либо void, что
указывает на необходимость отрисовки шаблона страницы Razor, либо
IActionResult, содержащий другие инструкции для генерации ответа, та-
кие как перенаправление пользователя на другую страницу.
ОПРЕДЕЛЕНИЕ  Каждый HTTP-запрос включает в  себя метод,
указывающий «тип» запроса. При просмотре веб-сайта по умолча-
нию используется метод GET, который извлекает ресурс с сервера,
чтобы его можно было просмотреть. Второй наиболее распростра-
ненный метод – POST, который используется для отправки данных
на сервер, например при заполнении формы.
PrivacyModel содержит единственный обработчик OnGet, который ука-
зывает, что он должен выполняться в ответ на запросы GET. Поскольку Страницы Razor должны наследовать
от класса PageModel.
Можно использовать
внедрение зависимостей
для предоставления сервисов
в конструкторе.
OnGet – обработчик страницы по умолчанию.
Возвращая void, вы указываете на то,
что должен быть сгенерирован HTML-код.

91 Создание ответов с по мощью Razor Pages
метод возвращает значение void, выполнение обработчика выполнит
ассоциированный шаблон Razor для страницы, чтобы сгенерировать
HTML-код.
ПРИМЕЧАНИЕ  Страницы Razor ориентированы на создание при-
ложений на основе страниц, поэтому обычно требуется возвращать
HTML-код, а не код в формате JSON или XML. Однако вы также мо-
жете использовать IActionResult для возврата любых данных, пе-
ренаправления пользователей на новую страницу или для отправ-
ки ошибки. Подробнее об IActionResult вы узнаете в главе 4.
Внедрение зависимостей используется для внедрения экземпляра
ILog ger <PrivacyModel> в конструктор модели страницы. В данном при-
мере сервис не применяется, но его можно использовать для записи по-
лезной информации в  различные места, такие как консоль, файл или
сервис удаленного ведения журнала. Вы можете получить доступ к до-
полнительным сервисам в своей модели страницы, указав их в качестве
параметров в  конструкторе,  – платформа ASP .NET Core позаботится
о настройке и внедрении экземпляров любых запрашиваемых вами сер-
висов.
ПРИМЕЧАНИЕ  Я  подробно описываю принцип инверсии зави-
симостей и  контейнер IoC, используемый в ASP .NET Core, в  гла-
ве 10. Журналирование рассматривается в главе 17.
Очевидно, что модель страницы PrivacyModel в этом случае мало что
дает, и вам может быть интересно, зачем она нужна. Если все, что они
делают, – это говорят странице Razor сгенерировать HTML-код, тогда за-
чем нам вообще нужны эти модели?
Здесь важно помнить, что теперь у вас есть фреймворк для выполне-
ния произвольно сложных функций в ответ на запрос. Вы можете легко
обновить метод обработчика, чтобы загрузить данные из базы данных,
отправить электронное письмо, добавить продукт в корзину или создать
счет – все в ответ на простой HTTP-запрос. В этой расширяемости и за-
ключается большая часть возможностей страниц Razor (и паттерна MVC
в целом).
Другой важный момент заключается в том, что вы отделили выполне-
ние этих методов от генерации самого HTML-кода. Если логика изменится
и вам понадобится добавить поведение для обработчика страницы, то не
нужно будет ничего менять в коде генерации HTML, поэтому вы с мень-
шей вероятностью внесете ошибки. И наоборот, если вам нужно немного
изменить пользовательский интерфейс, например изменить цвет заго-
ловка, тогда логике вашего метода обработчика ничего не угрожает.
И вот оно, готовое приложение ASP .NET Core, созданное с по мощью
страниц Razor! Прежде чем продолжить, в  последний раз посмотрим,
как наше приложение обрабатывает запрос. На рис.  2.16 показан за-
прос к пути /Privacy, обрабатываемый приложением. Здесь вы уже все

92 Глава 2 Ваше первое приложение
видели, поэтому процесс обработки запроса должен быть вам знаком.
Он показывает, как запрос проходит через конвейер промежуточного
ПО, прежде чем будет обработан компонентом конечной точки. Стра-
ница Razor Privacy.cshtml выполняет обработчик OnGet и генерирует от -
вет в виде HTML-кода, который возвращается через промежуточное ПО
к веб-серверу ASP .NET Core перед отправкой в   браузер пользователя.
ЗапросВеб-хост / обратный прокси-сервер
(IIS/Nginx/Apache)Ответ
Веб-сервер ASP.NET Core
Компонент маршрутизации
Компонент конечной точки1.  Выполняется HTTP-запрос
к URL-адресу /Privacy
2.  Запрос перенаправляется сервером
IIS/Nginx/Apache в ASP .NET Core
3.  Веб-сервер ASP .NET Core получает
HTTP-запрос и передает его
промежуточному ПО
4.  Путь запроса /Privacy
маршрутизируется на страницу Razor
Privacy.cshtml, поэтому он проходит
по конвейеру промежуточного ПО
без изменений
5.  Страница Privacy.cshtml.cs
обрабатывает запрос, выполняя
обработчик страницы OnGet6.  Обработчик OnGet возвращает
значение void , указывая на
то, что страница Razor должна
генерировать HTML-код
из своего шаблона Razor
в Privacy.cshtml8.  HTTP-ответ, содержащий
HTML-код для страницы
Privacy, отправляется в браузер
7.  Ответ в виде HTML-кода
возвращается через каждое
промежуточное ПО
на веб-сервер ASP .NET Core
Приложение ASP.NET Core Privacy.cshtml
OnGet
Bизуализация Razor
в HTML
Рис. 2.16 Обзор запроса к URL-адресу  /Privacy  для приложения ASP.NET, созданного
с использованием страниц Razor. Компонент маршрутизации направляет запрос обработчику
OnGet файла Privacy.cshtml.cs. Страница Razor генерирует ответ в виде HTML-кода, выполняя
шаблон Razor в файле Privacy.cshtml, и передает ответ обратно по конвейеру в браузер

93 Резюме
Это было довольно напряженное путешествие, но теперь вы имеете
неплохое представление о том, как настраивается приложение и как оно
обрабатывает запросы с по мощью страниц Razor. В следующей главе вы
более подробно ознакомитесь с конвейером промежуточного ПО, кото-
рый существует во всех приложениях ASP .NET Core. Вы узнаете, как его
создать, как с его помощью добавлять функции в ваше приложение и как
можно использовать его для создания простых HTTP-сервисов.
Резюме
Файл с расширением .csproj содержит подробную информацию о том,
как собрать проект, включая то, от каких пакетов NuGet он зависит. Он
используется Visual Studio и интерфейсом командной строки .NET для
сборки вашего приложения.
При восстановлении пакетов NuGet для приложения ASP .NET Core за-
гружаются все зависимости вашего проекта, чтобы его можно было
собрать и запустить.
Program.cs определяет точку входа static void Main для вашего прило-
жения. Эта функция выполняется при запуске приложения, так же как
и для консольных приложений.
Program.cs – это место, где вы создаете экземпляр IHost с по мощью
IHostBuilder. Вспомогательный метод Host.CreateDefaultBuilder()
создает  IHostBuilder, который загружает параметры конфигурации
и настраивает журналирование. При вызове метода Build() создается
экземпляр IHost.
Метод расширения ConfigureWebHostDefaults настраивает универ-
сальный узел с по мощью WebHostBuilder. Он настраивает HTTP-сервер
Kestrel, при необходимости добавляет интеграцию с  IIS и  указывает
класс Startup.
Вы можете запустить веб-сервер и начать принимать запросы по про-
токолу HTTP , вызвав метод Run объекта IHost.
Класс Startup отвечает за настройку сервиса и определение конвейера
промежуточного ПО.
Все сервисы, как сервисы фреймворка, так и  пользовательские сер-
висы приложений, должны регистрироваться в вызове ConfigureSer-
vices, чтобы к ним можно было получить доступ позже в вашем при-
ложении.
Промежуточное ПО добавляется в конвейер приложения с по мощью
IApplicationBuilder. Оно определяет, как ваше приложение отвечает
на запросы.
Порядок регистрации промежуточного ПО определяет окончатель-
ный порядок конвейера. Обычно EndpointMiddleware является по-
следним компонентом в  конвейере. Вначале запросы пытаются об-
работать компоненты, расположенные в конвейере раньше, такие как
StaticFileMiddleware. Если запрос обработан,  EndpointMiddleware его
не получит.

94 Глава 2 Ваше первое приложение
Страницы Razor располагаются в  папке Pages и  обычно именуются
в соответствии с URL-адресом, который они обрабатывают. Например,
Privacy.cshtml обрабатывает путь /Privacy.
Страницы Razor должны содержать директиву @page в первой строке
файла.
Модели страниц наследуют от базового класса PageModel и  содержат
обработчики страниц. Обработчики страниц – это методы, именуемые
с использованием соглашений, указывающих на обрабатываемую ими
команду HTTP . Например, OnGet обрабатывает команду GET.
Шаблоны Razor могут содержать автономный код C#, автономный код
HTML и  динамический HTML-код, созданный на основе данных C#.
Комбинируя все три типа кода, можно создавать высокодинамичные
приложения.
Макеты Razor определяют распространенные элементы веб-страницы,
такие как верхние и нижние колонтитулы. Они позволяют извлекать
этот код в один файл, поэтому вам не нужно дублировать его в каждом
шаблоне Razor.

3Обработка	запросов
с помощью	конвейера
промежуточного	ПО
В этой главе:
что такое промежуточное ПО;
обслуживание статических файлов с использованием
промежуточного ПО;
добавление функциональности с по мощью
промежуточного ПО;
объединение промежуточного ПО для формирования
конвейера;
обработка исключений и ошибок с по мощью
промежуточного ПО.
В предыдущей главе вы подробно ознакомились с полным приложением
ASP .NET Core, чтобы увидеть, как объединяются компоненты для созда-
ния веб-приложения.
В этой главе мы сосредоточимся на одном небольшом подразделе:
конвейере промежуточного программного обеспечения (middleware).
В ASP .NET Core промежуточное ПО – это классы или функции C#, ко-
торые обрабатывают HTTP-запрос или ответ. Они выстроены в цепочку,
чтобы выходные данные одного компонента действовали как входные
данные для следующего компонента, формируя конвейер.
Конвейер промежуточного программного обеспечения – одна из наи-
более важных частей конфигурации для определения того, как ваше

96 Глава 3 Обработка запросов с помощью конвейера промежуточного ПО
приложение ведет себя и как реагирует на запросы. Понимание того, как
создавать и  компоновать промежуточное программное обеспечение,
является ключом к добавлению функциональности в ваши приложения.
В этой главе вы узнаете, что такое промежуточное ПО и как исполь-
зовать его для создания конвейера. Вы увидите, как связать несколько
компонентов промежуточного программного обеспечения воедино, где
каждый компонент добавляет отдельную функциональность. Примеры,
приведенные в этой главе, ограничиваются использованием существую-
щих компонентов промежуточного программного обеспечения, показы-
вая, как правильно расположить их для своего приложения. В главе 19 вы
узнаете, как создавать собственные компоненты промежуточного про-
граммного обеспечения и включать их в конвейер.
Мы начнем с рассмотрения концепции промежуточного программ-
ного обеспечения, всего того, чего можно достичь с  его помощью,
и  того, как компонент промежуточного программного обеспечения
час то сопоставляется со «сквозной задачей». Это функции приложения,
работающие на разных уровнях. Журналирование, обработка ошибок
и безопасность – это классические сквозные задачи, необходимые мно-
жеству различных частей вашего приложения. Поскольку все запросы
проходят через конвейер промежуточного программного обеспече-
ния, то это предпочтительное место для настройки и обработки данной
функциональности.
В разделе 3.2 я объясню, как можно скомпоновать отдельные компо-
ненты промежуточного программного обеспечения в конвейер. Вы нач-
нете с малого, с веб-приложения, которое отображает только страницу
приветствия. Далее вы узнаете, как создать простой сервер статических
файлов, который возвращает запрашиваемые файлы из папки на диске.
Затем вы перейдете к  более сложному конвейеру, содержащему не-
сколько компонентов. Вы рассмотрите важность упорядочивания и уви-
дите, как обрабатываются запросы, когда ваш конвейер содержит не-
сколько компонентов.
В разделе 3.3 вы узнаете, как использовать промежуточное ПО для ре-
шения важного аспекта любого приложения: обработки ошибок. Ошиб-
ки – это реальность любого приложения, поэтому важно учитывать их
при его создании. Помимо обеспечения того, чтобы ваше приложение
не прерывалось при выбросе исключения или возникновении ошибки,
важно, чтобы пользователи вашего приложения были информированы
о том, что пошло не так, в удобной для них форме.
Можно обрабатывать ошибки несколькими способами, но посколь-
ку речь идет об одной из классических сквозных задач, промежуточное
программное обеспечение хорошо подходит для обеспечения необходи-
мой функциональности. В  разделе 3.3 я  покажу, как можно обрабаты-
вать исключения и ошибки с по мощью промежуточного программного
обеспечения, предоставляемого Microsoft. В частности, вы узнаете о трех
различных компонентах:
DeveloperExceptionPageMiddleware  – обеспечивает быструю обрат -
ную связь об ошибках при создании приложения;

97 Что такое промежуточное ПО?
ExceptionHandlerMiddleware – предоставляет удобную для пользова-
теля общую страницу ошибок в промышленном окружении;
StatusCodePagesMiddleware – преобразует низкоуровневые коды со-
стояния ошибок в удобные для пользователя страницы.
Комбинируя их, можно гарантировать, что любые ошибки, которые
происходят в вашем приложении, не приведут к утечке данных, связан-
ных с безопасностью, и не сломают ваше приложение.
В этой главе вы не увидите, как создать собственное промежуточное
программное обеспечение, – но поймете, что можно многого достичь,
используя компоненты, предоставляемые как часть ASP .NET Core. Разо-
бравшись с  тем, что такое конвейер промежуточного программного
обес печения и как он работает, легче понять, когда и почему требуется
специальное промежуточное ПО. Давайте приступим!
3.1 Что такое промежуточное ПО?
Словосочетание промежуточное	 программное	 обеспечение используется
в различных контекстах при разработке программного обеспечения и IT,
однако не особо информативно – так что же такое промежуточное про-
граммное обеспечение?
В ASP .NET Core промежуточное ПО – это классы C#1, которые могут об-
рабатывать HTTP-запрос или ответ. Оно может:
обработать входящий HTTP-запрос путем создания HTTP-ответа;
обработать входящий HTTP-запрос, изменить его и передать другой
части промежуточного ПО;
обработать исходящий HTTP-ответ, изменить его и передать либо
другой части промежуточного ПО, либо веб-серверу ASP .NET Core.
Промежуточное ПО можно использовать в своих приложениях самы-
ми разными способами. Например, компонент журналирования может
отмечать, когда поступил запрос, и затем передавать его другому компо-
ненту. Между тем компонент для изменения размера изображения мо-
жет обнаружить входящий запрос на изображение с указанным разме-
ром, сгенерировать запрошенное изображение и отправить его обратно
пользователю, не передавая его дальше.
Самый важный компонент промежуточного программного обеспече-
ния в большинстве приложений ASP .NET Core – это класс EndpointMiddle-
ware. Этот класс обычно генерирует все ваши HTML-страницы и ответы
API (для приложений веб-API), которым посвящена бóльшая часть этой
книги. Как и промежуточное ПО для изменения размера изображения,
оно обычно получает запрос, генерирует ответ и затем отправляет его
обратно пользователю, как показано на рис. 3.1.
1 Технически промежуточное ПО должно быть функцией, как вы увидите в гла-
ве 19, но очень часто оно реализуется в виде класса C# с по мощью одного-
единственного метода.

98 Глава 3 Обработка запросов с помощью конвейера промежуточного ПО
1.  Веб-сервер ASP .NET Core
передает запрос в конвейер
промежуточного ПО
2.  Компонент журналирования
записывает время поступления
запроса и передает его
следующему компоненту
3.  Если запрашивается
изображение определенного
размера, компонент изменения
изображения обработает его.
Если нет, то запрос передается
следующему компоненту 4.  Если запрос проходит по
конвейеру до компонента
конечной точки, он обработает
запрос и сгенерирует ответ5.  Ответ проходит через каждый
компонент, который ранее
выполнялся в конвейере6.  Ответ возвращается
на веб-сервер ASP .NET Core Запрос Ответ
Компонент журналирования
Компонент изменения изображения
Компонент конечной точки
Рис. 3.1 Пример конвейера промежуточного программного обеспечения.
Каждый компонент обрабатывает запрос и передает его следующему компоненту
в конвейере. После того как ответ будет сгенерирован, он передается дальше по
конвейеру.  Достигнув веб-сервера ASP.NET Core, ответ отправляется в браузер
пользователя
ОПРЕДЕЛЕНИЕ  Схема, при которой один компонент может вы-
зывать другой, который, в  свою очередь, может вызывать следу -
ющий, и так далее, называется конвейером. Можно рассматривать
каждую часть промежуточного программного обеспечения как
секцию канала – когда вы соединяете все секции, запрос перетека-
ет из одной части в другую.
Один из наиболее распространенных вариантов использования про-
межуточного программного обеспечения – решение сквозных задач ва-
шего приложения. Эти аспекты приложения должны выполняться для
каждого запроса, независимо от конкретного пути в запросе или запра-
шиваемого ресурса. Сюда входят:
журналирование каждого запроса;
добавление стандартных заголовков безопасности в ответ;
связывание запроса с соответствующим пользователем;
установка языка текущего запроса.
В каждом из этих примеров один компонент получал запрос, изме-
нял его, а  затем передавал его следующему компоненту в  конвейере.
Последующий компонент мог бы использовать детали, добавленные бо-
лее ранним компонентом, для обработки запроса. Например, на рис. 3.2
компонент аутентификации связывает запрос с пользователем. Он ис -
пользует эту деталь, чтобы проверить, есть ли у пользователя полномо-
чия на выполнение данного конкретного запроса к приложению.

99 Что такое промежуточное ПО?
1.  Веб-сервер ASP .NET Core
передает запрос в конвейер
промежуточного ПО
2.  Компонент аутентификации
связывает пользователя
с текущим запросом
3.  Компонент авторизации
проверяет, разрешено ли
пользователю выполнить
запрос
4.  Если пользователю
отказано, компонент
авторизации замкнет
конвейер 5.  Ответ проходит обратно
через каждый компонент,
который ранее выполнялся
в конвейере
Поскольку компонент
авторизации обработал запрос,
компонент  конечной точки
не выполняется6.  Ответ возвращается
на веб-сервер ASP .NET Core Запрос Ответ
Компонент аутентификации
Компонент авторизации
Компонент конечной точки
Рис. 3.2 Пример компонента промежуточного программного обеспечения,
изменяющего запрос для дальнейшего использования в конвейере. Промежуточное
ПО также может замкнуть конвейер, возвращая ответ до того, как запрос достигнет
более позднего компонента
Если у пользователя есть полномочия, компонент авторизации пере-
даст запрос компоненту конечной точки, чтобы он мог сгенерировать
ответ. Если у пользователя нет полномочий, то компонент авторизации
может замкнуть конвейер, генерируя ответ напрямую. Он возвращает
ответ предыдущему компоненту до того, как промежуточное программ-
ное обеспечение конечной точки увидит запрос.
Ключевым моментом, на который следует обратить внимание, высту -
пает то, что конвейер является двунаправленным. Запрос проходит через
конвейер в одном направлении, пока какая-то часть не сгенерирует от -
вет, после чего ответ проходит обратно по конвейеру, проходя через каж -
дый компонент во второй раз, пока не вернется к первой части.
Наконец, первый/последний компонент передаст ответ обратно веб-
серверу ASP .NET Core.
Объект HttpContext
Я упоминал объект HttpContext в главе 2, и здесь он также присутствует за
кулисами. Веб-сервер ASP.NET Core создает его для каждого запроса, а при-
ложение ASP.NET Core использует его как своего рода ящик для хранения
одного-единственного запроса.

100 Глава 3 Обработка запросов с помощью конвейера промежуточного ПО
Все, что относится к этому конкретному запросу и последующему ответу, мо-
жет быть связано с ним и храниться в нем. Это могут быть свойства запроса,
сервисы, связанные с запросом, загруженные данные или возникшие ошиб-
ки. Веб-сервер заполняет исходный объект HttpContext деталями исходного
HTTP-запроса и другими деталями конфигурации и передает их остальной
части приложения.
Все промежуточное ПО имеет доступ к объекту HttpContext для запроса. Он
может использоваться, например, чтобы определить, содержит ли запрос ка-
кие-либо учетные данные пользователя, к какой странице запрос пытается
получить доступ, и получить любые отправленные данные. Затем он может
использовать эти сведения, чтобы определить, как обрабатывать запрос.
Как только приложение завершит обработку запроса, оно обновит
объект HttpContext соответствующим ответом и  вернет его через кон-
вейер промежуточного программного обеспечения на веб-сервер. Затем
веб-сервер ASP .NET Core преобразует представление в низкоуровневый
HTTP-ответ и отправит его на обратный прокси-сервер, который пере-
сылает его в браузер пользователя.
Как вы видели в  главе 2, конвейер промежуточного программного
обес печения определяется в  коде как часть начальной конфигурации
приложения в классе Startup. Можно настроить конвейер в соответствии
со своими потребностями – простым приложениям может потребовать-
ся только короткий конвейер, тогда как для больших приложений с раз-
личными функциями может использоваться гораздо больше компонен-
тов. Промежуточное ПО  – это фундаментальный источник поведения
вашего приложения. В конечном итоге конвейер несет ответственность
за ответы на все получаемые HTTP-запросы.
Запросы передаются в  конвейер промежуточного ПО в  виде объек -
тов HttpContext. Как вы уже видели в главе 2, веб-сервер ASP .NET Core
создает объект HttpContext из входящего запроса, который проходит
вверх и вниз по конвейеру. Когда вы используете существующее проме-
жуточное ПО для создания конвейера, с этой деталью вы редко будете
сталкиваться. Но, как вы увидите в последнем разделе этой главы, его
присутствие за кулисами дает возможность получить дополнительный
контроль над конвейером.
Также можно рассматривать конвейер промежуточного ПО как се-
рию концентрических компонентов, похожих на традиционную русскую
мат решку, как показано на рис. 3.3. Запрос проходит «через» конвейер,
направляясь в стек промежуточного программного обеспечения, пока не
будет возвращен ответ. Затем ответ возвращается через промежуточное
ПО, проходя через компоненты в порядке, обратном запросу.

101 Что такое промежуточное ПО?
Запрос
ОтветМожно рассматривать
промежуточное ПО как серию
вложенных компонентов. Каждый
слой может проверять запрос
и выполнять логику. Затем он
передает запрос следующему
компонентуКогда промежуточное ПО
генерирует ответ, управление
возвращается к внешнему ПО,
и, наконец, ответ отправляется
клиентуКомпонент аутентификации
Компонент авторизации
Компонент
конечной точки
Рис. 3.3 Промежуточное ПО можно также рассматривать как серию вложенных компонентов,
в которых запрос отправляется глубже в промежуточное ПО, а из него выходит ответ. Каждый
компонент может выполнять логику перед передачей ответа компоненту и после создания
ответа на обратном пути из стека
Промежуточное ПО, или модули HTTP, или обработчики HTTP
В предыдущей версии ASP.NET не использовалась концепция конвейера
промежуточного программного обеспечения. Вместо этого у вас были моду-
ли и обработчики HTTP.
Обработчик HTTP – это процесс, который запускается в  ответ на запрос
и генерирует ответ. Например, обработчик страницы ASP.NET выполняется
в ответ на запросы страниц .aspx. В качестве альтернативы можно написать
собственный обработчик, который будет возвращать изображения с изме-
ненным размером при запросе изображения.
Модули HTTP решают общие проблемы приложений, такие как безопасность,
журналирование или управление сеансами. Они выполняются в ответ на со-
бытия жизненного цикла, через которые проходит запрос, когда он получен
сервером. Примеры событий включают BeginRequest, AcquireRequestState
и PostAcquireRequestState.
Этот подход работает, но иногда сложно понять, какие модули в каких точках
будут выполняться. Реализация модуля требует относительно подробного по-
нимания состояния запроса в каждом отдельном событии жизненного цикла.
Конвейер промежуточного программного обеспечения значительно упроща-
ет работу с приложением. Конвейер полностью определен в коде, в котором
указывается, какие компоненты должны выполняться и в каком порядке. За
кулисами конвейер представляет собой простую цепочку вызовов методов,
где каждая функция вызывает следующую в конвейере.
Это почти все, что нужно, чтобы изложить концепцию промежуточ-
ного программного обеспечения. В следующем разделе я расскажу, как
можно комбинировать компоненты промежуточного ПО для создания
приложения и как использовать его для отделения сквозных задач ваше-
го приложения друг от друга.

102 Глава 3 Обработка запросов с помощью конвейера промежуточного ПО
3.2 Объединение компонентов в конвейер
По сути, у каждого компонента промежуточного программного обеспе-
чения есть одна основная задача. Речь идет об обработке только одно-
го из аспектов запроса. Компонент журналирования занимается лишь
журналированием запроса, компонент аутентификации – только иден-
тификацией текущего пользователя, а  компонент статических файлов
занимается только возвратом статических файлов.
Каждая из этих проблем очень целенаправленна, что делает сами ком-
поненты небольшими и понятными, что также придает вашему прило-
жению дополнительную гибкость; добавление компонента статических
файлов не означает, что вас заставляют изменять размер изображения
или выполнять аутентификацию. Каждая из этих функций является до-
полнительным компонентом.
Чтобы создать законченное приложение, несколько компонентов объ-
единяются в  конвейер, как показано в  предыдущем разделе. Каждый
компонент имеет доступ к исходному запросу, а также к любым измене-
ниям, внесенным предыдущими компонентами в конвейере.
Как только ответ будет сгенерирован, каждый компонент может про-
верить и/или изменить его, когда он возвращается по конвейеру, прежде
чем он будет отправлен пользователю. Это позволяет создавать сложные
модели поведения приложений из небольших целенаправленных ком-
понентов.
В оставшейся части данного раздела вы увидите, как создать конвей-
ер промежуточного программного обеспечения путем объединения не-
больших компонентов. Используя стандартные компоненты промежу -
точного программного обеспечения, вы научитесь создавать страницу
приветствия и обслуживать статические файлы из папки на диске. На-
конец, мы еще раз взглянем на конвейер промежуточного ПО по умол-
чанию, который мы создали в главе 2, и разложим его на части, чтобы
понять, почему он так устроен.
3.2.1 Простой сценарий конвейера 1: страница приветствия
В случае со своим первым приложением и первым конвейером проме-
жуточного программного обеспечения вы узнаете, как создать приложе-
ние, состоящее из страницы приветствия. Это может быть полезно при
первой настройке приложения, чтобы гарантировать, что оно обрабаты-
вает запросы без ошибок.
СОВЕТ  Помните, вы можете просмотреть код приложения для
этой книги в репозитории GitHub по адресу https://github.com/an-
drewlock/asp-dot-net-core-in-action-2e.
В предыдущих главах я упоминал, что фреймворк ASP .NET Core состо-
ит из множества небольших отдельных библиотек. Обычно компонент

103 Объединение компонентов в конвейер
добавляют, ссылаясь на пакет в файле проекта .csproj приложения и на-
страивая промежуточное ПО в методе Configure  класса Startup. Компа-
ния Microsoft поставляет множество стандартных компонентов с  ASP .
NET Core на ваш выбор. Вы также можете использовать сторонние ком-
поненты из NuGet и GitHub или создать собственные.
ПРИМЕЧАНИЕ  Я расскажу о создании собственных компонентов
в главе 19.
К сожалению, окончательного списка доступного промежуточного
программного обеспечения нет, но вы можете просмотреть исходный
код всего промежуточного ПО, которое входит в  состав ASP .NET Core,
в основном репозитории GitHub ASP .NET Core (https://github.com /aspnet/
aspnetcore). Большую часть промежуточного программного обеспечения
можно найти в папке src/Middleware, хотя иногда оно находится в других
папках, где является частью более крупной функции. Например, компо-
ненты аутентификации и авторизации можно найти в папке src/Security.
В качестве альтернативы, если немного поискать на сайте https://nuget.
org, часто можно найти компоненты с нужными вам функциями.
В этом разделе вы увидите, как создать один из простейших конвейе-
ров промежуточного программного обеспечения, состоящий только из
компонента WelcomePageMiddleware. WelcomePageMiddleware предназначен
для быстрого предоставления образца страницы при первой разработке
приложения, как видно на рис. 3.4. Вы вряд ли стали бы использовать его
в промышленном окружении, так как здесь нельзя настроить вывод, но
это единственный автономный компонент, который можно использо-
вать, чтобы гарантировать правильную работу своего приложения.
Рис. 3.4 Ответ в виде страницы приветствия. Каждый запрос к приложению
на любом пути будет возвращаться в виде такой же страницы приветствия

104 Глава 3 Обработка запросов с помощью конвейера промежуточного ПО
СОВЕТ  WelcomePageMiddleware входит в  состав базового фрейм-
ворка ASP .NET Core, поэтому не нужно добавлять ссылку на какие-
либо дополнительные пакеты NuGet.
Несмотря на то что это простое приложение, точно такой же процесс,
который вы видели раньше, происходит, когда приложение получает
HTTP-запрос, как показано на рис. 3.5.
Запрос ОтветВеб-хост / обратный прокси-сервер
(IIS/Nginx/Apache)
Веб-сервер ASP.NET Core
Компонент страницы приветствия
Приложение ASP.NET Core1.  Браузер выполняет
HTTP-запрос к серверу
2.  IIS/Nginx/Apache пересылает
запрос в ASP .NET Core
3.  Веб-сервер ASP .NET Core
получает HTTP-запрос,
создает объект HttpContext
и передает его в конвейер
промежуточного ПО
4.  Запрос обрабатывается компонентом
страницы приветствия, который
генерирует HTML-ответ и возвращает
его в конвейер 5.  Ответ передается на веб-сервер
ASP .NET Core 6.  HTTP-ответ, содержащий HTML-код,
отправляется в браузер
Рис. 3.5 WelcomePageMiddleware обрабатывает запрос. Запрос проходит от обратного
прокси-сервера к веб-серверу ASP.NET Core и, наконец, к конвейеру, который генерирует
в ответ HTML-код
Запрос передается на веб-сервер ASP .NET Core, который создает пред-
ставление запроса и  передает его в  конвейер. Поскольку это первый
(и единственный!) компонент в конвейере, WelcomePageMiddleware полу -
чает запрос и должен решить, как его обработать. Промежуточное ПО
генерирует ответ в виде HTML-кода, независимо от того, какой запрос
получает. Этот ответ возвращается на веб-сервер ASP .NET Core, который
пересылает его пользователю для отображения в его браузере.
Как и  во всех приложениях ASP .NET Core, конвейер промежуточно-
го программного обеспечения определяется в методе Configure класса
Startup, добавляя компонент к объекту IApplicationBuilder. Чтобы соз-
дать свой первый конвейер, состоящий из одного компонента, вам пона-
добится всего лишь один вызов метода.

105 Объединение компонентов в конвейер
Листинг 3.1 Класс Startup конвейера страницы приветствия
using Microsoft.AspNetCore.Builder;
namespace CreatingAHoldingPage
{
public class Startup
{
public void Configure(IApplicationBuilder app)
{
app.UseWelcomePage();
}
}
}
Как видите, класс Startup  у этого приложения очень простой. У прило-
жения нет конфигурации и сервисов, поэтому в этом классе отсутствуют
конструктор и метод ConfigureServices. Единственный нужный метод –
это Configure, в котором вы вызываете метод UseWelcomePage.
Вы создаете конвейер промежуточного программного обеспечения
в ASP .NET Core, вызывая методы класса IApplicationBuilder, но этот ин -
терфейс не определяет такие методы, как UseWelcomePage. Это методы
расширения.
Использование методов расширения позволяет эффективно добав-
лять функциональные возможности к  классу IApplicationBuilder, со -
храняя при этом их реализации изолированными от него. Под капотом
методы обычно вызывают еще один метод расширения, чтобы добавить
промежуточное программное обеспечение в конвейер. Например, за ку -
лисами метод UseWelcomePage добавляет WelcomePageMiddleware в конвей-
ер, используя
UseMiddleware<WelcomePageMiddleware>();
Это соглашение о создании метода расширения для каждого компо-
нента промежуточного программного обеспечения. Имя метода начи-
нается со слова Use. Это делается для того, чтобы при добавлении про-
межуточного программного обеспечения в ваше приложение его проще
было обнаружить1.
ASP .NET Core включает в  себя множество компонентов в  качестве
частей основного фреймворка, поэтому вы можете использовать Intelli-
Sense в Visual Studio или другую интегрированную среду разработки для
просмотра всего доступного промежуточного программного обеспече-
ния, как показано на рис. 3.6.
1 Обратной стороной этого подхода является то, что он может скрыть, ка-
кое именно промежуточное ПО добавляется в  конвейер. Если ответ неясен,
я обычно ищу исходный код метода расширения на GitHub: https://github.com/
aspnet/aspnetcore.Класс Startup этого базового
приложения очень простой.
Метод Configure
используется
для определения конвейера
промежуточного ПО.Единственный
компонент
в конвейере.

106 Глава 3 Обработка запросов с помощью конвейера промежуточного ПО
По соглашению, методы расширения
для добавления промежуточного ПО
в конвейер начинаются со слова UseIntelliSense позволяет
легко просматривать
все промежуточное ПО,
доступное для
добавления
Рис. 3.6 IntelliSense упрощает просмотр всего промежуточного программного
обеспечения, доступного для добавления в ваш конвейер
Вызов метода UseWelcomePage добавляет WelcomePageMiddleware в  ка-
честве следующего компонента в  конвейер. Хотя здесь используется
только один компонент, важно помнить, что порядок, в котором вы вы-
зываете IApplicationBuilder  в  методе Configure, определяет порядок,
в котором компонент будет выполняться в конвейере.
ВНИМАНИЕ!  Всегда будьте осторожны при добавлении компо-
нента в конвейер и учитывайте порядок, в котором он будет вы-
полняться. Компонент может получить доступ только к  данным,
созданным компонентами, находящимися перед ним в конвейере.
Это самое простое из приложений, возвращающее один и тот же ответ
независимо от того, по какому URL-адресу вы переходите, но оно показыва-
ет, насколько легко определить поведение вашего приложения с по мощью
компонента. Теперь мы сделаем все немного интереснее и будем возвра-
щать разные ответы, когда вы отправляете запросы по разным путям.
3.2.2 Простой сценарий конвейера 2:
обработка статических файлов
В этом разделе я покажу вам, как создать один из простейших конвейе-
ров промежуточного программного обеспечения, который можно ис -
пользовать для полноценного приложения: приложения со статически-
ми файлами.
Большинство веб-приложений, в том числе и с динамическим содер-
жимым, возвращают несколько страниц с использованием статических
файлов. Изображения, таблицы стилей CSS и  файлы Java Script обычно
сохраняются на диск во время разработки и возвращаются по запросу,
обычно как часть полного запроса HTML-страницы.
На данный момент мы воспользуемся StaticFileMiddleware для соз-
дания приложения, которое обслуживает только статические файлы из
папки wwwroot по запросу, как показано на рис.  3.7. В  этом примере

107 Объединение компонентов в конвейер
изображение с именем moon.jpg находится в папке wwwroot. Когда вы
запрашиваете файл, используя путь /moon.jpg, он загружается и возвра-
щается в качестве ответа на запрос.
Запрос FILE
# FILE
Компонент статических файлов
1.  Компонент  статических файлов
обрабатывает запрос, возвращая
запрошенный файл 2.  Файловый поток отправляется
обратно через конвейер
промежуточного ПО и в браузер3.  Браузер отображает файл, возвращенный
в ответе
Рис. 3.7  Возврат статического файла изображения с по мощью компонента для статических
файлов
Если пользователь запрашивает файл, которого нет в папке wwwroot,
например missing.jpg, компонент статических файлов не будет обслужи-
вать файл. Вместо этого в браузер пользователя будет отправлен ответ
с  кодом ошибки HTTP 404, который по умолчанию выведет страницу
с надписью «Файл не найден», как показано на рис. 3.8.
Запрос 404
404
Компонент статических файлов
1.  Компонент  статических файлов обрабатывает
запрос, пытаясь вернуть запрошенный
файл, но поскольку его не существует, он
возвращает низкоуровневый ответ 4042.  Код ошибки 404 отправляется
обратно через конвейер
промежуточного ПО
к пользователю3.  В браузере по умолчанию
отображается страница
«Файл не найден»
Рис. 3.8 В браузер возвращается страница с сообщением об ошибке, если файл не существует.
Запрошенный файл не существует в папке wwwroot, поэтому приложение ASP.NET Core
вернуло ответ с кодом 404. Затем браузер, в данном случае Microsoft Edge, покажет
пользователю сообщение по умолчанию «Файл не найден»
ПРИМЕЧАНИЕ  Внешний вид этой страницы будет зависеть от ва-
шего браузера. В некоторых браузерах, таких как Internet Explorer
(IE), вы можете увидеть полностью пустую страницу.

108 Глава 3 Обработка запросов с помощью конвейера промежуточного ПО
Создать конвейер промежуточного программного обеспечения для
этого приложения очень просто. Он состоит из единственного компо-
нента StaticFileMiddleware, как видно в следующем листинге. Никакие
сервисы не нужны, поэтому все, что требуется, – это настроить конвейер
в методе Configure  с по мощью метода UseStaticFiles.
Листинг 3.2 Класс Startup конвейера статических файлов
using Microsoft.AspNetCore.Builder;
namespace CreatingAStaticFileWebsite
{
public class Startup
{
public void Configure(IApplicationBuilder app)
{
app.UseStaticFiles();
}
}
СОВЕТ  Помните, что код приложения для этой книги можно
просмотреть в  репозитории GitHub по адресу https://github.c om/
andrewlock/asp-do t-net-core-in-action-2e.
Когда приложение получает запрос, веб-сервер ASP .NET Core обраба-
тывает его и передает в конвейер промежуточного программного обес -
печения. StaticFileMiddleware получает запрос и  определяет, сможет
ли он его обработать. Если запрошенный файл существует, запрос об-
рабатывается, и в качестве ответа возвращается файл, как показано на
рис. 3.9.
Если файл не существует, запрос фактически проходит через компо-
нент статических файлов без изменений. Но подождите, вы добавили
только один компонент, верно? Конечно, вы не сможете передать запрос
следующему компоненту, если нет	другого?
ASP .NET Core автоматически добавляет «фиктивный» компонент про-
межуточного программного обеспечения в  конец конвейера, который
при вызове всегда возвращает ответ с ошибкой 404.
СОВЕТ  Помните, что если компонент не генерирует ответ на
запрос, конвейер автоматически вернет браузеру простой ответ
с ошибкой 404.Класс Startup этого базового
приложения со статическими
файлами очень простой.
Метод Configure используется
для определения конвейера
промежуточного ПО.Единственный компонент в конвейере.

109 Объединение компонентов в конвейер
Запрос ОтветВеб-хост / обратный прокси-сервер
(IIS/Nginx/Apache)
Веб-сервер ASP.NET Core
Компонент статических файловwwwroot/
moon.jpg
Приложение ASP.NET Core1.  Выполняется HTTP-запрос
к файлу moon.jpg
2.  Сервер IIS/Nginx/Apache
пересылает запрос
в ASP .NET Core
3.  Веб-сервер ASP .NET Core
получает HTTP-запрос, создает
объект HttpContext и передает
его промежуточному ПО
4.  Компонент статических файлов
проверяет, есть ли в папке
wwwroot файл moon.jpg,
и, если он есть, извлекает его 5.  Поскольку файл moon.jpg существует,
он возвращается в ответ на запрос 6.  Ответ передается веб-серверу
ASP .NET Core 7.  В браузер отправляется
HTTP-ответ, содержащий файл
Рис. 3.9 StaticFileMiddleware обрабатывает запрос на получение файла. Компонент проверяет
папку wwwroot, чтобы узнать, существует ли запрашиваемый файл moon.jpg. Файл существует,
поэтому компонент извлекает его и возвращает в виде ответа веб-серверу и в конечном итоге
браузеру
Коды состояния HTTP-ответа
Каждый HTTP-ответ содержит код состояния и, необязательно, поясняющую
фразу, описывающую код состояния. Коды состояния ответа являются осно-
вополагающими для протокола HTTP и  представляют собой стандартный
способ обозначения основных результатов. Например, ответ с  кодом 200
означает, что на запрос был успешно получен ответ, а  ответ с  кодом 404
означает, что запрошенный ресурс не может быть найден.
Коды состояния ответа всегда состоят из трех цифр и сгруппированы в пять
разных классов в зависимости от первой цифры:
  1xx  – информационные. Нечасто используются, дают общее подтверж -
дение;
  2xx – успешно. Запрос был успешно обработан;
  3xx  – перенаправление. Браузер должен перейти по предоставленной
ссылке, например чтобы пользователь мог войти в систему;
  4xx – ошибка клиента. Возникла проблема с запросом. Например, в запро-
се отправлены недопустимые данные или пользователь не авторизован
для выполнения запроса;

110 Глава 3 Обработка запросов с помощью конвейера промежуточного ПО
  5xx – ошибка сервера. На сервере возникла проблема, из-за которой не
удалось выполнить запрос.
Эти коды состояния обычно определяют поведение браузера пользователя.
Например, браузер автоматически обработает ответ 301 путем перенаправ-
ления на предоставленную новую ссылку и  выполнения второго запроса.
И все это без вмешательства пользователя. Коды ошибок находятся в клас -
сах 4xx и 5xx.
Среди распространенных кодов можно упомянуть ответ 404, когда файл не
может быть найден, ошибку 400, когда клиент отправляет недопустимые дан-
ные (например, неверный адрес электронной почты), и ошибку 500, когда
ошибка возникает на сервере. HTTP-ответы для кодов ошибок могут вклю-
чать или не включать тело ответа, содержимое которого отображается, когда
клиент получает ответ.
Это базовое приложение ASP .NET Core позволяет легко увидеть пове-
дение конвейера промежуточного программного обеспечения и, в част -
ности, компонента статических файлов, но маловероятно, что ваши
приложения будут такими простыми. Более вероятно, что статические
файлы станут одной из частей вашего конвейера. В следующем разде-
ле вы узнаете, как объединить несколько промежуточных программных
обеспечений, когда мы будем рассматривать простое приложение со
страницами Razor.
3.2.3 Простой сценарий конвейера 3: приложение
со страницами Razor
К этому моменту вы должны четко представлять себе, что такое кон-
вейер промежуточного программного обеспечения, а также понимать,
что он определяет поведение вашего приложения. В  этом разделе вы
увидите, как объединить несколько стандартных компонентов проме-
жуточного программного обеспечения для формирования конвейера.
Как и раньше, это выполняется в методе Configure класса Startup путем
добавления промежуточного программного обеспечения в объект IApp-
licationBuilder.
Мы начнем с  создания базового конвейера, который можно найти
в типичном шаблоне ASP .NET Core Razor Pages, а затем расширим его,
добавив промежуточное программное обеспечение. Результат при пере-
ходе на домашнюю страницу приложения показан на рис. 3.10, что иден-
тично примеру, приведенному во второй главе.
Для создания этого приложения требуется всего четыре компонента:
компонент маршрутизации для выбора страницы Razor, которую нуж -
но выполнить, компонент конечной точки для генерации HTML-кода из
страницы Razor, компонент статических файлов для обслуживания CSS
и файлов изображений из папки wwwroot и компонент обработчика ис -
ключений для обработки любых возможных ошибок.

111 Объединение компонентов в конвейер
Рис. 3.10 Простое приложение Razor Pages. Приложение использует только
четыре компонента: компонент маршрутизации для выбора страницы Razor
для выполнения, компонент конечной точки для генерации HTML-кода из страницы,
компонент статических файлов для обслуживания файлов CSS и компонент
обработчика исключений для перехвата любых ошибок
Конфигурация конвейера приложения, как всегда, происходит в мето-
де Configure  класса Startup и показана в следующем листинге. Помимо
конфигурации промежуточного программного обеспечения, в этом лис -
тинге также показан вызов метода  AddRazorPages() в  ConfigureServices,
необходимый при использовании страниц Razor. Подробнее о конфигу -
рации сервисов вы узнаете в главе 10.
Листинг 3.3  Базовый конвейер промежуточного ПО
для приложения Razor Pages
public class Startup
{
public void ConfigureServices(IServiceCollection services)
{
services.AddRazorPages();
}
public void Configure(IApplicationBuilder app)
{
app.UseExceptionHandler("/Error");
app.UseStaticFiles();
app.UseRouting();
app.UseEndpoints(endpoints =>
{
endpoints.MapRazorPages();
});
}
}

112 Глава 3 Обработка запросов с помощью конвейера промежуточного ПО
Добавление компонента к  объекту IApplicationBuilder для форми-
рования конвейера должно быть вам знакомо, но в этом примере сто-
ит отметить несколько моментов. Во-первых, все методы добавления
компонентов начинаются со слова Use. Как я упоминал ранее, это свя-
зано с соглашением об использовании методов расширения, чтобы рас -
ширить функциональность объекта IApplicationBuilder; если добавить
к методам префикс Use, то их будет легче обнаружить.
Еще один важный момент в этом листинге – порядок методов Use в ме -
тоде Configure. Порядок, в котором вы добавляете компонент к объекту
IApplicationBuilder, соответствует порядку, в котором они добавляются
в конвейер. В результате создается конвейер, аналогичный тому, что по-
казан на рис. 3.11.
Запрос Ответ
Компонент обработки ошибок
Компонент статических файлов
Компонент маршрутизации
Компонент конечной точкиКомпонент обработки ошибок был добавлен
первым, поэтому он является первым
(и последним) компонентом для обработки
запроса
Компонент статических файлов является
вторым компонентом в конвейере. Он
обрабатывает запросы к статическим
файлам до того, как они попадут в компонент
конечной точки
Компонент маршрутизации пытается найти
конечную точку Razor Page, которая будет
обрабатывать запрос
Компонент конечной точки является
последним компонентом в конвейере.
Если страница Razor для обработки запроса
отсутствует, конвейер возвращает ответ 404
Рис. 3.11 Конвейер промежуточного программного обеспечения приложения
из листинга 3.3. Порядок, в котором вы добавляете компоненты в объект
IApplicationBuilder, определяет порядок компонентов в конвейере
Сначала вызывается компонент обработчика исключений, который
передает запрос компоненту статических файлов. Обработчик статиче-
ских файлов сгенерирует ответ, если запрос соответствует файлу; в про-
тивном случае он передаст запрос компоненту маршрутизации.
Компонент маршрутизации выбирает страницу Razor на основе URL-
адреса запроса, а  компонент конечной точки выполняет выбранную
страницу Razor. Если ни одна страница не может обработать запрошен-
ный URL-адрес, автоматический фиктивный компонент возвращает от -
вет 404.

113 Объединение компонентов в конвейер
ПРИМЕЧАНИЕ  В  версиях ASP .NET Core 1.x и  2.x компоненты
маршрутизации и конечных точек были объединены в одно про-
межуточное ПО «MVC». Разделение ответственности за маршру -
тизацию от исполнения позволяет вставлять компоненты между
компонентами маршрутизации и  конечной точки. Подробнее
о маршрутизации я расскажу в главе 5.
Влияние упорядочения наиболее очевидно можно увидеть, когда у вас
есть два компонента, оба из которых прослушивают один и тот же путь.
Например, компонент конечной точки в  примере с  конвейером в  на-
стоящее время отвечает на запрос к  домашней странице приложения
(с путем "/"), генерируя ответ в виде HTML-кода, показанного ранее на
рис. 3.10. На рис. 3.12 показано, что произойдет, если вы повторно до-
бавите промежуточное программное обеспечение, которое уже видели
ранее, WelcomePageMiddleware, и  настроите его так, чтобы он также от -
вечал на путь "/".
Рис. 3.12 Страница приветствия, полученная в качестве ответа. Компонент
страницы приветствия предшествует компоненту конечной точки, поэтому запрос на
домашнюю страницу возвращает компонент страницы приветствия вместо ответа
Razor Pages
Как вы видели в  разделе 3.2.1, WelcomePageMiddleware предназначен
для возврата фиксированного ответа в виде HTML-кода, поэтому вы не
будете использовать его в промышленном окружении, однако он хорошо
иллюстрирует суть. В  следующем листинге он добавлен в  начало кон-
вейе ра и настроен для ответа только на путь "/".

114 Глава 3 Обработка запросов с помощью конвейера промежуточного ПО
Листинг 3.4  Добавление компонента WelcomePageMiddleware
в конвейер
public class Startup
{
public void ConfigureServices(IServiceCollection services
{
services.AddRazorPages();
}
public void Configure(IApplicationBuilder app)
{
app.UseWelcomePage("/");
app.UseExceptionHandler("/Error");
app.UseStaticFiles();
app.UseRouting();
app.UseEndpoints(endpoints =>
endpoints.MapRazorPages();
});
}
}
Несмотря на то что вы знаете, что промежуточное ПО конечной точки
также может обрабатывать путь "/", WelcomePageMiddleware идет в кон-
вейере перед ним, поэтому он возвращает ответ, когда получает запрос
на "/", замыкая конвейер, как показано на рис. 3.13. Ни один из других
компонентов конвейера не выполняется для запроса, поэтому ни у кого
нет возможности сгенерировать ответ.
Если переместить WelcomePageMiddleware в конец конвейера после вы-
зова UseEndpoints, то у вас будет обратная ситуация. Все запросы к  "/" бу -
дут обработаны компонентом конечной точки, и вы никогда не увидите
страницу приветствия.
СОВЕТ  Всегда нужно учитывать порядок компонентов при до-
бавлении их в  метод Configure. Компонент, добавленный в  кон-
вейер раньше, будет работать (и, возможно, вернет ответ), прежде
чем это сделает компонент, добавленный позже.
Во всех показанных до сих пор примерах мы пытались обработать вхо-
дящий запрос и сгенерировать ответ, но важно помнить, что конвейер
промежуточного программного обеспечения является двунаправлен-
ным. Каждый компонент получает возможность обрабатывать как вхо-
дящий запрос, так и исходящий ответ. Порядок наиболее важен для тех
компонентов, которые создают или изменяют исходящий ответ.
В предыдущем примере я включил ExceptionHandlerMiddleware в на-
чало конвейера приложения, но, похоже, он ничего не сделал. Компонент
обработки ошибок обычно игнорирует входящий запрос, когда тот по-WelcomePageMiddleware обрабатывает
все запросы к пути "/" и возвращает
образец ответа в виде HTML-кода.
Запросы к "/" никогда не достигнут
компонента конечной точки.

115 Объединение компонентов в конвейер
ступает в конвейер, и вместо этого проверяет исходящий ответ, изменяя
его только при возникновении ошибки. В следующем разделе я подроб-
но расскажу о типах компонентов для обработки ошибок, которые мож -
но использовать с вашим приложением, и о том, когда это делать.
Запрос ОтветВеб-хост / обратный прокси-сервер
(IIS/Nginx/Apache)
Веб-сервер ASP.NET Core
Компонент страницы приветствия
Компонент обработки ошибок
Компонент статических файлов
Компонент маршрутизации
Компонент конечной точки
Приложение ASP.NET Core1.  Выполняется HTTP-запрос
к URL-адресу http://localhost:49392/
2.  Сервер IIS/Nginx Apache пересылает
запрос ASP .NET Core
3.  Веб-сервер ASP .NET Core получает
HTTP-запрос и передает его
промежуточному ПО5.  Ответ в виде HTML-кода
передается обратно на веб-сервер
ASP .NET Core 6.  HTTP-ответ, содержащий страницу
приветствия, отправляется в браузер
4.  Компонент страницы приветствия
обрабатывает запрос и возвращает
ответ в виде HTML-кода, замыкая
конвейер
Ни один другой компонент
не выполняется для запроса, поэтому
компонент конечной точки не имеет
возможности обработать запрос
Рис. 3.13 Обзор приложения, обрабатывающего запрос к пути "/". Компонент страницы
приветствия идет первым в конвейере, поэтому он получает запрос раньше любого другого
компонента. Он генерирует ответ в виде HTML-кода, замыкая конвейер. Никакой другой
компонент не выполняется для запроса

116 Глава 3 Обработка запросов с помощью конвейера промежуточного ПО
3.3 Обработка ошибок с помощью
промежуточного ПО
Ошибки – это реальность при разработке приложений. Даже если вы на-
пишете идеальный код, как только вы выпустите и развернете свое при-
ложение, пользователи найдут способ сломать его, случайно или намерен-
но! Важно, чтобы ваше приложение корректно обрабатывало эти ошибки,
обеспечивая соответствующий ответ пользователю, и не давало сбой.
Философия проектирования ASP .NET Core заключается в  том, что
любая функциональность является подключаемой. Итак, поскольку об-
работка ошибок – это функциональность, вам необходимо явно активи-
ровать ее в своем приложении. В вашем приложении может возникать
множество различных типов ошибок, и есть много разных способов их
обработки, но в этом разделе я сосредоточусь на двух: исключениях и ко-
дах состояния ошибок.
Исключения обычно возникают всякий раз, когда вы сталкиваетесь
с непредвиденными обстоятельствами. Типичное (и очень неприятное)
исключение, с которым вы, несомненно, сталкивались раньше, – это ис -
ключение NullReferenceException, возникающее, когда вы пытаетесь по-
лучить доступ к объекту, который не был инициализирован3.
Если исключение возникает в  компоненте промежуточного про-
граммного обеспечения, оно распространяется вверх по конвейеру, как
показано на рис.  3.14. Если конвейер не обработает исключение, веб-
сервер вернет пользователю код состояния 500.
Запрос 500
Компонент
обработки ошибок
Компонент
маршрутизацииКомпонент
статических файлов
Компонент
конечной точки1.  Веб-сервер ASP .NET Core передает
запрос конвейеру промежуточного ПО
2.  Каждый компонент промежуточного
ПО по очереди обрабатывает запрос
3.  Компонент конечной точки
выбрасывает исключение во время
выполнения4.  Исключение распространяется
обратно по конвейеру, давая
каждому компоненту возможность
обработать его 5.  Если исключение не обрабатывается
промежуточным ПО, низкоуровневый
ответ с кодом состояния 500
отправляется в браузер
Рис. 3.14 Исключение в компоненте конечной точки распространяется по конвейеру. Если
исключение не было обнаружено ранее в конвейере, то в браузер пользователя отправляется
код состояния 500 «Ошибка сервера»

117 Обработка ошибок с помощью промежуточного ПО
В некоторых ситуациях ошибка не вызывает исключения. Вместо
этого промежуточное ПО может сгенерировать код состояния ошибки.
Один из таких случаев – когда запрашиваемый путь не обрабатывается.
В этой ситуации конвейер вернет ошибку 404, в результате чего пользо-
ватель увидит обычную недружественную страницу, которую вы видели
на рис. 3.8. Хотя такое поведение является «корректным», оно не обеспе-
чивает удобного взаимодействия с пользователями вашего приложения.
Запрос
ЗапросHTML
# 500HTML
500500Компонент обработки ошибок
Компонент обработки ошибокКомпонент изменения размера
изображения
Компонент изменения размера
изображенияКомпонент обработки ошибок идет первым в конвейере
1.  Если промежуточное ПО размещается
после компонента обработки ошибок
в конвейере, любой ответ, который
он генерирует, будет проходить через
компонент обработки ошибок
1.  Если компонент изменения размера
изображения размещается в начале
конвейера, до компонента обработки
ошибок, то любые коды ошибок,
возвращаемые промежуточным ПО,
не будут изменены2.  Например, представьте, что ошибка
возникает в компоненте изменения
размера изображения, который затем
генерирует низкоуровневый ответ
с ошибкой 500
2.  Компонент  обработки ошибок
обрабатывает ответ промежуточного
ПО позже в конвейере, но не видит
ответ, генерируемый компонентом
изменения размера изображения3.  Этот ответ проходит через
компонент обработки ошибок, когда
возвращается через конвейер
3.  Если компонент  изменения
размера изображения генерирует
низкоуровневую ошибку с кодом
состояния 500, она будет отправлена
обратно пользователю без изменений4.  Компонент обработки ошибок может
изменить низкоуровневый ответ
на удобную для пользователя
HTML-страницу
Компонент изменения размера изображения идет первым в конвейере
Рис. 3.15 Компонент обработки ошибок должен размещаться в начале конвейера
для перехвата ошибок кода состояния. В первом случае он помещается перед компонентом
изменения размера изображения, поэтому может заменить низкоуровневые ошибки кода
состояния удобной для пользователя страницей ошибок. Во втором случае он помещается после
компонента изменения размера изображения, поэтому коды состояния ошибок изменить нельзя

118 Глава 3 Обработка запросов с помощью конвейера промежуточного ПО
Компонент обработки ошибок пытается решить эти проблемы, изме-
няя ответ до того, как приложение вернет его пользователю. Как правило,
компонент обработки ошибок либо возвращает сведения о произошед-
шей ошибке, либо возвращает пользователю обычную, но приятную на
вид HTML-страницу. Этот компонент всегда следует размещать в начале
конвейера, чтобы он мог улавливать любые ошибки, сгенерированные
в последующих компонентах, как показано на рис. 3.15. Любые ответы,
сгенерированные компонентом, находящимся до компонента обработ -
ки ошибок, нельзя перехватить.
В оставшейся части этого раздела показано несколько типов компо-
нентов для обработки ошибок, которые доступны для использования
в вашем приложении. Они доступны как часть базовой платформы ASP .
NET Core, поэтому не нужно ссылаться на какие-либо дополнительные
пакеты NuGet, чтобы использовать их.
3.3.1 Просмотр исключений в окружении разработки:
DeveloperExceptionPage
Когда вы разрабатываете приложение, то вам обычно нужен доступ к как
можно большему количеству информации, если где-то в вашем прило-
жении возникает ошибка. По этой причине компания Microsoft предо-
ставляет DeveloperExceptionPageMiddleware, который можно добавить
в свой конвейер с по мощью
app.UseDeveloperExceptionPage();
Когда исключение выбрасывается и  распространяется по конвейеру
к этому компоненту, оно будет перехвачено. Затем компонент генериру -
ет удобную HTML-страницу, которую возвращает пользователю с кодом
состояния 500, как показано на рис.  3.16. Эта страница содержит раз-
личные сведения о  запросе и  исключении, включая трассировку стека
исключений, исходный код в строке, в которой произошло исключение,
и детали запроса, такие как файлы cookie или заголовки, которые были
отправлены.
Доступность этих сведений при возникновении ошибки имеет не-
оценимое значение для отладки проблемы, но это также представляет
угрозу для безопасности при неправильном использовании. Никогда
не возвращайте пользователям более подробную информацию о своем
приложении, чем нужно, поэтому вам следует использовать Developer-
ExceptionPage только при разработке приложения. Подсказка кроется
в названии!
ВНИМАНИЕ!  Никогда не используйте страницу исключений раз-
работчика при работе в  промышленном окружении. Это пред-
ставляет угрозу для безопасности, так как может предоставить от -
крытый доступ к коду вашего приложения, что делает вас легкой
мишенью для злоумышленников.

119 Обработка ошибок с помощью промежуточного ПО
Заголовок, указывающий на проблему
Если кликнуть по этим кнопкам,
то можно увидеть дополнительные
сведения о запросе,
вызвавшем исключениеПодробная информация об исключении
Полная трассировка стека
исключенияМесто в коде, где произошло исключение
Код, вызвавший исключение
Рис. 3.16 На странице исключения разработчика показана подробная информация
об исключении, когда оно возникает во время обработки запроса. Место в коде, вызвавшее
исключение, строка исходного кода и трассировка стека отображаются по умолчанию. Вы также
можете нажать кнопки Запрос, Файлы cookie, Заголовки или Маршрутизация, чтобы получить
дополнительные сведения о запросе, вызвавшем исключение
Если страница исключений разработчика не подходит для промыш-
ленного использования, то что тогда использовать вместо этого? К сча-
стью, есть еще один компонент для обработки ошибок общего назначе-
ния, который можно использовать в промышленном окружении. Вы уже
видели его и работали с ним. Это ExceptionHandlerMiddleware.
3.3.2 Обработка исключений в промышленном окружении:
ExceptionHandlerMiddleware
Страница исключений разработчика удобна при разработке приложе-
ний, но не следует использовать ее в  промышленном окружении, по-
скольку это может привести к утечке информации о вашем приложении
и  ей могут воспользоваться потенциальные злоумышленники. Тем не
менее вам все равно нужно отлавливать ошибки; в  противном случае
пользователи будут видеть недружелюбные страницы с ошибками или
пустые страницы, в зависимости от используемого браузера.
Эту проблему можно решить с по мощью компонента ExceptionHand-
lerMiddleware. Если в вашем приложении возникает ошибка, пользова-
тель увидит страницу с ошибкой, которая согласуется с остальной частью
приложения, но предоставляет только необходимые сведения об ошибке.
Например, страница ошибок, показанная на рис. 3.17, может сохранить
внешний вид приложения, используя тот же заголовок, отображая теку -
щего пользователя, вошедшего в систему, и соответствующее сообщение
для пользователя вместо полной информации об исключении.

120 Глава 3 Обработка запросов с помощью конвейера промежуточного ПО
Строка меню соответствует остальной
части вашего приложенияНа странице ошибки могут отображаться динамические
данные, такие как текущий пользователь
Страница ошибки содержит
соответствующие данные
для пользователя
Страница ошибок по умолчанию
напоминает вам о странице исключения
разработчика. В своем приложении вы,
скорее всего, поменяете этот текст на что-то
более универсальное
Нижний колонтитул соответствует
остальной части вашего приложения
Рис. 3.17  Пользовательская страница ошибок, созданная ExceptionHandlerMiddleware.
Такая страница может иметь тот же внешний вид, что и остальная часть приложения, за счет
повторного использования таких элементов, как верхний и нижний колонтитулы. Что еще
более важно, вы можете с легкостью контролировать сведения об ошибках, которые видят
пользователи
Если взглянуть на метод Configure почти любого приложения ASP .NET
Core, то почти наверняка можно найти страницу исключения разработ -
чика, используемую в сочетании с  ExceptionHandlerMiddleware аналогич-
но тому, что показано в листинге 3.5.
Листинг 3.5  Настройка обработки исключений для окружения
разработки и промышленного окружения
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
if (env.IsDevelopment())
{
app.UseDeveloperExceptionPage();
}
else
{
app.UseExceptionHandler("/Error");
}
//Дополнительная настройка компонента;
}
Помимо демонстрации того, как добавить компонент ExceptionHand-
lerMiddleware в свой конвейер, этот листинг показывает, что совершенно
приемлемо настраивать различные конвейеры в зависимости от окру -
жения при запуске приложения. Вы также можете изменить свой кон-
вейер на основе других значений, таких как параметры, загруженные из
конфигурации.Настраиваем другой конвейер
при запуске в окружении разработки.
Страницу исключения разработчика
следует использовать только при работе
в окружении разработки.
В промышленном окружении
в конвейер добавляется
ExceptionHandlerMiddleware.

121 Обработка ошибок с помощью промежуточного ПО
ПРИМЕЧАНИЕ  Вы увидите, как использовать значения конфигу -
рации для настройки конвейера промежуточного ПО, в главе 11.
При добавлении компонента ExceptionHandlerMiddleware в приложе-
ние обычно указывается путь к странице ошибки, которую увидит поль-
зователь. В  примере из листинга 3.5 мы использовали путь обработки
ошибок "/Error":
app.UseExceptionHandler("/Error");
ExceptionHandlerMiddleware вызовет этот путь после перехвата исклю-
чения, чтобы сгенерировать окончательный ответ. Возможность дина-
мически генерировать ответ – ключевая особенность ExceptionHand ler-
Middleware: это позволяет повторно запустить конвейер проме  жуточного
ПО, чтобы сгенерировать ответ, отправляемый пользователю.
На рис. 3.18 показано, что происходит, когда ExceptionHandlerMiddle-
ware обрабатывает исключение. Здесь показан поток событий, когда
страница Index.cshtml генерирует исключение, когда делается запрос
к пути "/". Окончательный ответ возвращает код состояния ошибки, но
также предоставляет страницу, которую увидит пользователь, используя
путь "/Error".
Последовательность событий, когда где-то в конвейере после Excep-
tionHandlerMiddleware возникает исключение, выглядит следующим об-
разом:
1 часть промежуточного ПО выбрасывает исключение;
2 ExceptionHandlerMiddleware  перехватывает его;
3 любой определенный к этому моменту частичный ответ удаляется;
4  промежуточное ПО перезаписывает путь запроса предоставлен-
ным путем обработки ошибок;
5  промежуточное ПО отправляет запрос обратно по конвейеру, как
если бы исходный запрос был для пути обработки ошибок;
6 конвейер генерирует новый ответ как обычно;
7  когда ответ возвращается в  ExceptionHandlerMiddleware, он изме-
няет код состояния на ошибку 500 и продолжает передавать ответ
по конвейеру на веб-сервер.
Основное преимущество, которое дает повторное выполнение конвей-
ера, – это возможность интегрировать сообщения об ошибках в обычный
макет сайта, как было показано ранее на рис. 3.17. Конечно, при возник -
новении ошибки можно вернуть фиксированный ответ, но у вас не будет
строки меню с динамически генерируемыми ссылками или вы не смо-
жете отобразить имя текущего пользователя в  меню. Повторно запус -
кая конвейер, можно убедиться, что все динамические области вашего
приложения правильно интегрированы, как если бы эта страница была
стандартной страницей вашего сайта.

122 Глава 3 Обработка запросов с помощью конвейера промежуточного ПО
/
/
/Error
/Error HTML
# HTML
# HTML
HTMLОбработчик исключений
Обработчик исключений
Обработчик исключенийОбработчик
исключенийКомпонент конечной точки
Компонент конечной точки
Компонент конечной точкиКомпонент конечной точкиЗапрос к URL-адресу / передается конвейеру
ExceptionHandlerMiddleware изначально
игнорирует запрос
Компонент конечной точки выбрасывает
исключение в файле Razor Page Index.cshtml
при обработке запроса
Исключение распространяется вверх
по конвейеру и перехватывается
ExceptionHandlerMiddleware. Он изменяет путь
запроса на путь /Error и снова отправляет запрос
по конвейеру промежуточного ПО
Конвейер промежуточного ПО
обрабатывает новый путь /Error
и генерирует ответ, как обычно. В данном
случае компонент конечной точки
генерирует ответ в виде HTML-кода
Компонент обработчика исключений
использует новый ответ, но обновляет код
состояния ответа на 500. Это указывает
браузеру, что произошла ошибка,
но пользователь видит удобную
веб-страницу, указывающую на то,
что что-то пошло не так
Рис. 3.18 ExceptionHandlerMiddleware обрабатывает исключение, чтобы
сгенерировать ответ в виде HTML-страницы. Запрос к пути / создает исключение,
которое обрабатывается промежуточным ПО. Конвейер повторно запускается
с использованием пути /Error для генерации ответа

123 Обработка ошибок с помощью промежуточного ПО
ПРИМЕЧАНИЕ  Все, что вам нужно сделать, – это добавить ком-
понент ExceptionHandlerMiddleware в  свое приложение и  настро-
ить валидный путь обработки ошибок, чтобы разрешить повтор-
ное выполнение конвейера. Компонент перехватит исключение
и повторно выполнит конвейер за вас. Последующий компонент
будет рассматривать повторное выполнение как новый запрос, но
предыдущий компонент в конвейере не узнает, что случилось что-
либо необычное.
Повторное выполнение конвейера – отличный способ сохранить по-
следовательность в своем веб-приложении для страниц с ошибками, но
есть некоторые подводные камни, о которых следует знать. Во-первых,
промежуточное ПО может изменять ответ, сгенерированный далее по
конвейеру, только если ответ	 еще	не	был	отправлен	 клиенту. Это может
быть проблемой, если, например, возникает ошибка, когда ASP .NET Core
отправляет статический файл клиенту.
В том случае, когда отправка байтов уже началась, компонент обра-
ботки ошибок не сможет запуститься, так как он не может сбросить от -
вет. В общем, с этой проблемой мало что можно сделать, но об этом нуж -
но знать.
Более распространенная проблема возникает, когда путь обработки
ошибок выбрасывает ошибку во время повторного выполнения конвейе-
ра. Представьте себе ошибку в коде, который генерирует меню в верхней
части страницы:
1  когда пользователь переходит на вашу домашнюю страницу, код
для создания строки меню выбрасывает исключение;
2  исключение распространяется по конвейеру промежуточного про-
граммного обеспечения;
3  когда оно доходит до ExceptionHandlerMiddleware, тот перехваты-
вает его, и  конвейер запускается повторно, используя путь обра-
ботки ошибок;
4  когда страница с ошибкой выполняется, она пытается создать стро-
ку меню для вашего приложения, что снова вызывает исключение;
5 исключение распространяется по конвейеру;
6  ExceptionHandlerMiddleware уже пытался перехватить запрос, по-
этому он позволит ошибке идти до самого верха конвейера;
7  веб-сервер возвращает низкоуровневую ошибку с кодом состояния
500, как будто компонента обработки ошибок и не было.
Из-за этой проблемы часто рекомендуется делать страницы обработ -
ки ошибок как можно проще, чтобы снизить вероятность возникновения
ошибок.
ПРЕДУПРЕЖДЕНИЕ  Если ваш путь обработки ошибок вызывает
ошибку, пользователь увидит общую ошибку браузера. Часто луч-
ше использовать статическую страницу, которая всегда работает,
вместо динамической страницы, которая рискует выдать больше
ошибок.

124 Глава 3 Обработка запросов с помощью конвейера промежуточного ПО
Компоненты ExceptionHandlerMiddleware и  DeveloperExceptionPage-
Middleware великолепно подходят для перехвата исключений в  вашем
приложении, но исключения – не единственный вид ошибок, с которы-
ми вы столкнетесь. В некоторых случаях ваш конвейер будет возвращать
в ответ код состояния ошибки HTTP . Важно обрабатывать и исключения,
и коды состояния ошибок для обеспечения согласованного взаимодей-
ствия с пользователем.
3.3.3 Обработка других ошибок: StatusCodePagesMiddleware
Ваше приложение может возвращать широкий спектр кодов состоя-
ния HTTP , указывающих на состояние ошибки. Вы уже видели, что 500
«ошибка сервера» отправляется при возникновении исключения и  не
обрабатывается, а  ошибка 404 «файл не найден» отправляется, когда
URL-адрес не обрабатывается каким-либо компонентом. В  частности,
очень распространены ошибки 404, часто возникающие, когда пользо-
ватель вводит недопустимый URL-адрес.
СОВЕТ  Помимо указания полностью необработанного URL-ад-
ре са, такие ошибки часто используются, чтобы указать на то, что
конкретный запрашиваемый объект не был найден. Например, за-
прос сведений о продукте с идентификатором 23 может вернуть
ошибку 404, если такого продукта не существует.
Если вы не будете обрабатывать эти коды состояния, пользователи
увидят обобщенную страницу с ошибкой, такую как на рис. 3.19, которая
может сбить с толку многих и заставить думать, что ваше приложение не
работает. Лучше было бы обработать эти коды ошибок и вернуть страни-
цу с ошибкой, которая соответствует остальной части вашего приложе-
ния или, по крайней мере, не создает впечатления, что ваше приложение
неисправно.
Компания Microsoft предоставляет компонент StatusCodePagesMiddle-
ware для обработки этого варианта использования. Как и все компонен-
ты для обработки ошибок, его следует добавить в начало конвейера, по-
скольку он будет обрабатывать только ошибки, сгенерированные более
поздними компонентами.
Вы можете использовать его различными способами в  своем при-
ложении. Самый простой подход – добавить промежуточное ПО в свой
конвейер без каких-либо дополнительных настроек, используя
app.UseStatusCodePages();
С помощью этого метода компонент будет перехватывать любой от -
вет, который имеет код состояния HTTP , начинающийся с  4xx или 5xx
и не имеющий тела ответа. В простейшем случае, когда вы не предостав-
ляете никакой дополнительной конфигурации, компонент добавит тело
ответа в виде простого текста с указанием типа и имени ответа, как по-
казано на рис. 3.20.

125 Обработка ошибок с помощью промежуточного ПО
Рис. 3.19 Обобщенная страница браузера с ошибкой. Если конвейер
промежуточного ПО не может обработать запрос, он вернет пользователю ошибку
404. Это сообщение не особо полезно для пользователей и может оставить многих
в замешательстве или заставить думать, что ваше веб-приложение неисправно
Рис. 3.20 Страница кода состояния для ошибки 404. Вы вряд ли будете
использовать эту версию в промышленном окружении, поскольку она не
обеспечивает надлежащего взаимодействия с пользователем, но демонстрирует, что
коды ошибок перехватываются правильно
На данный момент это, возможно, хуже, чем сообщение по умолча-
нию, но это отправная точка для обеспечения более единообразного
взаи модействия с пользователями.
Более типичным подходом к  использованию  StatusCodePagesMiddle-
ware в промышленном окружении является повторное выполнение кон-
вейера при перехвате ошибки с использованием техники, аналогичной
ExceptionHandlerMiddleware. Это позволяет вам иметь динамические
страницы ошибок, которые подходят для остальной части вашего при-
ложения. Чтобы использовать данный метод, замените вызов UseStatus-
CodePages следующим методом расширения:
app.UseStatusCodePagesWithReExecute("/{0}");

126 Глава 3 Обработка запросов с помощью конвейера промежуточного ПО
Этот метод расширения настраивает StatusCodePagesMiddleware для
повторного выполнения конвейера всякий раз, когда обнаруживает -
ся код ответа 4xx или 5xx, используя предоставленный путь обработки
ошибок. Это похоже на то, как ExceptionHandlerMiddleware повторно вы-
полняет конвейер, как показано на рис. 3.21.
/
404 /
/404
# /404 HTML
# HTML
# HTML
HTMLКомпонент кода состояния
Компонент кода состояния
Компонент кода состоянияКомпонент
кода состоянияКомпонент конечной точки
Компонент конечной точки
Компонент конечной точкиКомпонент конечной точкиЗапрос к URL-адресу / передается конвейеру
StatusCodePagesMiddleware изначально
игнорирует запрос
Компонент конечной точки возвращает код
состояния ошибки, в данном случае 404
Ответ распространяется вверх по конвейеру
и перехватывается StatusCodePagesMiddleware.
Он изменяет путь запроса на путь /404 и снова
отправляет запрос по конвейеру
Конвейер ПО обрабатывает новый путь
/Error и генерирует ответ, как обычно.
В данном случае компонент конечной
точки генерирует ответ в виде HTML-кода
StatusCodePagesMiddleware использует
новый ответ, но обновляет код состояния
на код 404. Это указывает браузеру, что
произошла ошибка, но пользователь видит
удобную веб-страницу, указывающую на то,
что что-то пошло не так
Рис. 3.21 StatusCodePagesMiddleware повторно выполняет конвейер для генерации
HTML-тела ответа 404. Запрос к пути / возвращает ответ 404, который
обрабатывается компонентом кода состояния. Конвейер повторно запускается
с использованием пути /404 для генерации ответа в виде HTML

127 Обработка ошибок с помощью промежуточного ПО
Обратите внимание, что путь обработки ошибок "/{0}" содержит
маркер строки форматирования, {0}. При повторном выполнении пути
компонент заменит этот маркер на номер кода состояния. Например,
ошибка 404 приведет к повторному выполнению пути /404. Обработчик
пути (обычно это страница Razor) имеет доступ к коду состояния и при
желании может изменить ответ в  зависимости от кода состояния. Вы
можете выбрать любой путь обработки ошибок, если ваше приложение
знает, как его обработать.
ПРИМЕЧАНИЕ  Вы узнаете о том, как маршрутизация отображает
пути запросов в страницы Razor, в главе 5.
При таком подходе можно создавать разные страницы для разных ко-
дов ошибок, например страницу с ошибкой 404, показанную на рис. 3.22.
Этот метод гарантирует, что ваши страницы ошибок согласованы
с  остальной частью вашего приложения, включая любое динамически
генерируемое содержимое, а также позволяет адаптировать сообщение
для распространенных ошибок.
Рис. 3.22 Страница для отсутствующего файла. При обнаружении кода ошибки
(в этом случае это ошибка 404) конвейер промежуточного ПО повторно запускается
для генерации ответа. Это позволяет динамическим частям вашей веб-страницы
оставаться согласованными
ВНИМАНИЕ!  Как и  раньше, при повторном запуске конвейера
необходимо соблюдать осторожность и  следить, чтобы ваш путь
обработки ошибок не генерировал ошибок.
StatusCodePagesMiddleware можно использовать в  сочетании с  дру -
гим компонентом для обработки исключений, добавив оба компонен-
та в  конвейер. StatusCodePagesMiddleware будет изменять ответ только

128 Глава 3 Обработка запросов с помощью конвейера промежуточного ПО
в том случае, если тело ответа не было записано. Поэтому если еще один
компонент, например ExceptionHandlerMiddleware, возвращает тело со-
общения вместе с кодом ошибки, он не будет изменен.
ПРИМЕЧАНИЕ  StatusCodePagesMiddleware имеет дополнитель-
ные перегруженные версии, позволяющие выполнять настраива-
емый компонент при возникновении ошибки вместо повторного
выполнения пути к страницам Razor.
Обработка ошибок важна при разработке любого веб-приложения;
ошибки случаются, и нужно аккуратно их обрабатывать. Но в зависимо-
сти от вашего приложения, возможно, вам не всегда хочется, чтобы ваш
компонент для обработки ошибок генерировал HTML-страницы.
3.3.4 Компонент обработки ошибок и веб-API
ASP .NET Core отлично подходит не только для создания веб-приложе-
ний, ориентированных на пользователя, но и для создания HTTP-служб,
доступ к которым можно получить из другого серверного приложения,
мобильного приложения или из браузера пользователя при запуске од-
ностраничного приложения на стороне клиента.
Во всех этих случаях вы, вероятно, не будете возвращать клиенту
HTML-код, а предпочтете использовать формат XML или JSON.
В этой ситуации, если произойдет ошибка, вы, возможно, не захотите
отправлять обратно большую страницу со словами «Ой, что-то пошло не
так». Возврат HTML-страницы в приложение, ожидающее формат JSON,
может с  легкостью привести к  сбою. Код состояния HTTP 500 и  тело
JSON, описывающее ошибку, более полезны для приложения-потреби-
теля. К счастью, ASP .NET Core позволяет делать именно это при создании
конт роллеров веб-API.
ПРИМЕЧАНИЕ  Речь о контроллерах MVC и Web API идет в гла-
ве 4. Web API и обработка ошибок подробно описаны в главе 9.
На этом пока все, что касается конвейера промежуточного ПО и его
компонентов в  ASP .NET Core. Вы узнали, как использовать и  сочетать
компоненты для формирования конвейера, а  также как обрабатывать
ошибки в своем приложении. Это очень поможет вам, когда вы начне-
те создавать свои первые приложения ASP .NET Core. Позже вы узнаете,
как создавать собственные компоненты промежуточного программного
обеспечения, а также как выполнять сложные операции с конвейером,
такие как разветвление в ответ на определенные запросы.
В следующей главе мы более подробно рассмотрим страницы Razor
и  то, как их можно использовать для создания веб-сайтов. Вы также
узнае те о паттерне проектирования MVC, его связи со страницами Ra-

129 Резюме
zor в ASP .NET Core и о том, когда следует отдать предпочтение тому или
иному подходу.
Резюме
Промежуточное ПО выполняет ту же роль, что и HTTP-модули и об-
работчики в ASP .NET, но оно проще.
Компоненты промежуточного ПО образуют конвейер, при этом вы-
ходные данные одного промежуточного программного обеспече-
ния передаются на вход следующего.
Конвейер промежуточного ПО является двусторонним: запросы
проходят через каждый компонент на входе, а  ответы проходят
в обратном порядке на выходе.
Компонент может замкнуть конвейер, обработав запрос и  вернув
ответ, или может передать запрос следующему компоненту в кон-
вейере.
Компонент может изменять запрос, добавляя данные в объект Http-
Context или изменяя его.
Если компонент, идущий раньше, замыкает конвейер, то не все ком-
поненты для всех запросов будут выполняться.
Если запрос не обработан, конвейер вернет код состояния 404.
Порядок, в котором компоненты добавляются в  IApplicationBuil-
der, определяет порядок, в котором они будут выполняться в кон-
вейере.
Конвейер можно выполнить повторно, если не были отправлены за-
головки ответа.
При добавлении в конвейер StaticFileMiddleware будет возвращать
все запрашиваемые файлы, находящиеся в папке wwwroot вашего
приложения.
DeveloperExceptionPageMiddleware предоставляет множество ин-
формации об ошибках при разработке приложения, но его никогда
не следует использовать в промышленном окружении.
ExceptionHandlerMiddleware позволяет предоставлять пользователю
удобные сообщения об обработке ошибок при возникновении ис -
ключения в конвейере. Он безопасен для использования в промыш-
ленном окружении, поскольку не раскрывает конфиденциальные
сведения о вашем приложении.
StatusCodePagesMiddleware позволяет предоставлять пользователю
удобные сообщения об обработке ошибок, когда конвейер возвра-
щает низкоуровневый код состояния ответа об ошибке.
Microsoft предоставляет ряд распространенных компонентов, а так -
же есть много сторонних вариантов, доступных в NuGet и GitHub.

4Создание	веб-сайта
с помощью	страниц	Razor
В этой главе:
знакомство со страницами Razor и паттерном
проектирования Модель–представление–контроллер (MVC);
использование страниц Razor в ASP.NET Core;
страницы Razor и контроллеры MVC – что выбрать;
управление потоком приложения с помощью результатов
действий (action result).
В главе 3 вы познакомились с конвейером промежуточного ПО, который
определяет, как приложение ASP .NET Core отвечает на запрос. Каждый
компонент может изменять или обрабатывать входящий запрос перед
передачей его следующему компоненту в конвейере.
В веб-приложениях ASP .NET Core конвейер промежуточного ПО обыч-
но включает в себя компонент EndpointMiddleware. Именно здесь вы, как
правило, пишете основную часть логики приложения, вызывая различ-
ные другие классы в своем приложении. Он также служит основной точ-
кой входа для пользователей, которые могут взаимодействовать с вашим
приложением. Обычно он принимает одну из трех форм:
веб-приложение	 с  HTML-разметкой, 	разработанное	 для	непосред-
ственного	 использования	 пользователями. Если приложение при-

131 Создание веб-сайта с помощью страниц Razor
меняется пользователями напрямую, как в традиционном веб-при-
ло жении, то страницы Razor отвечают за создание веб-страниц,
с которыми взаимодействует пользователь. Они обрабатывают за-
просы URL-адресов, получают данные, отправленные с  помощью
форм, и генерируют HTML-код, который пользователи используют
для просмотра и навигации по вашему приложению;
API,	предназначенный	 для	использования	 на	другой	машине	 или	в коде.
Еще одна основная возможность для веб-приложения  – служить
в качестве API для серверных процессов, мобильного приложения
или клиентской платформы для создания одностраничных при-
ложений. В  этом случае ваше приложение предоставляет данные
в машиночитаемом формате, таком как JSON или XML, вместо при-
вычного для человека вывода в виде HTML-разметки;
веб-приложение	 с HTML-разметкой	 и API. Также возможно наличие
приложений, которые удовлетворяют обеим потребностям, что мо-
жет позволить обслуживать более широкий круг клиентов, разделяя
логику в приложении.
В этой главе вы узнаете, как ASP .NET Core использует функцию
Razor Pages для обработки первого из этих вариантов, создания HTML-
страниц с отрисовкой на стороне сервера. Мы начнем с рассмотрения
шаблона проектирования Модель–представление–контроллер (MVC),
чтобы увидеть преимущества, которых можно достичь за счет его ис -
пользования, и узнать, почему он был принят таким большим числом
веб-фреймворков в качестве модели для создания легких в сопровож -
дении приложений.
Далее вы узнаете, как паттерн проектирования MVC применяется
к ASP .NET Core. Данный паттерн – это общая концепция, которую можно
применять в различных ситуациях, но в ASP .NET Core он используется
как абстракция пользовательского интерфейса. Вы увидите, как Razor
Pages реализует шаблон проектирования MVC, как он строится поверх
фреймворка ASP .NET Core MVC, и сравните оба подхода.
Далее вы узнаете, как добавить Razor Pages в существующее прило-
жение и как создать свою первую страницу Razor. Вы узнаете, как опре-
делить обработчики страниц, которые будут выполняться, когда ваше
приложение получает запрос, и  как сгенерировать результат, который
можно использовать для создания HTTP-ответа.
В этой главе я  не буду рассказывать, как создавать веб-API. Веб-API
по-прежнему применяют фреймворк ASP .NET Core MVC, однако они ис -
пользуются несколько иначе, чем Razor Pages. Вместо того чтобы воз-
вращать веб-страницы, которые отображаются непосредственно в брау -
зере пользователя, они возвращают данные, отформатированные для
по треб  ления в  коде. Веб-API часто используются для предоставления
данных мобильным и веб-приложениям или другим серверным прило-
жениям, но они по-прежнему следуют тому же общему паттерну MVC.
Вы увидите, как создать веб-API, в главе 9.

132 Глава 4 Создание веб-сайта с помощью страниц Razor
ПРИМЕЧАНИЕ  Данная глава является первой из нескольких
глав, посвященных Razor Pages и паттерну MVC в ASP .NET Core. Как
я уже упоминал, эти фреймворки часто отвечают за обработку всей
бизнес-логики и кода пользовательского интерфейса вашего при-
ложения, поэтому, что неудивительно, они большие и  довольно
сложные. Следующие пять глав посвящены различным аспектам
паттерна MVC, применяемого во фреймворках MVC и Razor Pages.
В этой главе я постараюсь подготовить вас к каждой из предстоящих
тем, но, возможно, вы обнаружите, что на данном этапе некоторые дей-
ствия покажутся вам немного магическими. Старайтесь не слишком за-
ботиться о том, как именно все части связаны друг с другом; сосредо-
точьтесь на конкретных рассматриваемых концепциях. Все станет ясно,
когда мы рассмотрим связанные с этим подробности в оставшихся раз-
делах первой части книги.
4.1 Введение в Razor Pages
Модель программирования Razor Pages была представлена в  ASP .NET
Core 2.0 как способ создания многостраничных веб-сайтов с отрисовкой
на стороне сервера. Она построена на основе инфраструктуры ASP .NET
Core, чтобы обеспечить оптимизированный опыт, по возможности с ис -
пользованием соглашений, дабы уменьшить необходимое количество
стандартного кода и конфигурации.
ОПРЕДЕЛЕНИЕ  Многостраничный	 веб-сайт – это сайт, на кото-
ром пользователь просматривает несколько страниц, вводит дан-
ные в  формы и  обычно потребляет контент, в  отличие от таких
приложений, как игры или одностраничные приложения (SPA),
которые являются сильно интерактивными на стороне клиента.
Вы уже видели очень простой пример страницы Razor в главе 2. В этом
разделе мы начнем с рассмотрения немного более сложной страницы,
чтобы лучше понять общий дизайн страниц Razor. Темы, о которых пой-
дет речь:
пример типичной страницы Razor;
паттерн проектирования MVC и как применить его к Razor Pages;
как добавить Razor Pages в ваше приложение.
В конце этого раздела вы должны хорошо разбираться в общем дизай-
не Razor Pages и понимать, как они связаны с паттерном MVC.
4.1.1 Изучение типичной страницы Razor
В главе 2 мы рассмотрели очень простую страницу Razor. Она не содер-
жала никакой логики, а  просто отображала связанное представление

133 Введение в Razor Pages
Razor. Такой подход может быть распространен, если вы создаете, на-
пример, маркетинговый веб-сайт с большим количеством контента, но
чаще всего ваши страницы Razor будут содержать некую логику, загру -
жать данные из базы данных или использовать формы, чтобы позволить
пользователям отправлять информацию.
Чтобы лучше понять, как работают типичные страницы Razor, в этом
разделе мы кратко рассмотрим страницу посложнее. Эту страницу мы
взяли из приложения со списком дел. Она используется для отображения
всех дел для данной категории. На этом этапе мы не фокусируемся на
генерации HTML-кода, поэтому в следующем листинге показан только
код программной части PageModel для страницы Razor.
Листинг 4.1  Страница Razor для просмотра всех дел
в заданной категории
public class CategoryModel : PageModel
{
private readonly ToDoService _service;
public CategoryModel(ToDoService service)
{
_service = service;
}
public ActionResult OnGet(string category)
{
Items = _service.GetItemsForCategory(category);
return Page();
}
public List<ToDoListModel> Items { get; set; }
}
Это по-прежнему относительно простой пример, однако он демонст -
рирует множество функций по сравнению с базовым примером из гла-
вы 2:
обработчик страницы OnGet принимает параметр метода, category.
Этот параметр автоматически заполняется инфраструктурой Razor
Page с использованием значений из входящего запроса в процессе
под названием привязка	 модели	 (Model	Binding). Привязка модели
подробно обсуждается в главе 6;
обработчик не взаимодействует с базой данных напрямую. Вместо
этого он использует значение category, предоставленное для взаи-
модействия с  ToDoService, которое внедряется как аргумент конст -
руктора с использованием внедрения зависимостей;
обработчик возвращает Page() в конце метода, чтобы указать, что
связанное представление Razor должно быть отрисовано. В  этом
случае оператор return фактически является необязательным; по
соглашению, если обработчик страницы – это метод void, представ-T oDoService получается
конструктором модели
с использованием внедрения
зависимостей.
Обработчик OnGet принимает
параметр, category.Обработчик обращается
к T oDoService
для извлечения данных
и задает свойство Items.
Возвращает объект PageResult,
указывая на то, что должно быть
отображено представление Razor.
Представление Razor может получить
доступ к свойству Items при визуализации.

134 Глава 4 Создание веб-сайта с помощью страниц Razor
ление Razor все равно будет отображаться, как если бы вы вызвали
return Page() в конце метода;
представление Razor имеет доступ к экземпляру CategoryModel, по -
этому он может получить доступ к свойству Items, установленному
обработчиком. Он использует эти элементы для создания HTML-
кода, который в конечном итоге отправляется пользователю.
Паттерн взаимодействий на странице Razor из листинга 4.1 демон-
стрирует распространенный подход. Обработчик страницы является
центральным контроллером страницы Razor. Он получает входные дан-
ные от пользователя (параметр метода category), обращается к  «моз-
гам» приложения (ToDoService) и  передает данные (предоставляя до-
ступ к свойству Items) представлению Razor, которое генерирует в ответ
HTML-код. Если приглядеться, то это похоже на паттерн проектирования
Модель–представление–контроллер (MVC).
В зависимости от вашего опыта в разработке программного обеспече-
ния вы, возможно, ранее сталкивались с этим паттерном в той или иной
форме. В веб-разработке MVC является распространенной парадигмой
и используется в таких фреймворках, как Django, Rails и Spring MVC. Но
поскольку это очень обширная концепция, вы можете найти MVC везде,
от мобильных приложений до полнофункциональных клиентских на-
стольных приложений. Надеюсь, это свидетельствует о пользе, которую
данный паттерн может принести при правильном использовании! В сле-
дующем разделе мы рассмотрим паттерн MVC в общих чертах и то, как
он используется ASP .NET Core.
4.1.2 Паттерн проектирования MVC
Паттерн проектирования MVC  – это распространенный шаблон для
проектирования приложений с  пользовательским интерфейсом. Ис -
ходный паттерн MVC имеет множество различных интерпретаций,
каждая из которых фокусируется на разных аспектах. Например, ис -
ходный паттерн проектирования MVC был определен с учетом полно-
функциональных клиентских приложений с графическим интерфейсом
пользователя (GUI), а не веб-приложений, поэтому в нем используются
терминология и парадигмы, связанные со средой графического интер-
фейса пользователя. По сути, однако, этот паттерн направлен на отде-
ление управления данными и манипулирования данными от их визу -
ального представления.
Прежде чем мы подробно изучим сам паттерн проектирования, рас -
смотрим типичный запрос. Представьте, что пользователь вашего при-
ложения запрашивает страницу Razor из предыдущего раздела, на кото-
рой отображена категория списка дел. На рис. 4.1 показано, как страница
Razor обрабатывает различные аспекты запроса, чтобы сгенерировать
окончательный ответ.

135 Введение в Razor Pages
Запрос
Обработчик страницы Razor
Представление
ОтветСписок
элементовМодель приложения1.  Запрос на просмотр
категории списка дел получен
от пользователя 3.  Обработчик страницы запрашивает текущие
элементы списка из модели приложения
с помощью T oDoService. Модель может извлекать
их из памяти, файла или базы данных, например
4.  Обработчик страницы передает элементы
списка из модели в представление Razor,
задавая свойство на странице Razor
5.  Представление Razor вставляет
элементы в HTML-шаблон и отправляет
полноценную HTML-страницу обратно
пользователю 2.  Обработчик страниц
CategoryModel.OnGet
обрабатывает запрос
Рис. 4.1 Запрос страницы списка дел для приложения Razor Pages.
Каждый аспект запроса обрабатывается отдельным «компонентом»
В целом паттерн проектирования MVC состоит из трех «компонентов»:
модель – это данные, которые необходимо отобразить, глобальное
состояние приложения. Доступ к  нему осуществляется через To-
DoService в листинге 4.1;
представление  – шаблон, отображающий данные, предоставленные
моделью;
контроллер – обновляет модель и предоставляет данные для отобра-
жения в  представлении. Эту роль выполняет обработчик страниц
в Razor Pages. Это метод OnGet из листинга 4.1.
Каждый компонент в паттерне проектирования MVC отвечает за один
аспект всей системы, которые при объединении можно использовать для
создания пользовательского интерфейса. В примере со списком дел MVC
рассматривается с точки зрения веб-приложения, использующего Razor
Pages, но запрос также может быть эквивалентен щелчку кнопки в на-
стольном приложении с графическим интерфейсом пользователя.
В целом порядок событий, когда приложение отвечает на взаимодей-
ствие с пользователем или запрос, следующий:
1 контроллер (обработчик страницы Razor) получает запрос;
2  в зависимости от запроса контроллер либо извлекает запрошенные
данные из модели приложения, используя внедренные сервисы,
либо обновляет данные, образующие модель;
3  контроллер выбирает представление для отображения и передает
ему представление модели;

136 Глава 4 Создание веб-сайта с помощью страниц Razor
4  представление использует данные, содержащиеся в  модели, для
создания пользовательского интерфейса.
Когда мы описываем MVC в  этом формате, контроллер (обработчик
страницы Razor) служит точкой входа для взаимодействия. Пользова-
тель связывается с контроллером, чтобы инициировать взаимодействие.
В веб-приложениях это взаимодействие принимает форму HTTP-запро-
са, поэтому, когда запрос на URL-адрес получен, контроллер обрабаты-
вает его.
В зависимости от характера запроса контроллер может выполнять
различные действия, но ключевым моментом является то, что действия
выполняются с использованием модели приложения. Модель здесь со-
держит всю бизнес-логику приложения, поэтому оно может предостав-
лять запрашиваемые данные или выполнять действия.
ПРИМЕЧАНИЕ  В  этом описании MVC модель рассматривается
как непростой зверь, содержащий всю логику выполнения дей-
ствия, а также любое внутреннее состояние. Класс Razor Page Page-
Model – это не та модель, о которой мы говорим! К сожалению, как
и во всей разработке программного обеспечения, названия – вещь
непростая.
Рассмотрим запрос на просмотр страницы товара для приложения
электронной торговли. Контроллер получит запрос и  будет знать, как
связаться с каким-то сервисом товаров, который является частью моде-
ли приложения. Он может получить сведения о запрашиваемом товаре
из базы данных и вернуть их контроллеру.
В качестве альтернативы представьте, что контроллер получает за-
прос на добавление товара в  корзину пользователя. Контроллер полу -
чит запрос и, скорее всего, вызовет метод модели, чтобы запросить до-
бавление товара. Затем модель обновит свое внутреннее представление
корзины пользователя, добавив, например, новую строку в таблицу базы
данных, содержащую данные пользователя.
СОВЕТ  Можно рассматривать каждый обработчик страниц Razor
как мини-контроллер, ориентированный на одну страницу. Каж -
дый веб-запрос – это независимый вызов контроллера, который
координирует получение ответа. Хотя существует много разных
контроллеров, все обработчики взаимодействуют с  одной	и той	же
моделью приложения.
После обновления модели контроллеру необходимо решить, какой
ответ сгенерировать. Одним из преимуществ использования паттерна
проектирования MVC является то, что модель, представляющая данные
приложения, отделена от окончательного внешнего вида этих данных,
называемого представлением. Контроллер отвечает за принятие реше-
ния о том, должен ли ответ генерировать HTML-представление, нужно ли

137 Введение в Razor Pages
отправлять пользователя на новую страницу или нужно вернуть страни-
цу с сообщением об ошибке.
Одним из преимуществ независимости модели от представления яв-
ляется то, что она улучшает тестируемость. Код пользовательского ин-
терфейса классически сложно протестировать, поскольку он зависит
от окружения – любой, кто писал тесты пользовательского интерфейса,
имитирующие нажатие пользователем кнопок и ввод данных в формы,
знает, что обычно они хрупкие. Сохраняя модель независимой от пред-
ставления, вы можете гарантировать, что модель останется легко тести-
руемой, без каких-либо зависимостей от конструкций пользовательско-
го интерфейса. Поскольку модель часто содержит бизнес-логику вашего
приложения, это явно хорошо!
Представление может использовать данные, передаваемые ему конт -
роллером, для генерации соответствующего ответа в  виде HTML-кода.
Представление отвечает только за генерацию окончательного представ-
ления данных; оно не участвует ни в какой бизнес-логике.
Это все, что касается паттерна проектирования MVC, если говорить
о  веб-приложениях. Большая часть путаницы, связанной с  MVC, по-
видимому, происходит из-за несколько разных применений этого тер-
мина для разных фреймворков и типов приложений. В следующем раз-
деле я  покажу, как фреймворк ASP .NET Core использует паттерн MVC
с Razor Pages, а также другие примеры этого паттерна в действии.
4.1.3 Применение паттерна проектирования MVC
к Razor Pages
В предыдущем разделе мы обсуждали паттерн MVC, который обычно ис -
пользуется в веб-приложениях; он используется и в Razor Pages. Но в ASP .
NET Core также есть фреймворк под названием ASP .NET Core MVC. Этот
фреймворк (что неудивительно) очень точно отражает паттерн проекти-
рования MVC, используя контроллеры и  методы	 действий вместо Razor
Pages и  обработчиков страниц. Razor Pages строится непосредственно
поверх базового фреймворка ASP .NET Core MVC, используя под капотом
фреймворк MVC для своего поведения.
При желании вы можете полностью отказаться от использования Razor
Pages и работать с фреймворком MVC непосредственно в ASP .NET Core.
В ранних версиях ASP .NET Core и предыдущей версии ASP .NET это был
единственный вариант.
СОВЕТ  Выбор между Razor Pages и платформой MVC будет более
подробно рассматриваться в разделе 4.2.
В этом разделе мы по пунктам рассмотрим, как паттерн проектирова-
ния MVC применяется к Razor Pages в ASP .NET Core. Это также поможет
прояснить роль различных функций Razor Pages.

138 Глава 4 Создание веб-сайта с помощью страниц Razor
MVC или MVVM – что используется в Razor Pages?
Иногда я видел, как некоторые утверждают, что Razor Pages использует пат -
терн проектирования Модель–представление–представление (MVVM), а не
паттерн MVC. Лично я не согласен с этим, но стоит помнить о различиях.
MVVM – это паттерн пользовательского интерфейса, который часто исполь-
зуется в  мобильных и  настольных приложениях и  некоторых клиентских
фреймворках. Его отличие от MVC состоит в том, что между представлени-
ем и моделью представления существует двунаправленное взаимодействие.
Модель представления сообщает представлению, что отображать, но пред-
ставление также может инициировать изменения непосредственно в модели
представления. Он часто используется с  двусторонней привязкой данных,
когда модель представления «привязана» к представлению. Некоторые счи-
тают, что в Razor Pages эту роль выполняет модель PageModel, но я не уверен.
Мне определенно кажется, что Razor Pages основан на паттерне MVC (в кон-
це концов, он основан на фреймворке ASP.NET Core MVC!), и у него нет такой
же двусторонней привязки, которую я ожидал бы в случае с MVVM.
Как вы видели в предыдущих главах, ASP .NET Core реализует конеч-
ные точки Razor Page, используя комбинацию  RoutigMiddleware и  End-
pointMiddleware, как показано на рис. 4.2. Как только запрос был обра-
ботан более ранним компонентом (и при условии, что ни один из них
не обработал запрос и  не замкнул конвейер), компонент маршрутиза-
ции выберет, какой обработчик страницы Razor должен быть выполнен,
а компонент конечной точки выполнит обработчик страницы.
Промежуточное ПО часто обрабатывает сквозную функциональность
или узко определенные запросы, такие как запросы файлов. Для требо-
ваний, выходящих за рамки этих функций или имеющих много внеш-
них зависимостей, требуется более надежный фреймворк. Razor Pages
(и/или ASP .NET Core MVC) может предоставить такой фреймворк, позво-
ляя взаимодействовать с основной бизнес-логикой вашего приложения
и  создавать пользовательский интерфейс. Он обрабатывает все, от со-
поставления запроса с  соответствующим контроллером до генерации
HTML- или API-ответов.
В традиционном описании паттерна проектирования MVC есть толь-
ко один тип модели, который содержит все данные и поведение, не от -
носящиеся к пользовательскому интерфейсу. Контроллер обновляет эту
модель соответствующим образом, а затем передает ее представлению,
которое использует ее для создания пользовательского интерфейса.
Одна из проблем, возникающих при обсуждении MVC, – это расплыв-
чатые и  неоднозначные термины, которые он использует, такие как
«контроллер» и «модель». Модель, в частности, – настолько перегружен-
ный термин, что часто бывает трудно понять, к чему именно он отно-
сится – это объект, коллекция объектов или абстрактное понятие? Даже
в ASP .NET Core слово «модель» используется для описания нескольких
связанных, но разных компонентов, как вы вскоре увидите.

139 Введение в Razor Pages
Запрос проходит через каждый
компонент в конвейере
Каждый компонент получает
возможность обработать запрос
Компонент маршрутизации
пытается найти конечную точку,
которая будет обрабатывать
запрос
Компонент конечной точки
является последним в конвейере.
Паттерн MVC полностью
реализуется отдельными
конечными точками Razor Page Запрос Ответ
Компонент обработки ошибок
Компонент статических файлов
Компонент маршрутизации
Компонент конечной точки
Рис. 4.2 Конвейер промежуточного ПО типичного приложения ASP .NET Core.
Запрос обрабатывается каждым компонентом последовательно. Если запрос
достигает компонента маршрутизации, выбирается конечная точка, например
страница Razor, для выполнения. Компонент конечной точки выполняет выбранную
конечную точку
Маршрутизация  запроса  на страницу  RazoR и создание  Модели  привязки
Первый шаг, когда ваше приложение получает запрос, – это его маршру -
тизация соответствующему обработчику страницы Razor. Давайте снова
обратимся к странице списка дел с категориями из листинга 4.1. На этой
странице отображен список элементов с ярлыком заданной категории.
Если вы просматриваете список элементов с категорией Simple, то долж -
ны сделать запрос к пути /category/Simple.
Маршрутизация берет заголовки и  путь запроса, /category/Simple,
и сопоставляет их с предварительно зарегистрированным списком пат -
тернов. Каждый из них соответствует пути к одной странице Razor и об-
работчику страницы. Подробнее о маршрутизации вы узнаете в следую-
щей главе.

140 Глава 4 Создание веб-сайта с помощью страниц Razor
СОВЕТ  Я использую термин Razor	Page для обозначения сочета-
ния представления Razor и  PageModel, который включает в себя об-
работчик страницы. Обратите внимание, что этот класс PageModel
не та «модель», о  которой мы говорим при описании паттерна
MVC. Как вы увидите позже в данном разделе, у него другая роль.
После выбора обработчика страницы создается модель	привязки (если
она применима). Эта модель построена на основе входящего запроса,
свойств PageModel, отмеченных для привязки, и параметров метода, нуж -
ных обработчику страницы, как показано на рис. 4.3. Модель привязки
обычно представляет собой один или несколько стандартных объектов
C#, свойства которых сопоставляются с  запрошенными данными. Мы
подробно рассмотрим модели привязки в главе 6.
ОПРЕДЕЛЕНИЕ  Модель	привязки – это один или несколько объ-
ектов, которые действуют как «контейнер» для данных, представ-
ленных в запросе, – данных, которые требуются обработчику стра-
ницы.
Запрос
Компонент маршрутизации
Обработчик страницы
Страница RazorМодель привязкиПолучение URL-адреса
/category/Simple
URL-адрес сопоставляется
со страницей Razor
CategoryModel.OnGet
category  = "Simple"
Выполняется обработчик страницы
OnGet(category)1.  Запрос получен и проходит через
конвейер промежуточного ПО
2.  Компонент маршрутизации
направляет запрос конкретной
странице Razor и обработчику
3.  Модель привязки строится
из деталей, предоставленных
в запросе
4.  Странице Razor передается
модель привязки, и выполняется
метод обработчика страницы
Рис. 4.3 Маршрутизация запроса к контроллеру и построение модели привязки. Запрос  URL-
адреса /category/Simple приводит к выполнению обработчика страницы CategoryModel.
OnGet, передавая заполненную модель привязки, category
В данном случае модель привязки представляет собой простую строку,
category, которая привязана к значению "Simple". Это значение указы-
вается в пути URL-адреса запроса. Также можно было использовать бо-
лее сложную модель привязки, в которой были бы заполнены несколько
свойств.

141 Введение в Razor Pages
Модель привязки в  данном случае соответствует параметру мето-
да обработчика страницы OnGet. Экземпляр страницы Razor создается
с  помощью конструктора, а  модель привязки передается обработчику
страницы при ее выполнении, поэтому ее можно использовать для того,
чтобы принять решение относительно того, как ответить. В этом приме-
ре обработчик страницы использует ее, чтобы решить, какие элементы
списка отображать на странице.
выполнение  обработчика  с использованиеМ  Модели  приложения
Роль обработчика страницы как контроллера в паттерне MVC заключает -
ся в координации генерации ответа на запрос, который он обрабатывает.
Это означает, что он должен выполнять только ограниченное количество
действий. В частности, он должен:
убедиться, что данные, содержащиеся в  предоставленной модели
привязки, действительны для запроса;
вызвать соответствующие действия в  модели приложения с  по-
мощью сервисов;
выбрать соответствующий ответ для генерации на основе ответа от
модели приложения.
На рис. 4.4 показан обработчик страницы, вызывающий соответству -
ющий метод в модели приложения. Здесь видно, что модель приложе-
ния  – это несколько абстрактная концепция, которая инкапсулирует
оставшиеся части вашего приложения, не относящиеся к пользователь-
скому интерфейсу. Она содержит модель	предметной	 области, ряд серви-
сов и взаимодействие с базой данных.
ОПРЕДЕЛЕНИЕ  Модель	предметной	 области инкапсулирует слож -
ную бизнес-логику в набор классов, которые не зависят от какой-
ли бо инфраструктуры и которые можно легко протестировать.
1.  Обработчик страницы
использует категорию,
указанную в модели
привязки, чтобы определить,
какой метод вызывать
в модели приложения2.  Метод обработчика страницы вызывает
сервисы, составляющие модель
приложения. Он может использовать
модель предметной области, чтобы
определить, включать ли, например,
завершенные элементы списка дел3.  Сервисы загружают детали
элементов из базы данных
и возвращают их методу
действия
Обработчик страницы
Страница RazorСервисы
Взаимодействие
с базой данныхМодель
предметной области
Модель приложения
Рис. 4.4 При выполнении действие вызовет соответствующие методы в модели
приложения

142 Глава 4 Создание веб-сайта с помощью страниц Razor
Обработчик страницы обычно вызывает одну точку в модели прило-
жения. В нашем примере просмотра категории списка дел модель при-
ложения может использовать различные сервисы, чтобы проверить,
разрешено ли текущему пользователю просматривать определенные
элементы, искать элементы в данной категории, загружать сведения из
базы данных или картинку, связанную с элементом из файла.
Если запрос действителен, модель приложения вернет необходимые
данные обработчику страницы. Затем обработчик должен выбрать ответ
для генерации.
Генерация  HTML- кода с использованиеМ  Модели  представления
После того как обработчик страницы вызвал модель приложения, содер-
жащую бизнес-логику, пора сгенерировать ответ. Модель	представления
фиксирует детали, необходимые для того, чтобы представление сгене-
рировало ответ.
ОПРЕДЕЛЕНИЕ  Модель	представления в паттерне MVC – это все
данные, необходимые представлению для отрисовки пользова-
тельского интерфейса. Обычно это некое преобразование дан-
ных, содержащихся в модели приложения, плюс дополнительная
информация, необходимая для отрисовки страницы, например ее
заголовок.
Термин модель	представления широко используется в  ASP .NET Core
MVC, где обычно обозначает один объект, который передается в пред-
ставление Razor для отрисовки. Однако в  Razor Pages представление
Razor может напрямую обращаться к классу модели	страницы Razor Page.
Следовательно, PageModel обычно действует	 как модель представления
в Razor Pages, при этом доступ к данным, необходимым для представ-
ления Razor, осуществляется через свойства, как вы видели ранее в лис -
тинге 4.1.
ПРИМЕЧАНИЕ  Razor Pages использует сам класс PageModel в ка-
честве модели представления для Razor, предоставляя необходи-
мые данные как свойства.
Представление Razor использует данные, имеющиеся в модели стра-
ницы, для генерации окончательного ответа в  виде HTML. В  конце он
отправляется обратно по конвейеру промежуточного ПО и  выводится
в браузер пользователя, как показано на рис. 4.5.
Важно отметить, что хотя обработчик страницы выбирает, выполнять
ли представление и какие данные использовать, он не контролирует, ка-
кой	HTML-код генерируется. Само представление решает, каким будет со-
держание ответа.

143 Введение в Razor Pages
Обработчик страницы
Страница Razor
Модель
представления
Представление
HTML4.  Ответ отправляется
обратно через конвейер
промежуточного ПО1.  Обработчик страницы
собирает модель
представления из данных,
предоставленных моделью
приложения, задавая
свойства PageModel
2.  Обработчик страницы
указывает, что
представление должно быть
визуализировано
3.  Представление
Razor использует
предоставленную модель
представления для
генерации ответа в виде
HTML-кода, содержащего
подробную информацию
об элементах списка дел,
которые нужно отобразить
Рис. 4.5 Обработчик страницы создает модель представления, задавая свойства
PageModel. Это представление, генерирующее ответ
собираеМ  все вМесте : полный  запрос  страницы  RazoR
Теперь, когда вы ознакомились с  каждым этапом обработки запроса
в ASP .NET Core с  помощью Razor Pages, давайте объединим все это от
запроса к ответу. На рис. 4.6 показано, как объединяются шаги для обра-
ботки запроса на отображение списка дел для категории Simple. Тради-
ционный паттерн MVC все еще виден в Razor Pages. Он состоит из обра-
ботчика страницы (контроллера), представления и модели приложения.
К настоящему времени вы можете подумать, что весь этот процесс ка-
жется довольно запутанным – так много шагов, чтобы отобразить HTML!
Почему бы не позволить модели приложения создавать представление
напрямую, вместо того чтобы танцевать взад и вперед с методом обра-
ботчика страницы?
Ключевым преимуществом такого процесса является разделение	 от-
ветственности:
представление отвечает только за получение некоторых данных
и генерацию HTML-кода;
модель приложения отвечает лишь за выполнение необходимой
бизнес-логики;
обработчик страницы (контроллер) отвечает только за проверку
входящего запроса и выбор необходимого ответа на основе выход-
ных данных модели приложения.
Благодаря четко определенным границам легче обновлять и тестиро-
вать каждый из компонентов независимо от других. Если ваша логика
пользовательского интерфейса изменится, вам не обязательно будет из-
менять какой-либо из классов бизнес-логики, поэтому вероятность воз-
никновения ошибок в неожиданных местах снижается.

144 Глава 4 Создание веб-сайта с помощью страниц Razor
Обработчик страницы
Страница RazorСервисы
Взаимодействие
с базой данныхМодель
предметной области
Модель приложения
Модель
представления
Представление
HTML4.  Обработчик страницы указывает,
что представление должно быть
визуализировано, и передает ему
модель представления, содержащую
сведения об элементах списка дел5.  Представление использует предоставленную модель
для генерации ответа в виде HTML-кода, который
возвращается пользователю1.  Получен запрос на URL-адрес
/category/Simple
2.  Компонент маршрутизации
направляет запрос
обработчику страниц
OnGet на странице Category
и собирает модель привязки3.  Обработчик страницы вызывает сервисы,
составляющие модель приложения,
для получения сведений о текущем элементе
списка дел и сборки модели представленияЗапрос
Компонент
маршрутизации
Модель привязки
Рис. 4.6 Полный запрос Razor Pages для списка дел в категории Simple
Опасность сильной связности
В целом рекомендуется как можно больше уменьшать связность между ло-
гическими частями вашего приложения. Это упрощает обновление прило-
жения, не вызывая неблагоприятных последствий и  не требуя изменений
в, казалось бы, несвязанных областях. Применение паттерна MVC – один из
способов помочь вам в достижении этой цели.
В качестве примера, когда связность поднимает голову, я вспоминаю случай,
произошедший несколько лет назад, когда я работал над небольшим веб-
приложением. В  спешке мы не отделили должным образом нашу бизнес-
логику от кода генерации HTML-кода, но поначалу очевидных проблем не
было – код работал, поэтому мы его отправили заказчику!
Несколько месяцев спустя какой-то новый сотрудник начал работать над
приложением, и я сразу же «помог» ему, переименовав безобидную орфо-
графическую ошибку в классе на бизнес-уровне. К сожалению, имена этих
классов были использованы для генерации нашего HTML-кода, поэтому
переименование класса привело к выходу из строя всего веб-сайта в брау-
зерах пользователей! Достаточно сказать, что после этого мы приложили
согласованные усилия, чтобы применить паттерн MVC и убедиться, что у нас
было надлежащее разделение ответственности.

145 Введение в Razor Pages
Примеры, показанные в  этой главе, демонстрируют основную часть
функциональности Razor Pages. У  него есть дополнительные функции,
такие как конвейер фильтров, о которых я расскажу позже, а более под-
робно остановлюсь на моделях связывания в главе 6, но общее поведе-
ние системы останется без изменений.
Также в главе 9 я расскажу, как применяется паттерн проектирования
MVC, когда вы генерируете ответы в  машиночитаемом формате с  по-
мощью контроллеров веб-API. Процесс во всех смыслах идентичен, за
исключением конечного результата.
В следующем разделе вы увидите, как добавить Razor Pages в свое при-
ложение. Некоторые шаблоны в Visual Studio и .NET CLI по умолчанию
включают Razor Pages, но вы увидите, как добавить его в существующее
приложение, и изучите различные доступные варианты.
4.1.4 Добавление Razor Pages в приложение
Инфраструктура MVC, независимо от того, используется ли она Razor
Pages или контроллерами MVC/API, является основополагающим аспек -
том всех приложений ASP .NET Core, кроме самых простых, поэтому
практически все шаблоны включают ее, настроенную по умолчанию тем
или иным образом. Но чтобы убедиться, что Razor Pages можно прекрас -
но добавить в существующий проект, я начну с простого пустого прило-
жения и покажу вам, как добавить в него Razor Pages.
Результат ваших усилий пока не будет впечатляющим. Мы выведем на
экран надпись «Hello World», но это покажет, насколько просто преобра-
зовать приложение ASP .NET Core, чтобы использовать Razor Pages, а так -
же подчеркнет модульный характер ASP .NET Core – если вам не нужны
функциональные возможности, предоставляемые Razor Pages, можете
их не использовать.
Вот как добавить Razor Pages в свое приложение.
1  В Visual Studio 2019 выберите File > New > Project (Файл > Создать
> Проект) или выберите Create a New Project (Создать новый про-
ект) на экране-заставке.
2  Выберите из списка шаблонов веб-приложение ASP .NET Core, убе-
дившись, что выбран шаблон языка C#.
3  На следующем экране введите имя проекта, расположение и имя
решения и нажмите Create (Создать).
4  На следующем экране создайте базовый шаблон без MVC или Razor
Pages, выбрав пустой шаблон проекта ASP .NET Core в Visual Studio,
как показано на рис. 4.7. Вы можете создать аналогичный пустой
проект с помощью интерфейса командной строки .NET, используя
команду dotnet new web.

146 Глава 4 Создание веб-сайта с помощью страниц Razor
Убедитесь, что выбрано
.NET Core
Выберите ASP .NET
Core EmptyУбедитесь, что выбрано ASP .NET Core 5.0
Убедитесь, что для схемы
аутентификации задано
значение No Authentication
(Без аутентификации)
Убедитесь, что отмечен пункт
Configure HTTPS и снят флажок
для пункта Enable Docker
Support (Включить поддержку
Docker)
Щелкните по кнопке Create
(Создать), чтобы сгенерировать
приложение из выбранного
шаблона
Рис. 4.7  Создание пустого шаблона ASP .NET Core. Пустой шаблон создаст простое приложение
ASP .NET Core, содержащее небольшой конвейер промежуточного программного обеспечения
без Razor Pages
5  Добавьте необходимые сервисы Razor Page (выделены полужир-
ным шрифтом) в метод ConfigureServices файла Startup.cs:
public void ConfigureServices(IServiceCollection services)
{
services.AddRazorPages();
}
6  Замените существующую базовую конечную точку, сконфигуриро-
ванную в  EndpointMiddleware в конце вашего конвейера, на метод
расширения MapRazorPages() (выделен жирным шрифтом). Для
простоты также пока удалите существующий компонент обработ -
чика ошибок из метода Configure файла Startup.cs:
public void Configure(IApplicationBuilder app, IwebHostEnvironment env)
{
app.UseRouting();
app.UseEndpoints(endpoints =>
{
endpoints.MapRazorPages();
});
}
7  Щелкните правой кнопкой мыши свой проект в обозревателе ре-
шений и  выберите Add > New Folder (Добавить > Новая папка),
чтобы добавить новую папку в корень проекта. Назовите ее Pages.
Теперь вы настроили свой проект для использования Razor Pages,
но у вас пока нет страниц. На следующих шагах мы добавим новую
страницу Razor в наше приложение. Можно создать аналогичную
страницу Razor с  помощью интерфейса командной строки .NET,

147 Введение в Razor Pages
используя команду dotnet new page -n Index -o Pages/ из каталога
проекта.
8  Щелкните правой кнопкой мыши папку новых страниц и выберите
Add > Razor Page (Добавить > Страница Razor), как показано на
рис. 4.8.
1.  Щелкните правой кнопкой
мыши папку Pages, чтобы
открыть контекстное меню
2.  Нажмите Add (Добавить),
чтобы открыть вложенное
меню Add (Добавить)3.  Выберите Razor Page,
чтобы добавить страницу
Razor в свой проект
Рис. 4.8 Добавление новой страницы Razor в ваш проект
9  На следующей странице выберите Razor Page – Empty и нажмите
Add (Добавить). В  открывшемся диалоговом окне назовите свою
страницу Index.cshtml, как показано на рис. 4.9.
Убедитесь, что выбрано
Razor Page – Empty
Введите имя для новой
страницы RazorНажмите Add, чтобы
добавить класс в свой
проект
Рис. 4.9 Создание новой страницы Razor с помощью диалогового окна Добавить страницу
Razor
10  После того как Visual Studio завершит создание файла, откройте
файл Index.cshtml и  обновите HTML-код, чтобы вывести надпись
Hello	World!, заменив содержимое файла на это:
@page
@model AddingRazorPagesToEmptyProject.IndexModel
@{
Layout = null;
}

148 Глава 4 Создание веб-сайта с помощью страниц Razor
<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width" />
<title>Index</title>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>
Выполнив все эти шаги, вы сможете восстановить пакеты, собрать
и запустить ваше приложение.
ПРИМЕЧАНИЕ  Можно запустить свой проект, нажав клавишу
F5, из Visual Studio (или вызвав команду dotnet run в командной
строке из папки проекта). После этого все указанные пакеты NuGet
будут восстановлены, проект будет собран, и ваше приложение за-
пустится. Visual Studio автоматически откроет окно браузера для
доступа к домашней странице вашего приложения.
Когда вы делаете запрос к корневому пути "/", приложение вызывает
обработчик OnGet в  IndexModel из-за традиционного способа, по кото-
рому маршрутизация работает для Razor Pages на основе имени файла.
Пока не беспокойтесь об этом; мы подробно рассмотрим это в следую-
щей главе.
Обработчик OnGet – это метод void, который заставляет страницу Razor
отображать связанное представление Razor и отправлять его в браузер
пользователя в ответе.
Для выполнения своих функций Razor Pages использует ряд внутрен-
них сервисов, которые необходимо зарегистрировать во время запуска
приложения. Это можно сделать с помощью вызова метода AddRazorP-
ages в методе ConfigureServices файла Startup.cs. Без этого при запуске
приложения будут возникать исключения, напоминающие о необходи-
мости вызова.
При вызове метода MapRazorPages в классе Configure регистрируются
конечные точки страницы Razor в компоненте конечных точек. В рамках
этого вызова маршруты, которые используются для сопоставления URL-
путей с определенными обработчиками страниц Razor, регистрируются
автоматически.
ПРИМЕЧАНИЕ  Я подробно расскажу о маршрутизации в следую-
щей главе.
В инструкциях, приведенных в этом разделе, описано, как добавить
Razor Pages в  приложение, но это не единственный способ добавить
в приложение возможность генерации HTML-кода. Как я упоминал ра-
нее, Razor Pages основан на фреймворке ASP .NET Core MVC, и у них мно-

149 Сравнение Razor Pages и MVC в ASP.NET Core
го общих концепций. В следующем разделе мы кратко рассмотрим конт -
роллеры MVC, сравним их с Razor Pages и обсудим, что и когда следует
использовать.
4.2 Сравнение Razor Pages и MVC в ASP.NET Core
В этой книге я  говорю преимущественно о  Razor Pages, поскольку это
рекомендуемый подход для создания приложений с отрисовкой на сто-
роне сервера с помощью ASP .NET Core. Однако я также упоминал, что за
кулисами Razor Pages использует фреймворк ASP .NET Core MVC, и если
хотите, то можете использовать его напрямую. Кроме того, если вы соз-
даете веб-API для работы с мобильными или клиентскими приложения-
ми, то почти наверняка будете напрямую использовать фреймворк MVC.
ПРИМЕЧАНИЕ  Тема создания веб-API рассматривается в главе 9.
Итак, в чем разница между Razor Pages и MVC, и что и когда следует
выбирать?
Если вы новичок в ASP .NET Core, ответ довольно прост – используйте
Razor Pages для приложений с отрисовкой на стороне сервера и фрейм-
ворк MVC для создания веб-API. Есть нюансы, о  которых я  расскажу
в следующих разделах, но этот совет на начальном этапе вам очень при-
годится.
Если вы знакомы с  предыдущей версией ASP .NET или более ранни-
ми версиями ASP .NET Core и решаете, использовать ли Razor Pages, этот
раздел поможет вам сделать выбор. Некоторые разработчики часто из-
начально неправильно понимают Razor Pages (как и я!), ошибочно при-
равнивая их к Web Forms, и упускают из виду лежащую в их основе базу
фреймворка MVC.
Однако, прежде чем мы сможем перейти к сравнениям, нужно крат -
ко взглянуть на сам фреймворк MVC ASP .NET Core. Понимание сходства
и различий между MVC и Razor Pages может быть очень полезным, по-
скольку в какой-то момент вы, вероятно, найдете применение MVC, даже
если вы большую часть времени используете Razor Pages.
4.2.1 Контроллеры MVC в ASP.NET Core
В разделе 4.1 мы рассматривали паттерн проектирования MVC и то, как
он применяется к Razor Pages в ASP .NET Core. Возможно, неудивительно,
что можно использовать фреймворк ASP .NET Core MVC почти таким же
образом. Чтобы продемонстрировать разницу между Razor Pages и MVC,
мы рассмотрим MVC-версию страницы Razor из листинга 4.1, где отобра-
жен список дел для заданной категории.
Вместо PageModel и  обработчика страницы MVC использует концеп-
цию контроллеров и методов	 действий. Они почти полностью совпадают

150 Глава 4 Создание веб-сайта с помощью страниц Razor
со своими аналогами в Razor Pages, как видно на рис. 4.10, где показан
эквивалент MVC, изображенный на рис. 4.6.
Обработчик страницы
Страница RazorСервисы
Взаимодействие
с базой данныхМодель
предметной области
Модель приложения
Модель
представления
Представление
HTML4.  Контроллер выбирает представление
Razor, которое будет использоваться,
и передает ему модель представления,
содержащую сведения о продукте
5.  Представление использует предоставленную модель
для генерации ответа в виде HTML-кода, который
возвращается пользователю1.  Получен запрос на URL-адрес
todo/category/123
2.  Компонент маршрутизации
направляет запрос к действию
Category в T oDoController
и собирает модель привязки3.  Метод действия вызывает сервисы, образующие
модель приложения, для получения сведений
о продукте и сборки модели представленияЗапрос
Компонент
маршрутизации
Модель привязки
Рис. 4.10 Полный запрос контроллера MVC для категории. Паттерн контроллера MVC почти
идентичен шаблону Razor Pages, показанному на рис. 4.6. Контроллер эквивалентен странице
Razor, а действие эквивалентно обработчику страницы
С другой стороны, контроллеры MVC используют явные модели	пред-
ставления для передачи данных в представление Razor, а не предостав-
ляют данные как свойства.
ОПРЕДЕЛЕНИЕ  Действие (или метод	действия) – это метод, ко-
торый выполняется в ответ на запрос. Контроллер MVC – это класс,
содержащий несколько логически сгруппированных методов дей-
ствий.
В листинге 4.2 показан пример того, как может выглядеть контроллер
MVC, который предоставляет ту же функциональность, что и страница
Razor в листинге 4.1. В MVC контроллеры часто используются для объ-
единения схожих действий, поэтому контроллер в данном случае назы-
вается ToDoController, поскольку обычно содержит дополнительные ме-
тоды действий для работы с элементами списка дел, например действия
для просмотра определенного элемента или создания нового.

151 Сравнение Razor Pages и MVC в ASP.NET Core
Листинг 4.2  Контроллер MVC для просмотра всех дел
в заданной категории
public class ToDoController : Controller
{
private readonly ToDoService _service;
public ToDoController(ToDoService service)
{
_service = service;
}
public ActionResult Category(string id)
{
var items = _service.GetItemsForCategory(id);
var viewModel = new CategoryViewModel(items);
return View(viewModel);
}
public ActionResult Create(ToDoListModel model)
{
// ...
}
}
За исключением некоторых различий в именах, ToDoController очень
похож на эквивалент Razor Page из листинга 4.1. И в самом деле,	 с точки
зрения	архитектуры Razor Pages и MVC по сути эквивалентны, поскольку
оба используют паттерн проектирования MVC. Самые очевидные раз-
личия связаны с тем, где файлы	размещаются в вашем проекте. Об этом
речь пойдет в следующем разделе.
4.2.2 Преимущества Razor Pages
В предыдущем разделе я показал, что код контроллера MVC очень похож
на код модели страницы PageModel. В таком случае какая польза от при-
менения Razor Pages? В  этом разделе мы обсудим некоторые болевые
точки контроллеров MVC и то, как Razor Pages пытается их решить.
Razor Pages – это не Web Forms
Распространенный аргумент, который я слышу от разработчиков ASP.NET не
в пользу Razor Pages: «О, это всего лишь Web Forms». Это мнение не соот -
ветствует действительности во многих отношениях, но оно достаточно рас -
пространено, поэтому рассмотрим его подробнее.
Web Forms  – это модель веб-программирования, которая была выпущена как
часть .NET Framework 1.0 в 2002 году. Это попытка обеспечить высокопроиз-
водительный опыт для разработчиков, впервые переходящих от разработки
настольных приложений к веб-разработке.T oDoService предоставляется
в конструкторе контроллера
с использованием внедрения
зависимостей.
Метод действия Category
принимает параметр, id.Метод действия обращается
к T oDoService для извлечения
данных и сборки модели
представления.
Модель представления –
это простой класс C#,
определенный в другом
месте вашего приложения.
Возвращает объект ViewResult, указывающий на то,
что должно быть визуализировано представление
Razor, передавая модель представления.Контроллеры MVC часто
содержат несколько методов
действий, которые отвечают
на разные запросы.

152 Глава 4 Создание веб-сайта с помощью страниц Razor
Сейчас Web Forms сильно критикуют, но слабость этой модели стала очевид-
ной лишь позже. Веб-формы пытались скрыть от вас сложности интернета,
чтобы создать впечатление, что вы ведете разработку с помощью настоль-
ного приложения. Часто это приводило к тому, что приложения были мед-
ленными, с  большим количеством взаимозависимостей, и  их было трудно
сопровождать.
Web Forms предоставляют модель программирования на основе страниц,
поэтому Razor Pages иногда ассоциируется с ними. Однако, как вы видели,
Razor Pages основан на паттерне проектирования MVC и предоставляет до-
ступ к внутренней веб-функциональности, не пытаясь скрыть ее от вас.
Razor Pages оптимизирует определенные пути, используя соглашения (некото-
рые из которых вы видели), но не пытается создать модель приложения с со-
стоянием поверх веб-приложения без состояния, как это делали Web Forms.
В MVC один контроллер может иметь несколько методов действия.
Каждое действие обрабатывает разные запросы и генерирует разные от -
веты. Группировка нескольких действий в контроллере несколько про-
извольна, но обычно она используется для группировки действий, свя-
занных с определенной сущностью: в данном случае элементы списка
дел. Более полная версия ToDoController из листинга 4.2 может включать
в себя методы действий для перечисления всех элементов, например для
удаления элементов и создания новых. К сожалению, часто можно обна-
ружить, что ваши контроллеры становятся очень большими и раздуты-
ми, и у них большое количество зависимостей1.
ПРИМЕЧАНИЕ  Необязательно делать контроллеры такими боль-
шими. Это распространенный шаблон. Вместо этого можно, на-
пример, создать отдельный контроллер для каждого действия.
Еще один минус контроллеров MVC – их типичная организация в ва-
шем проекте. Большинству методов действий в контроллере потребуется
связанное представление Razor и  модель представления для передачи
данных в представление. В MVC классы традиционно группируются по
типу (контроллер, представление, модель представления), тогда как
в Razor Page группировка идет по	 функциям – все, что связано с опреде-
ленной страницей, размещается в одном месте.
На рис. 4.11 сравнивается макет файла для простого проекта Razor
Pages с эквивалентом MVC. Использование Razor Pages означает гораз-
до меньшую прокрутку вверх и вниз между контроллером, представле-
ниями и  папками моделей представлений при работе с  определенной
страницей. Все, что вам нужно, находится в двух файлах: представлении
Razor .cshtml и файле PageModel  .cshtml.cs.
1 Перед переходом на Razor Pages шаблон ASP .NET Core, включающий функцио-
нальность входа пользователя, содержал два таких контроллера, в каждом из
которых было свыше 20 методов действий и более 500 строк кода!

153 Сравнение Razor Pages и MVC в ASP.NET Core
Razor Pages группирует
все, что связано с одной
страницей, в двух совместно
расположенных файлах
MVC традиционно группирует
файлы по типам, а не по функциям,
распределяя файлы, необходимые
для данной страницы, по всему
проекту
Рис. 4.11 Сравнение структуры папок для проекта MVC со структурой папок для проекта
Razor Pages
Между MVC и  Razor Pages есть дополнительные различия, которые
я буду освещать на протяжении всей книги, но эта разница в макете дей-
ствительно является самым большим выигрышем. Razor Pages учитыва-
ет тот факт, что вы создаете страничное приложение, и  оптимизирует
рабочий процесс, объединяя все, что связано с одной страницей.
СОВЕТ  Можно рассматривать каждую страницу Razor как мини-
контроллер, сфокусированный на одной странице. Обработчики
страниц с функциональной точки зрения эквивалентны методам
действия контроллера MVC.
Этот макет также имеет преимущество, которое состоит в  том, что
каждая страница превращается в  отдельный класс. Это контрастирует
с MVC, где каждая страница превращается в  действие в данном контрол-
лере. Каждая страница Razor связана с определенной	 функцией, напри-
мер отображением списка дел. Контроллеры MVC содержат методы дей-
ствий, которые обрабатывают несколько различных функций для более
абстрактной концепции, например все функции, относящиеся к элемен-
там списка дел.
Еще один важный момент заключается в том, что Razor Pages не те-
ряет разделения ответственности, которое есть в  MVC. Представление
Razor Pages по-прежнему связано только с  отрисовкой HTML, а  обра-
ботчик – это координатор, который обращается к модели приложения.
Единственное реальное отличие – это отсутствие явной модели пред-
ставления, которая есть у вас в MVC, но ее вполне возможно сымитиро-
вать в Razor Pages, если вам это мешает.

154 Глава 4 Создание веб-сайта с помощью страниц Razor
Преимущества использования Razor Pages особенно заметны, когда
у вас есть «содержательные» веб-сайты, такие как маркетинговые веб-
сайты, на которых вы в основном отображаете статические данные, а ре-
альная логика отсутствует. В этом случае MVC добавляет сложности без
каких-либо реальных преимуществ, поскольку в  контроллерах вообще
нет никакой логики. Еще один отличный вариант использования – соз-
дание форм для пользователей для отправки данных. Razor Pages специ-
ально оптимизирован для этого сценария, в чем вы убедитесь в следую-
щих главах.
Ясно, что я поклонник Razor Pages, но нельзя сказать, что это идеаль-
ный вариант для любой ситуации. В следующем разделе мы обсудим слу -
чаи, когда можно использовать контроллеры MVC в своем приложении.
Имейте в виду, что это не вариант «либо-либо» – можно использовать
и  контроллеры MVC, и  Razor Pages в  одном приложении, и  во многих
случаях это может быть лучшим вариантом.
4.2.3 Когда выбирать контроллеры MVC вместо Razor Pages
Razor Pages отлично подходят для создания многостраничных приложе-
ний с  отрисовкой на стороне сервера. Но не все приложения соответ -
ствуют данному шаблону, и даже некоторые приложения, которые все же
попадают в эту категорию, лучше всего разрабатывать с использованием
контроллеров MVC вместо Razor Pages. Вот несколько таких сценариев:
когда	вам	не	нужна	отрисовка	 представлений – Razor Pages лучше
всего подходит для многостраничных приложений, где вы отрисо-
вываете представление для пользователя. Если вы создаете веб-API,
то вместо этого следует использовать контроллеры MVC;
когда	вы	конвертируете	 существующее	 приложение	 MVC	в ASP.NET
Core – если у вас уже есть приложение ASP .NET, использующее MVC,
вероятно, не стоит преобразовывать существующие контролле-
ры MVC в Razor Pages. Имеет смысл сохранить существующий код
и, возможно, подумать о разработке нового приложения с помощью
Razor Pages;
когда	вы	делаете	 много	частичных	 обновлений	 страницы  – можно
использовать Java Script в приложении, чтобы избежать полной на-
вигации по странице, обновляя только часть страницы за раз. Та-
кой подход, находящийся на полпути между полной отрисовкой
на стороне сервера и клиентским приложением, возможно, проще
реа лизовать с помощью контроллеров MVC, чем использовать Razor
Pages.
Когда не следует использовать Razor Pages или контроллеры MVC
Обычно для написания бóльшей части логики приложения вы будете ис -
пользовать либо Razor Pages, либо контроллеры MVC. Вы будете применять
их для определения API и страниц в вашем приложении, а также того, как они

155 Razor Pages и обработчики страниц
взаимодействуют с вашей бизнес-логикой. Razor Pages и MVC предоставляют
обширный фреймворк (как вы увидите в следующих шести главах) со мно-
жеством функций, помогающих быстро и эффективно создавать приложения.
Но они подходят не для всех  приложений.
Такая обширная функциональность непременно сопряжена с определенны-
ми накладными расходами на производительность. Для типичных приложе-
ний удобство при использовании MVC или Razor Pages сильно перевешива-
ет любое влияние на производительность. Но если вы создаете небольшие,
легковесные приложения для облака, то можно рассмотреть возможность
использования настраиваемого компонента конвейера промежуточного
ПО напрямую (см. главу 19) или альтернативный протокол, например gRPC
(https://docs.microsoft.com/ru-ru/aspnet/core/grpc). Возможно, вы также за-
хотите ознакомиться с книгой «Микросервисы в .NET Core» Кристиана Хорс -
дала Гаммельгаарда (Manning, 2017).
В качестве альтернативы, если вы создаете приложение, функционирующее
в режиме реального времени, вы, вероятно, захотите рассмотреть возмож -
ность использования WebSockets вместо традиционных HTTP-запросов. Для
добавления в  приложение фунциональности  реального времени можно
использовать ASP.NET Core SignalR. ASP.NET Core SignalR предоставляет аб-
стракцию поверх WebSockets. SignalR также предоставляет простой меха-
низм отката транспорта и модель приложения удаленного вызова процедур
(RPC). Дополнительные сведения см. в документации по адресу https://docs.
microsoft.com/ru-ru/aspnet/core/signalr.
Еще один вариант, доступный в ASP.NET Core 5.0, – это Blazor. Данный фрейм-
ворк позволяет создавать интерактивные клиентские веб-приложения, ис -
пользуя стандарт WebAssembly для исполнения кода .NET непосредственно
в браузере или модель с отслеживанием состояния с SignalR. Дополнитель-
ную информацию см. в документации по адресу https://docs.microsoft.com/
ru-ru/aspnet/core/blazor/?view=aspnetcore-5.0.
Надеюсь, к этому моменту вы уже пользуетесь Razor Pages. До сих пор
все просмотренные нами страницы Razor использовали единственный
обработчик страниц. В следующем разделе мы более подробно рассмот -
рим обработчики страниц: как их определять, вызывать и как использо-
вать их для отрисовки представлений Razor.
4.3 Razor Pages и обработчики страниц
В первом разделе этой главы я  описал паттерн проектирования MVC
и его связь с ASP .NET Core. В этом паттерне контроллер получает запрос
и является точкой входа для генерации пользовательского интерфейса.
Для Razor Pages точкой входа является обработчик страницы, который
находится в  PageModel страницы Razor. Обработчик страницы – это ме-
тод, который выполняется в ответ на запрос.

156 Глава 4 Создание веб-сайта с помощью страниц Razor
По умолчанию путь к странице Razor на диске определяет путь URL-
адреса, на который отвечает страница Razor. Например, запрос к URL-
ад ресу /products/list соответствует странице Razor по пути pages/Pro-
ducts/List.cshtml. Страницы Razor могут содержать любое количество
обработчиков, но только один из них выполняется в ответ на данный
запрос.
ПРИМЕЧАНИЕ  О процессе выбора страницы и обработчика Ra-
zor, который называется маршрутизацией, 	вы подробнее узнае те
в следующей главе.
Ответственность обработчика страницы обычно состоит из трех
задач:
подтвердить, что входящий запрос действителен;
вызвать бизнес-логику, соответствующую входящему запросу;
выбрать подходящий	тип ответа, который нужно вернуть.
Обработчику страницы необязательно выполнять все эти действия, но
он должен, по крайней мере, выбрать тип ответа, который нужно вер-
нуть. Обработчики страниц обычно возвращают одно из трех:
объект	PageResult – это заставляет связанное представление Razor
генерировать ответ в виде HTML-кода;
ничего	 (обработчик возвращает void или Task) – аналогично преды-
дущему случаю, заставляя представление Razor генерировать ответ
в виде HTML-кода;
RedirectToPageResult – указывает на то, что пользователь должен
быть перенаправлен на другую страницу в приложении.
Это наиболее часто используемые результаты для Razor Pages, но
я опишу ряд дополнительных параметров в разделе 4.3.2.
Важно понимать, что обработчик страницы не генерирует ответ на-
прямую; он выбирает	 тип ответа и подготавливает для него данные. На-
пример, возвращая PageResult, в этот момент он не генерирует никакого
HTML-кода; он просто указывает на то, что представление должно	 быть
визуализировано. Это соответствует паттерну проектирования MVC, где
ответ генерирует представление, а не контроллер.
СОВЕТ  Обработчик страницы отвечает за выбор типа ответа, ко-
торый нужно вернуть; движок	представлений	 в MVC использует ре-
зультат для генерации ответа.
Также стоит помнить, что обработчики страниц обычно не должны
выполнять бизнес-логику напрямую. Вместо этого они должны вызы-
вать соответствующие сервисы в модели приложения для обработки за-
просов. Если обработчик страницы получает запрос на добавление про-
дукта в корзину пользователя, он не должен напрямую манипулировать
базой данных или пересчитывать общую сумму покупки. Он должен вы-

157 Razor Pages и обработчики страниц
звать еще один класс для обработки деталей. Такой подход разделения
ответственности гарантирует, что ваш код легко можно будет тестиро-
вать и сопровождать, по мере того как он будет расти.
4.3.1 Прием параметров в обработчиках страниц
Некоторые запросы к  обработчикам страниц потребуют дополнитель-
ных значений с  подробной информацией о  запросе. Если запрос от -
носится к странице поиска, он может содержать сведения о поисковом
запросе и номере просматриваемой страницы. Если запрос отправляет
форму в ваше приложение, например когда пользователь входит в си-
стему со своим именем пользователя и паролем, эти значения должны
содержаться в запросе. В других случаях никаких значений не будет, на-
пример когда пользователь запрашивает домашнюю страницу вашего
приложения.
Запрос может содержать дополнительные значения из множества раз-
ных источников. Они могут быть частью URL-адреса, строки запроса, за-
головков или тела самого запроса. Промежуточное ПО будет извлекать
значения из каждого из этих источников и преобразовывать их в типы
# .NET.
ОПРЕДЕЛЕНИЕ  Процесс извлечения значений из запроса и пре-
образования их в типы .NET называется привязкой	 модели. Мы об-
судим ее в главе 6.
ASP .NET Core может привязывать в Razor Pages:
аргументы	 метода – если у обработчика страницы есть аргументы
метода, значения из запроса используются для создания необходи-
мых параметров;
свойства, 	отмеченные	 атрибутом [BindProperty],  – любые свой-
ства, отмеченные этим атрибутом, будет привязаны. По умолчанию
этот атрибут ничего не делает для GET-запросов.
Привязанные значения могут быть простыми типами, такими как
строки и целые числа, или сложными, как показано в следующем листин-
ге. Если любое из значений, указанных в запросе, не привязано к свой-
ству или аргументу обработчика страницы, дополнительные значения
останутся неиспользованными.
Листинг 4.3 Пример обработчиков страниц Razor
public class SearchModel : PageModel
{
private readonly SearchService _searchService;
public SearchModel(SearchService searchService)
{
_searchService = searchService;
}SearchService предоставляется
SearchModel для использования
в обработчиках страниц.

158 Глава 4 Создание веб-сайта с помощью страниц Razor
[BindProperty]
public BindingModel Input { get; set; }
public List<Product> Results { get; set; }
public void OnGet()
{
}
public IActionResult OnPost(int max)
{
if (ModelState.IsValid)
{
Results = _searchService.Search (Input.SearchTerm, max);
return Page();
}
return RedirectToPage("./Index");
}
}
В этом примере обработчик OnGet не требует каких-либо параметров,
и метод простой – он возвращает void, а это означает, что будет отобра-
жено связанное представление Razor. Он также мог бы вернуть PageRe-
sult; эффект был бы таким же. Обратите внимание, что этот обработчик
предназначен для HTTP-запросов методом GET, поэтому свойство Input,
оформленное [BindProperty], не привязано.
СОВЕТ  Чтобы связать свойства и для запросов методом GET, ис -
пользуйте свойство атрибута SupportsGet, например [BindProper-
ty(SupportsGet=true)].
Обработчик OnPost, наоборот, принимает в качестве аргумента пара-
метр max. В данном случае это простой тип int, но он также может быть
сложным объектом. Кроме того, поскольку этот обработчик соответству -
ет HTTP-запросу методом POST, свойство Input также привязано к  за-
просу.
ПРИМЕЧАНИЕ  В  отличие от большинства классов .NET, нельзя
использовать перегрузку методов, чтобы иметь на странице Razor
несколько обработчиков с одним и тем же именем.
Когда метод действия использует привязанные свойства или парамет -
ры, он всегда должен проверять валидность предоставленной модели
с  помощью свойства ModelState.IsValid. ModelState предоставляется
как свойство в  базовом классе PageModel и  может использоваться для
проверки достоверности всех привязанных свойств и  параметров. Вы
увидите, как этот процесс работает, в главе 6, когда будете изучать тему
валидации.
Как только обработчик страницы установит, что параметры метода,
предоставленные для действия, являются валидными (достоверными), Свойства, декорированные
атрибутом [BindProperty],
будут привязаны к модели.Недекори-
рованные
свойства
не будут
привязаны
к модели.Обработчику страницы не нужно проверять,
является ли модель допустимой. После возврата
void представление будет визуализировано.
Параметр max в этом обработчике страницы
будет привязан к модели с использованием
значений в запросе.
Если запрос недействителен, метод указывает,
что пользователя следует перенаправить на страницу Index.

159 Razor Pages и обработчики страниц
он может выполнить соответствующую бизнес-логику и  обработать
запрос. В случае обработчика OnPost это включает в себя вызов предо-
ставленного сервиса SearchService и  установку результата в  свойстве
Results. Наконец, обработчик возвращает объект PageResult, вызывая
базовый метод.
return Page();
Если модель не является валидной, у  вас не будет результатов для
отображения! В  этом примере действие возвращает объект Redirect-
ToPageResult с помощью вспомогательного метода RedirectToPage. При
выполнении этот результат отправит пользователю ответ с  кодом 302,
который заставит его браузер перейти на страницу Razor Index.
Обратите внимание, что метод OnGet возвращает void в сигнатуре ме-
тода, тогда как метод OnPost возвращает объект IActionResult. Это не-
обходимо в методе OnPost, чтобы позволить C# выполнить компиляцию
(поскольку вспомогательные методы Page и RedirectToPage возвращают
разные типы), но не меняет окончательного поведения методов. С таким
же успехом можно было бы вызвать Page в методе OnGet и вернуть объект
IAction-Result. Поведение было бы идентичным.
СОВЕТ  Если вы возвращаете несколько типов результатов от об-
работчика страницы, вам необходимо убедиться, что ваш метод
возвращает объект IActionResult.
В следующем разделе мы более подробно рассмотрим результаты дей-
ствий и их использование.
4.3.2 Возврат ответов с помощью ActionResults
В предыдущем разделе я  подчеркнул, что обработчики страниц реша-
ют, какой тип ответа возвращать, но сами не генерируют ответ. Это  IAc-
tionResult, возвращаемый обработчиком страницы, при выполнении
инфраструктурой Razor Pages с использованием движка представлений,
будет генерировать ответ.
Такой подход является ключом к следованию паттерну проектирова-
ния MVC. Он отделяет решение о том, какой ответ отправить, от гене-
рации ответа, что позволяет с легкостью протестировать логику вашего
метода действий, чтобы подтвердить отправку правильного типа отве-
та. Затем можно отдельно проверить, например, что данный объект  IAc-
tionResult генерирует ожидаемый HTML-код.
В ASP .NET Core есть много разных типов  IActionResult:
PageResult – генерирует HTML-представление для связанной стра-
ницы в Razor Pages;
ViewResult – генерирует HTML-представление для заданного пред-
ставления Razor при использовании контроллеров MVC;

160 Глава 4 Создание веб-сайта с помощью страниц Razor
RedirectToPageResult – отправляет ответ с кодом 302 для автомати-
ческого перенаправления пользователя на другую страницу;
RedirectResult – отправляет ответ с кодом 302 для автоматического
перенаправления пользователя на указанный URL-адрес (это не-
обязательно должна быть страница Razor);
FileResult – возвращает ответ в виде файла;
ContentResult  – возвращает предоставленную строку в качестве от -
вета;
StatusCodeResult – отправляет код состояния в качестве ответа, не-
обязательно со связанным содержимым тела ответа;
NotFoundResult – в качестве ответа отправляет код состояния 404.
Каждый из них, когда выполняется Razor Pages, генерирует ответ для
обратной отправки через конвейер промежуточного ПО и  передачи
пользователю.
СОВЕТ  При работе с Razor Pages некоторые из этих результатов
действий обычно не используются, например ContentResult и Sta-
tusCodeResult. Тем не менее полезно знать о них, поскольку вы, ве-
роятно, будете использовать их при создании веб-API с помощью
контроллеров MVC.
В этом разделе я дам краткое описание наиболее распространенных
классов  IActionResult, которые вы будете использовать с Razor Pages.
PageResuL T и RediRec TToPageResuL T
При создании традиционного веб-приложения с помощью Razor Pages
обычно используется PageResult, который генерирует ответ в  виде
HTML-ко  да с помощью Razor. Мы подробно рассмотрим, как это проис -
ходит, в главе 7.
Вы также будете часто использовать различные результаты на основе
переадресации, чтобы перенаправить пользователя на новую веб-стра-
ницу. Например, когда вы размещаете заказ на сайте онлайн-магазина,
то обычно перемещаетесь по нескольким страницам, как показано на
рис. 4.12. Веб-приложение отправляет HTTP-перенаправления всякий
раз, когда нужно перейти на другую страницу, например когда пользо-
ватель отправляет форму. Ваш браузер автоматически следует запро-
сам перенаправления, создавая плавный поток в процессе оформления
заказа.
В этом потоке всякий раз, когда вы возвращаете HTML-код, использу -
ется PageResult; при перенаправлении на новую страницу используется
RedirectToPageResult.
СОВЕТ  Страницы Razor, как правило, не имеют состояния, поэто-
му если вы хотите сохранить данные между несколькими страни-
цами, то необходимо поместить их в  базу данных или подобное
хранилище. Если вы просто хотите сохранить данные для одного

161 Razor Pages и обработчики страниц
запроса, то можно использовать TempData, который хранит неболь-
шие объемы данных в файлах cookie для одного запроса. Подроб-
ности см. в документации: http://mng.bz/XdXp.
Браузер Приложение ASP.NET Core
Оформление заказа
Оплата
Заказ оформленКупить
ОтправитьGET-запрос к странице оформления заказа
302 REDIRECT отправляется на страницу оплаты
Ответ 302 REDIRECT отправляется
на страницу завершения оформления заказаGET-запрос к странице оплаты
GET-запрос к странице завершения
оформления заказа200 OK (HTML)
# 200 OK (HTML)
200 OK (HTML)POST-запрос к странице оплатыPOST-запрос к странице
оформления заказаПользователь начинает с перехода
на страницу оформления заказа,
которая отправляет GET -запрос
в приложение ASP .NET Core
Пользователь нажимает
кнопку «Купить» на странице
оформления заказа, после чего
POST -запрос отправляется
в веб-приложение Запрос к странице оформления
заказа обрабатывается
приложением, которое
генерирует HTML-страницу
и возвращает ее браузеру
Приложение ASP .NET Core
начинает процесс оформления
заказа и отправляет ответ
с кодом 302 REDIRECT на
страницу оплаты
Запрос к странице оплаты
обрабатывается приложением,
которое генерирует
HTML-страницу и возвращает
ее браузеру
Приложение ASP .NET Core
обрабатывает платеж
и отправляет ответ
302 REDIRECT на страницу
завершения оформления
заказа
Запрос к странице
«Завершение оформления
заказа» обрабатывается путем
создания HTML-страницы
и возврата ее в браузерБраузер автоматически
перенаправляет пользователя
на страницу оплаты
Пользователь заполняет
форму оплаты и нажимает
кнопку «Отправить», после
чего POST -запрос отправляется
в веб-приложение
Браузер автоматически перенаправляет
пользователя на страницу завершения
оформления заказа
Пользователь видит страницу
завершения оформления
заказа в формате HTML
Рис. 4.12 Типичный поток с использованием POST, REDIRECT, GET. Пользователь отправляет
свою корзину покупок на страницу оформления заказа, которая проверяет ее содержимое
и перенаправляет на страницу оплаты без необходимости вручную изменять URL-адрес
NoTFouNdResuL T и sTaTuscodeResuL T
Помимо HTML-кода и  переадресации, иногда нужно будет отправлять
определенные коды состояния HTTP . Если вы запрашиваете страницу
для просмотра продукта в  приложении онлайн-торговли, а  этого про-
дукта не существует, браузеру возвращается код состояния 404, и  вы
видите веб-страницу «Не найдено». Для этого Razor Pages возвращает
NotFoundResult, который вернет код состояния 404. Аналогичного ре-
зультата можно добиться, используя StatusCodeResult и задав для кода
состояния, возвращаемого явно, значение 404.

162 Глава 4 Создание веб-сайта с помощью страниц Razor
Обратите внимание, что NotFoundResult генерирует не HTML-разметку,
а только код состояния 404 и возвращает его через конвейер промежу -
точного ПО. Но, как уже обсуждалось в предыдущей главе, для перехвата
этого кода состояния 404, после того как он будет сгенерирован, мож -
но использовать компонент StatusCodePagesMiddleware и  предоставить
удобный для пользователя ответ.
создание  классов  acTioNResuL T с использованиеМ
вспоМоГ ательных  Методов
Классы  ActionResult  можно создавать и  возвращать с  использованием
обычного синтаксиса C#:
return new PageResult()
Однако базовый класс Razor Pages  PageModel также предоставляет ряд
вспомогательных методов для генерации ответов. Обычно для создания
соответствующего объекта  PageResult используется метод  Page, для соз-
дания RedirectToPageResult – метод RedirectToPage или метод NotFound
для создания NotFoundResult.
СОВЕТ  Большинство классов ActionResult имеют вспомогатель-
ный метод в базовом классе PageModel. Обычно он называется Type,
а полученный результат – TypeResult.  Например, метод StatusCode
возвращает экземпляр StatusCodeResult.
Как обсуждалось ранее, возврат IActionResult не приводит к мгновен-
ной генерации ответа – это происходит при выполнении IActionResult,
осуществляемом инфраструктурой Razor Pages за пределами метода
действия. После получения ответа Razor Pages возвращает его в конвей-
ер промежуточного ПО. Оттуда он проходит через все зарегистрирован-
ные компоненты, прежде чем веб-сервер ASP .NET Core наконец отпра-
вит его пользователю.
К настоящему времени вы должны иметь общее представление о пат -
терне проектирования MVC и о том, как он соотносится с ASP .NET Core
и Razor Pages. Методы обработчика страницы на странице Razor вызы-
ваются в ответ на запросы и используются для выбора типа ответа, кото-
рый необходимо сгенерировать, возвращая объект IActionResult.
Важно помнить, что MVC и инфраструктура Razor Pages в ASP .NET Core
работают как часть конвейера EndpointMiddleware, как вы уже видели
в предыдущей главе. Любой сгенерированный ответ, будь то PageResult
или RedirectToPageResult, будет проходить обратно через конвейер про-
межуточного ПО, предоставляя компонентам потенциальную возмож -
ность наблюдать за ответом до того, как веб-сервер отправит его поль-
зователю.
Аспект, который я  затронул лишь вскользь, – это то, как компонент
RoutingMiddleware решает, какую страницу Razor и  обработчик вызы-
вать для данного запроса. Вам же не нужна страница Razor для каждого

163 Резюме
URL-адреса в приложении. Было бы сложно, например, иметь отдельную
страницу для каждого товара в электронном магазине – для каждого то-
вара потребуется собственная страница Razor! Обработка этого и других
сценариев – роль инфраструктуры маршрутизации, и это ключевая часть
ASP .NET Core. В следующей главе вы увидите, как определять маршруты,
добавлять ограничения к своим маршрутам и как они деконструируют
URL-адреса, чтобы соответствовать одному обработчику страницы Razor.
Резюме
Паттерн проектирования MVC позволяет разделить задачи между
бизнес-логикой вашего приложения, передаваемыми данными и ото-
бражением данных в ответе.
Страницы Razor построены на фреймворке ASP .NET Core MVC и  ис -
пользуют множество тех же примитивов. Они используют соглашения
и иной макет проекта для оптимизации сценариев на основе страниц.
Контроллеры MVC содержат несколько методов	 действий, обычно
сгруппированных вокруг сущности высокого уровня. Razor Pages груп-
пирует все обработчики страниц для одной страницы в одном месте
вокруг страницы или функции, а не сущности.
Каждая страница Razor Page эквивалентна мини-контроллеру, сфо-
кусированному на одной странице, а  каждый обработчик страницы
Razor соответствует отдельному методу действия.
Страницы Razor должны наследовать от базового класса PageModel.
Один обработчик страницы Razor выбирается на основе URL-адреса
входящего запроса, HTTP-метода и строки запроса в процессе, назы-
ваемом маршрутизацией.
Обработчики страниц обычно должны делегировать полномочия сер-
висам для обработки бизнес-логики, необходимой запросу, вмес  то
того чтобы выполнять изменения самостоятельно. Это обеспечивает
четкое разделение ответственности, что помогает при тестировании
и улучшает структуру приложения.
Обработчики страниц могут иметь параметры, значения которых бе-
рутся из свойств входящего запроса в  процессе под названием при-
вязка	модели. Свойства, декорированные [BindProperty], также могут
быть привязаны к запросу.
По умолчанию свойства, декорированные [BindProperty], не при-
вязаны к  GET-запросам. Чтобы активировать привязку, используйте
[BindProperty(SupportsGet = true)].
Обработчики страниц могут возвращать PageResult или void для гене-
рации ответа в виде HTML-кода.
Можно перенаправлять пользователей на новую страницу Razor с по-
мощью RedirectToPageResult.
Базовый класс PageModel  предоставляет множество вспомогательных
методов для создания ActionResult.

5Сопоставление
URL-адресов	с Razor
Pages		с использованием
маршрутизации
В этой главе:
сопоставление URL-адресов с Razor Pages;
использование ограничений и значений по
умолчанию для сопоставления URL-адресов;
генерация URL-адресов из параметров маршрута.
В главе 4 вы узнали о паттерне проектирования MVC и о том, как ASP .
NET Core использует его для создания пользовательского интерфейса
приложения с по мощью Razor Pages. Razor Pages содержат обработчики
страниц, которые действуют как мини-контроллеры для запроса. Об-
работчик страницы вызывает модель приложения для получения или
сохранения данных. Затем он передает данные из модели приложения
в представление Razor, которое генерирует ответ в виде HTML-страницы.
Хотя это и не является частью паттерна проектирования MVC как та-
кового, одна из важнейших частей Razor Pages – это выбор страницы Ra-
zor, вызываемой в  ответ на данный запрос. Такой процесс называется
маршрутизацией и является предметом обсуждения этой главы.
Данная глава начинается с определения необходимости маршрутиза-
ции и ее пользы. Вы узнаете о системе маршрутизации конечных точек,
представленной в ASP .NET Core 3.0, увидите несколько примеров мето-
дов маршрутизации и изучите, как маршрутизация влияет на разделе-

165 Что такое маршрутизация?
ние расположения ваших файлов Razor Page и URL-адресов, которые вы
предоставляете.
Основная часть этой главы посвящена тому, как использовать марш-
рутизацию с Razor Pages для создания динамических URL-адресов, что-
бы одна страница Razor могла обрабатывать запросы к нескольким URL-
адресам. Я  покажу, как создавать эффективные шаблоны маршрутов,
и познакомлю вас с доступными вариантами.
В разделе 5.5 я описываю, как использовать систему маршрутизации
для генерации URL-адресов, которые можно применять для создания ссы-
лок и перенаправления запросов в вашем приложении. Одним из пре-
имуществ использования системы маршрутизации является то, что она
отделяет ваши страницы Razor от базовых URL-адресов, которые исполь-
зуются для их выполнения. Чтобы не засорять свой код жестко задан-
ными URL-адресами, например /Product/View/3, можно генерировать
URL-адреса во время выполнения на основе системы маршрутизации.
Это упрощает изменение конфигурации URL-адреса для страницы Ra-
zor. Вместо того чтобы искать, где вы использовали URL-адрес страни-
цы Razor, URL-адреса будут обновляться автоматически, без каких-либо
других изменений.
Я заканчиваю главу описанием того, как настроить соглашения, ис -
пользуемые Razor Pages, что даст вам полный контроль над URL-адре-
са ми, которые использует ваше приложение. Вы увидите, как изменить
встроенные соглашения, такие как использование строчных букв для
URL-адресов, а также как написать собственное соглашение и применить
его глобально к своему приложению.
К концу этой главы вы должны иметь более четкое представление
о  том, как работает приложение ASP .NET Core. Можно рассматривать
маршрутизацию как связующий элемент, который связывает конвейер
промежуточного ПО с Razor Pages и фреймворком MVC. Используя кон-
вейер, Razor Pages и маршрутизацию, вы будете писать веб-приложения
в кратчайшие сроки!
5.1 Что такое маршрутизация?
Маршрутизация – это процесс сопоставления входящего запроса с мето-
дом, который будет его обрабатывать. Маршрутизацию можно использо-
вать для управления URL-адресами, которые вы предоставляете в своем
приложении, а также для включения таких мощных функций, как сопо-
ставление нескольких URL-адресов с  одной и  той же страницей Razor
и автоматическое извлечение данных из URL-адреса запроса.
В главе 3 вы видели, что приложение ASP .NET Core содержит конвейер
промежуточного ПО, который определяет поведение вашего приложе-
ния. Промежуточное ПО хорошо подходит для обработки как сквозных
задач, таких как журналирование и обработка ошибок, так и узконаправ-
ленных запросов, таких как запросы изображений и файлов CSS.

166 Глава 5 Сопоставление URL-адресов с Razor Pages
Для обработки более сложной логики приложения обычно использу -
ется компонент EndpointMiddleware в  конце конвейера, как вы видели
в  главе 4. Он может обрабатывать соответствующий запрос, вызывая
метод, известный как обработчик страницы в Razor Page или метод дей-
ствия в контроллере MVC, и используя результат для генерации ответа.
Есть один аспект, который я упустил в главе 4. Он заключается в том,
как выбрать, какую страницу Razor или метод действия нужно выпол-
нить при получении запроса. Что делает запрос «уместным» для данного
обработчика страниц Razor? Процесс сопоставления запроса с обработ -
чиком называется маршрутизацией.
ОПРЕДЕЛЕНИЕ  Маршрутизация в ASP .NET Core – это процесс со-
поставления входящего HTTP-запроса с  конкретным обработчи-
ком. В Razor Pages обработчик – это метод обработчика страницы
в Razor Page. В MVC обработчик – это метод действия в контрол-
лере.
Вы уже имели дело с несколькими простыми приложениями, создан-
ными с по мощью Razor Pages в предыдущих главах, поэтому уже видели
маршрутизацию в действии, если тогда еще и не осознавали этого. Даже
простой путь URL-адреса, например /Index, использует маршрутизацию,
чтобы определить, что должна быть выполнена страница Index.cshtml
Razor, как показано на рис. 5.1.
Компонент маршрутизации
сопоставляет URL-адрес /Index
с конечной точкой Index.cshtml
Компонент маршрутизации
записывает выбранную
конечную точку в HttpContext
объекта запроса
Компонент конечной точки
выполняет выбранную конечную
точку и возвращает ответКомпонент маршрутизации
Компонент конечной точкиЗапрос
ЗапросОтвет
Конечная точка
Index.cshtml
Рис. 5.1 Маршрутизатор сравнивает URL-адрес запроса со списком настроенных
шаблонов маршрутов, чтобы определить, какой метод действия следует выполнить
На первый взгляд это кажется довольно простым. Вы можете спросить,
зачем мне нужна целая глава, чтобы объяснить это очевидное сопостав-
ление. Простота сопоставления в данном случае скрывает то, насколько
мощной может быть маршрутизация. Если бы этот подход, основанный
на разметке файлов, был единственным доступным, то вы были бы силь-
но ограничены в приложениях, которые можно было бы создать.

167 Что такое маршрутизация?
Например, рассмотрим приложение электронной коммерции, ис -
пользуемое для продажи разных товаров. У  каждого продукта должен
быть собственный URL-адрес, поэтому если бы вы использовали систему
маршрутизации, основанную исключительно на расположении файлов,
то у вас было бы только два варианта:
использовать	 разные	страницы	 Razor	для	каждого	 продукта	 из	вашего
ассортимента, что было бы совершенно невозможно практически
для любого реально существующего ассортимента;
использовать	 одну	страницу	 Razor	и строку	 запроса, 	чтобы	разли-
чать	продукты. Это гораздо более практично, но в итоге вы полу -
чите уродливые URL-адреса, например "/product?name=big-widget"
или "/product?id=12".
ОПРЕДЕЛЕНИЕ  Строка	запроса является частью URL-адреса, ко-
торый содержит дополнительные данные, не входящие в путь. Она
не используется инфраструктурой маршрутизации, чтобы опреде-
лить, какое действие следует выполнить, но ее можно использо-
вать для привязки модели, как вы увидите в главе 6.
Благодаря маршрутизации у вас может быть одна страница Razor, ко-
торая может обрабатывать несколько URL-адресов без необходимости
прибегать к уродливым строкам запроса. С точки зрения Razor Page под-
ходы к строке запроса и маршрутизации очень похожи – страница Razor
динамически отображает результаты для нужного продукта, если это не-
обходимо. Разница состоит в том, что с по мощью маршрутизации мож -
но полностью настроить URL-адреса, как показано на рис. 5.2. Это дает
гораздо больше гибкости и может быть важно в реальных приложениях
по причинам, связанным с поисковой оптимизацией1.
Помимо активации динамических URL-адресов, маршрутизация прин-
ципиально отделяет URL-адреса в вашем приложении от имен файлов ва-
ших страниц Razor. Например, предположим, что у вас есть приложение
конвертера валют со страницей Razor в вашем проекте, расположенной
по пути Pages/Rates/View.cshtml, которая используется для просмотра
обменного курса валюты, скажем доллара США. По умолчанию это может
соответствовать URL-адресу /rates/view/1 для пользователей. Могло бы
сработать, но это мало что скажет пользователям – в какой валюте все это
будет отображаться? Будут ли это старые котировки или текущий курс?
К счастью, с по мощью маршрутизации можно легко изменить предо-
ставленные URL-адреса без изменения имен файлов страниц Razor или
местоположений. В зависимости от конфигурации маршрутизации мож -
но задать URL-адрес, ведущий на страницу View.cshtml, выбрав одно из
следующих значений:
1 Важно отметить, что вы можете надлежащим образом закодировать иерархию
своего сайта в своих URL-адресах, как описано в руководстве Google по поис -
ковой оптимизации для начинающих: https://support.google.com/webmasters/
answer/7451184.

168 Глава 5 Сопоставление URL-адресов с Razor Pages
/rates/view/1;
/rates/view/USD;
/rates/current-exchange-rate/USD;
/current-exchange-rate-for-USD.
Сопоставление на основе расположения файлов
Одна страница со строкой запроса
МаршрутизацияКаждый URL-адрес сопоставляется с файлом на диске
URL-адрес сопоставляется с одной страницей, а строка запроса используется
для отображения динамических данных
Маршрутизация сопоставляет URL-адреса с одной страницей,
а конечный сегмент URL-адреса определяет динамические данные Products/SimpleWidget.cshtml
Products/BigWidget.cshtml
Products/SmallWidget.cshtml
Products.cshtml
Products.cshtml
Рис. 5.2 Если вы используете сопоставление на основе расположения файлов,
то вам потребуется отдельная страница Razor для каждого продукта в вашем
ассортименте. При маршрутизации несколько URL-адресов сопоставляются с одной
страницей Razor, и динамический параметр фиксирует разницу в URL-адресах
Я знаю, какие из них мне больше всего хотелось бы видеть в адресной
строке своего браузера и на какие я, скорее всего, щелкнул бы кнопкой
мыши! Такой уровень настройки требуется нечасто, и  URL-адреса по
умолчанию обычно являются лучшим вариантом в долгосрочной пер-
спективе, но очень полезно иметь возможность настраивать URL-адреса,
когда вам это нужно.

169 Маршрутизация в ASP.NET Core
В следующем разделе мы рассмотрим, как на практике работает марш-
рутизация в ASP .NET Core.
5.2 Маршрутизация в ASP.NET Core
Маршрутизация была частью ASP .NET Core с момента его создания, но
в ASP .NET Core 3.0 она претерпела некоторые существенные изменения.
В ASP .NET Core 2.0 и  2.1 маршрутизация была ограничена Razor Pages
и фреймворком ASP .NET Core MVC. В вашем конвейере промежуточного
ПО не было выделенного компонента маршрутизации – маршрутизация
выполнялась только внутри Razor Pages или компонентов MVC.
Учитывая, что бóльшая часть логики вашего приложения реализова-
на в Razor Pages, использование маршрутизации только для Razor Pages
по большей части было приемлемым. К сожалению, ограничение марш-
рутизации инфраструктурой MVC слегка запутало некоторые вещи. Это
означало, что некоторые сквозные задачи, такие как авторизация, были
ограничены инфраструктурой MVC, и их было трудно использовать из
другого промежуточного ПО в вашем приложении. Данное ограничение
привело к неизбежному дублированию, что было не идеально.
В ASP .NET Core 3.0 была представлена новая система маршрутиза-
ции – маршрутизация	 конечных	 точек. Маршрутизация конечных точек
делает систему маршрутизации более фундаментальной функцией ASP .
NET Core и больше не связывает ее с инфраструктурой MVC. Razor Pages
и  MVC по-прежнему используют маршрутизацию конечных точек, но
теперь с ней могут работать и другие компоненты. В ASP .NET Core 5.0
применяется та же система маршрутизации конечных точек, что и в ASP .
NET Core 3.0.
В этом разделе я расскажу:
как работает маршрутизация конечных точек в ASP .NET Core;
о двух доступных типах маршрутизации: маршрутизации на основе
соглашений и маршрутизации по атрибутам;
как работает маршрутизация для Razor Pages.
В конце данного раздела вы должны хорошо представлять себе, как
маршрутизация в ASP .NET Core работает с Razor Pages.
5.2.1 Использование маршрутизации конечных точек
в ASP.NET Core
Маршрутизация конечных точек имеет фундаментальное значение для
всех приложений ASP .NET Core, кроме самых простых. Она реализуется
с использованием двух компонентов, которые вы уже встречали:
EndpointMiddleware – этот компонент используется для регистрации
конечных точек в  системе маршрутизации при запуске приложе-
ния. Он выполняет одну из конечных точек во время выполнения;

170 Глава 5 Сопоставление URL-адресов с Razor Pages
EndpointRoutingMiddleware – этот компонент выбирает, какая из ко-
нечных точек, зарегистрированных EndpointMiddleware, должна вы-
полняться для данного запроса во время выполнения. Чтобы было
легче различать эти два типа, на протяжении всей книги я буду на-
зывать его RoutingMiddleware.
EndpointMiddleware – это место, где вы настраиваете все конечные	 точ-
ки в вашей системе. Здесь вы регистрируете свои страницы Razor и конт -
роллеры MVC, но вы также можете зарегистрировать дополнительные
обработчики, которые не входят во фреймворк MVC, например конеч-
ные точки проверки работоспособности, подтверждающие, что ваше
приложение все еще работает.
ОПРЕДЕЛЕНИЕ  Конечная	 точка в  ASP .NET Core – это некий об-
работчик, возвращающий ответ. Каждая конечная точка связана
с  шаблоном URL-адреса. Обработчики страниц Razor и  методы
действий контроллера MVC обычно составляют основную часть
конечных точек в приложении, но вы также можете использовать
простое промежуточное ПО в качестве конечной точки или конеч-
ную точку проверки работоспособности.
Чтобы зарегистрировать конечные точки в  своем приложении, вы-
зовите метод UseEndpoints в методе Configure из файла Startup.cs. Этот
метод принимает лямбда-функцию конфигурации, которая определяет
конечные точки в вашем приложении, как показано в следующем лис -
тинге. Вы можете автоматически зарегистрировать все страницы Razor
в своем приложении с по мощью таких расширений, как MapRazorPages.
Кроме того, можно явно зарегистрировать другие конечные точки с по-
мощью таких методов, как MapGet.
Листинг 5.1 Регистрация нескольких конечных точек в методе Configure
public void Configure(IApplicationBuilder app)
{
app.UseRouting();
app.UseEndpoints(endpoints =>
{
endpoints.MapRazorPages();
endpoints.MapHealthChecks("/healthz");
endpoints.MapGet("/test", async context =>
{
await context.Response.WriteAsync("Hello World!");
});
});
}Добавляем компонент
EndpointRoutingMiddleware в конвейер.
Добавляем компонент
EndpointMiddleware в конвейер
и предоставляем лямбда-функцию
конфигурации.
Регистрируем все
страницы Razor
в приложении
в качестве
конечных точек.
Регистрируем конечную точку проверки
работоспособности на маршруте /healthz.Регистрируем встроенную конечную точку, которая
возвращает «Hello World!» на маршруте /test.

171 Маршрутизация в ASP.NET Core
Каждая конечная точка связана с  шаблоном	 маршрута, который опре-
деляет, с какими URL-адресами конечная точка должна совпасть. В пре-
дыдущем листинге видно два шаблона маршрута, "/healthz" и "/test".
ОПРЕДЕЛЕНИЕ  Шаблон	маршрута – это шаблон URL-адреса, кото-
рый используется для сопоставления с URL-адресами запроса. Это
строки с фиксированными значениями, как, например, "/test" из
предыдущего листинга. Они также могут содержать заполнители
для переменных, как вы увидите в разделе 5.3.
EndpointMiddleware хранит зарегистрированные маршруты и  конеч-
ные точки в словаре, который используется совместно с  RoutingMiddle-
ware. Во время выполнения RoutingMiddleware сравнивает входящий
запрос с маршрутами, зарегистрированными в словаре. Если RoutingMid-
dleware находит подходящую конечную точку, то отмечает, какая конеч-
ная точка была выбрана, и прикрепляет ее к объекту запроса HttpContext,
после чего вызывает следующий компонент в конвейере. Когда запрос
достигает EndpointMiddleware, компонент проверяет, какая конечная
точка была выбрана, и выполняет ее, как показано на рис. 5.3.
1.  Компонент маршрутизации
проверяет входящий запрос
на соответствие списку
шаблонов маршрутов
3.  Компонент маршрутизации
записывает выбранную
конечную точку в объекте
запроса. Все последующие
компоненты могут видеть,
какая конечная
точка была
выбрана
4.  Компонент конечной точки
выполняет выбранную
конечную точку
и возвращает ответ
Если ни один маршрут
не соответствует URL-адресу
запроса, конечная точка
не выбирается, компонент
конечной точки не выполняется,
а фиктивное промежуточное
ПО возвращает ответ с кодом 4042.  URL-адрес соответствует шаблону маршрута
Index, а файл Index.cshtml выбран в качестве
конечной точки
Компонент маршрутизации
Компонент конечной точкиКонечная точка
Index.cshtml
Фиктивное промежуточное ПО,
возвращающее ответ с кодом 404 Запрос Ответ
ЗапросШаблон маршрута Страница Razor
Рис. 5.3 Маршрутизация конечных точек использует двухэтапный процесс. RoutingMiddleware
выбирает конечную точку для выполнения, а EndpointMiddleware выполняет ее. Если URL-адрес
запроса не соответствует шаблону маршрута, компонент конечной точки не сгенерирует ответ
Если URL-адрес запроса не соответствует шаблону маршрута, Routing-
Middleware не выбирает конечную точку, но запрос все равно продолжает
идти по конвейеру. Поскольку конечная точка не выбрана, EndpointMidd-

172 Глава 5 Сопоставление URL-адресов с Razor Pages
leware молча игнорирует запрос и передает его следующему компоненту
в конвейере. EndpointMiddleware – обычно последний компонент в кон-
вейере, поэтому «следующий» компонент, как правило, является фиктив-
ным и всегда возвращает ответ 404 Not Found, как вы уже видели в главе 3.
СОВЕТ  Если URL-адрес запроса не соответствует шаблону марш-
рута, конечная точка не выбирается и не выполняется. Весь кон-
вейер промежуточного ПО по-прежнему выполняется, но обычно
возвращается ответ 404, когда запрос достигает фиктивного ком-
понента 404.
Преимущество наличия двух отдельных компонентов для обработки
этого процесса на первый взгляд может быть неочевидным. Рисунок 5.3
намекает на главное преимущество  – все компоненты, размещенные
пос ле RoutingMiddleware, могут видеть, какая конечная точка будет вы-
полнена, прежде чем это случится.
ПРИМЕЧАНИЕ  Только компонент, размещенный после Routing-
Midd leware, может определить, какая конечная точка будет выпол-
няться.
На рис.  5.4 показан более реалистичный конвейер промежуточного
ПО, в котором компонент размещается как	 перед	RoutingMiddleware, так
и между  RoutingMiddleware и EndpointMiddleware.
Компонент, размещенный перед компонентом
маршрутизации, не может определить, какая конечная
точка будет выполнена
Компонент маршрутизации выбирает конечную
точку на основе URL-адреса запроса и маршрутов
приложения
Компонент авторизации размещается после
компонента маршрутизации, поэтому может
определить, какая конечная точка была выбрана,
и получить доступ к метаданным конечной точки
Компонент конечной точки выполняет выбранную
конечную точку и возвращает ответ Компонент статических файлов
Компонент маршрутизации
Компонент авторизации
Компонент конечной точкиКонечная точка
Index.cshtmlЗапрос Ответ
Запрос
Запрос
Запрос
Рис. 5.4 Компонент, размещенный перед компонентом маршрутизации, не знает, какую
конечную точку выберет этот компонент. Компонент, размещенный между компонентом
маршрутизации и компонентом конечной точки, может увидеть выбранную конечную точку

173 Маршрутизация в ASP.NET Core
На рис.  5.4 StaticFileMiddleware помещен перед RoutingMiddleware,
поэтому он выполняется до того, как будет выбрана конечная точка.
И наоборот, AuthorizationMiddleware размещен после RoutingMiddleware,
поэтому можно сказать, что конечная точка страницы Razor Index.cshtml
в конечном итоге будет выполнена. Кроме того, он может получить до-
ступ к определенным метаданным о конечной точке, например ее име-
ни, и необходимые полномочия для доступа к странице Razor.
СОВЕТ  AuthorizationMiddleware нужно знать, какая конечная
точка будет выполняться, поэтому в  конвейере его необходимо
разместить после RoutingMiddleware и  перед EndpointMiddleware.
Более подробно авторизация обсуждается в главе 15.
При сборке приложения важно помнить о различных ролях двух ти-
пов компонента маршрутизации. Если у  вас есть компонент, который
должен знать, какую конечную точку (если она есть) будет выполнять
данный запрос, то необходимо убедиться, что он будет помещен после
RoutingMiddleware и перед EndpointMiddleware.
Мы рассмотрели, как RoutingMiddleware и  EndpointMiddleware взаимо-
действуют друг с  другом для обеспечения возможностей маршрутиза-
ции в ASP .NET Core, но мы еще не видели,	 как RoutingMiddleware сопо-
ставляет URL-адрес запроса с конечной точкой. В следующем разделе мы
рассмотрим два разных подхода, используемых в ASP .NET Core.
5.2.2 Маршрутизация на основе соглашений
и маршрутизация на основе атрибутов
Маршрутизация является ключевой частью ASP .NET Core, поскольку она
сопоставляет URL-адрес входящего запроса с конкретной конечной точ-
кой, которую нужно будет выполнить. Существует два способа опреде-
лить эти сопоставления конечных точек URL-адресов в приложении:
использовать глобальную маршрутизацию на основе соглашений;
применять маршрутизацию на основе атрибутов.
Какой подход вы будете применять, обычно зависит от того, исполь-
зуете ли вы страницы Razor или контроллеры MVC и создаете ли вы API
или веб-сайт (с помощью HTML-кода). Как вы вскоре увидите, я склоня-
юсь к использованию маршрутизации на основе атрибутов.
Маршрутизация на основе соглашений определяется глобально для
вашего приложения. Вы можете использовать основанные на соглаше-
ниях маршруты для сопоставления конечных точек (действия контрол-
лера MVC) в приложении с URL-адресами, но ваши контроллеры должны
строго придерживаться определенных вами соглашений. Традиционно
приложения, использующие контроллеры MVC для генерации HTML-
кода, склонны применять этот подход. Но у него есть и обратная сторона.
Она состоит в том, что это затрудняет настройку URL-адресов для под-
множества контроллеров и действий.

174 Глава 5 Сопоставление URL-адресов с Razor Pages
В качестве альтернативы можно использовать маршруты на основе
атрибутов для привязки заданного URL-адреса к определенной конеч-
ной точке. В  случае с  контроллерами MVC это включает в  себя разме-
щение атрибутов [Route] в  самих методах действия, отсюда и термин
«маршрутизация на основе атрибутов». Это обеспечивает бóльшую гиб-
кость, поскольку вы можете явно определить, каким должен быть URL-
адрес для каждого метода действия. Данный подход, как правило, более
подробный, по сравнению с тем, где используется маршрутизация на ос -
нове соглашений, поскольку требует применения атрибутов к  каждому
методу действия в приложении. Несмотря на это, дополнительная гиб-
кость, предоставляемая им, может быть очень полезной, особенно при
создании веб-API.
Несколько сбивает с толку то, что страницы Razor используют соглаше-
ния для создания маршрутов	 атрибутов! Во многих отношениях такое
сочетание привносит лучшее из обоих миров – вы получаете предсказу -
емость и краткость маршрутизации на основе соглашений с простой на-
стройкой маршрутизации на основе атрибутов. Как показано в табл. 5.1,
для каждого из этих подходов есть свои компромиссы.
Таблица 5.1 Преимущества и недостатки стилей маршрутизации, доступных
в ASP.NET Core
Тип маршрутизации Типичное
использование Преимущества Недостатки
Маршрутизация на
основе соглашений Контроллеры
# MVC,
генерирующие
HTML-код Очень краткое определение
в одном месте вашего
приложения.
Обеспечивает согласованную
компоновку контроллеров MVCМаршруты определяются в месте,
отличном от ваших контроллеров.
Переопределение соглашений
о маршрутах может быть сложным
и подвержено ошибкам.
Добавляет дополнительный
уровень косвенности
при маршрутизации запроса
Маршрутизация на
основе атрибутов Контроллеры
MVC веб-API Предоставляет полный
контроль над шаблонами
маршрутов для каждого
действия.
Маршруты определяются рядом
с действием, которое они
выполняютПодробно по сравнению
с маршрутизацией на основе
соглашений.
Шаблоны маршрутов легко
изменить.
Шаблоны маршрутов разбросаны
по всему приложению,
а не в одном месте
Генерация
маршрутов
атрибутов на основе
соглашений Razor Pages Поощряет согласованный набор
предоставляемых URL-адресов.
Лаконично, когда вы
придерживаетесь соглашений.
Легко переопределить
шаблон маршрута
для отдельной страницы.
Настраивайте соглашения
глобально, чтобы изменить
предоставляемые URL-адресаВозможна чрезмерная настройка
шаблонов маршрутов.
Вы должны рассчитать, каким
должен быть шаблон маршрута
для страницы, вместо того чтобы
явно определять его
в приложении
Итак, какой подход следует использовать? Я считаю, что маршрути-
зация на основе соглашений не стоит усилий в 99 % случаев и следует
придерживаться маршрутизации на основе атрибутов. Если вы следуете

175 Маршрутизация в ASP.NET Core
мое му совету по использованию Razor Pages, то, значит, вы уже исполь-
зуете маршрутизацию на основе атрибутов. Кроме того, если вы создаете
API с по мощью контроллеров MVC, данный тип маршрутизации – луч-
ший вариант и рекомендуемый подход1.
Единственный сценарий, в котором традиционно применяется марш-
рутизация на основе соглашений,  – это использование контроллеров
MVC для генерации HTML-кода. Но если вы последуете моему совету из
главы 4, то будете использовать Razor Pages для приложений, генерирую-
щих HTML-код, и возвращаться к контроллерам MVC только тогда, когда
это неизбежно. Для единообразия в  этом сценарии я  бы по-прежнему
придерживался маршрутизации на основе атрибутов.
ПРИМЕЧАНИЕ  По указанным выше причинам в этой книге ос -
новное внимание уделяется маршрутизации на основе атрибутов.
Практически все функции, описанные в этом разделе, также при-
менимы к маршрутизации на основе соглашений.
Дополнительные сведения о  маршрутизации на основе соглашений
см. в документации Microsoft «Маршрутизация для действий контролле-
ра в ASP .NET Core»: http://mng.bz/ZP0O .
Какой бы метод вы ни использовали, вы будете определять ожидае-
мые URL-адреса своего приложения с  по мощью шаблонов	 маршрутов.
Они определяют шаблон ожидаемого URL-адреса с по мощью заполните-
лей для частей, которые могут отличаться.
ОПРЕДЕЛЕНИЕ  Шаблоны	 маршрутов определяют структуру из-
вестных URL-адресов в вашем приложении. Они представляют со-
бой строки с  заполнителями для параметров, которые могут со-
держать необязательные значения.
Один шаблон маршрута может соответствовать множеству разных
URL-адресов. Например, URL-адреса /customer/1 и  /customer/2 будут со -
ответствовать шаблону маршрута "customer/ {id}". Шаблон маршрута
имеет мощный синтаксис, содержащий множество различных функций,
которые управляются путем разделения URL-адреса на несколько сег-
ментов.
ОПРЕДЕЛЕНИЕ  Сегмент  – это небольшой непрерывный раздел
URL-адреса. Он отделен от других сегментов как минимум одним
символом. Часто это символ /. Маршрутизация включает в себя со-
поставление сегментов URL-адреса с шаблоном маршрута.
1 .NET 5.0 также включает в себя поддержку создания простых API без дополни-
тельных затрат (или удобства) MVC или Razor Pages. У Филипа У. есть отличная
статья о создании небольших простых приложений API с использованием C# 9
и .NET 5.0: http://mng.bz/yYey .

176 Глава 5 Сопоставление URL-адресов с Razor Pages
Для каждого шаблона маршрута можно определить:
конкретные ожидаемые строки;
переменные сегменты URL-адреса;
необязательные сегменты URL-адреса;
значения по умолчанию, если необязательный сегмент не указан;
ограничения на сегменты URL-адреса, например чтобы он был чис -
ловым.
Большинство приложений будут использовать множество этих функ -
ций, но часто вы будете использовать только одну или две функции то
тут, то там. По большей части шаблоны маршрутов атрибутов на осно-
ве соглашений по умолчанию, созданные Razor Pages, – это все, что вам
нужно. В следующем разделе мы подробно рассмотрим эти соглашения
и то, как URL-адрес запроса сопоставляется со страницей Razor.
5.2.3 Маршрутизация и страницы Razor
Как я уже упоминал в разделе 5.2.2, страницы Razor используют маршру -
тизацию на основе атрибутов, создавая шаблоны маршрутов на основе
соглашений. ASP .NET Core создает шаблон маршрута для каждой страни-
цы Razor в вашем приложении во время запуска приложения, когда вы
вызываете метод MapRazorPages в методе Configure из файла Startup.cs:
app.UseEndpoints(endpoints =>
{
endpoints.MapRazorPages();
});
Для каждой страницы Razor в приложении используется путь к файлу
страницы относительно корневого каталога страниц Pages/, за исключе-
нием расширения файла (.cshtml). Например, если у  вас есть страница,
расположенная по пути Pages/Products/View.cshtml, фреймворк создает
шаблон маршрута со значением "Products/View" , как показано на рис. 5.5.
Запросы к URL-адресу /products/view соответствуют шаблону марш-
рута "Products/View", который, в свою очередь, соответствует странице
View.cshtml. RoutingMiddleware выбирает страницу View.cshtml в качест -
ве конечной точки для запроса, а  EndpointMiddleware выполняет обработ -
чик страницы, как только запрос доходит до него в конвейере.
ПОДСКАЗКА  Маршрутизация не чувствительна к  регистру, по-
этому URL-адрес запроса не обязательно должен иметь тот же ре-
гистр URL, что и шаблон маршрута для сопоставления.
В главе 4 вы узнали, что обработчики страниц Razor – это методы, ко-
торые вызываются на странице Razor. Когда мы говорим «страница Razor
выполняется», то на самом деле имеем в виду, что «создается экземпляр
PageModel страницы Razor и вызывается обработчик страницы модели».
У  страниц Razor может быть несколько обработчиков, поэтому после

177 Маршрутизация в ASP.NET Core
того, как RoutingMiddleware выберет страницу, EndpointMiddleware нужно
решить, какой обработчик выполнить. Вы узнаете, как осуществляется
выбор обработчика страницы, в разделе 5.6.
Шаблоны маршрутов основаны на пути к файлам
относительно корневого каталога Razor Pages
Корневой каталог Razor Pages называется Pages
Странице Pages/Products/View.cshtml
соответствует шаблон маршрута Products/View
Странице Pages/Search/Products/StartSearch.cshtml
соответствует шаблон маршрута
Search/Products/StartSearch
Странице Pages/Privacy.cshtml соответствует
шаблон маршрута Privacy
Рис. 5.5 По умолчанию шаблоны маршрутов создаются для страниц Razor на
основе пути к файлу относительно корневого каталога, Pages
По умолчанию каждая страница Razor создает единый шаблон марш-
рута на основе пути к файлу. Исключением из этого правила являются
страницы Index.cshtml. Они создают два шаблона маршрутов, один из
которых оканчивается на "Index", а другой не имеет окончания. Напри-
мер, если у вас есть страница Razor по пути Pages/ToDo/Index.cshtml, бу -
дет сгенерировано два шаблона маршрута:
"ToDo";
"ToDo/Index".
При совпадении любого из этих маршрутов выбирается одна и та же
страница Index.cshtml.
Например, если ваше приложение работает по URL-адресу https://
example.org, можно просмотреть страницу, выполнив https://example.
org/ToDo или https://example.org/ToDo/Index.
В качестве последнего примера рассмотрим страницы Razor, создан-
ные по умолчанию, при создании приложения с по мощью Visual Studio
или при запуске команды dotnet new web с по мощью интерфейса команд-
ной строки .NET, как мы это делали в главе 2. Стандартный шаблон вклю-
чает в себя три страницы в каталоге Pages:

178 Глава 5 Сопоставление URL-адресов с Razor Pages
Pages/Error.cshtml;
Pages/Index.cshtml;
Pages/Privacy.cshtml.
Таким образом создается набор из четырех маршрутов для приложе-
ния, определенных следующими шаблонами:
"" соответствует Index.cshtml;
"Index" сопоставляется с Index.cshtml;
"Error" соответствует Error.cshtml;
"Privacy" соответствует Privacy.cshtml.
На этом этапе маршрутизация, вероятно, кажется до смешного баналь-
ной, но это только основы, которые вы получаете бесплатно, используя
соглашения Razor Pages по умолчанию. Часто этого бывает достаточно
для основной части практически любого веб-сайта. Однако в какой-то
момент вы обнаружите, что вам необходимо что-то более динамичное,
например сайт для онлайн-торговли, где вам нужно, чтобы у  каждого
продукта был свой URL-адрес, который сопоставляется с  одной-един-
ственной страницей Razor. Здесь на помощь приходят шаблоны и дан-
ные маршрутов, демонстрирующие реальную мощь маршрутизации.
5.3 Настройка шаблонов маршрутов
для страницы Razor
Шаблоны маршрута для страницы Razor по умолчанию основаны на пути
к файлу, но вы также можете настроить окончательный шаблон для каж -
дой страницы или даже полностью заменить его. В этом разделе я по-
кажу, как настроить шаблоны маршрутов для отдельных страниц, чтобы
вы могли настроить URL-адреса своего приложения и  сопоставить не-
сколько URL-адресов с одной страницей.
Шаблоны маршрутов имеют богатый и гибкий синтаксис, но на рис. 5.6
показан простой пример.
Обязательный параметр маршрута
Литеральный сегмент Обязательный параметр маршрута
Рис. 5.6 Простой шаблон маршрута с литеральным сегментом
и двумя обязательными параметрами маршрута
Компонент маршрутизации анализирует шаблон маршрута, разделяя
его на несколько сегментов. Сегмент обычно разделяется символом /, но
это может быть любой допустимый символ. Каждый сегмент – это либо
литеральное	значение, например product на рис. 5.6,
либо
параметр	маршрута, например {category} и {name} на рис. 5.6.

179 Настройка шаблонов маршрутов для страницы Razor
Литеральные значения должны точно совпадать (без учета регистра)
по URL-адресу запроса. Если вам нужно точно сопоставить конкретный
URL-адрес, то можно использовать шаблон, состоящий только из лите-
ралов. Это вариант по умолчанию, как вы видели в разделе 5.2.3; каж -
дая страница Razor состоит из ряда литеральных сегментов, например
"ToDo/Index".
ПОДСКАЗКА  Сегменты литералов в  ASP .NET Core не чувстви-
тельны к регистру.
Представьте, что в  вашем приложении есть страница контактов по
пути Pages/About/Contact.cshtml. Шаблон маршрута для этой страницы –
"About/Contact". Этот шаблон состоит только из литеральных значений
и поэтому соответствует лишь точному URL-адресу. Ни один из следу -
ющих URL-адресов не будет соответствовать этому шаблону маршрута:
/about;
/about-us/contact;
/about/contact/email;
/about/contact-us.
Параметры маршрута – это разделы URL-адреса, которые могут раз-
личаться, но по-прежнему будут соответствовать шаблону. Они опреде-
ляются путем присвоения им имени и помещения их в фигурные скобки,
например {category} или {name}. При таком использовании параметры
обязательны, поэтому в URL-адресе запроса должен быть сегмент, кото-
рому они соответствуют, но значение может быть разным.
СОВЕТ  Есть слова, которые нельзя использовать в  качестве на-
званий параметров маршрута: area, action, controller, handler
и page.
Возможность использовать параметры маршрута дает большую гиб-
кость. Например, простой шаблон маршрута "{category}/{name}" мож -
но использовать для сопоставления всех URL-адресов страниц продукта
в приложении онлайн-торговли, например:
/bag/rucksack-a, где category=bags, а name=rucksack-a;
/shoes/black-size9, где category=shoes, а name=black-size9.
Но обратите внимание, что этот шаблон не	будет соответствовать сле-
дующим URL-адресам:
/socks/ – параметр name не указан;
/trousers/mens/formal – дополнительный сегмент URL-адреса, for-
mal, отсутствует в маршруте шаблона.
Когда шаблон маршрута определяет параметр маршрута и  маршрут
соответствует URL-адресу, значение, связанное с параметром, фиксиру -
ется и сохраняется в словаре значений, связанных с запросом. Эти значе-
ния	маршрута обычно определяют поведение страницы Razor, например
привязку модели.

180 Глава 5 Сопоставление URL-адресов с Razor Pages
ОПРЕДЕЛЕНИЕ  Значения	 маршрута – это значения, извлечен-
ные из URL-адреса на основе заданного шаблона маршрута. Каж -
дый параметр маршрута в  шаблоне будет иметь связанное зна-
чение маршрута, и они хранятся в словаре в виде пары строк. Их
можно использовать во время привязки модели, как вы увидите
в главе 6.
Литеральные сегменты и параметры маршрута – это два краеугольных
камня шаблонов маршрутов ASP .NET Core. С помощью этих двух концеп-
ций можно создавать всевозможные URL-адреса для своего приложения.
Но как настроить страницу Razor на использование одного из этих шаб-
лонов?
5.3.1 Добавление сегмента в шаблон маршрута
Чтобы настроить шаблон маршрута страницы Razor, обновите директиву
@page в верхней части файла .cshtml. Эта директива – первое, что должно
быть правильно зарегистрировано в файле страницы Razor.
ПРИМЕЧАНИЕ  Вы должны включить директиву @page в верхнюю
часть файла .cshtml страницы Razor. Без этого ASP .NET Core не бу -
дет рассматривать файл как страницу Razor, и вы не сможете про-
сматривать ее.
Чтобы добавить дополнительный сегмент в шаблон маршрута страни-
цы Razor, добавьте пробел, за которым следует нужный шаблон маршру -
та, после инструкции @page. Например, чтобы добавить "Extra" к шабло-
ну маршрута страницы Razor, используйте
@page "Extra"
Так предоставленный шаблон маршрута будет добавлен к шаблону по
умолчанию, созданному для страницы Razor. Например, шаблон марш-
рута по умолчанию для страницы Razor в  Pages/Privacy.html – это "Pri-
vacy". С помощью предыдущей директивы новый шаблон маршрута для
страницы будет выглядеть так: "Privacy/Extra".
ПРИМЕЧАНИЕ  Шаблон маршрута, указанный в директиве @page,
добавляется	в конец шаблона по умолчанию для страницы Razor.
Наиболее частой причиной такой настройки шаблона маршрута стра-
ницы Razor является добавление параметра	 маршрута. Например, у вас
есть одна страница Razor для отображения продуктов на сайте для он-
лайн-торговли по пути Pages/Products.cshtml и вы можете использовать
параметр маршрута в директиве @page:
@page "{category}/{name}"

181 Настройка шаблонов маршрутов для страницы Razor
Так вы получаете окончательный шаблон маршрута для Products/
{category}/{name}, который будет соответствовать всем перечисленным
ниже URL-адресам:
/products/bags/white-rucksack;
/products/shoes/black-size9;
/Products/phones/iPhoneX.
Очень часто сегменты маршрута добавляются в шаблон страницы Ra-
zor таким образом, но что, если этого недостаточно? Возможно, вы не
хотите, чтобы сегмент /products присутствовал в  начале предыдущих
URL-адресов, или вам нужно использовать полностью настраиваемый
URL-адрес страницы. К счастью, этого легко добиться.
5.3.2 Полная замена шаблона маршрута страницы Razor
Работа со страницами Razor будет наиболее продуктивной, если вы смо-
жете по возможности придерживаться соглашений о  маршрутизации
по умолчанию, добавляя при необходимости дополнительные сегменты
для параметров маршрута. Но иногда вам просто нужно больше контро-
ля. Это часто происходит с важными страницами вашего приложения,
такими как страница оформления заказа, или даже страницами продук -
тов, как вы видели в предыдущем разделе.
Чтобы указать настраиваемый маршрут для страницы Razor, исполь-
зуйте префикс / в директиве @page. Например, чтобы удалить префикс
"product/" из шаблонов маршрутов в предыдущем разделе, используйте
эту директиву:
@page "/{category}/{name}"
Обратите внимание, что данная директива содержит символ "/" в на-
чале маршрута, указывая на то, что это настраиваемый шаблон марш-
рута, а  не добавление. Шаблон маршрута для этой страницы будет вы-
глядеть так: "{category}/{name}", независимо от того, к какой странице
Razor он применяется.
Точно так же можно создать статический настраиваемый шаблон для
страницы, поставив в начало шаблона символ "/" и используя только ли-
теральные сегменты. Например:
@page "/checkout"
Где бы вы ни разместили свою страницу оформления заказа в папке
Pages, использование этой директивы гарантирует, что она всегда будет
иметь шаблон маршрута "checkout", поэтому всегда будет соответство-
вать URL-адресу запроса /checkout.
СОВЕТ  Также можно рассматривать пользовательские шаблоны
маршрутов, которые начинаются с  символа «/» как абсолютные
шаблоны маршрутов, в то время как другие шаблоны являются от-
носительными	к их местоположению в файловой иерархии.

182 Глава 5 Сопоставление URL-адресов с Razor Pages
Важно отметить, что при настройке шаблона маршрута для страни-
цы Razor как при добавлении к значению по умолчанию, так и при его
замене настраиваемым маршрутом шаблон	 по	умолчанию	 становится
недействительным. Например, если вы используете шаблон маршрута
"checkout" по адресу Pages/Payment.cshtml, то можете получить к нему
доступ, только	 используя URL-адрес /checkout; URL-адрес /Payment уже
будет недействителен и не будет выполнять страницу Razor.
СОВЕТ  Настройка шаблона маршрута для страницы Razor с по-
мощью директивы @page заменяет шаблон маршрута по умолча-
нию. В разделе 5.7 я покажу, как можно добавить дополнительные
маршруты, сохранив шаблон маршрута по умолчанию.
В этом разделе вы узнали, как настроить шаблон маршрута для стра-
ницы Razor. В следующем разделе мы более подробно рассмотрим син-
таксис шаблона маршрута и некоторые другие доступные функции.
5.4 Изучение синтаксиса шаблона маршрута
Помимо основных элементов литералов и сегментов параметров марш-
рута, шаблоны маршрутов имеют дополнительные функции, которые
дают вам бóльший контроль над URL-адресами вашего приложения. Эти
функции позволяют создавать необязательные URL-сегменты, предо-
ставлять значения по умолчанию, если сегмент не указан, или накла-
дывать дополнительные ограничения на значения, действительные для
данного параметра маршрута. В данном разделе рассматриваются эти
функции и способы их применения.
5.4.1 Использование дополнительных значений и значений
по умолчанию
В предыдущем разделе вы видели простой шаблон маршрута с литераль-
ным сегментом и двумя обязательными параметрами маршрутизации.
На рис. 5.7 показан более сложный маршрут, использующий ряд допол-
нительных функций.
Обязательный
параметр маршрутаНеобязательный
параметр маршрута
Необязательный параметр маршрута
со значением по умолчанию, если он не указанЛитеральный сегмент
Рис. 5.7  Более сложный шаблон маршрута с литеральными сегментами,
именованными параметрами маршрута, необязательными параметрами
и значениями по умолчанию

183 Изучение синтаксиса шаблона маршрута
Литеральный сегмент product и  обязательный параметр {category}
такие же, как на рис. 5.6. Параметр {name} выглядит похожим, но для него
задано значение по умолчанию с по мощью = all. Если URL-адрес не со-
держит сегмента, соответствующего параметру {name}, маршрутизатор
будет использовать вместо него значение all.
Последний сегмент рис. 5.7, {id?}, определяет необязательный пара-
метр маршрута id. Этот сегмент URL-адреса является необязательным:
если он присутствует, маршрутизатор захватит значение параметра
{id}; если его там нет, то он не будет создавать значение маршрута
для id.
В своих шаблонах можно указать любое количество параметров марш-
рута, и эти значения будут доступны вам, когда дело дойдет до привяз-
ки модели. Сложный шаблон маршрута на рис.  5.7 позволяет сопоста-
вить большее количество URL-адресов, сделав параметры {name} и  {id}
необязательными и  предоставив значение по умолчанию для {name}.
В табл. 5.2 показаны некоторые возможные URL-адреса, которым будет
соответствовать этот шаблон, и  соответствующие значения маршрута,
которые задал бы маршрутизатор.
Таблица 5.2 URL-адреса, которые будут соответствовать шаблону на
рис. 5.7, и их соответствующие значения маршрута
URL-адрес Значения маршрута
/product/shoes/formal/3 category=shoes, name=formal, id=3
/product/shoes/formal category=shoes, name=formal
/product/shoes category=shoes, name=all
/product/bags/satchels category=bags, name=satchels
/product/phones category=phones, name=all
/product/computers/laptops/ABC-123 category=computes, name=laptops, id=ABC-123
Обратите внимание, что нельзя указать значение для необязательного
параметра {id}, не указав также параметры {category} и  {name}. Можно
поместить необязательный параметр (не имеющий значения по умол-
чанию) только	 в конец шаблона маршрута. Например, представьте, что
в вашем шаблоне маршрута есть необязательный параметр {category}:
{category?}/{name}
Теперь попробуйте придумать URL-адрес, в котором будет указан па-
раметр {name}, но не {category}. Это невозможно! Подобные шаблоны
сами по себе не вызывают ошибок; параметр категории просто обязате-
лен, даже если вы отметили его как необязательный.
Использование значений по умолчанию позволяет вызывать один
и  тот же URL-адрес несколькими способами, что в  некоторых случаях
может быть желательным. Например, учитывая шаблон маршрута на
рис. 5.7, следующие два URL-адреса эквивалентны:
/product/shoes;
/product/shoes/all.

184 Глава 5 Сопоставление URL-адресов с Razor Pages
Оба этих адреса будут выполнять одну и ту же страницу Razor с оди-
наковыми значениями маршрута category=shoes и  name=all. Использо-
вание значений по умолчанию позволяет применять более короткие
и  запоминающиеся URL-адреса в  приложении для распространенных
вариантов, но при этом иметь гибкость, позволяющую сопоставить мно-
жество маршрутов в одном шаблоне.
5.4.2 Добавление дополнительных ограничений
к параметрам маршрута
Определив, является ли параметр маршрута обязательным или необя-
зательным и имеет ли он значение по умолчанию, можно сопоставить
широкий диапазон URL-адресов с довольно кратким синтаксисом шаб-
лона. К сожалению, в некоторых случаях это может оказаться слишком
широким. Маршрутизация сопоставляет сегменты URL-адреса только
с параметрами маршрута; она ничего не знает о данных, которые, как вы
ожидаете, будут содержать эти параметры. Если рассматривать шаблон,
аналогичный тому, что изображен на рис.  5.7, "{category}/{name=all}/
{id?}", то следующие URL-адреса будут соответствовать:
/shoes/sneakers/test;
/shoes/sneakers/123;
/Account/ChangePassword;
/ShoppingCart/Checkout/Start;
/1/2/3.
Все эти URL-адреса являются вполне допустимыми с учетом синтак -
сиса шаблона, но некоторые из них могут вызвать проблемы у приложе-
ния. Они состоят из двух или трех сегментов, поэтому маршрутизатор
с радостью назначает значения маршрута и сопоставляет шаблон, когда
вы, возможно, этого и не хотите! Это присвоенные значения маршрута:
/shoes/sneakers/test—category=shoes, name=sneakers, id=test;
/shoes/sneakers/123—category=shoes, name=sneakers, id=123;
/Account/ChangePassword—category=Account, name=ChangePassword;
/Cart/Checkout/Start—category=Cart, name=Checkout, id=Start;
/1/2/3—category=1, name=2, id=3.
Обычно маршрутизатор передает значения маршрута в  Razor Pages
через процесс, называемый привязкой модели, который вы кратко ви-
дели в главе 4 (и который мы подробно обсудим в следующей главе). На-
пример, страница Razor с обработчиком public void OnGet (int id) полу -
чит аргумент id из значения маршрута id. Если параметру маршрута id
в конечном итоге назначается не	целочисленное	 значение из URL-адреса,
то вы получите исключение, когда он будет привязан к целочисленному
параметру id.
Чтобы избежать этой проблемы, можно добавить к шаблону маршрута
дополнительные ограничения, которые должны быть выполнены, что-
бы URL-адрес считался совпадающим. Ограничения можно определить
в шаблоне маршрута для данного параметра маршрута с по мощью двое-

185 Изучение синтаксиса шаблона маршрута
точия. Например, {id: int} добавит ограничение IntRouteConstraint
к параметру id. Чтобы данный URL-адрес считался совпадающим, зна-
чение, присвоенное значению маршрута id, должно быть преобразовано
в целое число.
Можно применить большое количество ограничений маршрута к шаб-
лонам маршрутов, чтобы обеспечить преобразование значений марш-
рута в соответствующие типы. Также можно использовать более слож -
ные ограничения, например выполнить проверку на предмет того, что
целочисленное значение имеет определенное минимальное значение
или строковое значение имеет максимальную длину. В табл. 5.3 описан
ряд возможных доступных ограничений, а более полный список можно
найти в интернете по адресу http://mng.bz/xmae.
Таблица 5.3 Ограничения маршрута и их поведение при применении
Ограничение Пример Примеры совпадений Описание
Int {qty:int} 123, -123, 0 Соответствует любому целому числу
Guid {id:guid} d071b70c-a812-4b54-
87d2-7769528e2814 Соответствует любому глобальному
уникальному идентификатору
Decimal {cost:decimal} 29.99, 52, -1.01 Соответствует любому значению decimal
min(value) {age:min(18)} 18, 20 Соответствует целочисленным значениям
от 18 и выше
length(value) {name:length(6)} andrew,123456 Соответствует строковым значениям
длиной 6 символов
optional int {qty:int?} 123, -123, 0, null Необязательно соответствует любому
целому числу
optional int
max(value){qty:int:max(10)?} 3, -123, 0, null Необязательно соответствует любому
целому числу 10 или меньше
ПОДСКАЗКА  Как видно из таблицы, также можно комбиниро-
вать несколько ограничений, разделяя их двоеточиями.
Использование ограничений позволяет сузить число URL-адресов, ко-
торым будет соответствовать данный шаблон маршрута. Когда компо-
нент маршрутизации сопоставляет URL-адрес с шаблоном маршрута, он
опрашивает ограничения, чтобы убедиться, что все они действительны.
Если это не так, то шаблон маршрута не считается совпадающим, и стра-
ница Razor не будет выполнена.
ВНИМАНИЕ!  Не используйте ограничения маршрутов для про-
верки общих вводимых данных, например для проверки правиль-
ности адреса электронной почты. Это приведет к появлению со-
общения об ошибке «Страница не найдена», которое будет сбивать
с толку пользователя.
Ограничения лучше всего использовать экономно, но они могут быть
полезны, если у вас есть строгие требования к URL-адресам, используе-
мым приложением, поскольку они могут позволить обойти некоторые
сложные комбинации.

186 Глава 5 Сопоставление URL-адресов с Razor Pages
Ограничения и порядок в маршрутизации на основе атрибутов
Если у вас есть хорошо разработанный набор URL-адресов для вашего при-
ложения, то вы, вероятно, обнаружите, что на самом деле вам не нужно ис -
пользовать ограничения маршрутов. Эти ограничения действительно полез-
ны, когда у вас есть «перекрывающиеся» шаблоны маршрутов.
Например, представьте, что у вас есть страница Razor с шаблоном маршру-
та "{number}/{name} " и еще одна – с шаблоном "{product}/{id}". Какой
шаблон выбирается при поступлении запроса с URL-адресом /shoes/123?
Они оба совпадают, поэтому компонент маршрутизации начинает паниковать
и выбрасывает исключение. Неидеальный вариант.
Это можно исправить, используя соглашения. Например, если обновить пер-
вый шаблон, чтобы он выглядел так: "{number: int}/{name}", то целочис -
ленное ограничение будет означать, что URL-адрес больше не соответству-
ет, и компонент маршрутизации может сделать правильный выбор. Однако
обратите внимание, что URL-адрес /123/shoes по-прежнему соответствует
обоим шаблонам маршрута, поэтому опасность еще не миновала.
Как правило, следует избегать дублирования подобных шаблонов маршру-
тов, поскольку они часто сбивают с толку и вызывают больше проблем.
Маршрутизация на основе атрибутов (используется контроллерами Razor
Pages и MVC для создания API) позволяет явно контролировать порядок, в ко-
тором компонент маршрутизации просматривает ваши шаблоны маршрутов,
которые также можно использовать для решения проблем, подобных той, что
описана выше. Однако если вам нужно контролировать порядок вручную, то
это явный показатель того, что ваши URL-адреса сбивают с толку1.
Если ваши шаблоны маршрутов четко определены, так что каждый URL-ад-
рес сопоставляется только с одним шаблоном, маршрутизация будет рабо-
тать без каких-либо трудностей. Придерживаться встроенных соглашений,
насколько это возможно, – лучший способ, чтобы все шло гладко!
На этом наше изучение шаблонов маршрутов подошло к  концу, но
прежде чем мы продолжим, есть еще один тип параметров, о котором
следует подумать: универсальный параметр.
5.4.3 Сопоставление произвольных URL-адресов
с помощью универсального параметра
Вы уже видели, как шаблоны маршрутов берут сегменты URL-адреса
и пытаются сопоставлять их с параметрами или литеральными строка-
ми. Эти сегменты обычно разделяются символом косой черты /, поэтому
сами параметры маршрута не содержат этого символа. Что делать, если
1 Если вы действительно уверены, что вам нужно контролировать порядок шаб-
лонов маршрутов, см. документацию по адресу http://mng.bz/MXqo. Обрати-
те внимание, что можно управлять порядком добавления дополнительных
маршрутов только с по мощью соглашений. Вы увидите это в разделе 5.7.

187 Изучение синтаксиса шаблона маршрута
вам нужно, чтобы они содержали косую черту, или вы не знаете, сколько
сегментов у вас будет?
Представьте, что вы создаете приложение – конвертер валют, которое
показывает обменный курс одной валюты к одной или нескольким ва-
лютам. Вам сказали, что URL-адреса этой страницы должны содержать
все валюты в виде отдельных сегментов. Вот несколько примеров:
/USD/convert/GBP – показывать доллары США с  курсом обмена на
фунты стерлингов;
/USD/convert/GBP/EUR – отображать доллары США с курсами обмена
на фунты стерлингов и евро;
/USD/convert/GBP/EUR/CAD  – показать доллары США с  курсами об-
мена на фунты стерлингов, евро и канадские доллары.
Если вы хотите поддерживать отображение любого количества валют,
как это делают приведенные выше URL-адреса, вам нужен способ захва-
та всего, что идет после сегмента convert. В случае со страницей Pages/
Convert.cshtml этого можно было бы добиться с по мощью универсаль-
ного параметра в директиве @page, как показано на рис. 5.8.
Конвертация на основе
обозначения валюты
Замена маршрута по умолчанию
вместо добавленияЛитеральный
сегментУниверсальный
параметр
Рис. 5.8 Можно использовать универсальные параметры для сопоставления
оставшейся части URL-адреса. Эти параметры могут включать в себя символ «/»
или могут быть пустой строкой
Универсальные параметры можно объявить с  по мощью одной или
двух звездочек внутри определения параметра, например {*others} или
{**others}. Они будут соответствовать оставшейся несовпадающей части
URL-адреса, включая любые косые черты и другие символы, не входящие
в состав более ранних параметров. Они также могут соответствовать пус -
той строке. Для URL-адреса /USD/convert/GBP/EUR значение others будет
представлять собой одну строку "GBP/EUR".
СОВЕТ  Универсальные параметры довольно прожорливы и  за-
хватывают всю несовпадающую часть URL-адреса. По возможно-
сти, чтобы избежать путаницы, избегайте определения шаблонов
маршрутов с такого рода параметрами, которые перекрывают дру -
гие шаблоны маршрутов.
Варианты с  одной и  двумя звездочками ведут себя идентично при
маршрутизации входящего запроса на страницу Razor. Разница появ-
ляется только тогда, когда вы	 генерируете URL-адреса (которые мы рас -
смотрим в следующем разделе): URL-адрес с одной звездочкой кодирует

188 Глава 5 Сопоставление URL-адресов с Razor Pages
косую черту, а версия с двумя звездочками – нет. Как правило, вам по-
требуется поведение версии с двумя звездочками1.
Вы не ошиблись: сопоставление URL-адресов со страницами Razor –
лишь половина обязанностей системы маршрутизации в ASP .NET Core.
Она также используется для генерации	 URL-адресов, чтобы можно было
легко ссылаться на свои страницы из других частей приложения.
5.5 Генерация URL-адресов из параметров
маршрута
В этом разделе мы рассмотрим вторую половину обязанностей маршру -
тизации – генерацию URL-адресов. Вы узнаете, как сгенерировать URL-
адреса в виде строки, которую можно использовать в своем коде, и как
автоматически отправлять URL-адреса перенаправления в качестве от -
вета от ваших страниц Razor.
Одним из побочных продуктов использования инфраструктуры марш-
рутизации в ASP .NET Core является то, что ваши URL-адреса могут быть
изменчивы. Если вы переименуете страницу Razor, URL-адрес, связанный
с  ней, также изменится. Например, переименование страницы Pages/
Cart.cshtml в  Pages/Basket/View.cshtml приведет к тому, что URL-ад рес,
который вы используете для доступа к  странице, изменится с  /Cart на
/Basket/View.
Ручное управление URL-адресами в приложении повлекло бы за собой
головную боль, неработающие ссылки и ошибки 404. Если бы ваши URL-
адреса были жестко запрограммированы, то вам нужно было бы непре-
менно выполнять поиск и замену при каждом переименовании!
К счастью, можно использовать инфраструктуру маршрутизации для
динамической генерации соответствующих URL-адресов во время вы-
полнения. Это освободит вас от подобного бремени. По сути, это почти
полная противоположность процессу сопоставления URL-адреса со стра-
ницей Razor, как показано на рис. 5.9. В случае «маршрутизации» компо-
нент маршрутизации принимает URL-адрес, сопоставляет его с шабло-
ном маршрута и разбивает его на значения. В случае «генерации URL»
генератор принимает значения маршрута и объединяет их с шаблоном
маршрута для создания URL-адреса.
1 Подробные сведения и  примеры такого поведения см. в  документации по
адресу http://mng.bz/aoGo.

189 Генерация URL-адресов из параметров маршрута
Маршрутизация
Создание URL-адресаМаршрутизация берет URL-адрес,
использует набор шаблонов
маршрутов и вычисляет значения
маршрутов
Генерация URL-адреса принимает
набор значений маршрута
и использует набор шаблонов
маршрутов для вычисления
URL-адреса Шаблоны
маршрутов
Шаблоны
маршрутовЗначения
маршрута
Значения
маршрутаМаршрутизатор URL
URL Маршрутизатор
Рис. 5.9 Сравнение маршрутизации и генерации URL-адреса. Маршрутизация
принимает URL-адрес и генерирует значения маршрута, а генерация URL-адресов
использует значения маршрута для создания адреса
5.5.1 Создание URL-адресов для страницы Razor
Вам нужно будет генерировать URL-адреса в различных местах прило-
жения, и одним из наиболее распространенных мест являются страницы
Razor и контроллеры MVC. В следующем листинге показано, как создать
ссылку на страницу Pages/Currency/View.cshtml, используя свойство Url
из базового класса PageModel.
Листинг 5.2  Генерация URL-адреса с использованием IUrlHelper
и имени страницы Razor
public class IndexModel : PageModel
{
public void OnGet()
{
var url = Url.Page("Currency/View", new { code = "USD" });
}
}Наследование от класса PageModel
дает доступ к свойству Url.
Вы указываете относительный путь
к странице Razor вместе с любыми
дополнительными значениями маршрута.

190 Глава 5 Сопоставление URL-адресов с Razor Pages
Свойство Url является экземпляром объекта IUrlHelper, позволяю-
щим легко генерировать URL-адреса для вашего приложения, ссылаясь
на другие страницы Razor по пути к их файлу. Он предоставляет метод
Page, которому вы передаете имя страницы Razor и любые дополнитель-
ные данные маршрута. Данные маршрута упаковываются в виде пары
«ключ-значение» в один анонимный объект C#.
Если вам нужно передать несколько значений маршрута, можно доба-
вить дополнительные свойства к анонимному объекту. Затем помощник
сгенерирует URL-адрес на основе указанного шаблона маршрута стра-
ницы.
СОВЕТ  Можно указать относительный путь к файлу для страни-
цы Razor, как показано в  листинге 5.2. В  качестве альтернативы
вы можете указать абсолютный путь к файлу (относительно папки
Pages), начав путь с символа «/», например "/Currency/View".
IUrlHelper имеет несколько различных перегруженных вариантов
метода Page. Некоторые из этих методов позволяют указать конкретный
обработчик страницы, другие  – сгенерировать абсолютный URL-адрес
вместо относительного, а  некоторые позволяют передавать дополни-
тельные значения маршрута.
В листинге 5.2, помимо указания пути к файлу, я передал анонимный
объект new {code = "USD"}. Этот объект предоставляет дополнительные
значения маршрута при генерации URL-адреса, в данном случае задавая
для параметра code значение "USD".
Если выбранный маршрут явно включает в себя определенное значе-
ние маршрута, например в шаблоне маршрута "Currency/View/{code}",
значение маршрута будет использоваться в пути URL-адреса, в резуль-
тате чего вы получите /Currency/View/USD.
Если маршрут не содержит явно значение маршрута, как в шаблоне
"/Currency/View", то значение маршрута добавляется в  виде дополни-
тельных данных как часть строки запроса, например /Currency/View?
code=USD.
Генерировать URL-адреса на основе страницы, которую вы хотите вы-
полнить, удобно, и в большинстве случаев это обычный подход. Если вы
используете контроллеры MVC для своих API, процесс во многом такой
же, как и для страниц Razor, хотя методы немного отличаются.
5.5.2 Создание URL-адресов для контроллера MVC
Создание URL-адресов для контроллеров MVC очень похоже на то, как
это делается для страниц Razor. Основное отличие состоит в том, что вы
используете метод Action в IUrlHelper и предоставляете имя контролле-
ра MVC и действия вместо пути к странице. В следующем листинге пока-
зан контроллер MVC, генерирующий ссылку от одного метода действия
к другому с по мощью помощника Url из базового класса Controller.

191 Генерация URL-адресов из параметров маршрута
Листинг 5.3  Генерация URL-адреса с использованием IUrlHelper
и имени действия
public class CurrencyController : Controller
{
[HttpGet("currency/index")]
public IActionResult Index()
{
var url = Url.Action("View", "Currency",
new { code = "USD" });
return Content($"The URL is {url}");
}
[HttpGet("currency/view/{code}")]
public IActionResult View(string code)
{
/* Реализация метода */
}
}
Можно вызывать методы Action и Page в IUrlHelper как из Razor Pages,
так и из контроллеров MVC, чтобы при необходимости создавать ссылки
между ними. Важный вопрос: каков пункт назначение	 URL-адреса? Если
нужный вам URL-адрес относится к странице Razor, используйте метод
Page. Если речь идет о действии MVC, применяйте метод Action.
СОВЕТ  Вместо использования строк для имени метода действия
привлеките оператор C# 6 nameof, чтобы сделать значение безопас -
ным для рефакторинга, например nameof(View).
Если вы выполняете маршрутизацию к действию в том же контролле-
ре, то можете использовать другой перегруженный вариант метода Ac-
tion, который пропускает имя контроллера при генерации URL-адреса.
IUrlHelper использует внешние	 значения из текущего запроса и заменяет
их конкретными значениями, которые вы предоставляете.
ОПРЕДЕЛЕНИЕ  Внешние	 значения – это значения маршрута для
текущего запроса. Они включают в  себя контроллер и  действие
при вызове из контроллера MVC, но также могут включать допол-
нительные значения маршрута, которые были установлены при
первоначальном обнаружении действия или страницы Razor с ис -
пользованием маршрутизации. См. статью «Маршрутизация в ASP .
NET Core» для получения дополнительных сведений: http://mng.
bz/xmae.
Создание URL-адресов с использованием свойства Url на практике не
особо распространено. Вместо этого URL-адреса чаще генерируются не-
явно с по мощью ActionResult. Наследование от класса Controller
дает доступ к свойству Url.
Вы указываете действие и имя
контроллера, а также любые
дополнительные значения
маршрута.
Это вернет строку
"The URL is /Currency/View/USD" .
Сгенерированный URL-адрес
выполнит маршрутизацию
к методу действия View.

192 Глава 5 Сопоставление URL-адресов с Razor Pages
5.5.3 Создание URL-адресов с по мощью ActionResults
Вы видели, как сгенерировать строку, содержащую URL-адрес для Ra-
zor Pages и для действий MVC. Это полезно, если вам нужно отобразить
URL-адрес пользователю или, например, включить URL-адрес в  ответ
API. Однако очень часто вам не нужно отображать URL-адрес. Чаще
всего вам нужно автоматически	 перенаправить пользователя. В  этой
ситуации можно использовать ActionResult для обработки генерации
URL-адреса.
В следующем листинге показано, как сгенерировать URL-адрес, кото-
рый автоматически перенаправляет пользователя на другую страницу
Razor с  по мощью ActionResult. Метод RedirectToPage принимает путь
к странице Razor и любые необходимые параметры маршрута и генери-
рует URL-адрес так же, как метод Url.Page. Фреймворк автоматически
отправляет сгенерированный URL-адрес в качестве ответа, поэтому вы
никогда не увидите его в своем коде. Затем браузер пользователя считы-
вает URL-адрес из ответа и автоматически перенаправляет его на новую
страницу.
Листинг 5.4 Создание URL-адреса перенаправления из ActionResult
public class CurrencyModel : PageModel
{
public IActionResult OnGetRedirectToPage()
{
return RedirectToPage("Currency/View", new { id = 5 });
}
}
Похожий метод RedirectToAction можно использовать для автомати-
ческого перенаправления на действие MVC. Как и в случае с методами
Page и Action, именно пункт назначения определяет, нужно ли вам ис -
пользовать метод RedirectToPage или метод RedirectToAction.
RedirectToAction необходим только в том случае, если вы используете
контроллеры MVC для генерации HTML-кода вместо Razor Pages.
СОВЕТ  Я  рекомендую применять Razor Pages вместо контрол-
леров MVC для генерации HTML-кода. Обсуждение преимуществ
Razor Pages приводится в главе 4.
Помимо создания URL-адресов из страниц Razor и контроллеров MVC,
вы часто будете сталкиваться с  необходимостью генерировать URL-
адреса при создании HTML-кода в представлениях. Это необходимо для
предоставления навигационных ссылок в  вашем веб-приложении. Вы
увидите, как этого добиться, когда мы будем рассматривать тег-хелперы
Razor в главе 8.
Если вам нужно сгенерировать URL-адреса из частей вашего прило-
жения за пределами страницы Razor или инфраструктуры MVC, вы не Метод RedirectT oPage генерирует
RedirectT oPageResult
со сгенерированным URL-адресом.

193 Генерация URL-адресов из параметров маршрута
сможете использовать помощник IUrlHelper или ActionResult. Вместо
этого понадобится класс LinkGenerator.
5.5.4 Создание URL-адресов из других частей
вашего приложения
Если вы пишете страницы Razor и контроллеры MVC, следуя советам из
главы 4, постарайтесь делать свои страницы относительно простыми.
Для этого требуется, чтобы вы выполняли бизнес-логику своего прило-
жения и логику предметной области в отдельных классах и сервисах.
По большей части URL-адреса, используемые вашим приложением,
не	должны быть частью логики предметной области. Это упрощает раз-
витие вашего приложения с течением времени или даже полное его из-
менение. Например, можно создать мобильное приложение, которое по-
вторно использует бизнес-логику из приложения ASP .NET Core. В этом
случае применение URL-адресов в бизнес-логике не имеет смысла, по-
скольку они не будут правильными, когда логика вызывается из мобиль-
ного приложения!
СОВЕТ  По возможности старайтесь держать клиентскую часть
приложения отдельно от бизнес-логики. Этот шаблон обычно из-
вестен как принцип инверсии зависимостей1.
К сожалению, иногда такое разделение невозможно, или оно зна-
чительно усложняет ситуацию. Один из примеров – когда вы создаете
электронные письма в  фоновом сервисе: вероятно, вам нужно будет
включить ссылку на свое приложение в электронное письмо. Класс Link-
Generator позволяет сгенерировать этот URL-адрес, чтобы он автомати-
чески обновлялся при изменении маршрутов в вашем приложении.
Класс LinkGenerator доступен в  любой части приложения, поэтому
можно использовать его внутри промежуточного ПО и  любых других
сервисов. Вы также можете использовать его из Razor Pages и MVC, если
хотите, но IUrlHelper обычно проще и скрывает некоторые детали при-
менения LinkGenerator.
У LinkGenerator имеются различные методы для создания URL-адре-
сов, такие как GetPathByPage, GetPathByAction и GetUriByPage, как показа-
но в следующем листинге. В использовании этих методов есть некоторые
нюансы, особенно в сложных конвейерах промежуточного ПО, поэтому
придерживайтесь IUrlHelper, где это возможно, и  обязательно озна-
комьтесь с документацией, если у вас появятся проблемы2.
1 У Стива Смита есть шаблон проекта, строго следующий этому принципу, ко-
торый называется «Чистая архитектура». Найти его, а также множество полез-
ных ссылок и книг по этой теме можно по адресу: https://github.com/ardalis/
CleanArchitecture.
2 Документацию по LinkGenerator вы можете найти здесь: http://mng.bz/goWx.

194 Глава 5 Сопоставление URL-адресов с Razor Pages
Листинг 5.5  Генерация URL-адресов с использованием
LinkGeneratorClass
public class CurrencyModel : PageModel
{
private readonly LinkGenerator _link;
public CurrencyModel(LinkGenerator linkGenerator)
{
_link = linkGenerator;
}
public void OnGet ()
{
var url1 = Url.Page("Currency/View", new { id = 5 });
var url2 = _link.GetPathByPage(
HttpContext,
"/Currency/View",
values: new { id = 5 });
var url3 = _link.GetPathByPage(
"/Currency/View",
values: new { id = 5 });
var url4 = _link.GetUriByPage(
page: "/Currency/View",
handler: null,
values: new { id = 5 },
scheme: "https",
host: new HostString("example.com"));
}
}
Независимо от того, создаете ли вы URL-адреса с по мощью IUrlHelp-
er или LinkGenerator, вы должны быть осторожны при использовании
методов создания маршрута. Убедитесь, что вы указали правильный
путь к странице Razor и все необходимые параметры маршрута. Если вы
ошиб  лись, например в пути допущена опечатка или вы забыли указать
обязательный параметр, сгенерированный URL-адрес будет нулевым.
Стоит явно проверить сгенерированный адрес на равенство значению
null, чтобы убедиться, что проблемы отсутствуют.
До сих пор в этой главе мы подробно рассматривали, как входящие
запросы маршрутизируются на страницы Razor, но мы так и не увиде-
ли, как в этом участвуют обработчики страниц. В следующем разделе мы
рассмотрим обработчики страниц и то, как можно использовать на стра-
нице Razor несколько обработчиков.
5.6 Выбор обработчика страницы для вызова
В начале этой главы я сказал, что маршрутизация заключается в сопо-
ставлении URL-адресов с  обработчиком. Для страниц Razor это означает
обработчик	 страницы, но до сих пор мы говорили только о маршрути-Доступ к LinkGenerator можно
получить с по мощью внедрения
зависимостей.
Url может генерировать
относительные пути с помощью
метода Url.Page. Можно
использовать относительные
или абсолютные пути.GetPathByPage эквивалентен
Url.Page при передаче в HttpContext.
Использовать относительные пути
нельзя.
Другие перегруженные
варианты не требуют
HttpContext.
GetUriByPage генерирует
абсолютный URL-адрес
вместо относительного.

195 Выбор обработчика страницы для вызова
зации на основе шаблона маршрута страницы Razor. В этом разделе вы
узнаете, как EndpointMiddleware выбирает, какой обработчик страницы
вызывать при выполнении страницы Razor.
Вы познакомились с обработчиками страниц и их ролью в страницах
Razor в главе 4, но мы не обсуждали, как выбирается обработчик стра-
ницы для данного запроса. Страницы Razor могут иметь несколько об-
работчиков, поэтому если RoutingMiddleware выбирает страницу Razor,
EndpointMiddleware нужно знать, какой обработчик выбрать для выпол-
нения.
Рассмотрим SearchModel страницы Razor, показанной в  следующем
листинге. У  этой страницы Razor три обработчика: OnGet, OnPostAsync
и OnPostCustomSearch. Тела методов обработчика не показаны, поскольку
на данный момент нас интересует только то, как RoutingMiddleware вы-
бирает, какой обработчик вызывать.
Листинг 5.6 Страница Razor с несколькими обработчиками страниц
public class SearchModel : PageModel
{
public void OnGet()
{
// Реализация обработчика;
}
public Task OnPostAsync()
{
// Реализация обработчика;
}
public void OnPostCustomSearch()
{
// Реализация обработчика;
}
}
Razor Pages может содержать любое количество обработчиков, но в от -
вет на заданный запрос выполняется только один. Когда EndpointMid-
dleware выполняет выбранную страницу Razor, то выбирает обработчик
страницы, который нужно будет вызвать на основе двух переменных:
HTTP-метод, используемый в  запросе (например, GET, POST или
# DELETE);
значение маршрута handler.
Значение маршрута handler обычно берется из значения строки за-
проса в  URL-адресе запроса, например /Search?Handler=CustomSearch.
Если вам не нравится внешний вид строк запроса (мне он не нравится!),
то можно включить параметр маршрута {handler} в шаблон маршрута
страницы Razor. Например, для страницы поиска в листинге 5.6 можно
обновить директиву страницы:
@page "{handler}" Обрабатывает GET-запросы.
Обрабатывает POST-запросы.
Суффикс async является необязательным
и игнорируется в целях маршрутизации.
Обрабатывает POST-запросы, в которых
значение маршрута обработчика имеет
значение CustomSearch.

196 Глава 5 Сопоставление URL-адресов с Razor Pages
Так вы получите полный шаблон маршрута что-то вроде "Search/{han-
dler}", который будет соответствовать таким URL-адресам, как /Search/
CustomSearch.
EndpointMiddleware использует значение маршрута обработчика
и  HTTP-метод вместе со стандартным соглашением об именах, чтобы
определить, какой обработчик страницы выполнить, как показано на
рис.  5.10. Параметр обработчика является необязательным и  обычно
предоставляется как часть строки запроса или как параметр маршрута,
как описано выше. Суффикс async также является необязательным и час -
то применяется, когда обработчик использует конструкции асинхронно-
го программирования, такие как Task или async/await1.
HTTP-методНеобязательный
суффикс async
Необязательное
имя обработчикаОбязательно
Рис. 5.10 Обработчики страницы Razor сопоставляются с запросом
на основе HTTP-метода и необязательного параметра обработчика
Основываясь на этом соглашении, теперь можно определить, какой тип
запроса соответствует каждому обработчику страницы в листинге 5.6:
OnGet – вызывается для GET-запросов, в которых не указано значе-
ние обработчика;
OnPostAsync – вызывается для запросов POST, в которых не указа-
но значение обработчика. Он возвращает Task, поэтому использует
суффикс Async, который игнорируется в целях маршрутизации;
OnPostCustomSearch – вызывается для запросов POST, в которых ука-
зано значение обработчика "CustomSearch".
Страница Razor в листинге 5.6 определяет три обработчика, поэтому
может обрабатывать только три пары метод–обработчик. Но что прои-
зойдет, если вы получите запрос, который не соответствует им, например
запрос с использованием команды DELETE, GET-запрос с непустым зна-
чением handler  или POST-запрос с нераспознанным значением handler?
Во всех этих случаях EndpointMiddleware вместо этого выполняет
неявный  обработчик страницы. Неявные обработчики страниц не содер-
жат логики; они просто визуализируют представление Razor. Например,
если вы отправили запрос DELETE на страницу Razor в листинге 5.6, то
будет выполнен неявный обработчик. Неявный обработчик страницы
эквивалентен следующему коду:
public void OnDelete() { }
1 Соглашение об именах асинхронных суффиксов предложено корпорацией
Mic rosoft, хотя оно и непопулярно среди некоторых разработчиков. NService-
Bus предоставляет обоснованный аргумент на странице (вместе с  советом
Mic rosoft): http://mng.bz/e59P .

197 Настройка соглашений с помощью Razor Pages
ОПРЕДЕЛЕНИЕ  Если обработчик страницы не соответствует
HTTP-методу запроса и значению обработчика, выполняется неяв-
ный обработчик страницы, который отображает ассоциированное
представление Razor. Неявные обработчики страниц участвуют
в привязке модели и используют фильтры страниц, но не выпол-
няют никакой логики.
Из правила неявного обработчика страниц есть одно исключение:
если в  запросе используется команда HEAD и  нет соответствующего
обработчика OnHead, Razor Pages выполнит обработчик OnGet (если он
существует)1.
На этом этапе мы рассмотрели сопоставление URL-адресов запросов
со страницами Razor и создание URL-адресов с использованием инфра-
структуры маршрутизации, но большинство URL-адресов, которые мы
использовали, были некрасивыми. Если заглавные буквы в URL-адресах
вас беспокоят, то следующий раздел для вас. В нем мы настроим согла-
шения, которые ваше приложение использует для генерации шаблонов
маршрутов.
5.7 Настройка соглашений с помощью
Razor Pages
Razor Pages основан на ряде соглашений, призванных уменьшить объем
шаблонного кода, который вам нужно писать. В этом разделе вы увидите
способы настройки этих условных соглашений. Настраивая соглашения,
используемые Razor Pages в вашем приложении, вы получаете полный
контроль над URL-адресами приложения без необходимости вручную
настраивать каждый шаблон маршрута Razor Page.
По умолчанию ASP .NET Core генерирует URL-адреса, которые очень
точно соответствуют именам файлов ваших страниц Razor. Например,
страница Razor, расположенная по пути Pages/Products/ProductDetails.
cshtml, будет соответствовать шаблону маршрута Products/Product-De-
tails.
В наши дни нечасто можно увидеть заглавные буквы в URL-адресах,
а слова в адресах обычно разделяются с по мощью дефиса, а не пропис -
ной буквы, например product-details вместо ProductDetails. Наконец,
также часто бывает, что в URL-адресах всегда идет косая черта, например
/product-details/ вместо /product-details. Razor Pages дает вам полный
контроль над соглашениями, которые ваше приложение использует для
создания шаблонов маршрутов, но это два распространенных измене-
ния, которые делаю я.
1 Запросы HEAD обычно отправляются браузером автоматически и не возвра-
щают тело ответа. Как вы увидите в главе 18, они часто используются в целях
безопасности.

198 Глава 5 Сопоставление URL-адресов с Razor Pages
В следующем листинге показано, как сделать так, чтобы URL-адреса
всегда были в нижнем регистре и всегда имели косую черту в конце. Вы
можете изменить эти соглашения, настроив объект RouteOptions из фай-
ла Startup.cs. Этот объект содержит конфигурацию всей инфраструктуры
маршрутизации ASP .NET Core, поэтому любые внесенные вами изме-
нения будут применяться и к страницам Razor и MVC. Подробнее о на-
стройке параметров вы узнаете в главе 10.
Листинг 5.7  Настройка соглашений о маршрутизации с использованием
объекта RouteOptions из файла Startup.cs
public void ConfigureServices(IServiceCollection services)
{
services.AddRazorPages();
services.Configure<RouteOptions>(options =>
{
options.AppendTrailingSlash = true;
options.LowercaseUrls = true;
options.LowercaseQueryStrings = true;
});
}
Чтобы использовать дефисы для своего приложения, нужно создать
преобразователь настраиваемых параметров, а это раздражает. Это не-
сколько сложная тема, но в данном случае ее относительно просто реа-
лизовать. В следующем листинге показано, как создать преобразователь
параметров, который использует регулярное выражение для замены
значений с прописными буквами в сгенерированном URL-адресе на де-
фисы.
Листинг 5.8  Создание преобразователя параметров для замены
на дефисы
public class KebabCaseParameterTransformer
: IOutboundParameterTransformer
{
public string TransformOutbound(object value)
{
if (value == null) return null;
return Regex.Replace(value.ToString(),
"([a-z])([A-Z])", "$1-$2").ToLower();
}
}
Можно зарегистрировать преобразователь параметров в  своем при-
ложении с по мощью метода расширения AddRazorPagesOptions из файла
Startup.cs. Он идет после метода AddRazorPages и может использоваться
для полной настройки соглашений, используемых Razor Pages. В следую-Добавляем стандартные сервисы Razor Pages.
Конфигурируем объект
RouteOptions, предоставив
метод Configure.
Вы можете изменить соглашения,
используемые для создания URL-адресов.
По умолчанию эти свойства имеют значение false.
Создаем класс, реализующий интерфейс
ParameterTransformer.
Защита от нулевых значений,
чтобы избежать исключений
во время выполнения.
Регулярное выражение заменяет
шаблоны PascalCase на дефисы
(kebab-case).

199 Настройка соглашений с помощью Razor Pages
щем листинге показано, как зарегистрировать преобразователь для де-
фисов, а также как добавить соглашение о  дополнительном маршруте
для данной страницы Razor.
Листинг 5.9  Регистрация преобразователя параметров с по мощью
RazorPagesOptions
public void ConfigureServices(IServiceCollection services)
{
services.AddRazorPages()
.AddRazorPagesOptions(opts =>
{
opts.Conventions.Add(
new PageRouteTransformerConvention(
new KebabCaseParameterTransformer()));
opts.Conventions.AddPageRoute(
"/Search/Products/StartSearch", "/search-products");
});
}
Соглашение AddPageRoute добавляет альтернативный способ выполне-
ния страницы Razor. В отличие от того, когда вы настраиваете шаблон
маршрута для страницы Razor с по мощью директивы @page, при исполь-
зовании AddPageRoute на страницу добавляется	 дополнительный	 шаблон
маршрута	 вместо замены того, что есть по умолчанию. Это означает, что
есть два шаблона маршрута, которые могут получить доступ к странице.
Есть много других способов настроить соглашения для приложений
Razor Pages, но в большинстве случаев в этом нет необходимости. Если
вы обнаружите, что вам нужно каким-то образом настроить все страни-
цы в приложении, например добавить дополнительный заголовок к каж -
дому ответу страницы, то можно использовать собственное соглашение.
В документации на странице http://mng.bz/A0BK содержится подробная
информация.
Соглашения  – ключевая особенность Razor Pages, и  вы должны как
можно больше использовать их. Хотя вы можете вручную переопреде-
лить шаблоны маршрутов для отдельных страниц Razor, как вы видели
в предыдущих разделах, я не рекомендую этим злоупотреблять. В част -
ности:
избегайте замены шаблона маршрута на абсолютный путь в дирек -
тиве страницы @page;
избегайте добавления литеральных сегментов в  директиву @page.
Вместо этого используйте файловую иерархию;
избегайте добавления дополнительных шаблонов маршрутов на
страницу Razor с  по мощью соглашения AddPageRoute. Наличие
нескольких способов доступа к  странице иногда может сбивать
с толку;Метод расширения AddRazorPagesOptions
можно использовать для настройки
соглашений, используемых Razor Pages.
Регистрирует преобразователь параметров как соглашение,
используемое всеми страницами Razor Pages.Метод AddPageRoute добавляет дополнительный шаблон
маршрута в путь Pages/Search/Products/StartSearch.cshtml.

200 Глава 5 Сопоставление URL-адресов с Razor Pages
добавьте параметры маршрута в директиву @page, чтобы сделать
свои маршруты динамическими, например @page{имя};
рассмотрите возможность использования глобальных соглашений,
если хотите изменить шаблоны маршрутов для всех своих страниц
Razor, например используя дефисы, как в предыдущем разделе.
Вкратце: эти правила сводятся к  «соблюдению соглашений». Опас -
ность, если вы этого не сделаете, заключается в том, что вы можете слу -
чайно создать две страницы Razor с  шаблонами маршрутов, которые
будут перекрывать друг друга. К сожалению, если вы попадете в такую
ситуацию, то не получите ошибку во время компиляции. Вместо этого вы
получите исключение во время выполнения, когда ваше приложение по-
лучит запрос, соответствующий нескольким шаблонам маршрутов, как
показано на рис. 5.11.
Рис. 5.11 Если несколько страниц Razor зарегистрированы с перекрывающимися шаблонами
маршрутов, вы получите исключение во время выполнения, когда маршрутизатор не сможет
решить, какой из них выбрать
Поздравляю, вы прошли все этапы подробного обсуждения маршру -
тизации! Маршрутизация – одна из тех тем, на которых люди часто за-
цикливаются, когда приступают к созданию приложения, а это расстраи-
вает. Мы еще вернемся к маршрутизации, когда я буду описывать, как
создавать веб-API в главе 9, но будьте уверены, что мы уже рассмотрели
все хитрые подробности в этой главе!
В главе 6 мы подробно рассмотрим привязку модели. Вы увидите, как
значения маршрута, созданные во время маршрутизации, привязаны
к методу действия (MVC) или обработчику страницы (Razor Pages) и, что,
возможно, еще более важно, как проверить предоставленные вам зна-
чения.

201 Резюме
Резюме
Маршрутизация – это процесс сопоставления URL-адреса входящего
запроса со страницей Razor, которая будет выполняться для генерации
ответа. Можно использовать маршрутизацию, чтобы отделить свои
URL-адреса от файлов в своем проекте и сопоставить несколько URL-
адресов с одной и той же страницей Razor.
ASP .NET Core использует два компонента маршрутизации. Endpoin-
tRoutingMiddleware добавляется в Startup.cs путем вызова метода Use-
Routing(), а EndpointMiddleware добавляется путем вызова метода Use-
Endpoints().
EndpointRoutingMiddleware выбирает, какая конечная точка должна
быть выполнена, используя маршрутизацию для определения соот -
ветствия URL-ад ресу запроса. EndpointMiddleware выполняет ее.
Любое промежуточное ПО, размещенное между вызовами UseRout-
ing() и UseEndpoints(), может сказать, какая конечная точка будет вы-
полнена для запроса.
Шаблоны маршрутов определяют структуру известных URL-адресов
в вашем приложении. Это строки с заполнителями для переменных,
которые могут содержать необязательные значения и сопоставляться
со страницами Razor или действиями контроллера MVC.
Параметры маршрута  – это значения переменных, извлекаемые из
URL-адреса запроса.
Параметры маршрута могут быть необязательными и могут использо-
вать значения по умолчанию, если значение отсутствует.
Параметры маршрута могут иметь ограничения, которые ограничи-
вают возможные допустимые значения. Если параметр маршрута не
соответствует ограничениям, маршрут не считается совпадающим.
Не используйте ограничения маршрута в качестве общих валидаторов
ввода. Используйте их для устранения неоднозначности между двумя
похожими маршрутами.
Применяйте универсальный параметр, чтобы записать оставшуюся
часть URL-адреса в значение маршрута.
Можно использовать инфраструктуру маршрутизации для создания
внутренних URL-адресов вашего приложения.
IUrlHelper можно использовать для создания URL-адресов в  виде
строки на основе имени действия или страницы Razor.
Можно применять методы RedirectToAction и  RedirectToPage для соз-
дания URL-адресов и ответа перенаправления.
LinkGenerator можно использовать для генерации URL-адресов из
других сервисов в вашем приложении, где у вас нет доступа к объекту
HttpContext.
При выполнении страницы Razor вызывается один обработчик стра-
ницы на основе HTTP-метода запроса и значения маршрута обработ -
чика.

202 Глава 5 Сопоставление URL-адресов с Razor Pages
Если для запроса нет обработчика страницы, используется неявный
обработчик, который визуализирует представление Razor.
Вы можете контролировать соглашения о маршрутизации, используе-
мые ASP .NET Core, настроив объект RouteOptions, например чтобы все
URL-адреса шли в нижнем регистре или всегда добавляли косую черту
в конце.
Вы можете добавить дополнительные соглашения о маршрутизации
для Razor Pages, вызвав метод AddRazorPagesOptions после метода Ad-
dRazorPages() из файла Startup.cs. Эти соглашения могут управлять
отображением параметров маршрута или добавлять дополнительные
шаблоны маршрутов для определенных страниц Razor.
По возможности избегайте настройки шаблонов маршрутов для стра-
ницы Razor и вместо этого используйте соглашения.

6Модель	привязки:
получение	и проверка
пользовательского	ввода
В этой главе:
использование значений из запроса для создания
моделей привязки;
настройка процесса привязки модели;
проверка пользовательского ввода с по мощью
атрибутов DataAnnotations.
В главе 5 я показал, как определить маршрут, используя параметры, на-
пример для дня в календаре или уникального идентификатора страни-
цы продукта. Но предположим, что пользователь запрашивает страницу
с данным продуктом, что тогда? Что, если запрос включает данные из
формы, например для изменения названия продукта? Как обработать
такой запрос и  получить доступ к  значениям, предоставленным поль-
зователем?
В первой половине этой главы мы рассмотрим использование моделей
привязки для извлечения этих параметров из запроса, чтобы вы могли
применять их на своих страницах Razor. Вы увидите, как взять данные,
опубликованные в форме или в URL-адресе, и привязать их к объектам
C#. Эти объекты передаются обработчикам страниц Razor в качестве па-
раметров метода или заданы как свойства для PageModel. Когда ваш об-
работчик страницы выполняется, он может использовать эти значения,
чтобы сделать что-то полезное – вернуть правильную запись в дневнике
или изменить название продукта, например.

204 Глава 6 Модель привязки: получение и проверка пользовательского ввода
После того как ваш код выполняется в методе обработчика страниц,
возможно, вас можно простить за то, что вы думаете, что можете пре-
красно использовать модель привязки без каких-либо дополнительных
размышлений. Постойте, откуда взялись эти данные? От пользователя –
вы знаете: ему нельзя доверять! Вторая половина главы посвящена тому,
как убедиться, что значения, предоставленные пользователем, являются
допустимыми и имеют смысл для вашего приложения.
Можно рассматривать модели привязки как входные	 данные для стра-
ницы Razor, принимая низкоуровневый HTTP-запрос пользователя
и делая его доступным для вашего кода, заполняя объекты Plain old CLR
object1. После выполнения обработчика страницы все готово для ис -
пользования моделей вывода в реализации MVC ASP .NET Core – моделей
представления и моделей API. Они используются для генерации ответа
на запрос пользователя. Мы рассмотрим их в главах 7 и 9.
Прежде чем продолжить, вспомним паттерн проектирования MVC
и то, как модели привязки вписываются в ASP .NET Core.
6.1 Модели в Razor Pages и MVC
В этом разделе описано, как модели привязки вписываются в паттерн
проектирования MVC, который мы рассматривали в главе 4. Я описываю
разницу между моделями привязки и другими концепциями «модели»
в паттерне MVC и то, как каждая из них используется в ASP .NET Core.
MVC – это разделение ответственности. Предпосылка состоит в том,
что, изолируя каждый аспект вашего приложения, чтобы сосредоточить-
ся на единственной ответственности, он уменьшает взаимозависимости
в  вашей системе. Такое разделение упрощает внесение изменений, не
влияя на другие части вашего приложения.
Классический паттерн проектирования MVC состоит из трех незави-
симых компонентов:
контроллер – вызывает методы модели и выбирает представление;
представление – отображает представление данных, составляющих
модель;
модель – отображаемые данные и методы обновления.
В этом представлении есть только одна модель, модель приложения,
которая представляет всю бизнес-логику приложения, а также способы
обновления и изменения его внутреннего состояния. В ASP .NET Core есть
несколько моделей, в которых принцип единственной ответственности
продвинулся на шаг вперед, по сравнению с некоторыми представления-
ми MVC.
В главе 4 мы рассмотрели пример приложения со списком дел, которое
может отображать все задачи для данной категории и имени пользовате-
1 POCO – это обычные классы и объекты C#, находящиеся в памяти. Нет никаких
особых требований к наследованию или атрибутов, необходимых для их ис -
пользования с ASP .NET Core.

205 Модели в Razor Pages и MVC
ля. С помощью этого приложения вы отправляете запрос на URL-адрес,
который маршрутизируется с  привлечением todo/listcategory/{cate-
gory}/{username}. После этого вы получаете ответ, показывающий все
соответствующие задачи, как показано на рис. 6.1.
Категория и имя
пользователя используются
для фильтрации
списка текущих задач Категория и имя
пользователя также
могут быть показаны
в модели представленияКатегория и имя пользователя указаны в URL-адресе
Рис. 6.1 Базовое приложение со списком дел, которое отображает элементы
списка дел. Пользователь может фильтровать список элементов, изменив параметры
category и username в URL-адресе
В приложении используются те же конструкции MVC, которые вы
уже видели, например маршрутизация к  обработчику страницы Razor,
а также ряд различных моделей. На рис. 6.2 показано, как запрос к это-
му приложению сопоставляется с паттерном проектирования MVC и как
он генерирует окончательный ответ, включая дополнительные сведения
о привязке модели и проверке (валидации) запроса.
Razor Pages использует несколько разных моделей, большинство из
которых являются объектами POCO, и модель приложения, которая боль-
ше представляет собой концепцию набора сервисов. Каждая из моделей
в ASP .NET Core отвечает за обработку разных аспектов общего запроса.
Модель	привязки – это вся информация, предоставляемая пользова-
телем при выполнении запроса, а также дополнительные контекст -
ные данные. Сюда входят такие вещи, как параметры маршрута,
извлеченные из URL-адреса, строка запроса и данные формы или
данные в формате JSON в теле запроса. Сама модель привязки – это
один или несколько определяемых вами объектов POCO. Модели
привязки в Razor Pages обычно определяются путем создания от -
крытого свойства в  PageModel страницы и декорирования его с по-
мощью атрибута [BindProperty]. Их также можно передать обработ -
чику страницы в качестве параметров.
В этом примере модель привязки будет включать имя категории
open и имя пользователя Andrew. Инфраструктура Razor Pages прове-
ряет модель привязки перед выполнением обработчика страницы,
чтобы проверить, действительны ли предоставленные значения,
хотя обработчик страницы будет выполняться, даже если они тако-
выми не являются. Вы увидите это, когда мы будем обсуждать вали-
дацию модели в разделе 6.3.

206 Глава 6 Модель привязки: получение и проверка пользовательского ввода
7.  Представление использует свойства PageModel
для создания ответа в виде HTML-кода,
который возвращается пользователюЗапрос
Модель привязки
Модель привязкиПривязка модели
Валидация модели
Состояние модели
Обработчик страницы
Страница Razor
ПредставлениеСервисы
Взаимодействие
с базой данныхМодель
предметной
области
Модель
приложения
PageModel
HTML1.  Получен запрос к URL-адресу /todo/listcategory/
open/Andrew. Компонент маршрутизации
сопоставляет запрос со страницей Razor
ListCategory и выводит параметры маршрута
category = open и username = Andrew2.  Параметры маршрута, извлеченные из
запроса, используются для сборки модели
привязки, установив свойства модели Username
и Category, экземпляра специального класса,
InputModel
3.  После привязки модель проверяется
на предмет наличия допустимых значений.
Результат проверки сохраняется в ModelState
4.  Модель привязки (InputModel) и ModelState
заданы как свойства ListCategory PageModel.
Модель привязки также может быть передана
в качестве параметра обработчику страницы5.  Обработчик страницы вызывает сервисы,
составляющие модель приложения,
для получения списка задач и сборки модели
представления
6.  Обработчик страницы задает список дел
в качестве свойства PageModel. Затем он
возвращает объект PageResult для выполнения
представления Razor
Рис. 6.2 Паттерн MVC в ASP.NET Core, обрабатывающий запрос на просмотр подмножества
элементов в приложении Razor Pages
Модель	приложения – модель приложения на самом деле не является
моделью ASP .NET Core. Как правило, это больше концепция, целая
группа различных сервисов и классов – все, что необходимо для вы-
полнения какого-либо бизнес-действия в вашем приложении. Она
может включать в себя модель предметной области (которая пред-
ставляет то, что ваше приложение пытается описать) и модели базы
данных (которые представляют данные, хранящиеся в базе данных),
как и любые другие, дополнительные сервисы.
В приложении со списком дел модель приложения будет содержать
полный список дел, который, вероятно, хранится в  базе данных,
и она знает, как найти только задачи в категории open, назначенной
Andrew.

207 Модели в Razor Pages и MVC
Моделирование предметной области  – огромная тема со мно-
жеством возможных подходов, поэтому она выходит за рамки этой
книги, но мы кратко коснемся создания моделей баз данных в гла-
ве 11.
Модель	страницы  – PageModel страницы Razor выполняет две ос -
новные функции: она действует как контроллер для приложения,
предоставляя методы обработчика страницы, и  как модель пред-
ставления для представления Razor. Все данные, необходимые
представлению для генерации ответа, представлены в  PageModel,
например список дел в категории open, назначенной Andrew.
Базовый класс PageModel, от которого вы наследуете свои страницы
Razor, содержит различные вспомогательные свойства и  методы.
Одно из них, свойство ModelState, содержит результат валидации
модели в виде серии пар «ключ-значение». Подробнее о валидации
и свойстве ModelState вы узнаете в разделе 6.3.
Эти модели составляют основу любого приложения Razor Pages, об-
рабатывая ввод, бизнес-логику и вывод каждого обработчика страницы.
Представьте, что у  вас есть приложение для онлайн-торговли, позво-
ляющее пользователям искать одежду, отправляя запросы в URL-адрес
/search/{query}, где {query} содержит поисковый запрос:
модель	привязки – принимает параметр маршрута {query} из URL-
адреса и любые значения, присланные в теле запроса (возможно,
порядок сортировки или число элементов для показа), и привязы-
вает их к классу C#, который обычно действует как класс передачи
данных. Объект этого класса передачи данных будет доступен как
свойство PageModel при вызове обработчика страницы;
модель	приложения  – это сервисы и  классы, выполняющие логи-
ку. При вызове обработчиком страницы эта модель загружает всю
одежду, соответствующую запросу, применяя необходимую сорти-
ровку и фильтры, и возвращает результаты контроллеру;
модель	страницы – значения, предоставляемые моделью приложе-
ния, будут заданы как свойства PageModel страницы Razor вместе
с  другими метаданными, такими как общее количество доступ-
ных элементов или возможность для пользователя оформить заказ
в данный момент. Представление Razor будет использовать эти дан-
ные для визуализации представления Razor в HTML-код.
Важным моментом всех этих моделей является то, что их обязанности
четко определены и  разделены. Их разделение и  предотвращение по-
вторного использования помогают обеспечить гибкость и простоту об-
новления вашего приложения.
Очевидным исключением из этого разделения является PageModel,
поскольку именно здесь определяются модели привязки и  обработчи-
ки страниц, а также хранятся данные, необходимые для визуализации
представления. Некоторые могут посчитать очевидное отсутствие раз-
деления кощунством, но на самом деле это не проблема. Демаркацион-

208 Глава 6 Модель привязки: получение и проверка пользовательского ввода
ные линии вполне очевидны. Если вы, например, не пытаетесь вызвать
обработчик страницы из представления Razor, то у вас не должно воз-
никнуть никаких проблем!
Теперь, когда вы должным образом познакомились с различными мо-
делями в ASP .NET Core, пора сосредоточиться на том, как их использо-
вать. В этой главе рассматриваются модели привязки, которые строятся
из входящих запросов, – как они создаются, и откуда берутся значения?
6.2 От запроса к модели: делаем запрос
полезным
В этом разделе вы узнаете:
как ASP .NET Core создает модели привязки из запроса;
как привязать простые типы, такие как int и string, а также слож -
ные классы;
как выбрать, какие части запроса используются в модели привязки.
К настоящему времени вы должны быть знакомы с тем, как ASP .NET
Core обрабатывает запрос, выполняя обработчик страницы для страни-
цы Razor. Кроме того, вы уже видели несколько обработчиков страниц,
например
public void OnPost(ProductModel product)
Обработчики страниц – это обычные методы C#, поэтому у фреймвор-
ка ASP .NET Core должна быть возможность вызывать их обычным спо-
собом. Когда обработчики страниц принимают параметры как часть их
сигнатуры метода, такой как product из предыдущего примера, фрейм-
ворку необходим способ создания этих объектов. Откуда они берутся
и как создаются?
Я уже намекнул, что в большинстве случаев эти значения исходят из
самого запроса. Но HTTP-запрос, который получает сервер, представляет
собой серию строк – как ASP .NET Core превращает это в объект .NET? Вот
тут-то и появляется привязка	модели.
ОПРЕДЕЛЕНИЕ  Привязка	 модели извлекает значения из запроса
и использует их для создания объектов .NET. Эти объекты переда-
ются как параметры метода в выполняемый обработчик страницы
или задаются как свойства PageModel, которые помечены атрибу -
том [BindProperty].
Связыватель модели отвечает за просмотр входящего запроса и поиск
значений для использования. Затем он создает объекты соответствую-
щего типа и назначает эти значения вашей модели в ходе процесса, на-
зываемого привязкой.

209 От запроса к модели: делаем запрос полезным
ПРИМЕЧАНИЕ  Привязка модели в Razor Pages и MVC – это од-
ностороннее заполнение объектов из запроса, а не двусторонняя
привязка данных, которая иногда используется при разработке
настольных или мобильных приложений.
Любые свойства PageModel вашей страницы Razor (в файле .cshtml.cs),
декорированные атрибутом [BindProperty], создаются из входящих за-
просов с использованием привязки модели, как показано в следующем
листинге. Если у метода обработчика вашей страницы есть какие-либо
параметры, они также создаются с по мощью привязки модели.
Листинг 6.1 Запросы привязки модели к свойствам на странице Razor
public class IndexModel: PageModel
{
[BindProperty]
public string Category { get; set; }
[BindProperty(SupportsGet = true)]
public string Username { get; set; }
public void OnGet()
{
}
public void OnPost(ProductModel model)
{
}
}
Как показано в предыдущем листинге, свойства PageModel не привяза-
ны к модели для запросов GET, даже если вы добавите атрибут [BindProp-
erty]. По соображениям безопасности привязываются только запросы,
использующие такие методы, как POST и PUT. Если вы хотите привязать
запросы GET, то можете задать свойство SupportsGet в атрибуте [Bind-
Property], чтобы разрешить привязку модели.
СОВЕТ  Чтобы привязать свойства PageModel для запросов GET,
используйте свойство атрибута SupportsGet, например [BindPro-
per ty(SupportsGet = true)].
Какая часть является моделью привязки?
В листинге 6.1 показана страница Razor, использующая несколько моделей
привязки: свойства Category, Username и ProductModel (в обработчике On-
Post) привязаны к модели.
Использование нескольких моделей таким образом – это нормально, но
я предпочитаю подход, при котором все привязки модели хранятся в одном
вложенном классе, который я  часто называю InputModel. При таком под-Свойства, декорированные атрибутом
[BindProperty], принимают участие
в привязке модели.
Свойства не будут привязаны
к модели для GET-запросов, если вы
не используете свойство SupportsGet.
Параметры обработчиков страниц
также привязаны к модели, когда
выбран этот обработчик.

210 Глава 6 Модель привязки: получение и проверка пользовательского ввода
ходе страницу Razor из листинга 6.1 можно было бы написать следующим
образом:
public class IndexModel: PageModel
{
[BindProperty]
public InputModel Input { get; set; }
public void OnGet()
{
}
public class InputModel
{
public string Category { get; set; }
public string Username { get; set; }
public ProductModel Model { get; set; }
}
}
У такого подхода есть некоторые организационные преимущества, о кото-
рых вы узнаете подробнее в разделе 6.4.
ASP .NET Core автоматически заполняет модели привязки за вас, ис -
пользуя свойства запроса, такие как URL-адрес запроса, любые заголов-
ки, отправленные в  HTTP-запросе, данные, явно отправленные с  по-
мощью POST в теле запроса, и т. д.
По умолчанию ASP .NET Core использует три разных источника	 привяз-
ки при создании модели привязки. Он просматривает каждый из них по
порядку и принимает первое значение, которое находит (если оно есть),
соответствующее имени модели:
значения	 формы – отправляются в теле HTTP-запроса, когда форма
отправляется на сервер, с по мощью POST;
значения	 маршрута – получаются из сегментов URL-адреса или зна-
чений по умолчанию после сопоставления маршрута, как вы видели
в главе 5;
значения	 строки	запроса – передаются в конце URL-адреса и не ис -
пользуются во время маршрутизации.
Процесс привязки модели показан на рис.  6.3. Связыватель модели
проверяет каждый источник привязки, чтобы убедиться, что он содер-
жит значение, которое можно задать в модели. В качестве альтернативы
модель также может выбрать конкретный источник, из которого должно
поступать значение. Вы увидите это в разделе 6.2.3.
После привязки каждого свойства модель валидируется и присваива-
ется в свойство объекта PageModel или передается в качестве параметра
обработчику страницы. С процессом валидации модели вы познакоми-
тесь во второй половине этой главы.

211 От запроса к модели: делаем запрос полезным
Каждое из свойств модели привязки
пытается привязаться к значению
из источника привязки Источники привязки
проверяются по
порядку, и используется
первое совпадающее
значение. В данном
случае свойство Id
привязано к значению
маршрута
Поскольку есть
значение формы,
соответствующее
свойству Name,
значения маршрута
и значения строки
запроса в этом случае
не проверяютсяЗначения формы
Значения формыЗначения маршрута
Значения маршрутаЗначения строки
запроса
Значения строки
запроса
Рис. 6.3 Привязка модели включает в себя отображение значений из источников
привязки, которые соответствуют разным частям запроса
Свойства PageModel или параметры обработчика страницы?
Привязку модели в Razor Pages можно использовать двумя способами:
 декорировать свойства PageModel атрибутом [BindProperty];
 добавить параметры в свой метод обработчика страницы.
Какой из этих подходов выбрать?
Ответ на этот вопрос – во многом дело вкуса. Задание свойств в  PageModel
и пометка их с по мощью [BindProperty] – это подход, который вы чаще
всего будете встречать в примерах. Если вы воспользуетесь им, то сможете
получить доступ к модели привязки при визуализации представления, как
увидите в главах 7 и 8.
Альтернативный подход, при котором к методам обработчика страницы до-
бавляются параметры, обеспечивает больше разделения между различны-
ми этапами MVC, поскольку вы не сможете получить доступ к параметрам
за пределами обработчика страницы. С другой стороны, если вам действи-
тельно нужно отобразить эти значения в представлении Razor, вам придется
вручную скопировать параметры в свойства, к которым можно получить до-
ступ в представлении.
Подход, который выбираю я, обычно зависит от конкретной страницы Razor,
которую я создаю. Если я создаю форму, то предпочту подход, использующий
атрибут [BindProperty], поскольку обычно мне нужен доступ к значениям
запроса внутри представления Razor. Для простых страниц, где привязка мо-
дели – это идентификатор продукта, я предпочитаю подход с параметрами
обработчика страницы из-за его простоты, особенно если обработчик пред-
назначен для запроса GET. Я даю несколько более конкретных советов по
своему подходу в разделе 6.4.

212 Глава 6 Модель привязки: получение и проверка пользовательского ввода
На рис. 6.4 показан пример запроса, создающего аргумент метода Pro-
ductModel, используя привязку модели для примера, показанного в на-
чале этого раздела:
public void OnPost(ProductModel product)
Получен HTTP-запрос, который направляется
в страницу EditProduct по маршрутизации.
Свойство типа ProductModel декорировано
атрибутом [BindProperty]
Связыватель модели создает
новый объект ProductModel,
используя значения, взятые
из запроса. Сюда входят значения
маршрута из URL-адреса, а также
данные, отправленные в теле
запроса
Рис. 6.4 Применение привязки модели для создания экземпляра модели, которая
используется для выполнения страницы Razor
Свойство Id было привязано из параметра маршрута URL, а свойства
Name и SellPrice – из тела запроса. Существенное преимущество: исполь-
зование привязки модели заключается в том, что вам не нужно писать
код для парсинга запросов и самостоятельно сопоставлять данные. Та-
кой код обычно является стереотипным и подвержен ошибкам, поэтому
использование встроенного традиционного подхода позволяет сосредо-
точить внимание на важных аспектах вашего приложения: бизнес-тре-
бованиях.
СОВЕТ  Привязка модели отлично подходит для уменьшения сте-
реотипного кода. Используйте ее всегда, когда это возможно, и вам
редко придется обращаться к объекту Request напрямую.
Если нужно, то есть возможности, позволяющие полностью настроить
способ работы привязки модели, но вам довольно редко придется захо-
дить так далеко. В большинстве случаев все работает как есть, и вы уви-
дите это в оставшейся части раздела.
6.2.1 Связывание простых типов
Мы начнем наше путешествие по привязке модели с рассмотрения прос -
того обработчика страницы Razor. В следующем листинге показана прос -
тая страница Razor, в которой в качестве параметра метода берется одно
число и возводится в квадрат.

213 От запроса к модели: делаем запрос полезным
Листинг 6.2 Страница Razor, принимающая простой параметр
public class CalculateSquareModel : PageModel
{
public void OnGet(int number)
{
Square = number * number;
}
public int Square { get; set; }
}
В предыдущей главе вы узнали, что такое маршрутизация и как она
выбирает, какую страницу Razor выполнить. Вы можете обновить ша-
блон маршрута для страницы Razor на "CalculateSquare/{number}", доба-
вив сегмент {number} к директиве @page страницы Razor в файле .cshtml,
как мы обсуждали в главе 5:
@page "{number}"
Когда клиент запрашивает URL-адрес /CalculateSquare/5, Razor Page
использует маршрутизацию для парсинга параметров маршрута. В ре-
зультате получается пара значений маршрута:
number=5
Обработчик страницы OnGet страницы Razor содержит единствен-
ный параметр – целое число number, – который является вашей моделью
привязки. Когда ASP .NET Core будет выполнять этот метод обработчика
страницы, то обнаружит ожидаемый параметр. Он просмотрит значения
маршрута, ассоциированные с запросом, и найдет пару number=5. Затем
он может привязать параметр number к этому значению маршрута и вы-
полнить метод. Сам метод обработчика страницы не заботится о том,
откуда взялось это значение; он идет своим путем, вычисляя квадрат
значения и устанавливая его в свойстве Square.
Главное, что необходимо понять, – вам не нужно было писать допол-
нительный код, чтобы пытаться извлечь число из URL-адреса при выпол-
нении метода. Все, что нужно было сделать, – создать параметр метода
(или открытое свойство) с  правильным именем и  позволить привязке
модели творить свою магию.
Значения маршрута – не единственные значения, которые связыватель
модели может использовать для создания привязки модели. Как вы уже
видели ранее, фреймворк будет просматривать три источника	 привязки
по умолчанию, чтобы найти соответствие вашим моделям привязки:
значения формы;
значения маршрута;
значения строки запроса.
Каждый из этих источников привязки содержит значения в виде пары
«имя-значение». Если ни один из источников привязки не содержит Параметр метода – это модель привязки.
В более сложном примере эта работа будет выполняться
во внешнем сервисе, в модели приложения.
Результат предоставляется как свойство и используется
представлением для генерации ответа.

214 Глава 6 Модель привязки: получение и проверка пользовательского ввода
нужного значения, для модели привязки по умолчанию задается новый
экземпляр типа. Точное значение модели привязки в этом случае зави-
сит от типа переменной:
для типов значений будет использоваться значение default(T). Для
параметра int это будет 0, а для bool – false;
для ссылочных типов тип создается с  по мощью конструктора по
умолчанию (без параметров). Для пользовательских типов, таких
как ProductModel, будет создан новый объект. Для типов, допуска-
ющих значение null, таких как int? или bool?, значение будет null;
для строковых типов значение будет null.
ВНИМАНИЕ!  Важно учитывать поведение обработчика страни-
цы, когда привязка модели не может связать параметры вашего
метода. Если ни один из источников привязки не содержит значе-
ние, то значение, передаваемое методу, может быть null или не-
ожиданно иметь значение по умолчанию (для типов значений).
В листинге 6.2 показано, как привязать один-единственный параметр
метода. Давайте сделаем следующий логический шаг и посмотрим, как
привязать несколько параметров.
В предыдущей главе мы обсуждали маршрутизацию для создания
приложения для конвертера валют. На следующем этапе разработки ваш
начальник просит вас создать метод, в котором пользователь указыва-
ет стоимость в одной валюте, а вы должны конвертировать ее в другую.
Сначала вы создаете страницу Razor под названием Convert.cshtml, а по-
том настраиваете шаблон маршрута для страницы с по мощью директи-
вы @page, чтобы использовать абсолютный путь, содержащий два значе-
ния маршрута:
@page "/{currencyIn}/{currencyOut}"
Затем вы создаете обработчик страницы, который принимает три не-
обходимых вам значения, как показано в следующем листинге.
Листинг 6.3  Обработчик страницы Razor, принимающий несколько
параметров привязки
public class ConvertModel : PageModel
{
public void OnGet(
string currencyIn,
string currencyOut,
int qty
)
{
/* Реализация метода */
}
}

215 От запроса к модели: делаем запрос полезным
Как видите, здесь есть три разных параметра для привязки. Вопрос
в том, откуда берутся значения и как они будут заданы? Ответ: все за-
висит от обстоятельств! В  табл. 6.1 показано множество возможных
вариантов. Во всех этих примерах используется один и тот же шаблон
маршрута и обработчик страницы, но в зависимости от отправленных
данных будут привязаны разные значения. Фактические значения мо-
гут отличаться от ожидаемых, поскольку доступные источники привязки
предлагают противоречивые значения!
Таблица 6.1 Привязка данных запроса к параметрам обработчика
страницы из нескольких источников привязки
URL (значения маршрута) Данные тела HTTP
(значения формы) Привязанные значения
параметров
/GBP/USD currencyIn=GBP
currencyOut=USD qty=0
/GBP/USD?currencyIn=CAD QTY=50 currencyIn=GBP
currencyOut=USD qty=50
/GBP/USD?qty=100 qty=50 currencyIn=GBP
currencyOut=USD qty=50
/GBP/USD?qty=100 currencyIn=CAD&
currencyOut=EUR&qty=50currencyIn=CAD
currencyOut=EUR qty=50
Для каждого примера убедитесь, что вы понимаете, почему	 связанные
значения имеют те значения, которые у них есть. В первом примере зна-
чения qty нет в данных формы, значении маршрута или в строке запроса,
поэтому он имеет значение по умолчанию 0. В других примерах запрос
содержит одно или несколько повторяющихся значений; в этих случа-
ях важно помнить о порядке, в котором связыватель модели проверяет
источники привязки. По умолчанию значения формы имеют приоритет
над другими источниками привязки, включая значения маршрута!
ПРИМЕЧАНИЕ  По умолчанию связыватель модели не чувствите-
лен к регистру, поэтому значение QTY=50 будет успешно привязано
к параметру qty.
Хотя это может показаться немного сложным, относительно необычно
связывать все эти источники сразу. Чаще всего все ваши значения по-
ступают из тела запроса в виде значений формы, возможно, с иденти-
фикатором из значений маршрута URL. Данный сценарий служит скорее
поучительным рассказом о том, какое странное поведение вы можете
встретить, если не уверены, как все работает под капотом.
В этих примерах вы успешно связали целочисленное свойство qty
с  входящими значениями, но, как я  упоминал ранее, все значения,
хранящиеся в источниках привязки, являются строками. В какие типы
можно преобразовать строку? Связыватель модели преобразует прак -
тически любой примитивный тип .NET, такой как int, float, decimal
(и,  очевидно, string), а  также все, что имеет преобразователь типов,

216 Глава 6 Модель привязки: получение и проверка пользовательского ввода
TypeConverter1. Есть несколько других особых случаев, когда можно вы-
полнить преобразование из строки, например Type, но, рассматривая
это только как примитивы, вы далеко продвинетесь!
6.2.2 Привязка сложных типов
Если кажется, что возможность привязывать только простые примитив-
ные типы несколько ограничивает вас, то вы правы! К счастью, это не от -
носится к связывателю моделей. Хотя он может только преобразовывать
строки непосредственно в эти примитивные типы, он также может при-
вязывать сложные типы, просматривая все свойства, предоставляемые
вашими моделями привязки.
Вас это не осчастливило? Тогда посмотрим, как вам пришлось бы
создавать обработчики страниц, если бы простые типы были вашим
единственным вариантом. Представьте себе, что пользователь вашего
приложения конвертера валют дошел до страницы оформления заказа
и собирается обменять валюту. Здорово! Все, что вам нужно сейчас, – это
взять его имя, адрес электронной почты и номер телефона. К сожалению,
ваш метод обработчика страницы должен выглядеть как-то так:
public IActionResult OnPost(string firstName, string lastName, string
phoneNumber, string email)
Фу! Сейчас четыре параметра могут показаться не такими уж плохи-
ми, но что произойдет, когда требования изменятся и вам понадобятся
другие сведения? Сигнатура метода продолжит расти. Привязка модели
довольно успешно привязывает значения, но это не совсем чистый код.
Использование [BindProperty] тоже не спасает – вам все равно придется
загромождать PageModel множеством свойств и атрибутов!
упрощение  параМетров  Метода  привязкой  к сложныМ  объектаМ
Обычным паттерном для любого кода C#, когда у вас много параметров
метода, является извлечение класса, который инкапсулирует данные,
необходимые методу. Если необходимо добавить дополнительные па-
раметры, то можно добавить в этот класс новое свойство. Класс станет
вашей моделью привязки, которая может выглядеть примерно так.
Листинг 6.4 Модель привязки для сбора сведений о пользователе
public class UserBindingModel
{
public string FirstName { get; set; }
public string LastName { get; set; }
public string Email { get; set; }
1 TypeConverter можно найти в  пакете System.ComponentModel.TypeConverter.
Подробнее о них можно прочитать в документации Microsoft «Преобразова-
ние типов в .NET»: http://mng.bz/A0GK.

217 От запроса к модели: делаем запрос полезным
public string PhoneNumber { get; set; }
}
С помощью этой модели вы теперь можете обновить сигнатуру метода
обработчика страницы:
public IActionResult OnPost(UserBindingModel user)
Или, в  качестве альтернативы, используя [BindProperty], создайте
свойство для PageModel:
[BindProperty]
public UserBindingModel User { get; set; }
Теперь можно еще больше упростить сигнатуру обработчика стра-
ницы:
public IActionResult OnPost()
Функционально связыватель модели несколько иначе трактует этот
новый сложный тип. Вместо того чтобы искать параметры со значением,
которое соответствует имени параметра (user или User для свойства), он
создает новый экземпляр модели, используя new UserBindingModel().
ПРИМЕЧАНИЕ  Не обязательно использовать отдельные классы
для своих методов; все зависит от ваших требований. Если обра-
ботчику страницы требуется только одно целое число, то имеет
смысл выполнить привязку к простому параметру.
После этого связыватель модели перебирает все свойства вашей моде-
ли привязки, такие как FirstName и  LastName в листинге 6.4. Для каждого
из этих свойств он обращается к коллекции источников привязки и пы-
тается найти совпадающую пару «имя-значение». Если он ее находит, то
задает значение свойства и идет дальше.
СОВЕТ  Хотя имя модели в этом примере не является обязатель-
ным, связыватель модели также будет искать свойства с  префик -
сом имени свойства, такие как user.FirstName и  user.LastName для
свойства User. Вы можете использовать этот подход, когда у вас есть
несколько сложных параметров для обработчика страницы или не-
сколько сложных свойств [BindProperty]. В целом для простоты по
возможности следует избегать такой ситуации. Как и для остальных
случаев привязки моделей, регистр префикса значения не имеет.
После того как все свойства, которые можно привязать, будут зада-
ны, модель передается обработчику страницы (или задается свойство
[BindProperty]), а обработчик выполняется как обычно. С этого момента
поведение идентично ситуации, когда у вас много отдельных парамет -
ров, – вы получите те же значения, которые были заданы в модели при-
вязки, но код будет чище, и с ним будет легче работать.

218 Глава 6 Модель привязки: получение и проверка пользовательского ввода
СОВЕТ  Чтобы класс был привязан к модели, он должен иметь от -
крытый конструктор по умолчанию. Привязывать можно только те
свойства, которые являются открытыми и доступными для записи.
С помощью этой техники можно привязать сложные иерархические
модели, свойства которых сами	по	себе являются сложными моделями.
Пока каждое свойство предоставляет тип, который может быть привязан
к модели, связыватель может с легкостью совершить по нему обход.
привязка  коллекций  и словарей
Помимо обычных настраиваемых классов и примитивов, можно выпол-
нять привязку к коллекциям, спискам и словарям. Представьте, что у вас
есть страница, на которой пользователь выбрал все валюты, которые его
интересуют; их котировки можно отобразить так, как показано на рис. 6.5.
Рис. 6.5 Список выбора валют в приложении конвертера отправит список
выбранных валют в приложение. Привязка модели может привязать выбранные
валюты и настроить представление, чтобы пользователь видел эквивалентный курс
Для этого можно создать обработчик страницы, который принимает
тип List <string>:
public void OnPost(List<string> currencies);
Затем можно отправить данные POST в этот метод, предоставив зна-
чения в нескольких разных форматах:
currencies [index], где currencies – это имя параметра для привяз-
ки, а index – индекс элемента для привязки, например currencies[0
]=GBP&currencies[1]=USD;
[index] – если вы выполняете привязку только к одному списку (как
в этом примере), то имя параметра можно не указывать, например
# [0]=GBP&[1]=USD;

219 От запроса к модели: делаем запрос полезным
currencies – вы также можете опустить index и отправить curren-
cies в качестве ключа для каждого значения, например currencies=
GBP&currencies=USD.
Значения ключей могут поступать из значений маршрута и запроса,
но гораздо чаще их отправляют через форму, используя метод POST.
Словари могут использовать аналогичную привязку, где ключ словаря
заменяет индекс как при именовании параметра, так и при его опу -
щении.
Если все это кажется немного запутанным, не волнуйтесь. Если вы
создаете традиционное веб-приложение и  используете представления
Razor для генерации HTML-кода, фреймворк позаботится о  создании
правильных имен за вас. Как вы увидите в главе 8, представление Razor
гарантирует, что любые данные формы, которые вы отправляете, будут
сгенерированы в правильном формате.
привязка  заГрузки  файлов  с поМощью  iFoRMFiLe
Распространенной особенностью многих веб-сайтов является возмож -
ность загружать файлы. Это может быть относительно нечастое действие,
например загрузка пользователем изображения для своего профиля
в Stack Overflow, или быть неотъемлемой частью приложения, например
загрузка фотографий на Facebook.
Разрешить пользователям загружать файлы в ваше приложение
Загрузка файлов на веб-сайты – довольно распространенное действие, но
вы должны внимательно подумать, нужна ли вашему приложению такая воз-
можность. Когда пользователи могут загружать файлы, подобная возмож -
ность таит в себе опасность.
Вы должны быть осторожны, относясь к входящим файлам как к потенциаль-
но вредоносным: не доверяйте указанному имени файла, позаботьтесь о за-
гружаемых файлах большого размера и не позволяйте файлам выполняться
на вашем сервере.
Файлы также вызывают вопросы относительно того, где следует хранить дан-
ные, – должны ли они находиться в базе данных, в файловой системе или
в каком-либо другом хранилище? Ни на один из этих вопросов нет одно-
значного ответа, и  следует хорошенько подумать о  последствиях выбора.
А еще лучше, если можно этого избежать, не позволяйте пользователям за-
гружать файлы!
ASP .NET Core поддерживает загрузку файлов, предоставляя интерфейс
IFormFile. Можно использовать этот интерфейс в качестве модели при-
вязки как параметр метода для своего обработчика страницы или с по-
мощью [BindProperty], и он будет заполнен деталями загрузки файла:
public void OnPost(IFormFile file);

220 Глава 6 Модель привязки: получение и проверка пользовательского ввода
Также можно использовать IEnumerable <IFormFile>, если нужно при-
нять несколько файлов:
public void OnPost(IEnumerable<IFormFile> file);
Объект IFormFile предоставляет несколько свойств и служебных мето-
дов для чтения содержимого загружаемого файла, некоторые из которых
показаны здесь:
public interface IFormFile
{
string ContentType { get; }
long Length { get; }
string FileName { get; }
Stream OpenReadStream();
}
Как видите, этот интерфейс предоставляет свойство FileName, которое
возвращает имя файла, с которым был загружен файл. Но вы ведь знаете,
что пользователям нельзя доверять, верно? Никогда не используйте имя
файла непосредственно в  коде – всегда создавайте новое имя, прежде
чем сохранить файл.
ВНИМАНИЕ!  Никогда не используйте отправленные имена фай-
лов в своем коде. Пользователи могут использовать их для атаки
на ваш сайт и доступа к файлам, к которым у них не должно быть
доступа.
Объект IFormFile прекрасно подходит, если пользователи собирают -
ся загружать только небольшие файлы. Когда ваш метод принимает эк -
земпляр IFormFile, все содержимое файла буферизируется в памяти и на
диске до того, как вы его получите. Затем можно использовать метод
OpenReadStream для считывания данных.
Если пользователи размещают на вашем веб-сайте большие файлы,
вы можете обнаружить, что у вас начинает не хватать места в памяти или
на диске, поскольку буферизуется каждый файл. В этом случае вам мо-
жет потребоваться передавать файлы напрямую, чтобы не сохранять все
данные сразу. К сожалению, в отличие от подхода с привязкой модели,
потоковая передача больших файлов может быть сложной и подвержена
ошибкам. Эта тема выходит за рамки книги. Дополнительные сведения
см.	в статье «Загрузка файлов в ASP .NET Core» на странице http://mng.bz/
# SH7X.
СОВЕТ  Не используйте интерфейс IFormFile для обработки за-
грузки больших файлов, поскольку из-за этого могут возникнуть
проблемы с производительностью. Помните: нельзя полагаться на
то, что пользователи не будут загружать файлы большого размера,
поэтому еще лучше полностью избегать загрузки файлов!

221 От запроса к модели: делаем запрос полезным
Для подавляющего большинства страниц Razor конфигурация при-
вязки модели по умолчанию для простых и сложных типов работает от -
лично, но вы можете столкнуться с ситуациями, когда вам потребуется
больше контроля. К счастью, это вполне возможно, и при необходимо-
сти можно полностью переопределить процесс, заменив используемые
внут ри фреймворка связыватели модели.
Однако такой уровень настройки требуется редко – я обнаружил, что
вместо этого чаще всего нужно указать, какой источник	 привязки следует
использовать для модели привязки страницы.
6.2.3 Выбор источника привязки
Как вы уже видели, по умолчанию связыватель модели ASP .NET Core бу -
дет пытаться привязать ваши модели привязки из трех разных источни-
ков: данные формы, данные маршрута и строка запроса.
Иногда вам может потребоваться специально объявить, к какому ис -
точнику привязки нужно выполнить привязку. В  других случаях этих
трех источников вообще будет недостаточно. Наиболее распространен-
ные сценарии  – когда нужно привязать параметр метода к  значению
заголовка запроса или когда тело запроса содержит данные в формате
JSON, которые вы хотите привязать к параметру. В этих случаях можно
декорировать свои модели привязки атрибутами, которые говорят, от -
куда выполнять привязку, как показано в следующем листинге.
Листинг 6.5 Выбор источника привязки для привязки модели
public class PhotosModel: PageModel
{
public void OnPost(
[FromHeader] string userId
[FromBody] List<Photo> photos)
{
/* Реализация метода */
}
}
В этом примере обработчик страницы обновляет коллекцию фотогра-
фий с  по мощью идентификатора пользователя. Здесь есть параметры
метода для идентификатора пользователя, которого нужно отметить на
фотографиях, userId и список объектов Photo для пометки, photos.
Вместо того чтобы выполнить привязку этих параметров метода с по-
мощью стандартных источников привязки, я  добавил к  каждому па-
раметру атрибуты, указывая на источник привязки, который будет ис -
пользоваться. Атрибут [FromHeader] применен к  параметру userId. Так
мы сообщаем связывателю модели привязать значение к значению за-
головка HTTP-запроса, userId.
Мы также привязываем список фотографий к  телу HTTP-запроса
с по мощью атрибута [FromBody]. Данные в формате JSON будут прочи-UserId будет привязан
к HTTP-заголовку в запросе.
Список объектов photo будет привязан
к телу запроса, обычно в формате JSON.

222 Глава 6 Модель привязки: получение и проверка пользовательского ввода
таны из тела запроса, и будет выполнена привязка к параметру метода
List<Photo>.
ВНИМАНИЕ!  Разработчикам, знакомым с  предыдущей верси-
ей ASP .NET, следует обратить внимание на то, что при привязке
к запросам в формате JSON в Razor Pages явно требуется атрибут
[FromBody]. Это отличается от предыдущего поведения ASP .NET,
где атрибут не требовался.
Вы не ограничены привязкой данных JSON из тела запроса – можно
использовать и другие форматы, в зависимости от того, какие формате-
ры ввода вы настраиваете для работы с фреймворком. По умолчанию на-
строен только форматер ввода JSON. Вы увидите, как добавить форматер
XML, в главе 9, когда мы будем обсуждать веб-API.
Можно использовать несколько разных атрибутов, чтобы переопреде-
лить значения по умолчанию и указать источник привязки для каждой
модели привязки (или каждого свойства модели привязки):
[FromHeader] – привязка к значению заголовка;
[FromQuery] – привязка к значению строки запроса;
[FromRoute] – привязка к параметрам маршрута;
[FromForm] – привязка к данным формы, размещенным в теле за-
проса;
[FromBody] – привязка к содержимому тела запроса.
Вы можете применить каждый из них к любому количеству парамет -
ров или свойств метода обработчика, как вы уже видели в листинге 6.5,
за исключением атрибута [FromBody] – этим атрибутом можно декори-
ровать только одно значение. Кроме того, при отправке данных формы
в теле запроса атрибуты [FromBody] и  [FromForm] фактически являются
взаимоисключающими.
СОВЕТ  Только один параметр может использовать атрибут [From-
Body]. Этот атрибут будет использовать данные тела входящего за-
проса, поскольку тело HTTP-запроса можно безопасно прочитать
только один раз.
Помимо этих атрибутов для указания источников привязки, есть еще
несколько атрибутов для дальнейшей настройки процесса привязки:
[BindNever] – связыватель модели полностью пропустит этот пара-
метр1;
[BindRequired] – если параметр не был указан или был пустым, свя-
зыватель добавит ошибку валидации модели;
[FromServices] – используется, чтобы указать, что параметр должен
быть предоставлен с  применением внедрения зависимостей (см.
главу 10 для получения подробной информации).
1 Можно использовать атрибут [BindNever] для предотвращения массового на-
значения, как описано в двух постах моего блога: http://mng.bz/QvfG и  http://
mng.bz/Vd90.

223 Обработка пользовательского ввода с помощью валидации модели
Кроме того, у вас есть атрибут [ModelBinder], который переводит вас
в «режим Бога», что касается привязки модели. С помощью этого атрибу -
та можно указать точный источник привязки, переопределить имя пара-
метра для привязки и указать тип привязки, который нужно выполнить.
Вы вряд ли будете часто его использовать.
Объединив все эти атрибуты, вы обнаружите, что можно настроить
привязку модели для привязки практически ко всем данным запроса,
которые хочет использовать обработчик страницы. Однако в целом, ве-
роятно, вам редко придется их использовать; в большинстве случаев вам
подойдут значения по умолчанию.
На этом мы подошли к концу раздела, посвященного привязке моде-
ли. Если все прошло хорошо, ваш обработчик страницы должен иметь
доступ к заполненной модели привязки и быть готовым выполнить ло-
гику. Пора обработать запрос, верно? Беспокоиться не о чем?
Не так быстро! Откуда вы знаете, что полученные вами данные валид-
ны? Что вам не были отправлены вредоносные данные при попытке ата-
ки с использованием SQL-инъекции или номер телефона, полный букв?
Связыватель относительно слепо присваивает значения, отправлен-
ные в запросе, который вы с радостью собираетесь включить в свои ме-
тоды? Что остановит гнусного маленького Джимми от отправки вредо-
носных значений в ваше приложение?
За исключением элементарных мер предосторожности, ничто его не
остановит, поэтому важно всегда проверять входящие данные. ASP .NET
Core предоставляет возможность сделать это декларативным способом
из коробки, что является основной темой второй половины этой главы.
6.3 Обработка пользовательского ввода
с помощью валидации модели
В этом разделе мы обсудим:
что такое валидация модели и зачем она нужна;
использование атрибутов DataAnnotations для описания ожидае-
мых данных;
как проверить свои модели привязки в обработчиках страниц.
Валидация модели в целом – довольно большая тема, и ее необходимо
будет учитывать в каждом создаваемом вами приложении. ASP .NET Core
позволяет относительно легко добавить валидацию модели в ваши при-
ложения, сделав ее неотъемлемой частью фреймворка.
6.3.1 Необходимость валидации модели
Данные могут поступать из множества различных источников в вашем
веб-приложении – вы можете загружать их из файлов, читать из базы
данных или принимать значения, которые пользователь вводит в форму
в запросах. Хотя вы, возможно, склонны полагать, что данные, которые

224 Глава 6 Модель привязки: получение и проверка пользовательского ввода
находятся на вашем сервере, уже валидные (хотя иногда это опасное
предположение!), вам	 определенно не следует доверять данным, отправ-
ляемым как часть запроса.
Валидация модели выполняется во фреймворке Razor Pages после
привязки модели, но до выполнения обработчика страницы, как вы ви-
дели на рис. 6.2. На рис. 6.6 показано более компактное представление
того, где валидация модели вписывается в этот процесс, демонстрируя,
как выполняется привязка и проверка запроса к странице оформления
заказа, которая запрашивает личные данные пользователя.
1.  Получаем запрос для URL/checkout/saveuser,
и промежуточное ПО маршрутизации выбирает
конечную точку страницы Razor SaveUser в папке
Checkout
2.  Фреймворк создает UserBindingModel из деталей,
предоставленных в запросе
3.  UserBindingModel проверяется в соответствии
с атрибутами DataAnnotations в свойствах
4.  UserBindingModel и проверка ModelState
задаются на странице SaveUser, и выполняется
обработчик страницыЗапрос
Привязка модели
Привязка модели Состояние моделиПривязка модели
Валидация модели
Обработчик страницы
Страница Razor
Рис. 6.6 Валидация модели происходит после привязки, но до выполнения
обработчика страницы. Обработчик страницы выполняется независимо от того,
прошла проверка успешно или нет
Нужно	всегда	проверять	 данные,	предоставляемые	 пользователями,
прежде	чем	использовать	 их	в своих	методах. Вы не знаете, что вам от -
правил браузер. Классический пример с «Таблицами маленького Бобби»
(https://xkcd.com/327/) подчеркивает необходимость всегда проверять
все данные, отправляемые пользователем.
Однако валидация модели предназначена не только для проверки
угроз безопасности; необходимо также выполнять проверку на предмет
выявления невредоносных ошибок:
данные должны быть отформатированы правильно (поля адресов
электронной почты имеют допустимый формат);
возможно, что числа должны идти в  определенном диапазоне
(нельзя купить –1 копию этой книги!);
некоторые значения могут быть обязательными, а другие – необя-
зательными (для профиля может потребоваться имя, но номер те-
лефона указывать не обязательно);

225 Обработка пользовательского ввода с помощью валидации модели
значения должны соответствовать вашим бизнес-требованиям (нель-
зя конвертировать валюту в ту же валюту, ее нужно конвертировать
в другую).
Может показаться, что с некоторыми из них можно легко справиться
в браузере. Например, если пользователь выбирает валюту для конверта-
ции, не позволяйте ему выбирать ту же валюту; и все мы видели сообще-
ния «введите действующий адрес электронной почты».
К сожалению, хотя эта валидация	 на	стороне	 клиента полезна для
пользователей, поскольку дает им мгновенный отклик, на нее никогда
нельзя полагаться, так как эти средства защиты браузера всегда можно
обойти. Всегда необходимо проверять данные по мере их поступления
в ваше приложение, используя валидацию	на	стороне	сервера.
ВНИМАНИЕ!  Всегда проверяйте данные, введенные пользовате-
лем на стороне сервера.
Если вам это кажется лишним, например вам нужно будет дублиро-
вать логику и код, тогда боюсь, что вы правы. Это один из прискорбных
аспектов веб-разработки; дублирование – необходимое зло. К счастью,
ASP .NET Core предоставляет несколько функций, которые могут попро-
бовать уменьшить это бремя.
СОВЕТ  Blazor, новый фреймворк C# для создания одностранич-
ных приложений, обещает решить некоторые из этих проблем. Для
получения дополнительной информации	 см. https://dotnet.micro-
soft.com/apps/aspnet/web-apps/Blazor и  книгу «Blazor	 в действии»
Криса Сейнти.
Если бы вам пришлось каждый раз писать новый код валидации для
каждого приложения, это было бы утомительно и, вероятно, привело бы
к появлению ошибок. К счастью, можно значительно упростить его, ис -
пользуя набор атрибутов, предоставляемых .NET Core и .NET 5.0.
6.3.2 Использование атрибутов DataAnnotations
для валидации
Атрибуты валидации, или, точнее, атрибуты DataAnnotations, позволя-
ют указать правила, которым должна соответствовать ваша модель при-
вязки. Они предоставляют метаданные о вашей модели, описывая тип
данных, которые должна содержать модель привязки, в отличие от самих
данных.
ОПРЕДЕЛЕНИЕ  Метаданные описывают другие данные, опреде-
ляя правила и характеристики, которых следует придерживаться
данным.

226 Глава 6 Модель привязки: получение и проверка пользовательского ввода
Можно применять атрибуты DataAnnotations непосредственно к сво-
им моделям привязки, чтобы указать допустимый тип данных. Это по-
зволяет, например, проверить, заполнены ли обязательные поля, на-
ходятся ли числа в  правильном диапазоне и  что в  полях электронной
почты указаны допустимые адреса.
В качестве примера рассмотрим страницу оформления заказа для ва-
шего приложения конвертера валют. Вам необходимо собрать сведения
о  пользователе, прежде чем вы сможете продолжить, поэтому вы по-
просите его указать свое имя, адрес электронной почты и, при желании,
номер телефона. В следующем листинге показана UserBindingModel, де -
корированная атрибутами валидации, которые представляют правила
проверки для модели. Это расширенный вариант примера, который вы
видели в листинге 6.4.
Листинг 6.6  Добавление DataAnnotations в модель привязки
для предоставления метаданных
public class UserBindingModel
{
[Required]
[StringLength(100)]
[Display(Name = "Your name")]
public string FirstName { get; set; }
[Required]
[StringLength(100)]
[Display(Name = "Last name")]
public string LastName { get; set; }
[Required]
[EmailAddress]
public string Email { get; set; }
[Phone]
[Display(Name = "Phone number")]
public string PhoneNumber { get; set; }
}
Внезапно ваша модель привязки теперь содержит огромное количест -
во информации, хотя раньше она была довольно скудной. Например, вы
указали, что нужно всегда предоставлять свойство FirstName, и его мак -
симальная длина должна составлять 100 символов, и  что при его упо-
минании (например, в сообщениях об ошибках) оно должно называться
"Your name", а не "FirstName".
Самое замечательное в этих атрибутах то, что они четко декларируют
ожидаемое состояние модели. Глядя на эти атрибуты, вы знаете, что бу -
дут или должны содержать свойства. Они также предоставляют хуки для Значения,
отмеченные
как Required,
должны быть
предоставлены.StringLengthAttribute задает
максимальную длину свойства.
Настраивает имя, используемое
для описания свойства.
StringLengthAttribute задает максимальную длину свойства.
Настраивает имя, используемое
для описания свойства.
Проверяет, является ли значение Email
допустимым адресом электронной почты.

227 Обработка пользовательского ввода с помощью валидации модели
фреймворка ASP .NET Core, чтобы проверить, что набор данных в модели
во время привязки является валидным, как вы вскоре увидите.
У вас есть множество атрибутов на выбор при применении DataAn-
notations к  вашим моделям. Я  перечислил здесь некоторые распро-
страненные атрибуты, но можно найти и другие в  пространстве имен
System.ComponentModel.DataAnnotations. Для получения более полного
списка рекомендую использовать IntelliSense в Visual Studio или Visual
Studio Code, или вы всегда можете посмотреть исходный код напрямую
на GitHub (http://mng.bz/5jxZ).
[CreditCard] – проверяет, что свойство имеет допустимый формат
номера кредитной карты.
[EmailAddress] – проверяет, что свойство имеет допустимый фор-
мат адреса электронной почты.
[StringLength(max)] – проверяет, что строка имеет не более макси-
мального количества символов.
[MinLength(min)] – проверяет, что коллекция имеет как минимум
минимальное количество элементов.
[Phone]  – проверяет, что свойство имеет допустимый формат но-
мера телефона.
[Range(min, max)] – проверяет, что свойство имеет значение от ми-
нимального до максимального.
[RegularExpression(regex)] – проверяет, соответствует ли свойство
шаблону регулярного выражения.
[Url] – проверяет, что свойство имеет допустимый формат URL.
[Required]  – указывает, что свойство не должно иметь значение
null.
[Compare] – позволяет подтвердить, что два свойства имеют одина-
ковое значение (например, Email и ConfirmEmail).
ВНИМАНИЕ!  [EmailAddress] и другие атрибуты только проверя-
ют, что формат	 значения является допустимым. Они не проверя-
ют существование адреса электронной почты1.
Атрибуты DataAnnotations не являются новшеством – они были частью
.NET Framework начиная с версии 3.5 – и в ASP .NET Core они используют -
ся почти так же, как и в предыдущей версии ASP .NET.
Их также применяют и для других целей, не только для валидации мо-
делей. Entity Framework Core (среди прочего) использует атрибуты Data-
Annotations для определения типов столбцов и правил, которые будут
применяться при создании таблиц базы данных из классов C#. Подроб-
нее о Entity Framework Core можно узнать в главе 12 и в книге Джона П.
Смита «Entity	 Framework	 Core	в действии», второе издание (Manning,
2021).
1 Атрибут номера телефона не очень ограничивает допустимые форматы. Что-
бы увидеть пример и узнать, как более тщательно выполнить валидацию но-
мера телефона, см. пост в блоге Twilio: http://mng.bz/xmZe.

228 Глава 6 Модель привязки: получение и проверка пользовательского ввода
Если атрибуты DataAnnotation, предоставляемые из коробки, не охва-
тывают все, что вам нужно, также можно написать специальные атри-
буты путем наследования от базового класса ValidationAttribute. В гла-
ве  19 вы узнаете, как создать специальный атрибут для приложения
конвертера валют.
В качестве альтернативы, если вы не являетесь поклонником подхода,
основанного на использовании атрибутов, то ASP .NET Core достаточно
гибок, чтобы вы могли полностью заменить инфраструктуру валидации
предпочтительной техникой. Например, если хотите, то вместо атри-
бутов DataAnnotations можно использовать популярную библиотеку
FluentValidation (https://github.com/JeremySkinner/FluentValidation). Вы
увидите, как это сделать, в главе 20.
СОВЕТ  DataAnnotations хорошо подходят для изолированной ва-
лидации ввода, но не очень полезны при проверке бизнес-правил.
Скорее всего, вам потребуется выполнить эту проверку за преде-
лами DataAnnotations.
Какой бы подход вы ни использовали, важно помнить, что эти методы
сами по себе не защищают ваше приложение. Фреймворк Razor Pages
обеспечивает выполнение проверки, но ничего не делает автоматиче-
ски, если валидация модели потерпела неудачу. В  следующем разделе
мы рассмотрим, как проверить результат валидации на сервере и что де-
лать, если проверка не удалась.
6.3.3 Валидация модели на сервере в целях безопасности
Валидация модели привязки происходит до выполнения обработчика
страницы, но обратите внимание, что обработчик всегда выполняется,
независимо от того, завершилась валидация успешно или была неудач-
ной. Обработчик страницы должен проверить результат.
ПРИМЕЧАНИЕ  Валидация модели происходит автоматически,
но обработка ошибок проверки является обязанностью обработ -
чика страницы.
Razor Pages сохраняет выходные данные попытки валидации модели
в свойстве PageModel под названием ModelState. Это свойство представ-
ляет собой объект ModelStateDictionary, содержащий список всех оши-
бок валидации, возникших после привязки модели, а также некоторые
служебные свойства для работы с ним.
В качестве примера в следующем листинге показан обработчик OnPost
для страницы Checkout.cshtml. Свойство Input помечено для привязки
и  использует тип UserBindingModel, показанный ранее в  листинге  6.6.
Этот обработчик страницы ничего не делает с  данными, но ключевой
вывод здесь – шаблон проверки ModelState в начале метода.

229 Обработка пользовательского ввода с помощью валидации модели
Листинг 6.7  Проверка состояния модели для просмотра результата
валидации
public class CheckoutModel : PageModel
{
[BindProperty]
public UserBindingModel Input { get; set; }
public IActionResult OnPost()
{
if (!ModelState.IsValid)
{
return Page();
}
/* Сохранение в базу данных, обновление пользователя
и возврат сообщения об успехе */
return RedirectToPage("Success");
}
}
Если свойство ModelState указывает, что произошла ошибка, тотчас
же вызывается вспомогательный метод Page. Он возвращает объект
PageResult, который в  конечном итоге сгенерирует HTML-код, чтобы
вернуть его пользователю, как вы видели в главе 4. Представление ис -
пользует (недопустимые) значения, предоставленные в  свойстве Input
для повторного заполнения формы при ее отображении, как показано на
рис. 6.7. Кроме того, полезные сообщения для пользователя добавляются
автоматически с использованием ошибок валидации в свойстве Model-
State.
ПРИМЕЧАНИЕ  Сообщения об ошибках, отображаемые в форме,
являются значениями по умолчанию для каждого атрибута вали-
дации. Вы можете настроить сообщение, задав свойство ErrorMes-
sage для любого из атрибутов. Например, можно настроить атри-
бут [Required], используя [Required(ErrorMessage="Required")].
Если запрос успешен, обработчик страницы возвращает объект Redi-
rectToPageResult (используя вспомогательный метод RedirectToPage()),
который перенаправляет пользователя на страницу Success.cshtml. Дан-
ный шаблон возврата ответа перенаправления после успешного вызова
POST называется паттерн POST-REDIRECT-GET.Свойство ModelState доступно
в базовом классе PageModel.
Свойство Input содержит данные,
привязанные к модели.
Модель привязки валидируется перед
выполнением обработчика страницы.
Если были ошибки валидации,
IsValid будет ложным.
Валидация не удалась, поэтому повторно отобразите
форму с ошибками и завершите метод раньше.
Валидация прошла, поэтому можно
безопасно использовать данные,
представленные в модели.

230 Глава 6 Модель привязки: получение и проверка пользовательского ввода
Рис. 6.7  Если валидация модели завершилась неудачно, можно повторно
отобразить форму, чтобы показать пользователю ошибки ModelState. Обратите
внимание, что поле «Ваше имя» не имеет ассоциированных ошибок валидации,
в отличие от других полей
# POST-REDIRECT-GET
POST-REDIRECT-GET – это паттерн веб-разработки, который не дает пользо-
вателю случайно отправить одни и те же данные через форму несколько раз.
Пользователи обычно отправляют данные через форму, используя стандарт -
ный механизм браузера POST, отправляющий данные на сервер. Например,
это обычный способ для получения платежа.
Если сервер использует простой подход и в ответ выдает сообщение с кодом
200 OK и некий HTML-код, пользователь по-прежнему будет использовать

231 Обработка пользовательского ввода с помощью валидации модели
тот же URL-адрес. Если пользователь затем обновит окно браузера, то отпра-
вит дополнительный запрос с по мощью метода POST на сервер, потенциаль-
но совершая еще один платеж! У браузеров есть механизмы, позволяющие
избежать этого, например как показано на следующем рисунке, но такая си-
туация нежелательна.
При обновлении окна браузера после запроса с методом POST
пользователь видит сообщение с предупреждением
Паттерн POST-REDIRECT-GET определяет, что в ответ на успешный запрос
с по мощью метода POST нужно вернуть ответ REDIRECT на новый URL-адрес,
после которого браузер выполнит запрос, используя метод GET для нового
URL-адреса. Если пользователь обновит свой браузер, то будет обновлять
последний вызов GET для нового URL-адреса. Никаких дополнительных за-
просов с методом POST не производится, поэтому не должно быть никаких
дополнительных платежей или побочных эффектов.
Этого легко добиться в приложениях ASP.NET Core MVC, используя паттерн,
показанный в листинге 6.7. Возвращая объект RedirectToPageResult после
успешного выполнения POST, ваше приложение будет в безопасности, если
пользователь обновит страницу в своем браузере.
Вам, наверное, интересно, почему ASP .NET Core не обрабатывает не-
действительные запросы автоматически – если валидация не удалась,
а результат у вас есть, почему обработчик страницы вообще выполняет -
ся? Нет ли риска, что вы можете забыть проверить результат?
Это правда, и в некоторых случаях лучше всего сделать автоматиче-
скую генерацию проверки и ответа. Фактически это именно тот подход,
который мы будем использовать для веб-API в главе 9.
Однако для приложений Razor Pages обычно требуется сгенерировать
ответ в виде HTML-кода, даже если валидация не удалась. Это позволяет
пользователю увидеть проблему и потенциально исправить ее. Сделать
это автоматическим намного сложнее.

232 Глава 6 Модель привязки: получение и проверка пользовательского ввода
Например, вы можете обнаружить, что вам нужно загрузить дополни-
тельные данные, прежде чем вы сможете повторно отобразить страницу
Razor, например загрузить список доступных валют. С помощью шабло-
на IsValid сделать это проще и яснее. Попытка сделать это автоматиче-
ски, скорее всего, закончится борьбой с пограничными случаями и об-
ходными путями.
Кроме того, за счет явного включения проверки с по мощью IsValid
в обработчики страниц легче контролировать, что происходит в слу -
чае сбоя дополнительных валидаций. Например, если пользователь
пытается обновить продукт, то при валидации с по мощью атрибутов
DataAnnotations вы не узнаете, существует ли продукт с запрошенным
идентификатором, а  узнаете только, есть ли у  идентификатора пра-
вильный	 формат. Перенося проверку в метод обработчика, вы можете
работать с ошибками валидации данных и бизнес-правил одинаковым
образом.
Надеюсь, мне удалось донести до вас, насколько важно проверять
данные, вводимые пользователями в  ASP .NET Core, но на всякий слу -
чай повторю: ВЫПОЛНЯЙТЕ ВАЛИДАЦИЮ! Валидация только на сто-
роне сервера может оставить у пользователей несколько отрицательные
впечатления. Сколько раз вы заполняли онлайн-форму, отправляли ее,
уходили перекусить и, возвращаясь, выясняли, что вы где-то сделали
опечатку и вам придется все переделывать. Не лучше было бы получить
отклик сразу же?
6.3.4 Валидация на стороне клиента для улучшения
пользовательского интерфейса
Можно добавить в приложение валидацию на стороне клиента несколь-
кими способами. В HTML5 существует несколько встроенных режимов
валидации, которые будут использовать многие браузеры. Если открыть
страницу с полем адреса электронной почты и ввести фразу Not an email,
браузер автоматически не даст вам указать недопустимый формат поч-
ты, как показано на рис. 6.8.
Рис. 6.8 По умолчанию современные браузеры автоматически проверяют то,
что вы вводите в поле адреса электронной почты

233 Обработка пользовательского ввода с помощью валидации модели
Ваше приложение не контролирует эту валидацию; она встроена в совре-
менные браузеры с поддержкой HTML51. Есть и альтернативный подход –
выполнить валидацию на стороне клиента, запустив на странице Java Script
и проверяя значения, введенные пользователем перед отправкой формы.
Это наиболее распространенный подход, используемый в Razor Pages.
Я подробно расскажу, как сгенерировать помощники валидации на
стороне клиента, в следующей главе, где вы снова увидите, как атрибуты
DataAnnotations выходят на первый план. Декорируя модель представ-
ления этими атрибутами, вы предоставляете механизму Razor метадан-
ные, необходимые для создания соответствующего HTML-кода.
При таком подходе пользователь сразу видит все ошибки в своей фор-
ме, еще до того, как запрос будет отправлен на сервер, как показано на
рис. 6.9. Это дает гораздо более короткий цикл обратной связи, обеспе-
чивая более качественный пользовательский интерфейс.
Рис. 6.9 При валидации на стороне клиента нажатие кнопки «Отправить»
инициирует проверку, которая будет отображаться в браузере, до того, как запрос
отправится на сервер. Как показано на правой панели, запрос не отправляется
1 Поддержка проверки ограничений HTML5 зависит от браузера. Подробнее
о  доступных ограничениях см. в  документации Mozilla (http://mng.bz/daX3)
и на странице https://caniuse.com/#feat=constraint-validation.

234 Глава 6 Модель привязки: получение и проверка пользовательского ввода
Если вы создаете одностраничное приложение, ответственность за ва-
лидацию данных на стороне клиента перед их отправкой в веб-API ле-
жит на клиентском фреймворке. Веб-API по-прежнему будет проверять
данные, когда они поступают на сервер, но фреймворк отвечает за обес -
печение хорошего взаимодействия с пользователем.
Когда вы используете Razor Pages для генерации HTML-кода, то полу -
чаете бóльшую часть этой валидации бесплатно. Он автоматически на-
страивает валидацию на стороне клиента для большинства встроенных
атрибутов, не требуя дополнительной работы, как вы увидите в главе 7.
К сожалению, если вы использовали специальные атрибуты Validation-
Attributes, по умолчанию они будут выполняться только на сервере;
вам нужно выполнить дополнительное подключение атрибута, чтобы
он также работал и на стороне клиента. Несмотря на это, специальные
атрибуты валидации могут быть полезны при работе с распространен-
ными сценариями проверки в вашем приложении, как вы увидите в гла-
ве 20.
Фреймворк привязки модели в  ASP .NET Core дает множество вари-
антов для настройки страниц Razor: параметры обработчика страницы
или свойства PageModel; одна модель привязки или несколько; варианты
того, где определять классы вашей модели привязки. В следующем раз-
деле я дам несколько советов относительно того, какая настройка стра-
ниц Razor нравится мне.
6.4 Организация моделей привязки в Razor Pages
В этом разделе я даю несколько общих советов по поводу того, как мне
нравится настраивать модели привязки в  Razor Pages. Если вы будете
следовать шаблонам из этого раздела, ваши станицы Razor будут при-
держиваться согласованного макета, чтобы другим было легче понять,
как работает каждая страница в вашем приложении.
ПРИМЕЧАНИЕ  Это сугубо личный совет, поэтому не стесняйтесь
адаптировать его, если найдете аспекты, с которыми вы не соглас -
ны. Важно понять, почему	 я вношу каждое предложение, и прини-
мать его во внимание. В случае необходимости я тоже отклоняюсь
от этих рекомендаций!
Привязка модели в  ASP .NET Core имеет множество эквивалентных
подходов, поэтому «правильного» способа не существует. В следующем
листинге показан пример того, как бы я спроектировал простую стра-
ницу Razor. В нем отображена форма продукта с заданным идентифи-
катором. Страница позволяет редактировать детали с по мощью запроса
POST. Это гораздо более длинный пример, по сравнению с тем, что мы
рассматривали до сих пор, но ниже я выделю важные моменты.

235 Организация моделей привязки в Razor Pages
Листинг 6.8  Проектирование страницы Razor для редактирования
информации о продукте
public class EditProductModel : PageModel
{
private readonly ProductService _productService;
public EditProductModel(ProductService productService)
{
_productService = productService;
}
[BindProperty]
public InputModel Input { get; set; }
public IActionResult OnGet(int id)
{
var product = _productService.GetProduct(id);
Input = new InputModel
{
Name = product.ProductName,
Price = product.SellPrice,
};
return Page();
}
public IActionResult OnPost(int id)
{
if (!ModelState.IsValid)
{
return Page();
}
_productService.UpdateProduct(id, Input.Name, Input.Price);
return RedirectToPage("Index");
}
public class InputModel
{
[Required]
public string Name { get; set; }
[Range(0, int.MaxValue)]
public decimal Price { get; set; }
}
}
На этой странице показана модель PageModel типичной «формы редак -
тирования». Она очень часто встречается во многих бизнес-приложени-
ях среди прочего, и это тот сценарий, для которого прекрасно подходит
Razor Pages. Вы увидите, как создавать HTML-сторону форм, в главе 8. ProductService внедряется
с использованием
внедрения зависимостей
и обеспечивает доступ
к модели приложения.
Одно свойство помечено
атрибутом BindProperty.
Параметр id привязан к модели
из шаблона маршрута для
обработчиков OnGet и OnPost.Загрузка сведений
о продукте
из модели
приложения.Создаем экземпляр InputModel
для редактирования в форме
из сведений о существующем продукте.
Параметр id привязан к модели
из шаблона маршрута для
обработчиков OnGet и OnPost.
Если запрос
оказался
невалидным,
повторно
отображаем форму
без сохранения.Обновляем продукт
в модели приложения
с по мощью
ProductService.Перенаправление на новую страницу
с использованием паттерна POST-REDIRECT-GET.
Определяем InputModel
как вложенный класс
на странице Razor.

236 Глава 6 Модель привязки: получение и проверка пользовательского ввода
ПРИМЕЧАНИЕ  Цель данного примера – только описать подход
к привязке модели. С точки зрения логики	 код излишне упрощен.
Например, здесь не проверяется, существует ли продукт с указан-
ным идентификатором, и нет обработки ошибок.
Эта форма показывает несколько паттернов, связанных с привязкой
модели, которых я  стараюсь придерживаться при создании страниц
Razor:
выполняйте	 привязку	 только	одного	свойства	 с по	мощью	[BindPro-
perty] –	 я предпочитаю, чтобы у меня было только одно свойство,
декорированное [BindProperty] для привязки модели в целом. Ког -
да нужно привязать несколько значений, я создаю отдельный класс
InputModel, где будут храниться значения. Я декорирую это един-
ственное свойство атрибутом [BindProperty]. При декорировании
одного такого свойства сложнее забыть добавить атрибут, а  это
озна чает, что все ваши страницы Razor используют один и тот же
шаб  лон;
определите	 свою	модель	привязки	 как	вложенный	 класс. Я определяю
InputModel как вложенный класс внутри своей страницы Razor. Мо-
дель привязки обычно очень специфична для этой единственной
страницы, поэтому все, над чем вы работаете, будет собрано воеди-
но. Кроме того, я обычно использую именно InputModel в качестве
имени класса для всех своих страниц, что опять же добавляет им
единообразия;
не	используйте	 атрибут	 [BindProperties]. Помимо [BindProperty],
существует атрибут [BindProperties] (обратите внимание на разни-
цу в написании), который можно применять к  PageModel страницы
Razor напрямую. Это приведет к тому, что все свойства в вашей мо-
дели будут привязаны. Это может сделать вас уязвимым для атак
с  по мощью оверпостинга, если вы не будете проявлять осторож -
ность. Я предлагаю вам не использовать атрибут [BindProperties]
и  вместо этого придерживаться привязки одного свойства с  по-
мощью атрибута [BindProperty];
принимайте	 параметры	 маршрута	 в обработчике	 страницы. В слу -
чае с простыми параметрами маршрута, такими как id, передава-
емого в обработчики OnGet и OnPost в листинге 6.8, я добавляю па-
раметры к  самому методу обработчика страницы. Это позволяет
избежать неуклюжего синтаксиса типа Supports Get=true для запро-
сов GET;
всегда	выполняйте	 валидацию	 модели	перед	использованием	 данных.
Я уже говорил это прежде, поэтому повторю снова. Проверяйте кор-
ректность данных, вводимых пользователем.
На этом мы завершаем обзор привязки модели в Razor Pages. Вы ви-
дели, как фреймворк ASP .NET Core использует привязку модели, чтобы
упростить процесс извлечения значений из запроса и превращения их
в обычные .NET-объекты, с которыми можно быстро работать. Наиболее

237 Резюме
важным аспектом этой главы является валидация модели – это распро-
страненная проблема всех веб-приложений, а использование атрибутов
DataAnnotations может облегчить процесс добавления такой валидации
к вашим моделям.
В следующей главе мы продолжим наше путешествие по Razor Pages
и рассмотрим, как создавать представления. В частности, вы узнаете, как
сгенерировать HTML-код в ответ на запрос, используя механизм шабло-
нов Razor.
Резюме
Razor Pages использует три различные модели, каждая из которых от -
вечает за свой аспект запроса. Модель привязки инкапсулирует дан-
ные, отправляемые как часть запроса. Модель приложения представ-
ляет состояние приложения. PageModel  – это дополнительный класс
для страницы Razor, который предоставляет данные, используемые
представлением Razor, чтобы сгенерировать ответ.
Привязка модели извлекает значения из запроса и использует их для
создания объектов .NET, которые обработчик страницы может исполь-
зовать при выполнении.
Любые свойства PageModel, отмеченные атрибутом [BindProperty],
и параметры методов обработчиков страниц будут принимать участие
в привязке модели.
Свойства, декорированные атрибутом [BindProperty], не привязаны
к  запросам GET. Для их привязки нужно использовать [Bind Pro per-
ty(SupportsGet = true)].
По умолчанию существует три источника привязки: значения формы,
переданные с  по мощью метода POST, значения маршрута и  строка
запроса. Связыватель будет опрашивать их по порядку при попытке
привязать ваши модели привязки.
При привязке значений к  моделям имена параметров и  свойств не
чувствительны к регистру.
Вы можете выполнять привязку к  простым типам или к  свойствам
сложных типов.
Чтобы привязать сложные типы, они должны иметь конструктор по
умолчанию и открытые доступные для записи свойства.
Для автоматической привязки простые типы должны уметь конвер-
тироваться из строки, например числа, даты и логические значения.
Коллекции и  словари можно привязать с  по мощью синтаксиса
[index]=value и [key]=value.
Вы можете настроить источник привязки для модели привязки с по-
мощью атрибутов [From*], примененных к методу, например [From-
Header] и [FromBody]. Их можно использовать для привязки к источни-
кам привязки не по умолчанию, таким как заголовки или содержимое
тела в формате JSON.

238 Глава 6 Модель привязки: получение и проверка пользовательского ввода
В отличие от предыдущей версии ASP .NET, атрибут [FromBody] требу -
ется при привязке свойств JSON (ранее это не требовалось).
Валидация модели необходима для выявления угроз безопасности.
Убедитесь, что данные отформатированы правильно, и подтвердите,
что они соответствуют ожидаемым значениям и вашим бизнес-пра-
вилам.
ASP .NET Core предоставляет атрибуты DataAnnotations, позволяющие
декларативно определять ожидаемые значения.
Валидация модели выполняется автоматически после привязки моде-
ли, но вы должны вручную проверить ее результат и действовать соот -
ветствующим образом в обработчике страницы, запрашивая свойство
ModelState.
Валидация модели на стороне клиента обеспечивает более качествен-
ный пользовательский интерфейс, нежели валидация только на сторо-
не сервера, но вы всегда должны использовать валидацию на стороне
сервера.
При валидации на стороне клиента используются Java Script и атрибу -
ты, применяемые к вашим HTML-элементам для проверки значений
формы.

7Визуализация
HTML-кода
с использованием
представлений	Razor
В этой главе:
создание представлений Razor для отображения
HTML-кода пользователем;
использование C# и синтаксиса разметки Razor
для динамической генерации HTML-кода;
повторное использование общего кода с макетами
и частичными представлениями.
Легко запутаться в терминах, используемых в Razor Pages, – PageModel,
обработчики страниц, представления Razor, – тем более что одни терми-
ны описывают конкретные функции, а другие – паттерны и концепции.
Мы подробно обсудили все эти термины в предыдущих главах, но важно,
чтобы вы четко понимали:
Razor	Pages – обычно Razor Pages обозначает парадигму на основе
страниц, которая сочетает в себе маршрутизацию, привязку модели
и генерацию HTML-кода с использованием представлений Razor;
страница	 Razor – представляет одну страницу или «конечную точ-
ку». Обычно она состоит из двух файлов: файла с  расширением
.cshtml, содержащего представление Razor, и файла с расширением
.cshtml.cs, содержащего PageModel;

240 Глава 7 Визуализация HTML-кода с использованием представлений Razor
PageModel – PageModel страницы Razor – это то место, где происхо-
дит бóльшая часть действий. Здесь вы определяете модели привяз-
ки для страницы, которая извлекает данные из входящего запроса,
а также определяете обработчики страницы;
обработчик	 страницы – каждая страница Razor обычно обрабатыва-
ет один маршрут, но может обрабатывать несколько HTTP-методов,
таких как GET и POST. Каждый обработчик страницы обычно обра-
батывает один HTTP-метод;
представление	 Razor – представления Razor (также называемые шаб-
лонами Razor) используются для генерации HTML-кода. Обычно они
используются на заключительном этапе страницы Razor для генера-
ции ответа в виде HTML-кода, который будет отправлен пользователю.
В предыдущих четырех главах мы рассмотрели все разделы Razor
Pages, включая паттерн проектирования MVC, PageModel страницы Ra-
zor, обработчики страниц, маршрутизацию и модели привязки. В этой
главе разбирается последняя часть паттерна MVC – использование пред-
ставления для генерации HTML-кода, который доставляется в  браузер
пользователя.
В ASP .NET Core представления обычно создаются с  использованием
синтаксиса разметки Razor (иногда его называют языком шаблонов), ко-
торый использует смесь HTML-кода и кода C# для генерации окончатель-
ного варианта. В этой главе рассказывается о некоторых функциях Razor
и о том, как использовать его для создания шаблонов представлений ва-
шего приложения. Пользователи будут взаимодействовать с вашим при-
ложением двумя способами: будут читать данные, которые отобра жает
ваше приложение, и будут в ответ отправлять ему данные или команды.
Язык Razor содержит ряд конструкций, упрощающих создание приложе-
ний обоих типов.
При отображении данных можно использовать язык Razor, чтобы
с легкостью сочетать статический HTML-код и значения из вашей Page-
Model. Razor может использовать C# в качестве механизма управления,
поэтому добавлять условные элементы и циклы просто – чего нельзя до-
биться с по мощью одного только HTML.
Обычный подход к отправке данных в веб-приложения  – это HTML-фор-
мы. Практически каждое динамическое приложение, которое вы создае-
те, будет использовать формы, а некоторые приложения будут представ-
лять собой только формы! ASP .NET Core и язык шаблонов Razor включают
в себя ряд тег-хелперов, которые упрощают создание HTML-форм.
ПРИМЕЧАНИЕ  В  следующем разделе вы кратко познакомитесь
с тег-хелперами, а более подробно мы рассмотрим их в следующей
главе.
В этой главе мы сосредоточимся в  первую очередь на отображении
данных и  генерации HTML-кода с  по мощью Razor, а  не на создании
форм. Вы увидите, как преобразовать значения из PageModel в HTML-код
и использовать C# для управления сгенерированным выводом. Наконец,

241 Представления: визуализация пользовательского интерфейса
вы узнаете, как извлечь распространенные элементы ваших представле-
ний во вложенные представления, которые называются макеты	 и час-
тичные	 представления, а  также способы их компоновки для создания
окончательной HTML-страницы.
7.1 Представления: визуализация
пользовательского интерфейса
В этом разделе я даю краткое введение в визуализацию HTML-кода с ис -
пользованием представлений Razor. Мы резюмируем все вышесказанное
о паттерне проектирования MVC, используемом Razor Pages, и посмот -
рим, где лучше всего использовать представление. Затем я расскажу, как
синтаксис Razor позволяет смешивать C# и HTML для создания динами-
ческих пользовательских интерфейсов.
Как вы знаете из предыдущих глав, где говорится о паттерне проек -
тирования MVC, обязанность выбирать, что вернуть клиенту, лежит на
обработчике страницы Razor. Например, если вы разрабатываете прило-
жение со списком дел, представьте себе запрос на просмотр конкретного
элемента, как показано на рис. 7.1.
Запрос
Модель
привязки id = 3Привязка модели
Обработчик страницы
Страница Razor
ПредставлениеСервисы
Взаимодействие
с базой данныхМодель
предметной
области
Модель
приложения
PageModel
HTML1.  Получен запрос к URL-адресу /T oDo/View/3.
Компонент маршрутизации сопоставляет запрос
со страницей View в папке T oDo и получает
параметр маршрута id = 32.  Обработчик страницы вызывает
сервисы, составляющие модель
приложения, для получения сведений
об элементе списка дел
3.  Обработчик страницы предоставляет
подробные сведения об элементе списка
дел в качестве свойств PageModel
для использования их в представлении
4.  Представление использует предоставленную
модель для генерации ответа в виде
HTML-кода, который возвращается
пользователю
Рис. 7.1 Обработка запроса элемента списка дел с по мощью Razor Pages. Обработчик
страницы создает данные, необходимые для представления, и предоставляет их как свойства
в PageModel. Представление генерирует HTML-код только на основе предоставленных данных;
ему не нужно знать, откуда они

242 Глава 7 Визуализация HTML-кода с использованием представлений Razor
Типичный запрос следует этапам, показанным на рис. 7.1.
1  Конвейер промежуточного ПО получает запрос, а компонент марш-
рутизации определяет конечную точку для вызова – в данном слу -
чае страницу View в папке ToDo.
2  Связыватель модели (часть фреймворка Razor Pages) использу -
ет запрос для сборки моделей привязки страницы, как вы виде-
ли в  предыдущей главе. Модели привязки задаются как свойства
на странице Razor или передаются методу обработчика страницы
в качестве аргументов при выполнении обработчика. Он проверя-
ет, что вы передали допустимый идентификатор элемента списка
дел, что делает запрос валидным.
3  Предполагая, что все в  порядке, обработчик страницы обращает -
ся к различным сервисам, из которых состоит модель приложения.
Можно загрузить подробную информацию о текущих делах из базы
данных или файловой системы, возвращая их обработчику. В рам-
ках этого процесса либо модель приложения, либо сам обработчик
страницы генерирует значения для передачи их в представление
и задает их в качестве свойств в  PageModel страницы Razor. После
выполнения обработчика страницы PageModel должна содержать
все данные, необходимые для визуализации представления. В этом
примере она содержит подробную информацию о самом элемен-
те списка, но также может содержать и другие данные: сколько дел
у вас осталось, есть ли у вас какие-либо дела на сегодня, ваше имя
пользователя и  т. д. – все, что контролирует создание конечного
пользовательского интерфейса для запроса.
4  Шаблон представления Razor использует PageModel для генерации
окончательного ответа. Он возвращает его пользователю через
конвейер промежуточного ПО.
Общей темой в этом обсуждении MVC является разделение задач, ко-
торое обеспечивает MVC, и то же самое, когда дело касается представ-
лений. Было бы достаточно легко напрямую сгенерировать HTML-код
в модели приложения или в действиях вашего контроллера, но вместо
этого вы делегируете эту ответственность одному-единственному ком-
поненту, представлению.
И даже более того. Вы также будете отделять данные, необходимые для
сборки представления, от процесса его создания с по мощью свойств Pa-
geModel. Эти свойства должны содержать все динамические данные, не-
обходимые представлению для генерации окончательного вывода.
СОВЕТ  Представления не должны вызывать методы PageModel –
как правило, представление должно получать доступ только к дан-
ным, которые уже были собраны и представлены в виде свойств.
Обработчики страниц Razor указывают на то, что представление Razor
следует визуализировать, возвращая объект PageResult (или void), как вы
видели в главе 4. Инфраструктура Razor Pages выполняет представление
Razor, связанное с данной страницей Razor, для генерации окончатель-

243 Представления: визуализация пользовательского интерфейса
ного ответа. Использование C# в шаблоне Razor означает, что вы можете
динамически генерировать окончательный HTML-код, отправляемый
в браузер. Это позволяет, например, отображать имя текущего пользо-
вателя на странице, скрывать ссылки, к которым у пользователя нет до-
ступа, или отображать кнопку для каждого элемента в списке.
Представьте, что ваш начальник просит вас добавить в  приложение
страницу со списком пользователей приложения. Вы также должны
иметь возможность просматривать пользователя, находясь на странице,
или создавать нового, как показано на рис. 7.2.
PageModel содержит данные, которые вы хотите
отобразить на страницеЭлементы формы можно использовать
для отправки значений обратно в приложение
Разметка Razor описывает, как отображать
эти данные, используя комбинацию HTML-кода и C#
Сочетая данные в своей модели представления с разметкой
Razor, HTML-код можно генерировать динамически,
а не фиксировать его во время компиляции
Рис. 7.2 Использование C# в Razor позволяет с легкостью генерировать динамический HTML-
код, который изменяется во время выполнения. В этом примере использование цикла foreach
внутри представления Razor значительно сокращает дублирование в HTML-коде. В противном
случае вам пришлось бы все это писать самим
С помощью шаблонов Razor создать такого рода динамическое содер-
жимое очень просто. Например, в листинге 7.1 показан шаблон, который
можно использовать для создания интерфейса, показанного на рис. 7.2.
Он сочетает в себе стандартный HTML-код с инструкциями C# и исполь-
зует тег-хелперы для генерации элементов формы.
Листинг 7.1  Шаблон Razor для вывода списка пользователей
и форма для добавления нового пользователя
@page
@model IndexViewModel
<div class="row">
<div class="col-md-6">
<form method="post">
<div class="form-group">Обычный HTML-код отправляется
в браузер без изменений.

244 Глава 7 Визуализация HTML-кода с использованием представлений Razor
<label asp-for="NewUser"></label>
<input class="form-control" asp-for="NewUser" />
<span asp-validation-for="NewUser"></span>
</div>
<div class="form-group">
<button type="submit"
class="btn btn-success">Add</button>
</div>
</form>
</div>
</div>
<h4>Number of users: @Model.ExistingUsers.Count</h4>.
<div class="row">
<div class="col-md-6">
<ul class="list-group">
@foreach (var user in Model.ExistingUsers)
{
<li class="list-group-item d-flex justify-content-between">
<span>@user</span>
<a class="btn btn-info"
asp-page="ViewUser"
asp-route-userName="@user">View</a>
</li>
}
</ul>
</div>
</div>
В этом примере демонстрируются различные функции Razor. Это
смесь HTML-кода, написанного без изменений для вывода ответа, и раз-
личных конструкций C#, используемых для динамической генерации
HTML-кода. Кроме того, можно увидеть несколько тег-хелперов. Они
выглядят как обычные HTML-атрибуты, начинающиеся с  asp-, и являют -
ся частью языка Razor. Они могут настраивать HTML-элемент, к которо-
му прикреплены, изменяя способ его отображения, и делают создание
HTML-форм намного проще. Не волнуйтесь, если данный шаблон кажет -
ся несколько громоздким; мы разберем все это по частям по мере про-
хождения этой и последующей глав.
Страницы Razor компилируются при сборке приложения. За кулиса-
ми они становятся просто еще одним классом C# в вашем приложении.
Также можно активировать компиляцию страниц Razor во	время	выпол-
нения. Это позволяет изменять страницы Razor во время работы прило-
жения без необходимости явно останавливаться и выполнять повторную
сборку, что может быть удобно при локальной разработке, но лучше из-
бегать этого при развертывании в промышленном окружении1.
1 Подробные сведения о том, как активировать компиляцию во время выпол-
нения, включая активацию условной предварительной компиляции для про-
мышленного окружения, см. в документации на странице http://mng.bz/opwy .Т ег-хелперы прикрепляются
к элементам HTML
для создания форм.
Значения могут быть
записаны из объектов C#
в HTML.
В Razor можно использовать
конструкции C#, такие как циклы for.
Т ег-хелперы также можно использовать
за пределами форм, чтобы было проще
генерировать другой HTML-код.

245 Создание представлений Razor
ПРИМЕЧАНИЕ  Как и  большинство вещей в  ASP .NET Core, дви-
жок шаблонов Razor можно заменить собственным движком для
отрисовки на стороне сервера, но нельзя заменить Razor на такие
фреймворки, как Angular или React. Если вы хотите применить
этот подход, то используйте веб-API. Мы будем подробно обсуж -
дать их в главе 9.
В следующем разделе мы более подробно рассмотрим, как представ-
ления Razor вписываются в фреймворк Razor Pages и как передавать дан-
ные из обработчиков страниц Razor в  представление Razor, чтобы по-
мочь сгенерировать ответ в виде HTML-кода.
7.2 Создание представлений Razor
В этом разделе мы рассмотрим, как представления Razor вписываются
в фреймворк Razor Pages. Вы узнаете, как передавать данные из обработ -
чиков страниц в представления Razor и как использовать эти данные для
создания динамического HTML-кода.
В ASP .NET Core всякий раз, когда вам нужно отобразить пользователю
ответ в виде HTML-кода, вы должны использовать представление для его
генерации. Хотя можно напрямую сгенерировать строку из обработчи-
ков страниц, которая будет отображаться в браузере в виде HTML-кода,
такой подход не соответствует разделению ответственности MVC и быст -
ро приведет к тому, что вы начнете рвать на себе волосы.
ПРИМЕЧАНИЕ  Некоторые компоненты промежуточного ПО, та-
кие как WelcomePageMiddleware, который вы видели в главе 3, могут
генерировать ответы в виде HTML-кода без использования пред-
ставления, что может иметь смысл в  некоторых ситуациях. Но
страница Razor и ваши контроллеры MVC всегда должны генери-
ровать HTML-код с использованием представлений.
Полагаясь на представления Razor для генерации ответа, вы получае-
те доступ к широкому спектру функций, а также к инструментам редак -
тора, которые могут помочь. Данный раздел служит легким введением
в представления Razor. В нем рассказывается, что можно с ними делать,
и обсуждаются различные способы, с по мощью которых вы можете пере-
давать им данные.
7.2.1 Представления Razor и сопутствующий код
В этой книге вы уже видели, что Razor Pages обычно состоит из двух
файлов:
файла с расширением .cshtml, который обычно называют представ-
лением Razor;

246 Глава 7 Визуализация HTML-кода с использованием представлений Razor
файла с расширением .cshtml.cs, который обычно называют сопут -
ствующим кодом. Он содержит PageModel.
Представление Razor содержит директиву @page, которая делает	 его
страницей Razor, как вы видели в главе 4. Без нее платформа Razor Pages
не будет маршрутизировать запросы на страницу, и для большинства це-
лей файл будет проигнорирован.
ОПРЕДЕЛЕНИЕ  Директива – 	это инструкция в файле Razor, из-
меняющая способ, которым вы парсите или компилируете шаблон.
Еще одна распространенная директива – @using newNamespace, ко -
торая делает доступными объекты в  пространстве имен newN-
amespace.
Файл .cshtml.cs с сопутствующим кодом содержит PageModel для свя-
занной страницы Razor. В нем находятся обработчики страниц, которые
отвечают на запросы, и именно здесь страница Razor обычно взаимодей-
ствует с другими частями вашего приложения.
Несмотря на то что файлы .cshtml и .cshtml.cs имеют одно и то же имя,
например ToDoItem.cshtml и ToDoItem.cshtml.cs, не оно их связывает. Но
если это не имя файла, как же фреймворк Razor Pages узнает, какая Page-
Model ассоциируется с данным файлом представления страницы Razor?
В верхней части каждой страницы Razor сразу после директивы @page
идет директива @model с типом, указывающим, какая модель страницы
ассоциируется с  представлением Razor. Например, следующие дирек -
тивы указывают на то, что ToDoItemModel – это PageModel, связанная со
страницей Razor:
@page
@model ToDoItemModel
Как только запрос маршрутизируется на страницу Razor, как мы рас -
смотрели в главе 5, фреймворк ищет директиву @model, чтобы решить,
какую модель страницы использовать. Основываясь на выбранной Pa-
geModel, затем он выполняет привязку к любым свойствам в  PageModel,
отмеченным атрибутом [BindProperty] (как мы рассмотрели в главе 6),
и выполняет соответствующий обработчик страницы.
ПРИМЕЧАНИЕ  Технически PageModel и директива @model не яв-
ляются обязательными. Если вы не укажете PageModel, фреймворк
выполнит обработчик страницы по умолчанию, как вы видели
в  главе 5. Также можно объединить файлы .cshtml и  .cshtml.cs
в один файл с расширением .cshtml. На практике ни один из этих
подходов не особо распространен даже для простых страниц, но об
этом следует помнить, если вы столкнетесь с этим1.
1 Такие альтернативные подходы обычно не считаются идиоматическими, по-
этому я не обсуждаю их в этой книге, но вы можете прочитать о них подробнее
здесь: https://www.learnrazorpages.com/razor-pages.

247 Создание представлений Razor
Помимо директив @page и @model, файл представления Razor содержит
шаблон Razor, который выполняется для генерации ответа в виде HTML-
кода.
7.2.2 Знакомство с шаблонами Razor
Шаблоны представлений Razor содержат смесь кода HTML и  C#, пере-
межающихся друг с другом. Разметка HTML позволяет с легкостью опи-
сать, что именно следует отправлять в браузер, тогда как код C# можно
использовать для динамического изменения того, что визуализируется.
Например, в следующем листинге показан пример того, как Razor ви-
зуализирует список строк, обозначающих задачи.
Листинг 7.2 Шаблон Razor для визуализации списка строк
@page
@{
var tasks = new List<string>
{ "Buy milk", "Buy eggs", "Buy bread" };
}
<h1>Tasks to complete</h1>
<ul>
@for(var i=0; i< tasks.Count; i++)
{
var task = tasks[i];
<li>@i – @task</li>
}
</ul>
Разделы чистого HTML в этом шаблоне заключены в угловые скобки.
Движок Razor копирует этот код прямо в вывод без изменений, как если
бы вы писали обычный HTML-файл.
ПРИМЕЧАНИЕ  Возможность синтаксиса Razor знать, когда вы
переключаетесь между HTML и C#, может быть сверхъестествен-
ной и  раздражающей одновременно. Я  обсуждаю подробности
того, как управлять этим переходом, в разделе 7.3.
Помимо HTML-кода, здесь также можно увидеть ряд инструкций C#.
Преимущество иметь возможность, например, использовать цикл for,
вместо того чтобы явно выписывать каждый элемент <li>, должно быть
очевидным. Я немного более подробно рассмотрю функции C# в Razor
в  следующем разделе. При визуализации шаблон из листинга 7.2 даст
следующий HTML-код.
Листинг 7.3 Вывод HTML, созданный при визуализации шаблона Razor
<h1>Tasks to complete</h1>
<ul>Произвольный код C# можно выполнить
в шаблоне. Переменные остаются
в области видимости по всей странице.
Стандартная разметка HTML будет
отображаться на выходе без изменений.
Сочетание C# и HTML-кода позволяет динамически
создавать HTML-код во время выполнения.
HTML-код из шаблона Razor
записывается прямо в вывод.

248 Глава 7 Визуализация HTML-кода с использованием представлений Razor
<li>0 – Buy milk</li>
<li>1 – Buy eggs</li>
<li>2 – Buy bread</li>
</ul>
Как видите, окончательный вывод шаблона Razor после визуализа-
ции – это простой HTML-код. Не осталось ничего сложного, просто раз-
метка HTML, которую можно отправить в браузер и визуализировать. На
рис. 7.3 показано, как это будет отображать браузер.
Сочетая данные объекта C# с разметкой Razor,
HTML-код можно генерировать динамически,
а не фиксировать его во время компиляцииДанные для отображения определены в коде C#
Разметка Razor описывает, как отображать эти
данные, используя комбинацию HTML-кода и C#
Рис. 7.3 Шаблоны Razor можно использовать для динамической генерации
HTML-кода во время выполнения из объектов C#. В данном случае цикл for
используется для создания повторяющихся элементов <li>
В данном примере я жестко закодировал значения списка для прос -
тоты  – динамических данных не было. Это часто бывает с  простыми
страницами Razor Pages, например с тем, что у вас может быть на вашей
домашней странице, – вам нужно отображать почти статичную страни-
цу. Что касается остальной части вашего приложения, то здесь гораздо
чаще будут присутствовать некие данные, которые вам нужно отобра-
зить, обычно предоставляемые как свойства PageModel.
7.2.3 Передача данных в представления
В ASP .NET Core у вас есть несколько способов передачи данных из об-
работчика страницы на странице Razor в представление. Какой подход
лучше, будет зависеть от данных, которые вы пытаетесь передать, но
в целом вы должны использовать механизмы в следующем порядке:
свойства PageModel  – обычно вы должны предоставлять любые
данные, которые должны отображаться как свойства вашей Pa-
geModel. Таким образом должны быть представлены все данные,
относящиеся к  связанному представлению Razor. Как вы вскоре
увидите, объект PageModel  доступен в представлении во время ви-
зуализации;Элементы <li> генерируются
динамически на основе данных.
HTML-код из шаблона Razor записывается прямо в вывод.

249 Создание представлений Razor
ViewData – это словарь объектов со строковыми ключами, которые
можно использовать для передачи произвольных данных из обра-
ботчика страницы в представление. Кроме того, он позволяет пере-
давать данные в файлы _layout, как вы увидите в разделе 7.4. Это ос -
новная причина использовать ViewData, вместо того чтобы задавать
свойства в PageModel;
HttpContext – технически объект HttpContext доступен как в обра-
ботчике страницы, так и в представлении Razor, поэтому его можно
было	бы	использовать для передачи данных между ними. Но не нуж -
но – в этом нет необходимости, поскольку в вашем распоряжении
имеются другие доступные методы;
сервисы @inject  – вы можете использовать внедрение зависимо-
стей, чтобы сделать сервисы доступными в ваших представлениях,
хотя обычно его следует использовать очень экономно. Я описываю
внедрение зависимостей и директиву @inject в главе 10.
Безусловно, лучший подход для передачи данных из обработчика
страницы в  представление – использовать свойства в  PageModel. В  са-
мих свойствах нет ничего особенного; можете хранить там все, что вам
нужно.
ПРИМЕЧАНИЕ  Многие фреймворки имеют концепцию контек -
ста данных для привязки компонентов пользовательского интер-
фейса. PageModel представляет собой аналогичную концепцию, по-
скольку содержит значения для отображения в пользовательском
интерфейсе, но привязка является только однонаправленной; Pa-
geModel предоставляет значения пользовательскому интерфейсу,
и как только интерфейс будет создан и отправлен в качестве от -
вета, PageModel будет уничтожена.
Как я писал в разделе 7.2.1, директива @model в верхней части ваше-
го представления Razor описывает, какой тип PageModel ассоциируется
с данной страницей Razor. PageModel, связанная со страницей Razor, со-
держит один или несколько обработчиков страниц и предоставляет дан-
ные в качестве свойств для использования в представлении Razor.
Листинг 7.4 Представление данных в качестве свойств в PageModel
public class ToDoItemModel : PageModel
{
public List<string> Tasks { get; set; }
public string Title { get; set; }
public void OnGet(int id)
{
Title = "Tasks for today";
Tasks = new List<string>
{
"Get fuel",PageModel передается в представление
Razor при выполнении.
Доступ к открытым свойствам можно
получить из представления Razor.
Создание необходимых данных:
обычно для загрузки данных
вызывается сервис или база данных.

250 Глава 7 Визуализация HTML-кода с использованием представлений Razor
"Check oil",
"Check tyre pressure"
};
}
}
Вы можете получить доступ к самому экземпляру PageModel из пред-
ставления Razor, используя свойство Model. Например, чтобы отобразить
свойство Title класса ToDoItemModel в представлении Razor, вы должны
использовать <h1>@Model.Title</h1>. Так вы визуализируете строку, ука-
занную в свойстве ToDoItemModel.Title, создавая код: <h1>Tasks for to-
day</h1>.
СОВЕТ  Обратите внимание, что директива @model должна нахо-
диться в верхней части вашего представления сразу после дирек -
тивы @page и  что в  ней есть строчная буква m. К  свойству Model
может получить доступ в любом месте представления, и оно имеет
прописную букву M.
В подавляющем большинстве случаев использование открытых
свойств PageModel – верный путь; это стандартный механизм передачи
данных между обработчиком страницы и представлением. Но в некото-
рых случаях свойства PageModel могут быть не самым лучшим вариантом.
Это часто бывает, когда вы хотите передавать данные между макетами
представления (вы увидите, как это работает, в разделе 7.4).
Типичный пример  – заголовок страницы. Вам необходимо указать
заголовок для каждой страницы в вашем приложении, чтобы вы могли
создать базовый класс со свойством Title и сделать так, чтобы каждая
PageModel наследовала от него. Но это будет выглядеть очень громоздко,
поэтому обычный подход в этой ситуации заключается в использовании
коллекции ViewData для передачи данных.
Фактически стандартные шаблоны страниц Razor используют этот
подход по умолчанию, задавая значения в  словаре ViewData из самого
представления:
@{
ViewData["Title"] = "Home Page";
}
<h2>@ViewData["Title"].</h2>
Этот шаблон задает для ключа "Title" в  словаре ViewData значение
"Home Page", а затем извлекает ключ для визуализации его в шаблоне. Все
это может показаться излишним, но поскольку словарь ViewData исполь-
зуется во всем запросе, он делает заголовок страницы доступным в ма-
кетах, как вы увидите позже. После визуализации предыдущий шаблон
даст следующий вывод:
<h2>Home Page.</h2>Создание необходимых данных: обычно для загрузки
данных вызывается сервис или база данных.

251 Создание динамических веб-страниц с помощью Razor
Также можно задать значения в  словаре ViewData из обработчиков
страниц двумя разными способами, как показано в следующем листинге.
Листинг 7.5 Задаем значения ViewData с по мощью атрибута
public class IndexModel: PageModel
{
[ViewData]
public string Title { get; set; }
public void OnGet()
{
Title = "Home Page";
ViewData["Subtitle"] = "Welcome";
}
}
Вы можете отобразить значения в шаблоне так же, как и раньше:
<h1>@ViewData["Title"]</h3>
<h2>@ViewData["Subtitle"]</h3>
СОВЕТ  Я  не считаю атрибут [ViewData] особенно полезным, но
это еще одна особенность, на которую стоит обратить внимание.
Я создаю набор глобальных статических констант для всех ключей
ViewData и ссылаюсь на них, вместо того чтобы постоянно наби-
рать "Title". У вас будет IntelliSense, когда вы будете работать со
значениями. Они будут безопасны для рефакторинга, и вы избе-
жите труднозаметных опечаток.
Как я упоминал ранее, помимо свойств PageModel и ViewData существу -
ют и другие механизмы, которые можно использовать для передачи дан-
ных, но только эти два я использую сам, поскольку с ними можно делать
все, что вам нужно. Напоминаю: по возможности всегда используйте
свойства PageModel, так как вы получаете выгоду от строгой типизации
и IntelliSense. Возвращайтесь к  ViewData, только если речь идет о значе-
ниях, которые должны быть доступны за	пределами представления Razor.
Вы немного познакомились с возможностями, доступными вам в шаб-
лонах Razor, но в следующем разделе мы подробнее рассмотрим некото-
рые доступные возможности C#.
7.3 Создание динамических веб-страниц
с помощью Razor
Возможно, вам будет приятно узнать, что практически все, что вы може-
те делать в C#, возможно в синтаксисе Razor. За кулисами файлы с рас -
ширением .cshtml компилируются в  обычный код C# (используя тип Свойства, отмеченные атрибутом
[ViewData], задаются в ViewData.
Значение ViewData ["Title"]
будет задано как "Home Page" .
Можно задать ключи напрямую
в словаре ViewData.

252 Глава 7 Визуализация HTML-кода с использованием представлений Razor
string для низкоуровневых HTML-секций), поэтому какое бы странное
и чудесное поведение вам не понадобилось, его можно создать!
Говоря это, следует учитывать: то, что вы	 можете что-то делать, не
означает, что вы должны	 это делать. Вам будет намного легче работать
с файлами и сопровождать их, если они будут как можно проще. Это ка-
сается почти всего в программировании, но я считаю, что особенно это
касается шаблонов Razor.
В этом разделе рассматриваются некоторые наиболее распространен-
ные конструкции C#, которые вы можете использовать. Если вы обнару -
жите, что вам нужно нечто более экзотическое, обратитесь к документа-
ции по синтаксису Razor: htt p://mng.bz/opj2.
7.3.1 Использование C# в шаблонах Razor
Одним из наиболее распространенных требований при работе с шабло-
нами Razor является отрисовка значения, вычисленного в C#, в HTML.
Например, у  вас может возникнуть желание вывести текущий год, ко-
торый будет отображаться рядом со знаком авторского права в вашем
HTML-коде:
<p>Copyright 2020 ©</p>
Или вывести результат сложения:
<p>The sum of 1 and 2 is <i>3</i><p>
Можно сделать это двумя способами, в  зависимости от того, какой
именно код C# нужно выполнить. Если код представляет собой одну-
единственную инструкцию, то можно использовать символ @, чтобы
указать, что вы хотите записать результат в вывод HTML, как показано
на рис. 7.4. Вы уже видели, как это используется для записи значений из
PageModel или ViewData.
@ указывает на начало
выражения C#Пробел указывает
на конец выражения C#
HTML-код Выражение C#. Результат
будет записан в HTML-вывод HTML-код
Рис. 7.4 Запись результата выражения C# в HTML. Символ @ указывает,
где начинается код C#, а выражение заканчивается в конце инструкции,
в данном случае на пробеле
Если код C#, который вы хотите выполнить, требует	 пробела, то нужно
использовать круглые скобки для разделения, как показано на рис. 7.5.
Эти два подхода, в которых код C# вычисляется и записывается непо-
средственно в вывод HTML, называются выражениями	Razor.

253 Создание динамических веб-страниц с помощью Razor
Все выражение C# внутри @() вычисляется
и записывается в вывод HTML
HTML-код HTML-код
Рис. 7.5 Если выражение C# содержит пробелы, нужно заключить его
в круглые скобки, используя @(), чтобы движок Razor знал, где заканчивается C#
и начинается HTML
СОВЕТ  Если вы хотите написать литерал @, а не выражение C#,
используйте второй символ @: @@.
Иногда нужно выполнить некий код C#, но не нужно выводить значе-
ния. Мы использовали эту технику, когда задавали значения в ViewData:
@{
ViewData["Title"] = "Home Page";
}
В этом примере демонстрируется блок	кода	Razor, который представ-
ляет собой обычный код C#, идентифицируемый структурой @{}. Здесь
ничего не записывается в вывод HTML; все компилируется, как если бы
вы написали это в любом другом обычном файле C#.
СОВЕТ  Когда вы выполняете код в блоках кода, он должен быть
допустимым, поэтому нужно добавить точки с  запятой. И  на-
оборот, когда вы записываете значения непосредственно в ответ
с  по мощью выражений Razor, они вам не нужны. Если в  вашем
HTML-коде на выходе неожиданно что-то пошло не так, следите
за отсутствующими или лишними точками с запятой.
Выражения Razor  – один из наиболее распространенных способов
запи си данных из PageModel в вывод HTML. В следующей главе вы уви-
дите другой подход, при котором используются тег-хелперы. Однако
возможности Razor простираются гораздо дальше, в чем вы убедитесь,
пройдя следующий раздел, в котором узнаете, как включать традицион-
ные структуры C# в свои шаблоны.
7.3.2 Добавление циклов и условий в шаблоны Razor
Одно из самых больших преимуществ использования шаблонов Razor по
сравнению со статическим HTML – возможность динамически генериро-
вать выходные данные. Возможность записывать значения из PageModel
в HTML с по мощью выражений Razor является ключевой частью этого
процесса, но есть еще один распространенный вариант использования –
циклы и условные выражения. С их помощью можно, например, скрыть
разделы пользовательского интерфейса или создать HTML-код для каж -
дого элемента в списке.

254 Глава 7 Визуализация HTML-кода с использованием представлений Razor
Циклы и условные выражения включают такие конструкции, как цик -
лы if и for. Их использование в шаблонах Razor почти идентично C#, но
необходимо добавить к ним символ @. Если вы еще не освоили Razor, то
в случае сомнений добавьте еще один символ @!
Одним из весомых преимуществ Razor в контексте ASP .NET Core яв-
ляется тот факт, что он использует языки, с которыми вы уже знакомы:
C# и  HTML. Нет необходимости изучать новый набор примитивов для
какого-либо другого языка шаблонов: это те же самые конструкции if,
foreach и  while, с которыми вы уже знакомы. А когда они вам не нужны,
вы пишете низкоуровневый HTML-код, чтобы точно видеть, что пользо-
ватель получит в своем браузере.
В листинге 7.6 я применил ряд этих техник в шаблоне для отображе-
ния списка дел. PageModel имеет свойство IsComplete, а также свойство
List<string> с именем Tasks, которое содержит все невыполненные за-
дачи.
Листинг 7.6 Шаблон Razor для визуализации ToDoItemViewModel
@page
@model ToDoItemModel
<div>
@if (Model.IsComplete)
{
<strong>Well done, you're all done!</strong>
}
else
{
<strong>The following tasks remain:</strong>
<ul>
@foreach (var task in Model.Tasks)
{
<li>@task</li>
}
</ul>
}
</div>
Этот код определенно соответствует тому, о чем мы говорили ранее:
речь идет о  смешении C# и  HTML. Существуют традиционные управ-
ляющие конструкции C#, такие как if и foreach, которые вы ожидаете
увидеть в любой обычной программе, с вкраплениями разметки HTML,
которую вы хотите отправить в браузер. Вы видите, что символ @ ис -
пользуется для того, чтобы обозначить, когда вы запускаете управляю-
щую инструкцию, но в целом вы позволяете шаблону Razor делать вывод,
когда переключаетесь туда-сюда между HTML и C#.
В шаблоне показано, как генерировать динамический HTML-код во
время выполнения в зависимости от предоставленных точных данных.
Если у модели есть невыполненные задачи, HTML сгенерирует элемент
списка для каждой задачи, давая на выходе примерно такой результат,
как показано на рис. 7.6.Директива @model указывает тип PageModel в модели.
Конструкция управления if
проверяет значение свойства
IsComplete во время выполнения.
Конструкция foreach будет
генерировать элементы <li>
один раз для каждой задачи
в Model.Tasks.
Выражение Razor используется
для записи задачи в вывод HTML.

255 Создание динамических веб-страниц с помощью Razor
В HTML визуализируется только соответствующий
блок «if», а содержимое цикла foreach отображается
один раз для каждого элемента Отображаемые данные определяются
в свойствах PageModel
Разметка Razor может включать в себя такие
конструкции C#, как операторы if и циклы for
Рис. 7.6 Шаблон Razor создает элемент <li> для каждой оставшейся задачи
в зависимости от данных, передаваемых в представление во время выполнения.
Вы можете использовать блок if для визуализации совершенно другого HTML-кода
в зависимости от значений в вашей модели
Распространенный подход членов команды ASP .NET Core состоит
в том, что они пытаются гарантировать, что при создании приложения
вы можете пользоваться всеми преимуществами данного фреймворка
без дополнительных настроек. Это относится к идее, согласно которой
по умолчанию самый	простой	 способ сделать что-то должен быть пра-
вильным. Это отличная философия, поскольку это означает, что вы не
должны обжечься, например, на проблемах, связанных с безопасностью,
если следуете стандартным подходам. Однако иногда вам может потре-
боваться выйти за безопасные рамки. Вот распространенный вариант
использования – вам нужно визуализировать HTML-код, содержащийся
в объекте C# для вывода. Вы увидите это в следующем разделе.
IntelliSense и поддержка инструментов
Возможно, смесь C# и HTML трудно читать, и это разумная жалоба. Это еще
один веский аргумент в пользу того, чтобы шаблоны Razor были как можно
проще.
К счастью, если вы используете такие редакторы, как Visual Studio или Visual
Studio Code, это может помочь. Как видно на этом рисунке, код C# затенен,
чтобы его легче было отличить от окружающего его HTML-кода.

256 Глава 7 Визуализация HTML-кода с использованием представлений Razor
Visual Studio затеняет код C# и подсвечивает символы @,
где C# переходит в HTML. Это упрощает чтение шаблонов Razor
Хотя возможность использовать циклы и  условные выражения – мощное
средство, это одно из преимуществ Razor перед статическим HTML – они
также усложняют ваше представление. Постарайтесь ограничить количество
логики в представлениях, чтобы сделать их максимально простыми для по-
нимания и сопровождения.
7.3.3 Визуализация HTML с по мощью метода Raw
В предыдущем примере мы визуализировали список задач в  HTML,
написав строковую задачу с  использованием выражения Razor, @task.
Но что, если переменная task содержит HTML-код, который вы хоти-
те отобра зить, поэтому вместо "Check oil" он содержит "<strong>Check
oil</strong>"? Если вы используете выражение Razor для вывода, как
делали это раньше, то, возможно, надеетесь получить это:
<li><strong>Check oil</strong></li>
Но нет. Сгенерированный HTML-код выглядит так:
<li>&lt;strong&gt;Check oil&lt;/strong&gt;</li>
Хм, выглядит странно, правда? Что же здесь произошло? Почему шаб-
лон не записал вашу переменную в HTML-код, как в предыдущих при-
мерах? Если вы посмотрите, как браузер отображает этот HTML-код на
рис. 7.7, тогда, надеюсь, это будет иметь больше смысла.

257 Создание динамических веб-страниц с помощью Razor
Рис. 7.7  Второй элемент, "<strong>Check oil</strong>", был в кодировке HTML,
поэтому элементы <strong> видны пользователю как часть задачи. Это позволяет
избежать проблем с безопасностью, поскольку пользователи не смогут внедрять
вредоносные скрипты в ваш HTML-код
Шаблоны Razor кодируют выражения C# до того, как они будут запи-
саны в выходной поток. Это делается в первую очередь из соображений
безопасности; запись произвольных строк в  ваш HTML-код может по-
зволить пользователям внедрять вредоносные данные и код Java Script на
ваш сайт. Следовательно, переменные C#, которые вы выводите в шабло-
не Razor, записываются как значения в кодировке HTML.
В некоторых случаях вам может потребоваться напрямую записать
HTML-код, содержащийся в строке, в ответ. Если вы оказались в такой
ситуации, сначала остановитесь. Вам действительно	 нужно это делать?
Если значения, которые вы пишете, были введены пользователем или
созданы на основе значений, предоставленных пользователями, то вы
рискуете создать брешь в системе безопасности своего сайта.
Если вам действительно	 нужно записать переменную в HTML-поток,
это можно сделать, используя свойство Html на странице представления
и вызвав метод Raw:
<li>@Html.Raw(task)</li>
При таком подходе строка в  task будет напрямую записана в выход-
ной поток, в результате чего вы получите HTML-код, который изначаль-
но был вам нужен: <li><strong>Check oil</strong></li> (рис. 7.8).
ВНИМАНИЕ!  Использование Html.Raw таким способом создает
угрозу для безопасности, которую пользователи могут использо-
вать для внедрения вредоносного кода на ваш сайт. По возмож -
ности избегайте этого.

258 Глава 7 Визуализация HTML-кода с использованием представлений Razor
Рис. 7.8 Второй элемент, "<strong>Check oil</strong>", был выведен
с использованием Html.Raw(), поэтому он не был закодирован в HTML.
Элементы <strong> приводят к тому, что второй элемент отображается жирным
шрифтом.  По возможности следует избегать использования Html.Raw() таким
способом, поскольку это угроза безопасности
Конструкции C#, показанные в этом разделе, могут быть полезны, но
они могут привести к тому, что ваши шаблоны будет трудно читать. Как
правило, легче понять назначение шаблонов Razor, которые преиму -
щественно представляют собой HTML-разметку, а не код C#.
В предыдущей версии ASP .NET эти конструкции и, в частности, вспо-
могательное свойство Html были стандартным способом создания ди-
намической разметки. Данный подход по-прежнему можно применять
в ASP .NET Core, используя различные методы HtmlHelper1 свойства Html,
но они в значительной степени заменены более совершенной техникой:
тег-хелперами.
ПРИМЕЧАНИЕ  Я расскажу о тег-хелперах и о том, как их исполь-
зовать для создания HTML-форм, в следующей главе.
Тег-хелперы – полезная функция, впервые появившаяся в  Razor, но
ряд других функций был перенесен из предыдущей версии ASP .NET.
В следующем разделе этой главы вы увидите, как создавать вложенные
шаблоны Razor и использовать частичные представления, чтобы умень-
шить число дублирований в представлениях.
1 HTMLHelpers почти устарели, хотя если вы предпочитаете их использовать,
они все еще доступны.

259 Макеты, частичные представления и _ViewStart
7.4 Макеты, частичные представления
и _ViewStart
В этом разделе вы узнаете о макетах и частичных представлениях, ко-
торые позволяют извлекать общий код для уменьшения дублирования.
Эти файлы упрощают внесение изменений в HTML-код, которые влияют
на несколько страниц одновременно. Вы также узнаете, как выполнять
общий код для каждой страницы Razor с по мощью _ViewStart и _ViewIm-
ports, а также как включать дополнительные разделы в свои страницы.
Каждый HTML-документ имеет определенное количество необходи-
мых элементов: <html>, <head> и  <body>. Кроме того, часто есть общие
разделы, которые повторяются на каждой странице вашего приложения,
такие как верхний и нижний колонтитулы, как показано на рис. 7.9. На
каждой странице вашего приложения также, вероятно, будут присут -
ствовать ссылки на одни и те же файлы CSS и Java Script.
Заголовок, общий
для каждой страницы
в приложении
Общая боковая
панель для некоторых
представлений
в приложении Содержимое тела страницы,
относящееся только
к данному конкретному
представлению
Рис. 7.9 Типичное веб-приложение имеет блочный макет, где некоторые блоки являются
общими для каждой страницы приложения. Верхний колонтитул, вероятно, будет одинаковым
для всего вашего приложения, но боковая панель может быть идентичной только для страниц
в одном разделе. Содержимое тела будет отличаться для каждой страницы вашего приложения
Все эти элементы – просто кошмар, когда речь идет о сопровождении.
Если бы вам пришлось вручную включать их в  каждое представление,
то внесение любых изменений превратилось бы в  трудоемкий и  под-
верженный ошибкам процесс, связанный с  редактированием каждой
страницы. Вместо этого Razor позволяет извлекать эти общие элементы
в макеты.
ОПРЕДЕЛЕНИЕ  Макет в Razor – это шаблон, включающий в себя
общий код. Его нельзя визуализировать напрямую, но можно де-
лать это вместе с обычными представлениями Razor.
Располагая общую разметку в макетах, вы можете уменьшить дубли-
рование в своем приложении, что упрощает внесение изменений, управ-
ление и  сопровождение ваших представлений, и  вообще это хорошая
практика!

260 Глава 7 Визуализация HTML-кода с использованием представлений Razor
7.4.1 Использование макетов для общей разметки
Файлы макета – это по большей части обычные шаблоны Razor, содер-
жащие разметку, общую для нескольких страниц. Приложение ASP .NET
Core может иметь несколько макетов, и макеты могут ссылаться на дру -
гие макеты. Обычно это используется для разных макетов разных раз-
делов вашего приложения. Например, веб-сайт для онлайн-торговли
может использовать представление с тремя столбцами для большинства
страниц и  макет с  одним столбцом, когда вы переходите на страницы
оформления заказа, как показано на рис. 7.10.
Трехколоночный макет Одноколоночный макет
Рис. 7.10 На сайте https://manning.com используются разные макеты для разных
частей веб-приложения. На страницах товаров используется трехколоночный макет,
а на странице корзины – одноколоночный
Вы часто будете использовать макеты на разных страницах Razor, по-
этому обычно они помещаются в папку Pages/Shared. Можете называть
их как хотите, но существует общее соглашение об использовании _Lay -
out.cshtml в качестве имени файла для базового макета в вашем прило-
жении. Это имя по умолчанию, используемое шаблонами страниц Razor
в Visual Studio и интерфейсе командной строки .NET.
ПОДСКАЗКА  Обычно к файлам макета добавляется символ под-
черкивания (_), чтобы отличать их от стандартных шаблонов Razor
в папке Pages.
Файл макета похож на обычный шаблон Razor, за одним исключе-
нием: каждый макет должен вызывать функцию @RenderBody(). Так вы
сообщаете движку шаблонов, куда вставить содержимое из дочерних
представлений. Простой макет показан в следующем листинге. Обычно
ссылки на все ваши файлы CSS и Java Script будут находиться в макете,
а также здесь будут содержаться все общие элементы, такие как верхний
и нижний колонтитулы, но данный пример включает в себя почти мини-
мальный HTML-код.

261 Макеты, частичные представления и _ViewStart
Листинг 7.7  Базовый файл _Layout.cshtml, вызывающий функцию
RenderBody
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>@ViewData["Title"]</title>
<link rel="stylesheet" href="~/css/site.css" />
</head>
<body>
@RenderBody()
</body>
</html>
Как видите, файл макета включает необходимые элементы, такие как
<html> и  <head>, а также элементы, которые нужны на каждой странице,
такие как <title> и  <link>. Этот пример также демонстрирует преиму -
щество хранения заголовка страницы в  ViewData; макет может визуали-
зировать его в элементе <title> так, чтобы он отображался на вкладке
браузера, как показано на рис. 7.11.
Рис. 7.11 Содержимое элемента <title> используется в качестве имени вкладки
в браузере пользователя, в данном случае это домашняя страница
ПРИМЕЧАНИЕ  Файлы макета не являются автономными стра-
ницами Razor Pages и не участвуют в маршрутизации, поэтому они
не начинаются с директивы @page.
Представления могут указать, какой файл макета использовать, задав
свойство Layout внутри кодового блока Razor.
Листинг 7.8 Задаем свойство Layout из представления
@{
Layout = "_Layout";
ViewData["Title"] = "Home Page";
}
<h1>@ViewData["Title"]</h1>
<p>This is the home page</p>
Любое содержимое в представлении будет отображаться внутри маке-
та, где вызывается функция @RenderBody(). Соедините два предыдущих
листинга, и вы получите следующий HTML-код, который генерируется
и отправляется пользователю.ViewData – это стандартный механизм
передачи данных в макет из представления.
Элементы, общие для каждой
страницы, такие как стили CSS, обычно
находятся в макете.
Сообщает механизму шаблонов, куда вставить
содержимое дочернего представления.
Задаем для страницы макет _Layout.cshtml.
ViewData – удобный способ передачи
данных из представления Razor в макет.
Содержимое в представлении Razor для
визуализации внутри макета.

262 Глава 7 Визуализация HTML-кода с использованием представлений Razor
Листинг 7.9  Визуализированный результат объединения представления
и его макета
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Home Page</title>
<link rel="stylesheet" href="/css/site.css" />
</head>
<body>
<h1>Home Page</h1>
<p>This is the home page</p>
</body>
Разумное использование макетов может быть чрезвычайно полезным
для уменьшения дублирования между страницами. По умолчанию маке-
ты предоставляют только одно место, где можно отображать содержимое
из представления, при вызове функции @RenderBody. В тех случаях, ког -
да это слишком ограничивает вас, можно визуализировать содержимое
с по мощью секций.
7.4.2 Переопределение родительских макетов
с помощью секций
Когда вы начинаете использовать несколько макетов в своем приложе-
нии, то зачастую возникает необходимость визуализировать содержи-
мое из дочерних представлений в  нескольких местах вашего макета.
Рассмотрим макет, в  котором используются два столбца. Представле-
нию нужен механизм, чтобы сказать: «визуализировать это	 содержимое
в левом	 столбце» и «визуализировать это содержимое в  правом столбце».
Для этого нужны секции.
ПРИМЕЧАНИЕ  Помните, что все функции, описанные в этой гла-
ве, относятся только к Razor, который представляет собой движок
для отрисовки на стороне сервера. Если вы используете фрейм-
ворк для создания одностраничных приложений на стороне кли-
ента, то, вероятно, будете работать с этими требованиями другими
способами, либо в клиентском коде, либо путем выполнения не-
скольких запросов к конечной точке веб-API.
Секции обеспечивают способ организации размещения элементов
представления в макете. Они определяются в представлении с по мощью
определения @section, как показано в  следующем листинге, который
определяет HTML-содержимое боковой панели, отдельно от основного
содержимого в секции Sidebar. @section можно разместить в любом мес -
те файла, вверху или внизу, где удобно.ViewData, заданный в представлении,
используется для визуализации макета.
Вызов RenderBody отображает
содержимое представления.

263 Макеты, частичные представления и _ViewStart
Листинг 7.10 Определение секции в шаблоне представления
@{
Layout = "_TwoColumn";
}
@section Sidebar {
<p>This is the sidebar content</p>
}
<p>This is the main content </p>
Секция визуализируется в  родительском макете с  по мощью вызова
функции @RenderSection(). Так вы визуализируете содержимое, содер-
жащееся в дочернем разделе, в макет. Секции могут быть обязательными
либо нет. Если они необходимы, представление должно объявить данное
определение @section; если они необязательны, их можно опустить,
и макет пропустит их. Пропущенные секции не появятся в визуализи-
рованном HTML-коде. В следующем листинге показан макет, в котором
есть обязательная секция Sidebar и необязательная секция Scripts.
Листинг 7.11 Визуализация секции в файле макета, _TwoColumn.cshtml
@{
Layout = "_Layout";
}
<div class="main-content">
@RenderBody()
</div>
<div class="side-bar">
@RenderSection("Sidebar", required: true)
</div>
@RenderSection("Scripts", required: false)
СОВЕТ  Обычно на страницах макета есть необязательная секция
под названием Scripts. Ее можно использовать для визуализа-
ции дополнительного кода Java Script, который требуется для не-
которых представлений, но не для каждого. Типичный пример –
скрипты jQuery Unobtrusive Validation для валидации на стороне
клиента. Если представлению нужны скрипты, оно добавляет со-
ответствующий @section Scripts в разметку Razor.
Вы, наверное, заметили, что в  предыдущем листинге определено
свойство Layout, даже если это сам макет, а не представление. Это впол-
не приемлемо и позволяет создавать вложенные иерархии макетов, как
показано на рис. 7.12.Все содержимое в фигурных скобках является
частью секции Sidebar, а не основного содержимого.
Любое содержимое, не входящее в @section,
будет обработано вызовом @RenderBody.
Этот макет вложен внутри самого макета.
Визуализирует все содержимое из представления,
которое не является частью секции.
Визуализирует секцию Sidebar; если эта
секция не определена в представлении,
выдается ошибка.
Визуализирует секцию Scripts; если
она не определена в представлении,
игнорируйте его.

264 Глава 7 Визуализация HTML-кода с использованием представлений Razor
СОВЕТ  Большинство веб-сайтов в наши дни должны быть «отзыв-
чивыми», чтобы работать на самых разных устройствах. Обычно
для этого не	следует использовать макеты. Не нужно использовать
разные макеты для одной страницы в зависимости от устройства,
отправляющего запрос. Вместо этого используйте один и тот же
HTML-код для всех устройств и  CSS на стороне клиента, чтобы
адаптировать отображение вашей веб-страницы по мере необхо-
димости.
Основное содержимое представления
визуализируется в файле
_T woColumn.cshtml с помощью
RenderBodyСодержимое боковой панели
представления отображается в файле
_T woColumn.cshtml с помощью
RenderSection (Боковая панель)Файл _Layout.cshtml определяет
HTML-код в верхнем и нижнем
колонтитулах
Файл _T woColumn.cshtml
визуализируется внутри файла
__Layout.cshtml
Рис. 7.12 Несколько макетов могут быть вложены для создания сложных
иерархий. Это позволяет сохранить элементы, общие для всех представлений,
в вашем базовом макете, и извлекать макет, общий для нескольких представлений,
во вложенные макеты
Файлы макета и секции обеспечивают большую гибкость для создания
сложных пользовательских интерфейсов, но одно из наиболее важных
их применений – уменьшение дублирования кода в  приложении. Они
идеально подходят для предотвращения дублирования содержимого,
которое вам пришлось бы писать для каждого представления. А как на-
счет тех случаев, когда вы обнаружите, что хотите повторно использо-
вать часть представления в другом месте? Для этого у вас есть частичные
представления.
7.4.3 Использование частичных представлений
для инкапсуляции разметки
Частичные представления, как и  следует из их названия, являются
частью  представления. Они позволяют разбить крупное представление
на более мелкие, многоразовые фрагменты. Это может быть полезно
как для уменьшения сложности большого представления, разделив его
на несколько частичных представлений, так и для того, чтобы дать воз-
можность повторно использовать часть представления внутри другого
представления.

265 Макеты, частичные представления и _ViewStart
Большинство веб-фреймворков, использующих отрисовку на стороне
сервера, обладают такой возможностью: в Ruby on Rails есть частичные
представления, в Django – теги inclusion, а в Zend – Partial. Все они работа-
ют одинаково, извлекая общий код в небольшие повторно используемые
шаблоны. Даже шаблонизаторы на стороне клиента, такие как Mustache
и Handlebars, используемые такими фреймворками, как Angular и Ember,
имеют аналогичные концепции «частичного представления».
Снова рассмотрим приложение со списком дел. Вы можете обнару -
жить, что у вас есть страница Razor под названием ViewToDo.cshtml, ко-
торая отображает один элемент списка с заданным идентификатором.
Позже вы создаете новую страницу Razor, RecentToDos.cshtml, которая
отображает пять последних дел. Вместо того чтобы копировать и встав-
лять код с одной страницы на другую, можно создать частичное пред-
ставление с именем _ToDo.cshtml, как показано в следующем листинге.
Листинг 7.12  Частичное представление _ToDo.cshtml для отображения
ToDoItemViewModel
@model ToDoItemViewModel
<h2>@Model.Title</h2>
<ul>
@foreach (var task in Model.Tasks)
{
<li>@task</li>
}
</ul>
Частичные представления немного похожи на страницы Razor, толь-
ко в  них нет PageModel и  обработчиков. Они предназначены исключи-
тельно для визуализации небольших фрагментов HTML-кода, а  не для
обработки запросов, привязки и  валидации модели, и  вызова модели
приложения. Они отлично подходят для инкапсуляции небольших по-
лезных фрагментов HTML-кода, которые необходимо сгенерировать на
нескольких страницах Razor.
И ViewToDo.cshtml, и RecentToDos.cshtml могут отображать частичное
представление _ToDo.cshtml, которое имеет дело с  генерацией HTML-
ко да для одного класса. Частичные представления отображаются с по-
мощью тег-хелпера <partial/>, предоставляющего имя представления
для визуализации и данные (модель). Например, посмотрите на пред-
ставление RecentToDos.cshtml, показанное в следующем листинге.
Листинг 7.13  Визуализация частичного представления со страницы
Razor
@page
@model RecentToDoListModelЧастичные представления могут
привязываться к данным в свойстве
Model, как обычная страница Razor
использует PageModel.
Содержимое частичного
представления, которое ранее
находилось в файле ViewT oDo.cshtml.
Это страница Razor, поэтому используется директива @page.
Частичные представления не используют ее.
PageModel содержит список последних элементов
для визуализации.

266 Глава 7 Визуализация HTML-кода с использованием представлений Razor
@foreach(var todo in Model.RecentItems)
{
<partial name="_ToDo" model="todo" />
}
Когда вы визуализируете частичное представление без указания аб-
солютного пути или расширения файла, как, например, _ToDo в листин-
ге  7.13, фреймворк пытается найти представление, выполняя поиск
в папке Pages, начиная с страницы Razor, которая его вызвала. Напри-
мер, если ваша страница расположена в  Pages/Agenda/ToDos/RecentTo-
Dos.chstml, фреймворк будет искать файл с именем _ToDo.chstml в сле-
дующих местах:
Pages/Agenda/ToDos/ (текущая папка Razor Page);
Pages/Agenda/;
Pages/;
Pages/Shared/;
Views/Shared/.
Будет выбрано первое расположение, содержащее файл с  именем
_ToDo.cshtml. Если вы включите расширение файла .cshtml, когда ссы-
лаетесь на частичное представление, фреймворк будет искать	 только
в папке текущей страницы Razor. Кроме того, если вы укажете абсолют -
ный путь к частичному представлению, например /Pages/Agenda/ToDo.
cshtml, то это будет единственным местом, где фреймворк будет искать1.
ПРИМЕЧАНИЕ  Как и в случае с макетами, к именам частичных
представлений обычно добавляется подчеркивание в начале.
Код Razor, содержащийся в частичном представлении, почти иденти-
чен стандартному представлению. Основное отличие состоит в том, что
частичные представления вызываются только из других представлений.
Другое отличие состоит в том, что частичные представления не исполь-
зуют _ViewStart.cshtml при выполнении. Скоро вы это увидите.
Дочерние действия в ASP.NET Core
В предыдущей версии ASP.NET MVC существовала концепция дочернего дей­
ствия. Это был метод действия, который можно было вызвать изнутри пред-
ставления. Это был основной механизм визуализации отдельных секций
сложного макета, не имевший ничего общего с основным методом действия.
Например, дочерний метод действия мог визуализировать корзину на сайте
онлайн-магазина.
1 Как и  в  большинстве страниц Razor, места поиска представляют собой со-
глашения, которые при желании можно настроить. Если появится необходи-
мость, то можете настроить пути, как показано здесь: http://mng.bz/nM9e.Перебираем недавние предметы. todo –
это T oDoItemViewModel, как того требует
частичное представление.
Используем тег-хелпер partial
для визуализации частичного представления
_T oDo, передавая модель для визуализации.

267 Макеты, частичные представления и _ViewStart
Такой подход означал, что вам не нужно было загрязнять каждую модель
представления страницы элементами, необходимыми для визуализации
корзины, но он в корне нарушал паттерн проектирования MVC, ссылаясь на
контроллеры из представления.
В ASP.NET Core дочерних действий больше нет. Их заменили компоненты
представления.  Концептуально они очень похожи тем, что допускают вы-
полнение произвольного кода и визуализацию HTML, но не вызывают дей-
ствия контроллера напрямую. Можно рассматривать их как более мощное
частичное представление, которое следует использовать везде, где частич-
ное представление должно содержать значимый код или бизнес-логику. Вы
увидите, как создать небольшой компонент представления, в главе 20.
Частичные представления – не единственный способ уменьшить дуб-
лирование в  шаблонах представлений. Razor также позволяет перено-
сить общие элементы, такие как объявления пространств имен и конфи-
гурацию макета, в централизованные файлы. В следующем разделе вы
увидите, как использовать эти файлы для очистки своих шаблонов.
7.4.4 Выполнение кода в каждом представлении
с помощью _ViewStart и _ViewImports
Из-за природы представлений вы неизбежно обнаружите, что вы сно-
ва и  снова пишете определенные вещи. Если все ваши представления
используют один и тот же макет, то при добавлении следующего кода
в верхнюю часть каждой страницы вы почувствуете, что это лишнее:
@{
Layout = "_Layout";
}
Точно так же, если вы обнаружите, что вам нужно ссылаться на объ-
екты из другого пространства имен в ваших представлениях Razor, тогда
добавление @using WebApplication1.Models в верхнюю часть каждой стра-
ницы может стать рутиной. К счастью, у ASP .NET Core есть два механиз-
ма, чтобы справиться с этими распространенными задачами: _ViewIm-
ports.cshtml и _ViewStart.cshtml.
иМпорт  общих  директив  с поМощью  _ViewiMPoRTs
Файл _ViewImports.cshtml содержит директивы, которые будут встав-
ляться в верхнюю часть каждого представления. Сюда входят такие ин-
струкции, как @using и  @model, которые вы уже видели, – в основном это
любая директива Razor. Чтобы не добавлять инструкцию в каждое пред-
ставление, можно включить ее в  _ViewImports.cshtml, а  не в  страницы
Razor.

268 Глава 7 Визуализация HTML-кода с использованием представлений Razor
Листинг 7.14  Типичный файл _ViewImports.cshtml, импортирующий
дополнительные пространства имен
@using WebApplication1
@using WebApplication1.Pages
@using WebApplication1.Models
@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers
Файл _ViewImports.cshtml можно поместить в любую папку, и он будет
применяться ко всем представлениям и вложенным папкам. Как прави-
ло, он помещается в корневую папку Pages и применяется ко всем стра-
ницам Razor и частичному представлению в вашем приложении.
Важно отметить, что нужно помещать директивы Razor только в  _
ViewImports .cshtml – нельзя помещать туда старый код C#. Как видно
из предыдущего листинга, вы ограничены такими конструкциями, как
@using или директива @addTagHelper, о которых вы узнаете в следующей
главе. Если вы хотите выполнять произвольный C# в  начале каждого
представления приложения, например чтобы задать свойство Layout, то
должны использовать файл _ViewStart.cshtml.
выполнение  кода для каждоГ о представления  с поМощью  _ViewsTaRT
Можно легко выполнить общий код в  начале каждой страницы Razor,
добавив файл _ViewStart.cshtml в папку Pages своего приложения. Этот
файл может содержать любой код Razor, но обычно он используется,
чтобы задать свойство Layout для всех страниц вашего приложения, как
показано в  следующем листинге. Затем можно опустить инструкцию
Layout на всех страницах, использующих макет по умолчанию. Если для
представления необходимо использовать макет, отличный от макета по
умолчанию, можно переопределить его, задав значение на самой стра-
нице Razor.
Листинг 7.15  Типичный файл _ViewStart.cshtml, задающий макет
по умолчанию
@{
Layout = "_Layout";
}
Любой код в  файле _ViewStart.cshtml выполняется до выполнения
представления. Обратите внимание, что _ViewStart.cshtml запускается
только для представлений Razor Page – он не запускается для макетов
или частичных представлений.
Также обратите внимание, что имена для этих специальных файлов
Razor являются обязательными. Это не соглашения, которые можно из-
менить. Пространство имен по умолчанию
для вашего приложения и папка Pages.
Добавьте эту директиву,
чтобы не размещать ее
в каждом представлении.Делает доступными тег-хелперы в ваших
представлениях, добавляется по умолчанию.

269 Макеты, частичные представления и _ViewStart
ВНИМАНИЕ!  Вы должны использовать имена _ViewStart.cshtml
и  _ViewImports.cshtml, чтобы движок Razor мог их найти и  пра-
вильно выполнить. Чтобы применить их ко всем страницам своего
приложения, добавьте их в корень папки Pages, а не во вложенную
папку Shared.
Вы можете указать дополнительные файлы _ViewStart.cshtml или
_ViewImports.cshtml, чтобы они выполнялись для подмножества ваших
представлений, включив их во вложенную папку в Pages. Файлы во вло-
женных папках будут выполняться после файлов в корневой папке Pages.
Частичные представления, макеты и AJAX
В этой главе описывается, как использовать Razor для отрисовки целиковых
HTML-страниц на стороне сервера, которые затем отправляются в браузер
пользователя в традиционных веб-приложениях. Распространенным альтер-
нативным подходом при создании веб-приложений является использование
фреймворка Java Script для создания одностраничного приложения (SPA)
на стороне клиента, которое визуализирует HTML-код на стороне клиента
в браузере.
Одной из технологий, которые обычно используют одностраничные прило-
жения, является AJAX (асинхронный Java Script и XML), когда браузер отправ-
ляет запросы в ваше приложение ASP.NET Core, не перезагружая целиком
новую страницу. Также можно использовать запросы AJAX с приложениями,
применяющими отрисовку на стороне сервера. Для этого вы должны приме-
нять Java Script, чтобы запрашивать обновление части страницы.
Если вы хотите использовать AJAX с приложением, использующим Razor, то
следует рассмотреть возможность широкого применения частичных пред-
ставлений. Тогда вы можете предоставлять к ним доступ с по мощью допол-
нительных обработчиков страниц Razor, как показано в этой статье: http://
mng.bz/vzB1. Использование AJAX может уменьшить общий объем данных,
которые необходимо пересылать между браузером и  вашим приложени-
ем, благодаря чему приложение будет работать более плавно и станет от -
зывчивее, поскольку не нужно будет загружать полностью столько страниц.
Но использование AJAX с Razor может добавить сложности, особенно для
больших приложений. Если вы уверены, что будете широко применять AJAX
для создания высокодинамических веб-приложений, то можно рассмотреть
возможность использования контроллеров веб-API и фреймворка для раз-
работки приложений на стороне клиента (см. главу 9) или подумать об ис -
пользовании Blazor.
В этой главе я сосредоточился на использовании представлений Razor
с фреймворком Razor Page, поскольку именно такой подход я предлагаю
при создании приложения ASP .NET Core с отрисовкой на стороне серве-
ра. Однако, как я писал в главе 4, в некоторых случаях можно использо-

270 Глава 7 Визуализация HTML-кода с использованием представлений Razor
вать контроллеры MVC. В последнем разделе этой главы мы рассмотрим,
как визуализировать представления Razor из действий вашего контрол-
лера MVC и как фреймворк находит правильное представление Razor для
визуализации.
7.5 Выбор представления из контроллера MVC
В этом разделе:
как контроллеры MVC используют ViewResults для визуализации
представлений Razor;
как создать новое представление Razor;
как фреймворк находит представление Razor для визуализации.
Если вы последуете моему совету из главы 4, то вам следует использо-
вать Razor Pages для своих приложений с отрисовкой на стороне сервера
вместо контроллеров MVC, которые были распространены в версиях 1.x
и 2.x. Одним из существенных преимуществ Razor Pages является близ-
кое расположение представления Razor и связанных обработчиков стра-
ниц. Вам не нужно перемещаться между папками.
Если по какой-то причине вам действительно нужно использовать
контроллеры MVC вместо Razor Pages, важно понимать, как вы выби-
раете, какое представление визуализировать после выполнения метода
действия. На рис. 7.13 этот процесс показан в увеличенном виде сразу
после того, как действие вызвало модель приложения и вернуло некие
данные.
Кое-что из этого рисунка должно быть знакомо – это нижняя половина
рис. 4.6 из главы 4 (с парой дополнений) и эквивалент MVC на рис. 7.1.
Метод действия контроллера MVC использует объект ViewResult, чтобы
указать, что нужно визуализировать представление Razor. Этот объект
содержит имя шаблона представления Razor, которое нужно визуализи-
ровать, и модель представления – произвольный класс POCO, содержа-
щий данные для визуализации.
ПРИМЕЧАНИЕ  Мы обсуждали объекты ViewResult в главе 4. Они
представляют собой MVC-эквивалент объекта PageResult страни-
цы Razor. Основное отличие состоит в том, что ViewResult вклю-
чает в себя имя представления, которое нужно визуализировать,
и модель, которую нужно передать в шаблон представления, в то
время как PageResult всегда отображает связанное представление
страницы Razor и передает PageModel в шаблон представления.
После возврата объекта ViewResult из метода действия поток управ-
ления возвращается к фреймворку MVC, который использует эвристику
для поиска представления на основе предоставленного имени шаблона.
После того как шаблон представления Razor найден, движок Razor пере-
дает модель представления из объекта ViewResult в представление и вы-

271 Выбор представления из контроллера MVC
полняет шаблон для генерации окончательного HTML-кода. Этот послед-
ний шаг, визуализация HTML-кода, по сути, представляет собой тот же
процесс, что мы наблюдали для Razor Pages.
Действие
Контроллер
Имя шаблона
представления
Модель представления
Модель представленияViewResult
Поиск
шаблона
Представление
HTML 1.  Последний шаг, сделанный методом
действия MVC, – создание модели
представления и выбор имени
представления Razor, которое будет
визуализировано
2.  Имя представления и модель
представления инкапсулированы
в объект ViewResult, который
возвращается из метода действия
4.  После того как шаблон будет найден,
представление Razor передается
в модель представления и вызывается
для генерации окончательного
HTML-кода
5.  Сгенерированный HTML-код
передается обратно через конвейер
промежуточного ПО и обратно
в браузер пользователя 3.  Фреймворк MVC использует имя
представления, чтобы найти
конкретный шаблон представления
Razor для визуализации
Рис. 7.13 Процесс генерации HTML-кода из контроллера MVC с использованием объекта
ViewResult. Это очень похоже на процесс для страницы Razor. Основное отличие состоит в том,
что в случае с Razor Pages представление является неотъемлемой частью страницы Razor;
в случае с контроллерами MVC представление должно быть найдено во время выполнения
Вы видели, как создавать контроллеры, в главе 4, а в этом разделе вы
узнаете, как создавать представления и объекты ViewResult, а также как
указать шаблон для визуализации. Можно добавить новый шаблон пред-
ставления в свое приложение в Visual Studio и, щелкнув правой кнопкой
мыши в приложении MVC в Обозревателе решений, выбрать Add > New
Item (Добавить > Новый элемент), а затем – Razor View (Представление
Razor) в диалоговом окне, как показано на рис. 7.14. Если вы не исполь-
зуете Visual Studio, то создайте в папке Views новый пустой файл с рас -
ширением .cshtml.
Создав шаблон представления, нужно его вызвать. В  большинстве
случаев нельзя создавать объект ViewResult непосредственно в методах
действий. Вместо этого воспользуйтесь одним из вспомогательных ме-
тодов View базового класса Controller. Эти методы упрощают передачу
модели представления и выбор шаблона представления, но в них нет ни-
чего волшебного – все, что они делают, – это создают объекты ViewResult.

272 Глава 7 Визуализация HTML-кода с использованием представлений Razor
Рис. 7.14 Диалоговое окно «Добавить новый элемент». Выберите Razor View – Empty
и добавьте новый файл шаблона представления Razor в свое приложение
В простейшем случае можно вызвать метод View без аргументов, как
показано в следующем листинге. Этот вспомогательный метод возвра-
щает объект ViewResult, который будет использовать соглашения, чтобы
найти шаблон представления для визуализации, и не будет предостав-
лять модель представления при выполнении представления.
Листинг 7.16  Возвращаем объект ViewResult из метода действия,
используя соглашения по умолчанию
public class HomeController : Controller
{
public IActionResult Index()
{
return View();
}
}
В этом примере вспомогательный метод View возвращает объект
ViewResult без указания имени шаблона для выполнения. Имя исполь-
зуемого шаблона основано на имени контроллера и имени метода дей-
ствия. Учитывая, что контроллер называется HomeController, а метод –
Index, по умолчанию шаблонизатор Razor ищет шаблон в расположении
Views/Home/Index.cshtml, как показано на рис. 7.15.
Это еще один случай использования соглашений в MVC, чтобы умень-
шить количество шаблонного кода, который вам нужно написать. Как
всегда, соглашения необязательны. Вы также можете явно передать имя
шаблона для выполнения в  виде строки методу View. Например, если
метод Index возвратил View("ListView"), шаблонизатор будет искать Наследование от базового класса
Controller делает доступными
вспомогательные методы View.
Вспомогательный метод View
возвращает объект ViewResult.

273 Выбор представления из контроллера MVC
шаблон с именем ListView.cshtml. Вы даже можете указать полный путь
к файлу представления относительно корневой папки своего приложе-
ния, например View("Views/global.cshtml"), который будет искать шаб-
лон в расположении Views/global.chtml.
ПРИМЕЧАНИЕ  При указании абсолютного пути к  представле-
нию необходимо включить в путь и папку верхнего уровня Views,
и  файл с  расширением .cshtml. Это напоминает правила поиска
шаблонов частичных представлений.
Файлы представлений
Razor находятся в папке Views
Представления HomeController
по умолчанию будут
находиться в папке Home
Представления в папке Shared
могут быть вызваны любым
контроллером Представления имеют то же
имя, что и соответствующий
метод действия
Рис. 7.15 Поиск файлов представлений во время выполнения производится в соответствии
с соглашениями об именах. Файлы представления Razor находятся в папке на основе имени
ассоциированного контроллера MVC и носят имя метода действия, который их запрашивал.
Представления в папке Shared могут использоваться любым контроллером
Процесс поиска представления MVC Razor очень похож на процесс по-
иска частичного представления для визуализации, как вы видели в раз-
деле 7.4. Фреймворк выполняет поиск в нескольких местах, чтобы найти
запрашиваемое представление. Разница состоит в том, что в случае с Ra-
zor Pages процесс поиска выполняется только для визуализации частич-
ного	 представления, поскольку основное представление Razor, которое
нужно визуализировать, уже известно – это шаблон представления стра-
ницы Razor.
На рис.  7.16 показан полный процесс, используемый фреймворком
MVC для поиска правильного шаблона представления для выполнения,
когда объект ViewResult возвращается из контроллера MVC. Может быть

274 Глава 7 Визуализация HTML-кода с использованием представлений Razor
найдено несколько шаблонов, например если файл Index.chstml присут -
ствует в папках Home и Shared. Аналогично правилам поиска частичных
представлений, движок будет использовать первый найденный шаблон.
Метод действия
MVC создает объект
ViewResult
Указан ли абсолютный
путь представления?
Находится ли
представление в views/
controller/action?
Находится ли
представление в views/
shared/action?
Выброс исключения:
InvalidOperationExceptionВыброс исключения:
InvalidOperationException
Имя
действия
Имя
действияИмя
контроллераЕсть ли представление
по указанному пути?
Использовать указанный
абсолютный путь
Использовать путь
views/controller/action
Использовать путь
views/shared/actionДа
ДаНетНет
Нет
Нет
НетДа
Рис. 7.16 Блок-схема, описывающая, как шаблонизатор Razor находит правильный
шаблон представления для выполнения. Избегайте сложности этой диаграммы. Это
одна из причин, по которой я рекомендую использовать Razor Pages везде, где это
возможно!
СОВЕТ  Можно изменить все эти соглашения, включая алгоритм,
показанный на рис. 7.16, во время начальной настройки. Фактиче-
ски можно заменить весь шаблонизатор Razor, если потребуется,
но данная тема выходит за рамки этой книги.

275 Выбор представления из контроллера MVC
У вас может возникнуть соблазн явно указать имя файла представле-
ния, который вы хотите визуализировать в контроллере. Если это так, то
я бы посоветовал вам побороть желание. Будет намного проще, если вы
примете соглашения такими, какие они есть, и будете им следовать. Это
распространяется на всех, кто просматривает ваш код; если вы будете
придерживаться стандартных соглашений, им будет комфортно иметь
дело с вашим приложением. А от этого будет только польза!
Помимо указания имени шаблона представления, вы также можете
передать объект, который будет действовать как модель представления
для представления Razor. Этот объект должен соответствовать типу, ука-
занному в директиве представления @model, и доступ к нему осуществ-
ляется точно так же, как и для Razor Pages, – используя свойство Model.
В  следующем листинге показаны два примера передачи модели пред-
ставления в представление.
Листинг 7.17  Возвращаем объект ViewResult из метода действия
с использованием соглашений по умолчанию
public class ToDoController : Controller
{
public IActionResult Index()
{
var listViewModel = new ToDoListModel();
return View(listViewModel);
}
public IActionResult View(int id)
{
var viewModel = new ViewToDoModel();
return View("ViewToDo", viewModel);
}
}
После того как шаблон представления Razor будет найден, представ-
ление визуализируется с  использованием синтаксиса Razor, который
вы видели в этой главе. Вы можете использовать все уже знакомые вам
функции, например макеты, частичные представления, _ViewImports
и _ViewStart. С точки зрения представления Razor между представлени-
ем Razor Pages и представлением MVC Razor нет разницы.
На этом мы завершаем наше знакомство с визуализацией HTML-кода
с использованием шаблонизатора Razor. В следующей главе вы узнаете
о тег-хелперах и о том, как их использовать для создания HTML-форм,
которые являются основным элементом современных веб-приложений.
Тег-хелперы – одно из самых существенных улучшений Razor в ASP .NET
Core по сравнению с предыдущей версией, поэтому их освоение сде-
лает редактирование ваших представлений в  целом более приятным
занятием!Создание экземпляра модели
представления для передачи
в представление Razor.
Модель представления передается
View в качестве аргумента.
Можно указать имя шаблона
представления одновременно
с моделью представления.

276 Глава 7 Визуализация HTML-кода с использованием представлений Razor
Резюме
В паттерне проектирования MVC представления отвечают за создание
пользовательского интерфейса вашего приложения.
Razor  – это язык шаблонов, позволяющий генерировать динамиче-
ский HTML-код, используя смесь HTML и C#.
HTML-формы – это стандартный подход для отправки данных из брау -
зера на сервер. Можно использовать тег-хелперы, чтобы с легкостью
создавать эти формы.
Razor Pages может передавать строго типизированные данные в пред-
ставление Razor, задавая открытые свойства в  PageModel. Чтобы полу -
чить доступ к свойствам модели представления, представление долж -
но объявить тип модели с по мощью директивы @model.
Обработчики страниц могут передавать пары «ключ-значение»
в представление с по мощью словаря ViewData.
Выражения Razor визуализируют значения C# в  выводе HTML с  по-
мощью символов @ или @(). При использовании выражений Razor не
нужно ставить точку с запятой после инструкции.
Блоки кода Razor, определенные с по мощью @{}, выполняют код C#
без вывода HTML. Блоки кода C# в Razor должны быть полными ин-
струкциями, поэтому должны включать точки с запятой.
Циклы и  условные выражения можно использовать для простой ге-
нерации динамического HTML-кода в  шаблонах, но рекомендуется,
в частности, ограничить количество операторов if, чтобы ваши пред-
ставления можно было легко читать.
Если вам нужно визуализировать строку как низкоуровневый HTML-
код, можно использовать Html.Raw, но делайте это осторожно – отобра-
жение низкоуровневого пользовательского ввода может привести
к возникновению бреши в системе безопасности вашего приложения.
Тег-хелперы позволяют привязать вашу модель данных к элементам
HTML, благодаря чему становится проще генерировать динамический
HTML-код, сохраняя при этом удобство редактирования.
В макете можно разместить общий HTML-код для нескольких пред-
ставлений. Макет будет отображать любое содержимое из дочернего
представления в месте, где вызывается функция @RenderBody.
Инкапсулируйте часто используемые фрагменты кода Razor в частич-
ном представлении. Частичное представление можно визуализиро-
вать с по мощью тега <partial/>.
Файл _ViewImports.cshtml можно использовать для включения общих
директив, таких как инструкции @using, во всех представлениях.
Файл _ViewStart.cshtml вызывается перед выполнением каждой стра-
ницы Razor и  может использоваться для выполнения кода, общего
для всех страниц Razor, например для установки страницы макета по
умолчанию. Он не выполняется для макетов или частичных представ-
лений.

277 Резюме
_ViewImports.cshtml и  _ViewStart.cshtml являются иерархическими –
файлы в корневой папке выполняются первыми, а за ними следуют
файлы в папках представления для конкретного контроллера.
Контроллеры могут вызывать представление Razor, возвращая объект
ViewResult. Он может содержать имя представления для визуализации
и, необязательно, объект модели представления, который будет ис -
пользоваться при отрисовке представления. Если имя представления
не указано, представление выбирается с использованием соглашений.
По соглашению, представления MVC Razor именуются так же, как
и вызывающий их метод действия. Они находятся либо в папке с тем
же именем, что и контроллер метода действия, либо в папке Shared.

8Создание	форм
с помощью тег-хелперов
В этой главе:
простое создание форм с по мощью тег-хелперов;
генерация URL-адресов с по мощью Anchor Tag
Helper;
использование тег-хелперов для добавления
функций в Razor.
В главе 7 вы узнали о шаблонах Razor и о том, как использовать их для
создания представлений для вашего приложения. Смешивая HTML и C#,
можно создавать динамические приложения, которые могут отображать
разные данные в зависимости от запроса, вошедшего в систему пользо-
вателя или любых других данных, к которым вы можете получить доступ.
Отображение динамических данных  – важный аспект многих веб-
приложений, но обычно это только половина дела. Помимо отображения
данных пользователю, часто требуется, чтобы пользователь мог отправ-
лять данные обратно в ваше приложение. Вы можете использовать дан-
ные для настройки представления или чтобы обновить модель прило-
жения, например сохранив ее в базе данных. В случае с традиционными
веб-приложениями эти данные обычно отправляются с использованием
HTML-формы.
В главе 6 вы узнали о привязке модели, то есть о том, как принимать
данные, отправленные пользователем в  запросе, и  конвертировать их
в  объекты C#, которые можно использовать на своих страницах Razor.
Вы также узнали, что такое валидация и как важно проверять данные,

279 Создание форм с помощью тег-хелперов
отправленные в запросе. Вы использовали атрибуты DataAnnotations для
определения правил, связанных с вашими моделями, а также другие ме-
таданные, такие как отображаемое имя свойства.
Последний аспект, который мы еще не рассмотрели,  – это создание
HTML-форм, которые пользователи используют для отправки этих дан-
ных в  запросе. Формы  – один из основных способов взаимодействия
пользователей с вашим приложением в браузере, поэтому важно, чтобы
они были правильно определены и удобны для пользователя. Для этой
цели ASP .NET Core предоставляет функцию под названием тег-хелперы.
Тег-хелперы – новинка от ASP .NET Core. Это дополнения к синтаксису
Razor, которые можно использовать для настройки HTML-кода, генери-
руемого в ваших шаблонах. Тег-хелперы можно добавить к стандартно-
му элементу HTML, такому как <input>, для настройки его атрибутов на
основе вашей модели C#, избавляя вас от необходимости писать шаблон-
ный код. Они также могут быть автономными элементами и использо-
ваться для генерации полностью настраиваемого HTML-кода.
ПРИМЕЧАНИЕ  Помните, что Razor, а  следовательно, и  тег-
хелперы предназначены для отрисовки HTML-кода на стороне сер-
вера. Тег-хелперы нельзя использовать напрямую в таких фрейм-
ворках, как Angular или React.
Если вы использовали предыдущую версию ASP .NET, то тег-хелперы
могут напомнить вам HTML-хелперы, которые также можно использо-
вать для генерации HTML-кода на основе ваших классов C#. Тег-хелперы
являются логическим преемником HTML-хелперов, поскольку обеспечи-
вают более упрощенный синтаксис по сравнению с предыдущими вари-
антами, ориентированными на C#. HTML-хелперы по-прежнему доступ-
ны в ASP .NET Core, поэтому если вы конвертируете некоторые старые
шаблоны в ASP .NET Core, то можете использовать их в своих шаблонах,
но я не буду рассматривать их в этой книге.
В данной главе вы узнаете, как использовать тег-хелперы при созда-
нии форм. Они упрощают процесс создания правильных имен и иден-
тификаторов элементов, поэтому привязка модели может происходить
без проблем при отправке формы обратно в  ваше приложение. Чтобы
рассматривать их в  контексте, мы продолжим создание приложения
конвертера валют, которое вы видели в предыдущих главах. Мы добавим
возможность отправлять ему запросы на обмен валюты, проверять дан-
ные и повторно отображать ошибки в форме с по мощью тег-хелперов,
которые сделают всю работу за вас, как показано на рис. 8.1.
По мере разработки приложения вы познакомитесь с  наиболее рас -
пространенными тег-хелперами, с  которыми встретитесь при работе
с формами. Вы также увидите, как с их помощью упростить другие рас -
пространенные задачи, такие как создание ссылок, условное отображе-
ние данных в вашем приложении, и как сделать так, чтобы пользователи
видели последнюю версию файла изображения, когда обновляют стра-
ницу в браузере.

280 Глава 8 Создание форм с помощью тег-хелперов
Рис. 8.1 Формы приложения конвертера валют, созданные с по мощью тег-хелперов. Ярлыки,
раскрывающиеся списки, элементы ввода и сообщения о валидации генерируются с по мощью
тег-хелперов
Для начала я немного расскажу, для чего нужны тег-хелперы, если Ra-
zor уже может сгенерировать любой HTML-код, который вы пожелаете,
путем объединения C# и HTML в один файл.
8.1 Редакторы кода и тег-хелперы
Одна из распространенных жалоб на сочетание C# и HTML в шаблонах
Razor заключается в том, что с ними нелегко использовать стандартные
инструменты редактирования HTML-кода; все символы @ и {} в коде C#,
как правило, сбивают редакторы кода с толку. Чтение шаблонов также
может представлять трудность и  для людей; переключение парадигм
между C# и HTML иногда может немного раздражать.
Возможно, это не было такой проблемой, когда Visual Studio был един-
ственным поддерживаемым способом создания веб-сайтов на ASP .NET,
поскольку, очевидно, он мог без проблем понимать шаблоны и услужли-
во использовать выделение цветом в редакторе. Но поскольку ASP .NET
Core становится кросс-платформенным, снова стало появляться желание
поэкспериментировать с другими редакторами.
Это было одной из главных мотиваций для создания тег-хелперов.
Они легко интегрируются в стандартный синтаксис HTML, добавляя эле-
менты, которые выглядят как атрибуты, обычно начинающиеся с asp-*.
Чаще всего они используются для создания HTML-форм, как представле-
но в следующем листинге. В нем показано представление из первой ите-

281 Редакторы кода и тег-хелперы
рации приложения конвертера валют, в котором вы выбираете валюту
и сумму для конвертации.
Листинг 8.1 Форма регистрации пользователя с использованием
тег-хелперов
@page
@model ConvertModel
<form method="post">
<div class="form-group">
<label asp-for="CurrencyFrom"></label>
<input class="form-control" asp-for="CurrencyFrom" />
<span asp-validation-for="CurrencyFrom"></span>
</div>
<div class="form-group">
<label asp-for="Quantity"></label>
<input class="form-control" asp-for="Quantity" />
<span asp-validation-for="Quantity"></span>
</div>
<div class="form-group">
<label asp-for="CurrencyTo"></label>
<input class="form-control" asp-for="CurrencyTo" />
<span asp-validation-for="CurrencyTo"></span>
</div>
<button type="submit" class="btn btn-primary">Submit</button>
</form>
На первый взгляд, вы можете даже не заметить тег-хелперы, настоль-
ко хорошо они сочетаются с HTML-кодом! Это упрощает редактирование
файлов с  по мощью любого стандартного текстового редактора HTML.
Но не беспокойтесь о  том, что вы пожертвовали удобочитаемостью,
предоставляемой Visual Studio, – как видно на рис. 8.2, элементы с тег-
хелперами четко отличаются от стандартного элемента <div> и  стан-
дартного атрибута class элемента <input>.
Рис. 8.2 В Visual Studio тег-хелперы отличаются от обычных элементов жирным
шрифтом и другим цветом, код C# затенен, и доступна технология IntelliSenseЭто представление для страницы Razor
Convert.cshtml. Тип модели – ConvertModel.
asp-for рядом
с тегами
<label>
генерирует
заголовок для
ярлыков на
основе модели
представления.asp-for рядом
с тегами <input>
генерирует
правильный
тип, значение,
имя и атрибуты
валидации
для модели.
Сообщения о валидации записываются
в теги <span> с по мощью тег-хелперов.

282 Глава 8 Создание форм с помощью тег-хелперов
Свойства C# модели представления, на которую ссылаются (CurrencyFrom
в данном случае), также по-прежнему затенены, как и другой код C# в фай-
лах Razor. И конечно же, у вас будет IntelliSense, как и следовало ожидать1.
Тег-хелперы – это дополнительные атрибуты стандартных элементов
HTML (или полностью новые элементы), которые работают путем из-
менения HTML-элемента, к которому они прикреплены. Они позволя-
ют легко интегрировать ваши значения на стороне сервера, как те, что
представлены в PageModel, со сгенерированным HTML-кодом.
Обратите внимание, что в листинге 8.1 не указаны заголовки, кото-
рые будут отображаться в ярлыках. Вместо этого мы декларативно ис -
пользовали asp-for="CurrencyFrom", чтобы сказать: «для этого элемента
<label> используйте свойство CurrencyFrom, чтобы определить, какой
заголовок использовать». Аналогичным образом для элементов <input>
тег-хелперы используются, чтобы:
автоматически заполнять значение из свойства PageModel;
выбрать правильный идентификатор и  имя, чтобы при отправке
формы обратно на страницу Razor свойство было правильно при-
вязано к модели;
выбрать правильный тип ввода для отображения (например, число-
вой ввод для свойства Quantity);
отобразить все ошибки валидации, как показано на рис. 8.32.
Т екст заголовка рассчитывается
на основе атрибута [Display]
Типы исходных данных, определенные
на основе DataAnnotations
и типа свойства
Сообщение об ошибке валидации,
заполненное из ModelState
Рис. 8.3 Т ег-хелперы подключаются к метаданным, предоставляемым атрибутами
DataAnnotations, а также самим типам свойств. Т ег-хелпер валидации может
даже заполнять сообщения об ошибках на основе ModelState, как вы видели
в предыдущей главе
1 Другие редакторы, такие как Visual Studio Code, JetBrains Rider и Visual Studio
for Mac, также включают подсветку синтаксиса и поддержку IntelliSense.
2 Чтобы узнать больше о  внутреннем устройстве тег-хелперов, прочтите до-
кументацию на странице https://docs.microsoft.com/en-us/aspnet/core/mvc/
views/tag-helpers/authoring?view=aspnetcore-5.0.

283 Создание форм с по мощью тег-хелперов
Тег-хелперы могут выполнять множество функций, изменяя элементы
HTML, к которым они применяются. В этой главе рассказывается о не-
скольких распространенных тег-хелперах и о том, как их использовать,
но это не исчерпывающий список. Я не буду рассказывать обо всех тег-
хелперах, которые входят в  стандартную комплектацию ASP .NET Core
(с каждым выпуском их будет все больше!), а вы легко можете создать
собственные тег-хелперы, как вы увидите в главе 19. В качестве альтер-
нативы можно использовать те, что опубликованы другими на NuGet или
GitHub1. Как и в отношении всего, что касается ASP .NET Core, корпорация
Microsoft разрабатывает тег-хелперы в открытом виде на GitHub, поэто-
му вы всегда можете взглянуть на исходный код, чтобы увидеть, как они
реализованы.
Вспоминая WebForms
У тех, кто использовал ASP.NET еще во времена WebForms, до появления
шаблона MVC для веб-разработки, тег-хелперы могут вызывать плохие вос -
поминания. Хотя префикс asp- чем-то напоминает определения элементов
управления веб-сервера ASP.NET, не бойтесь – это два разных существа.
Элементы управления веб-сервера были напрямую добавлены в сопутству-
ющий класс страницы C# и имели обширную область действия, которая мог -
ла изменять, казалось бы, несвязанные части страницы. В сочетании с этим
у них был сложный жизненный цикл, который было трудно понять и отла-
дить, когда что-то не работало. Опасность попытки работать с таким уровнем
сложности не забыта, но тег-хелперы не то же самое.
У тег-хелперов нет жизненного цикла – они участвуют в отрисовке элемента,
к которому прикреплены, и все. Они могут изменять HTML-элемент, к кото-
рому прикреплены, но не могут изменять что-либо еще на вашей странице,
что значительно упрощает их концептуально. Дополнительная возможность,
которую они привносят, – это возможность иметь несколько тег-хелперов,
действующих на один элемент, – что нелегко было сделать с по мощью эле-
ментов управления веб-сервером.
В целом когда вы пишете шаблоны Razor, то получите гораздо больше удоволь-
ствия, если будете использовать тег-хелперы как неотъемлемую часть его син-
таксиса. Они приносят много пользы без очевидных недостатков, и ваши друзья,
использующие кросс-платформенные редакторы, будут вам благодарны!
8.2 Создание форм с по мощью тег-хелперов
В этом разделе вы узнаете, как использовать одни из наиболее полезных
тег-хелперов: тег-хелперы, которые работают с  формами. Вы увидите,
как использовать их для генерации разметки HTML на основе свойств
1 Неплохой пример – пакет Tag Helper от Дэмиана Эдвардса (из команды ASP .
NET Core): https://github.com/DamianEdwards/TagHelperPack.

284 Глава 8 Создание форм с помощью тег-хелперов
PageModel, создавая правильные атрибуты id и name и задавая value эле -
мента значению свойства модели (среди прочего). Такая возможность
значительно сокращает объем разметки, которую необходимо писать
вручную.
Представьте, что вы создаете страницу оформления заказа для прило-
жения конвертера валют и вам нужно получить данные пользователя на
странице оформления заказа. В главе 6 мы создали модель UserBinding-
Model (показанную в листинге 8.2), добавили атрибуты DataAnnotations
для валидации и  увидели, как привязать ее к  модели в  POST-запросе
к странице Razor. В этой главе вы увидите, как создать для нее представ-
ление, предоставив UserBindingModel в качестве свойства PageModel.
ПРЕДУПРЕЖДЕНИЕ  Используя Razor Pages, вы часто предостав-
ляете в своем представлении тот же объект, который используете
для привязки модели. Делая это, нужно быть осторожными, чтобы
не включить в модель привязки конфиденциальные значения (ко-
торые не следует редактировать), дабы избежать атак с по мощью
оверпостинга на ваше приложение1.
Листинг 8.2  UserBindingModel для создания пользователя на странице
оформления заказа
public class UserBindingModel
{
[Required]
[StringLength(100, ErrorMessage = "Maximum length is {1}")]
[Display(Name = "Your name")]
public string FirstName { get; set; }
[Required]
[StringLength(100, ErrorMessage = "Maximum length is {1}")]
[Display(Name = "Last name")]
public string LastName { get; set; }
[Required]
[EmailAddress]
public string Email { get; set; }
[Phone(ErrorMessage = "Not a valid phone number.")]
[Display(Name = "Phone number")]
public string PhoneNumber { get; set; }
}
UserBindingModel декорирована рядом атрибутов DataAnnotations.
В главе 6 вы видели, что эти атрибуты используются во время валида-
ции модели, когда модель привязывается к запросу, до того, как будет
1 Подробнее об этих атаках можно узнать в моем блоге по адресу http://mng.bz/
RXw0.

285 Создание форм с по мощью тег-хелперов
выполнен обработчик страницы. Они	также используются языком шаб-
лонизатора Razor для предоставления метаданных, необходимых для ге-
нерации правильного HTML-кода при использовании тег-хелперов.
Можно использовать паттерн, описанный в главе 6, предоставив User-
BindindModel в качестве свойства Input вашей PageModel, чтобы исполь-
зовать модель и для привязки модели, и в представлении Razor:
public class CheckoutModel: PageModel
{
[BindProperty]
public UserBindingModel Input { get; set; }
}
С помощью свойства UserBindingModel, тег-хелперов и небольшого ко-
личества HTML-кода можно создать представление Razor, позволяющее
пользователю вводить сведения о себе, как показано на рис. 8.4.
Рис. 8.4 Страница для ввода сведений о пользователе. HTML-код генерируется
на основе UserBindingModel, используя тег-хелперы для визуализации необходимых
значений элемента, типов вводимых данных и сообщений валидации
Шаблон Razor для создания этой страницы показан в  листинге 8.3.
В этом коде используются различные тег-хелперы, в том числе:

286 Глава 8 Создание форм с помощью тег-хелперов
тег-хелпер Form для элемента <form>;
тег-хелпер Label для элементов <label>;
тег-хелпер Input для элементов <input>;
тег-хелпер Validation для элементов валидации <span> у  каждого
свойства в UserBindingModel.
Листинг 8.3 Шаблон Razor для привязки к UserBindingModel
@page
@model CheckoutModel
@{
ViewData["Title"] = "Checkout";
}
<h1>@ViewData["Title"]</h1>
<form asp-page="Checkout">
<div class="form-group">
<label asp-for="Input.FirstName"></label>
<input class="form-control" asp-for="Input.FirstName" />
<span asp-validation-for="Input.FirstName"></span>
</div>
<div class="form-group">
<label asp-for="Input.LastName"></label>
<input class="form-control" asp-for="Input.LastName" />
<span asp-validation-for="Input.LastName"></span>
</div>
<div class="form-group">
<label asp-for="Input.Email"></label>
<input class="form-control" asp-for="Input.Email" />
<span asp-validation-for="Input.Email"></span>
</div>
<div class="form-group">
<label asp-for="Input.PhoneNumber"></label>
<input class="form-control" asp-for="Input.PhoneNumber" />
<span asp-validation-for="Input.PhoneNumber"></span>
</div>
<button type="submit" class="btn btn-primary">Submit</button>
</form>
В листинге 8.4 вы видите HTML-разметку, создаваемую этим шабло-
ном. Эта разметка Razor и полученный в результате HTML-код создают
форму, которую вы видели на рис.  8.4. Видно, что каждый из HTML-
элементов с тег-хелпером был расширен при выводе: у элемента <form>
есть атрибут action, у элементов <input> – идентификатор и имя на ос -
нове имени ссылаемого свойства, а у элементов <input> и <span> – атри-
буты data-* для валидации.CheckoutModel – это PageModel,
которая предоставляет UserBindingModel
для свойства Input.
Т ег-хелперы form используют маршрутизацию
для определения URL-адреса, на который будет
отправлено содержимое формы.
Т ег-хелпер label
использует
DataAnnotations
в свойстве, чтобы
определить заголовок
для визуализации.
Т ег-хелпер input
использует
DataAnnotations
для определения
типа ввода
для генерации.
Т ег-хелпер validation отображает сообщения
об ошибках, ассоциированные с данным свойством.

287 Создание форм с по мощью тег-хелперов
Листинг 8.4 HTML-код, сгенерированный шаблоном Razor
<form action="/Checkout" method="post">
<div class="form-group">
<label for="Input_FirstName">Your name</label>
<input class="form-control" type="text"
data-val="true" data-val-length="Maximum length is 100"
id="Input_FirstName" data-val-length-max="100"
data-val-required="The Your name field is required."
Maxlength="100" name="Input.FirstName" value="" />
<span data-valmsg-for="Input.FirstName"
class="field-validation-valid" data-valmsg-replace="true"></span>
</div>
<div class="form-group">
<label for="Input_LastName">Your name</label>
<input class="form-control" type="text"
data-val="true" data-val-length="Maximum length is 100"
id="Input_LastName" data-val-length-max="100"
data-val-required="The Your name field is required."
Maxlength="100" name="Input.LastName" value="" />
<span data-valmsg-for="Input.LastName"
class="field-validation-valid" data-valmsg-replace="true"></span>
</div>
<div class="form-group">
<label for="Input_Email">Email</label>
<input class="form-control" type="email" data-val="true"
data-val-email="The Email field is not a valid e-mail address."
Data-val-required="The Email field is required."
Id="Input_Email" name="Input.Email" value="" />
<span class="text-danger field-validation-valid"
data-valmsg-for="Input.Email" data-valmsg-replace="true"></span>
</div>
<div class="form-group">
<label for="Input_PhoneNumber">Phone number</label>
<input class="form-control" type="tel" data-val="true"
data-val-phone="Not a valid phone number." Id="Input_PhoneNumber"
name="Input.PhoneNumber" value="" />
<span data-valmsg-for="Input.PhoneNumber"
class="text-danger field-validation-valid"
data-valmsg-replace="true"></span>
</div>
<button type="submit" class="btn btn-primary">Submit</button>
<input name="__RequestVerificationToken" type="hidden"
value="CfDJ8PkYhAINFx1JmYUVIDWbpPyy_TRUNCATED" />
</form>
Ух, как много разметки! Если вы новичок в  HTML, то все это может
показаться немного сложным, но важно отметить, что вам	не	нужно	было
писать	большую	 часть	этого	кода! Тег-хелперы сделали бóльшую часть
работы за вас. Они упрощают сложный механизм создания HTML-форм,
позволяя сосредоточиться на общем дизайне вашего приложения, вмес -
то того чтобы писать шаблонный код разметки.

288 Глава 8 Создание форм с помощью тег-хелперов
ПРИМЕЧАНИЕ  Если вы используете Razor для создания пред-
ставлений, тег-хелперы облегчат вам жизнь, но они совершенно
необязательны. Можно писать низкоуровневый HTML-код без них
или использовать устаревшие HTML-хелперы.
Тег-хелперы упрощают и абстрагируют процесс генерации HTML-кода
и обычно стараются делать это, не мешая вам. Если вам нужен оконча-
тельный сгенерированный HTML-код с определенным атрибутом, може-
те добавить его в  свою разметку. Это видно в  предыдущих листингах,
где атрибуты class определены в  элементах <input>, например <input
class="form-control" asp-for="Input.FirstName" />. Они переходят не-
тронутыми из Razor в вывод HTML.
СОВЕТ  Это отличается от того, как работали HTML-хелперы в пре-
дыдущей версии ASP .NET; часто требовалось чуть ли не с бубном
плясать, чтобы задать атрибуты в сгенерированной разметке.
Мало того, вы также можете задать атрибуты, которые обычно гене-
рируются тег-хелпером, как, например, атрибут type элемента <input>.
Например, если свойство FavoriteColor вашей PageModel было бы стро-
кой, тогда по умолчанию тег-хелперы сгенерировали бы элемент <input>
с по мощью этого: type="text". А если вы хотите обновить свою разметку
для использования типа выбора цвета HTML5, то сделать это банально
просто – явно задайте атрибут type в представлении Razor:
<input type="color" asp-for="FavoriteColor" />
СОВЕТ  HTML5 добавляет огромное количество функций, вклю-
чая множество элементов формы, которые вы, возможно, не встре-
чали раньше, например элементы <input> с типами range и color.
Я не буду описывать их в этой книге, но вы можете прочитать о них
на сайте Mozilla Developer Network по адресу http://mng.bz/qOc1.
В этом разделе вы создадите шаблоны Razor для калькулятора валют
с нуля, добавляя тег-хелперы, когда вам понадобится. Вы, вероятно, об-
наружите, что используете бóльшую часть тег-хелперов для создания
привычных форм в каждом приложении, даже если это просто страница
авторизации.
8.2.1 Тег-хелпер формы
Неудивительно, что первое, что вам нужно для создания HTML-формы, –
это элемент <form>. В предыдущем примере он был дополнен атрибутом
asp-page:
<form asp-page="Checkout">

289 Создание форм с по мощью тег-хелперов
В результате в окончательный HTML-код добавляются action и method,
указывающие, на какой URL-адрес должно быть отправлено содержимое
формы и какой HTTP-метод использовать:
<form action="/Checkout" method="post">
Установка атрибута asp-page позволяет указать в приложении другую
страницу Razor, на которую будет отправляться содержимое формы. Если
убрать его, содержимое уйдет обратно на тот же URL-адрес, с которого
было отправлено, что очень распространено в Razor Pages. Обычно ре-
зультат отправки содержимого формы обрабатывается на той же стра-
нице Razor, которая используется для ее отображения.
ВНИМАНИЕ!  Если вы уберете атрибут asp-page, то должны вруч-
ную добавить атрибут method="post". Это важно сделать, чтобы со-
держимое формы отправлялось с  использованием метода POST,
а не GET по умолчанию. Использование метода GET может пред-
ставлять угрозу для безопасности.
Атрибут asp-page добавляется с  по мощью FormTagHelper. Этот тег-
хелпер использует значение, предоставленное для создания URL-адреса
для атрибута action с использованием функций маршрутизации, кото-
рые описаны в конце главы 5.
ПРИМЕЧАНИЕ  Тег-хелперы могут сделать доступными для эле-
мента несколько атрибутов. Рассматривайте их как свойства объ-
екта конфигурации тег-хелпера. Добавляя единственный атрибут
asp-, вы активируете тег-хелпер для элемента. Добавление допол-
нительных атрибутов позволяет переопределять другие значения
по умолчанию для его реализации.
Тег-хелпер формы делает несколько других атрибутов доступными
в элементе <form>, которые можно использовать для настройки сгене-
рированного URL-адреса. Надеюсь, вы помните из главы 5, что можно
задать значения маршрута при генерации URL-адресов. Например, если
у вас есть страница Razor с именем Product.cshtml, использующая ди-
рективу
@page "{id}"
то полный шаблон маршрута для страницы будет выглядеть так: "Prod-
uct/{id}". Чтобы правильно сгенерировать URL-адрес этой страницы,
необходимо указать значение {id}. Как задать это значение с по мощью
тег-хелпера формы?
Тег-хелпер формы определяет подстановочный атрибут asp-route-*,
который можно использовать, чтобы задать произвольные параметры
маршрута. Задайте * в атрибуте для имени параметра маршрута. Напри-

290 Глава 8 Создание форм с помощью тег-хелперов
мер, чтобы установить параметр маршрута id, нужно установить значе-
ние asp-route-id (в следующем примере показано фиксированное зна-
чение 5, но чаще всего он будет динамическим):
<form asp-page="Product" asp-route-id="5">
На основе шаблона маршрута страницы Product.cshtml будет создана
следующая разметка:
<form action="/Product/5" method="post">
Можно добавить столько атрибутов asp-route-* к тегу <form>, сколько
нужно, чтобы сгенерировать правильный URL-адрес атрибута action. Вы
также можете настроить обработчик страницы Razor на использование
атрибута asp-page-handler. Это гарантирует, что POST-запрос формы бу -
дет обработан обработчиком, который вы указали.
ПРИМЕЧАНИЕ  Тег-хелпер формы имеет множество дополни-
тельных атрибутов, таких как asp-action и  asp-controller, кото -
рые обычно не требуется использовать с Razor Pages. Они полезны
только в том случае, если вы используете контроллеры MVC с пред-
ставлениями. В частности, обратите внимание на то, что атрибуты
asp-route и  asp-route-* – это не одно и то же. Первый использует -
ся для указания именованного маршрута (не используется с Razor
Pages), а второй – для указания значений маршрута, которые будут
применяться во время генерации URL-адреса.
Как и для всех других конструкций Razor, в тег-хелперах можно ис -
пользовать значения C# из вашей PageModel (или C# в целом). Например,
если свойство ProductId вашей PageModel содержит значение, необходи-
мое для значения маршрута {id}, можно использовать
<form asp-page="Product" asp-route-id="@Model.ProductId">
Основная задача тега-хелпера формы – создать атрибут action, но он
выполняет одну важную дополнительную функцию: создает скрытое
поле <input> для предотвращения	межсайтовой	подделки	запросов.
ОПРЕДЕЛЕНИЕ  Атаки с межсайтовой	 подделкой	 запросов (CSRF) –
это эксплойт, который может разрешить выполнение действий
на вашем веб-сайте сторонним вредоносным сайтом. Подробнее
о них вы узнаете в главе 18.
В листинге 8.4 вы видите сгенерированный скрытый тег <input>
в нижней части формы. Он называется __RequestVerificationToken и со -
держит на первый взгляд случайную строку символов. Само по себе это
поле не защитит вас, но в главе 18 я расскажу, как использовать его для
защиты своего сайта. Тег-хелпер формы генерирует его по умолчанию,

291 Создание форм с по мощью тег-хелперов
поэтому обычно не нужно беспокоиться об этом, но если вам нужно от -
ключить его, это можно сделать, добавив asp-antiforgery="false" в свой
элемент <form>.
Тег-хелпер формы, очевидно, полезен для генерации URL-адреса
атрибута action, но пора переходить к более интересным элементам –
тем, что вы видите в своем браузере!
8.2.2 Тег-хелпер метки (label)
Каждое поле <input> в  приложении конвертера валют должно иметь
ассоциированную метку, чтобы пользователь знал, для чего нужен тег
<input>. Можно бы легко создать их самостоятельно, вручную введя имя
поля и задав соответствующий атрибут for, но, к счастью, есть тег-хелпер,
который сделает это за вас.
Тег-хелпер метки используется для создания заголовка (видимого тек -
ста) и атрибута for элемента <label> на основе свойств в  PageModel, пу -
тем указания имени свойства в атрибуте asp-for:
<label asp-for="FirstName"></label>
Тег-хелпер метки использует атрибут [Display] DataAnnotations, кото -
рый вы видели в главе 6, чтобы определить соответствующее значение
для отображения. Если у свойства, для которого вы создаете метку, нет
атрибута [Display], тег-хелпер будет использовать имя свойства. Рас -
смотрим модель, в которой свойство FirstName имеет атрибут [Display],
а у свойства Email его нет:
public class UserModel
{
[Display(Name = "Your name")]
public string FirstName { get; set; }
public string Email { get; set; }
}
Используя теги
<label asp-for="FirstName"></label>
<label asp-for="Email"></label>
вы сгенерируете следующий HTML-код:
<label for="FirstName">Your name</label>
<label for="Email">Email</label>
Текст внутри элемента <label> использует значение, заданное в атри-
буте [Display], или имя свойства в случае свойства Email. Также обратите
внимание, что атрибут for был создан с именем свойства. Это ключевой
бонус использования тег-хелпера – он подключается к идентификаторам
элементов, созданным другими тег-хелперами. Вскоре вы это увидите.

292 Глава 8 Создание форм с помощью тег-хелперов
ПРИМЕЧАНИЕ  Атрибут for важен для доступности. Он определя-
ет идентификатор элемента, к которому относится метка. Это важ -
но для пользователей, которые, например, используют программу
для чтения с  экрана, поскольку они могут определить, к  какому
свойству относится поле формы.
Помимо свойств в  PageModel, вы также можете ссылаться на вложен-
ные свойства дочерних объектов. Например, как я писал в главе 6, обыч-
но на странице Razor создают вложенный класс, предоставляют его как
свойство и декорируют его атрибутом [BindProperty]:
public class CheckoutModel: PageModel
{
[BindProperty]
public UserBindingModel Input { get; set; }
}
Можно ссылаться на свойство FirstName UserBindingModel, «расставив
точки», как это делается в любом другом коде C#. В листинге 8.3 показа-
ны дополнительные примеры.
<label asp-for="Input.FirstName"></label>
<label asp-for="Input.Email"></label>
Как это обычно бывает с  тег-хелперами, тег-хелпер метки не пере-
определяет значения, которые вы задали сами. Если, например, вы не хо-
тите использовать заголовок, созданный хелпером, то можете вставить
собственный заголовок вручную. Следующий элемент <label>
<label asp-for="Email">Please enter your Email</label>
сгенерирует следующий HTML-код:
<label for="Email">Please enter your Email</label>
Как и всегда, вам будет легче сопровождать код, если вы будете при-
держиваться стандартных соглашений и не переопределять такие значе-
ния, но выбор есть. На очереди у нас важные персоны: тег-хелперы ввода
и области текста.
8.2.3 Тег-хелперы ввода (input) и области текста (textarea)
Теперь перейдем к сути вашей формы – элементам <input>, обрабаты-
вающим ввод данных, предоставляемых пользователем. Учитывая, что
существует очень широкий спектр возможных типов ввода, есть мно-
жество различных способов их отображения в браузере. Например, логи-
ческие значения обычно представлены элементом типа checkbox, тогда
как целочисленные значения будут использовать тип number, а дата будет
использовать тип date, как показано на рис. 8.5.

293 Создание форм с по мощью тег-хелперов
Рис. 8.5 Различные типы элемента <input>. Т очный способ,
которым отображается каждый тип, зависит от браузера
Чтобы справиться с  таким разнообразием, есть тег-хелпер ввода  –
один из самых мощных тег-хелперов. Он использует информацию, ос -
нованную на типе свойства (bool, string, int и т. д.), и любые применен-
ные к  нему атрибуты DataAnnotations ( [EmailAddress] и  [Phone] среди
прочего), чтобы определить тип создаваемого элемента <input>. DataAn-
notations также используются для добавления атрибутов валидации на
стороне клиента data-val-* в сгенерированном HTML-коде.
Рассмотрим свойство Email из листинга 8.2, декорированное атрибу -
том [EmailAddress]. Добавить элемент <input> так же просто, как исполь-
зовать атрибут asp-for:
<input asp-for="Input.Email" />
Свойство представляет собой строку, поэтому обычно тег-хелпер
ввода генерирует тег <input> с  типом "text". Но добавление атрибута
[EmailAddress] предоставляет дополнительные метаданные об объекте.
Следовательно, тег-хелпер генерирует тег <input> с типом "email":
<input type="email" id="Input_Email" name="Input.Email"
value="test@example.com" data-val="true"
data-val-email="The Email Address field is not a valid e-mail address."
Data-val-required="The Email Address field is required."
/>

294 Глава 8 Создание форм с помощью тег-хелперов
Из этого примера можно извлечь множество вещей. Во-первых, атри-
буты HTML-элемента id и name были сгенерированы из имени свойства.
Значение атрибута id совпадает со значением, сгенерированным тег-
хелпером метки в атрибуте for, Input_Email. Значение атрибута name со -
храняет «точечную» нотацию Input_Email, чтобы привязка модели рабо-
тала правильно, когда содержимое поля отправляется на страницу Razor.
Кроме того, начальное значение поля было задано равным значению,
которое в настоящее время хранится в свойстве (в данном случае "test@
example.com"). Тип элемента также был установлен как тип email HTML5
вместо типа text по умолчанию.
Возможно, наиболее ярким дополнением является набор атрибутов
data-val-*. Они могут использоваться клиентскими библиотеками Java-
Script, такими как jQuery, для обеспечения валидации ограничений DataAn-
notations на стороне клиента. Проверка на стороне клиента обеспечивает
пользователям мгновенную обратную связь, если значения, которые они
вводят, невалидны, что обеспечивает более удобный пользовательский
интерфейс, по сравнению с тем, который мог бы у вас быть, если бы вы ис -
пользовали только проверку на стороне сервера, о чем я описал в главе 6.
Валидация на стороне клиента
Чтобы активировать валидацию на стороне клиента в своем приложении, не-
обходимо добавить на страницу некоторые библиотеки jQuery. В частности,
нужно включить библиотеки jQuery, jQuery-validation и  jQuery-validation-
unobtrusive. Сделать это можно несколькими способами, но самый простой –
подключить файлы сценариев в нижней части представления:
<script src="~/lib/jquery-
validation/dist/jquery.validate.min.js"></script>
<script src="~/lib/jquery-validation-
unobtrusive/jquery.validate.unobtrusive.min.js"></script>
В шаблонах по умолчанию эти сценарии уже есть. Это удобный частичный
шаблон, который вы можете добавить на свою страницу в секции Scripts.
Если вы используете макет по умолчанию и вам необходимо добавить ва-
лидацию на стороне клиента в  ваше представление, добавьте где-нибудь
в представлении сле  дую щую секцию:
@section Scripts{
@Html.Partial("_ValidationScriptsPartial")
}
Это частичное представление ссылается на файлы в вашей папке wwwroot.
Шаблон _layout по умолчанию уже содержит jQuery, как того требует библио-
тека интерфейсных компонентов Bootstrap1.
1 Вы также можете загрузить эти файлы из сети доставки содержимого (CDN).
Если вы хотите использовать данный подход, вам следует рассмотреть сце-
нарии, в которых CDN недоступна или скомпрометирована. Я обсуждаю это
в своем посте: http://mng.bz/2e6d.

295 Создание форм с по мощью тег-хелперов
Тег-хелпер ввода пытается выбрать наиболее подходящий шаблон для
данного свойства на основе атрибутов DataAnnotations или типа свой-
ства. Сгенерирует ли он точный тип элемента <input>, который вам ну -
жен, может в некоторой степени зависеть от вашего приложения.
Как и  всегда, вы можете переопределить сгенерированный тип, до-
бавив собственный атрибут type к  элементу в  вашем шаблоне Razor.
В табл. 8.1 показано, как некоторые привычные типы данных сопостав-
ляются с типами <input> и как можно указать сами типы данных.
Таблица 8.1 Распространенные типы данных, способы их указания и тип
элемента <input>, с которым они сопоставляются
Тип данных Как он указан Тип элемента <input>
byte, int, short, long, uint Тип свойства Number
decimal, double, float Тип свойства Text
Bool Тип свойства Checkbox
String Тип свойства, атрибут
[DataType(DataType.Text)] Text
HiddenInput  Атрибут [HiddenInput] Hidden
Password Атрибут [Password] Password
Phone Атрибут [Phone] Tel
EmailAddress Атрибут [EmailAddress] Email
Url Атрибут [Url] url
Date Тип свойства DateTime  атрибут
[DataType(DataType.Date)]Date
У тег-хелпера ввода есть один дополнительный атрибут, который
можно использовать для настройки способа отображения данных: asp-
format. Формы HTML полностью основаны на строках, поэтому когда
атрибут value элемента <input> задан, тег-хелпер должен взять значе-
ние, хранящееся в свойстве, и преобразовать его в строку. За кулисами
он выполняет метод string.Format() для значения свойства, передавая
строку формата.
Тег-хелпер ввода использует строку форматирования по умолчанию
для каждого типа данных, но в случае с атрибутом asp-format можно за-
дать конкретную строку форматирования, которую нужно использовать.
Например, вы можете убедиться, что свойство Dec отформатировано до
трех десятичных знаков, с по мощью следующего кода:
<input asp-for="Dec" asp-format="{0:0.000}" />
Если бы свойство Dec имело значение 1,2, был бы сгенерирован HTML-
код, аналогичный этому:
<input type="text" id="Dec" name="Dec" value="1.200">
ПРИМЕЧАНИЕ  Возможно, вы удивитесь, что типы decimal и dou-
ble отображаются как текстовые поля, а  не как числовые. Это
связано с  рядом технических причин, в  основном с тем, как не-

296 Глава 8 Создание форм с помощью тег-хелперов
которые культуры визуализируют числа с запятыми и пробелами.
Визуализация в  виде текста позволяет избежать ошибок, кото-
рые могут появиться только в определенных сочетаниях браузера
и культуры.
Помимо тег-хелпера ввода, ASP .NET Core предоставляет тег-хелпер
textarea. Он работает аналогичным образом, используя атрибут asp-for,
но привязан к элементу <textarea>:
<textarea asp-for="BigtextValue"></textarea>
Так вы сгенерируете HTML-код, подобный тому, что приведен далее.
Обратите внимание, что значение свойства визуализируется внутри
тега, а элементы валидации data-val-* привязаны как обычно:
<textarea data-val="true" id="BigtextValue" name="BigtextValue"
data-val-length="Maximum length 200." data-val-length-max="200"
data-val-required="The Multiline field is required." >This is some text,
I'm going to display it
in a text area</textarea>
Надеюсь, пройдя этот раздел, вы убедились, насколько тег-хелперы
могут помочь вам печатать меньше кода, особенно если использовать
их вместе с  DataAnnotations для генерации атрибутов проверки. Но это
больше, чем сокращение количества требуемых нажатий клавиш. Тег-
хелперы обеспечивают правильность созданной разметки и правильное
имя, идентификатор и  формат для автоматической привязки моделей
при их отправке на сервер.
Имея в своем распоряжении элементы <form>, <label> и  <input>, мож -
но создать бóльшую часть формы конвертера валют. Прежде чем мы рас -
смотрим визуализацию сообщений валидации, есть еще один элемент,
на который стоит обратить внимание: <select>, или раскрывающийся
список.
8.2.4 Тег-хелпер раскрывающегося списка
Помимо полей <input>, в  веб-формах часто встречается элемент <se-
lect>, или раскрывающийся список. Ваше приложение конвертера ва-
лют, например, может использовать его, чтобы можно было выбрать ва-
люту для конвертации из списка.
По умолчанию этот тег показывает список элементов и  позволяет
выбрать один, но можно выбрать и несколько, как показано на рис. 8.6.
Помимо обычного раскрывающегося списка, можно отображать прокру -
чивающийся список, добавить множественный выбор или отображать
элементы списка группами.

297 Создание форм с по мощью тег-хелперов
Рис. 8.6 Некоторые из множества способов отображения элементов <select> с помощью тег-
хелпера раскрывающегося списка
Чтобы использовать элементы <select> в  коде Razor, необходимо
включить в  PageModel два свойства: одно для списка отображаемых пара-
метров и другое для хранения выбранного значения (или значений). На-
пример, в листинге 8.5 показаны свойства PageModel, используемые для
создания трех крайних левых списков выбора, показанных на рис. 8.6.
Для отображения групп требуется несколько иная настройка, как вы
вскоре увидите.
Листинг 8.5  Модель представления для отображения раскрывающегося
и прокручивающегося списков
public class SelectListsModel: PageModel
{
[BindProperty]
public class InputModel Input { get; set; }
public IEnumerable<SelectListItem> Items { get; set; }
= new List<SelectListItem>
{
new SelectListItem{Value= "csharp", Text="C#"},
new SelectListItem{Value= "python", Text= "Python"},
new SelectListItem{Value= "cpp", Text="C++"},
new SelectListItem{Value= "java", Text="Java"},
new SelectListItem{Value= "js", Text="Java Script"},
new SelectListItem{Value= "ruby", Text="Ruby"},
};InputModel для привязки выбора
пользователя к полям выбора.
Список элементов
для отображения в полях
выбора.

298 Глава 8 Создание форм с помощью тег-хелперов
public class InputModel
{
public string SelectedValue1 { get; set; }
public string SelectedValue2 { get; set; }
public IEnumerable<string> MultiValues { get; set; }
}
}
Данный листинг демонстрирует ряд аспектов работы со списками <se-
lect>:
SelectedValue1/SelectedValue2 используется для хранения значе-
ния, выбранного пользователем. Они привязаны к  значению, вы-
бранному из раскрывающегося или прокручивающегося списка,
и используются для предварительного выбора правильного элемен-
та при визуализации формы;
MultiValues используется для хранения выбранных значений для
списка множественного выбора. Это объект IEnumerable, поэтому
он может содержать несколько вариантов выбора для каждого эле-
мента <select>;
Items предоставляет список значений для отображения в  элемен-
тах <select>. Обратите внимание, что тип элемента должен быть
SelectListItem, который предоставляет свойства Value и  Text для
работы с тег-хелпером. Он не является частью InputModel, посколь-
ку нам не нужно привязывать эти элементы к запросу – обычно они
загружаются непосредственно из модели приложения или жестко
запрограммированы.
ПРИМЕЧАНИЕ  Тег-хелпер раскрывающегося списка работает
только с  элементами SelectListItem. Это означает, что обычно
нужно выполнять преобразование из набора элементов списка
для конкретного приложения (например, List <string> или List
<MyClass>) в  ориентированный на пользовательский интерфейс
List<SelectListItem>.
Тег-хелпер раскрывающегося списка предоставляет атрибуты asp-for
и asp-items, которые можно добавить в элементы <select>. Что касается
тег-хелпера ввода, атрибут asp-for указывает свойство в  PageModel, к ко -
торому нужно выполнить привязку.
Чтобы отобразить доступные элементы <option>, предоставляется
атрибут asp-items для IEnumerable<SelectListItem>.
СОВЕТ  Обычно требуется отобразить список параметров enum
в списке <select>. Это настолько распространено, что ASP .NET Core
поставляется с помощником генерации SelectListItem для любого
enum. Если у вас есть перечисление типа TEnum, то можно сгенериро-
вать доступные параметры в своем представлении, используя asp-
items="Html.GetEnumSelectList<TEnum>()".Эти свойства будут содержать
значения, выбранные в полях
с возможностью выбора одного
варианта.
Чтобы создать поле с множественным
выбором, используйте IEnumerable<>.

299 Создание форм с по мощью тег-хелперов
В следующем листинге показано, как отобразить раскрывающийся
список, список с одним вариантом выбора и список с несколькими ва-
риантами. В нем используется PageModel из предыдущего листинга. Каж -
дый список <select> привязан к другому свойству, но для всех них по-
вторно используется один и тот же список Items.
Листинг 8.6  Шаблон Razor для отображения элемента <select> тремя
разными способами
@page
@model SelectListsModel
<select asp-for="Input.SelectedValue1"
asp-items="Model.Items"></select>
<select asp-for="Input.SelectedValue2"
asp-items="Model.Items" size="4"></select>
<select asp-for="Input.MultiValues"
asp-items="Model.Items"></select>
Надеюсь, вы видите, что шаблон генерации раскрывающегося списка
<select> почти идентичен шаблону для создания списка множественно-
го выбора. Тег-хелпер заботится о добавлении HTML-атрибута multiple
к сгенерированному выводу, если свойство, к которому оно привязыва-
ется, – это IEnumerable.
ВНИМАНИЕ!  Атрибут asp-for не	должен включать в себя префикс
Model.. С другой стороны, он должен быть у атрибута asp-items при
ссылке на свойство в  PageModel. Атрибут asp-items может также
ссылаться на другие элементы C#, такие как объекты, хранящиеся
в ViewData, но использование свойства PageModel – лучший подход.
Вы видели, как связать три разных типа списка выбора, но есть еще
один, который мы не рассматривали. Он изображен на рис. 8.6. Речь идет
о том, как отображать группы в прокручивающихся списках с по мощью
элементов <optgroup>.
К счастью, в коде Razor ничего менять не нужно; просто нужно обно-
вить способ определения объектов SelectListItem.
Объект SelectListItem определяет свойство Group, указывающее Se-
lectListGroup, к которому принадлежит элемент. В следующем листинге
показано, как создать две группы и назначить каждый элемент списка
либо «динамической», либо «статической» группе, используя PageModel,
аналогичную той, что показана в листинге 8.5. Последний элемент спис -
ка, C#, не назначается группе, поэтому он будет отображаться как обыч-
но, без тега <optgroup>.Создает стандартный раскрывающийся список
путем привязки к стандартному свойству
в asp-for.
Создает список с одним вариантом
выбора высотой 4, предоставляя
стандартный HTML-атрибут size.
Создает список с множественным выбором
путем привязки к свойству IEnumerable в asp-for.

300 Глава 8 Создание форм с помощью тег-хелперов
Листинг 8.7  Добавление групп в объекты SelectListItem для создания
элементов optgroup
public class SelectListsModel: PageModel
{
[BindProperty]
public IEnumerable<string> SelectedValues { get; set; }
public IEnumerable<SelectListItem> Items { get; set; }
public SelectListsModel()
{
var dynamic = new SelectListGroup { Name = "Dynamic" };
var stat = new SelectListGroup { Name = "Static" };
Items = new List<SelectListItem>
{
new SelectListItem {
Value= "js",
Text="Java Script",
Group = dynamic
},
new SelectListItem {
Value= "cpp",
Text="C++",
Group = stat
},
new SelectListItem {
Value= "python",
Text="Python",
Group = dynamic
},
new SelectListItem {
Value= "csharp",
Text="C#",
}
};
}
}
После этого тег-хелпер будет генерировать элементы <optgroup> по
мере необходимости при отрисовке шаблона в HTML-код. Этот шаблон
Razor
@page
@model SelectListsModel
<select asp-for="SelectedValues" asp-items="Model.Items"></select>
будет отображаться в HTML следующим образом:
<select id="SelectedValues" name="SelectedValues" multiple="multiple">
<optgroup label="Dynamic">
<option value="js">Java Script</option>
<option value="python">Python</option>Используется для хранения выбранных
значений, где разрешено несколько
вариантов для выбора.
Инициализирует элементы списка в конструкторе.
Создает один экземпляр
каждой группы
для передачи элементам
SelectListItem.
Задает соответствующую группу
для каждого элемента SelectListItem.
Если у элемента SelectListItem нет группы,
он не будет добавлен в <optgroup>.

301 Создание форм с по мощью тег-хелперов
</optgroup>
<optgroup label="Static Languages">
<option value="cpp">C++</option>
</optgroup>
<option value="csharp">C#</option>
</select>
Еще одно распространенное требование при работе с элементами <se-
lect> – включить в списке параметр, который указывает, что значение не
было выбрано, как показано на рис. 8.7. Без этой дополнительной опции
раскрывающийся список по умолчанию всегда будет иметь значение,
и по умолчанию он будет первым элементом в списке.
Рис. 8.7  Без опции «не выбран» элемент <select> всегда будет иметь значение.
Возможно, это не то поведение, которое вам нужно, если вы не хотите, чтобы
элемент <option> был выбран по умолчанию
Этого можно добиться одним из двух способов: либо добавить опции
«не выбран» к доступным объектам SelectListItem, либо вручную доба-
вить опцию к Razor, например так:
<select asp-for="SelectedValue" asp-items="Model.Items">
<option Value = "">*Не выбран**</option>
</select>
Так вы добавите дополнительный элемент <option> в верхней части
своего элемента <select> с пустым атрибутом Value, позволяя предоста-
вить пользователю вариант «не выбран».
СОВЕТ  Добавление опции «не выбран» к элементу <select> на-
столько распространено, что вы, возможно, захотите создать час -
тичное представление для инкапсуляции этой логики.

302 Глава 8 Создание форм с помощью тег-хелперов
Имея в своем арсенале тег-хелперы ввода и раскрывающегося списка,
вы сможете создавать большинство форм, которые вам понадобятся. Те-
перь у вас есть все необходимое для создания приложения конвертера
валют, за одним исключением.
Помните, что всякий раз, когда вы принимаете данные, вводимые
пользователем, всегда нужно проверять их. Тег-хелперы валидации по-
зволяют отображать пользователю ошибки проверки модели в  форме
без необходимости писать большое количество шаблонной разметки.
8.2.5 Тег-хелперы сообщений валидации и сводки сообщений
(Validation Summary)
В разделе 8.2.3 вы видели, как тег-хелпер input генерирует необходи-
мые атрибуты валидации data-val-* на самих элементах <input>. Но
вам нужно где-то отображать сообщения проверки. Это можно сделать
для каждого свойства в модели представления с по мощью тег-хелпера
сообщений валидации, примененного к тегу <span>, используя атрибут
asp-validation-for:
<span asp-validation-for="Email"></span>
Когда ошибка возникает во время валидации на стороне клиента, со-
ответствующее сообщение об ошибке для указанного свойства будет
отобра жаться в тегах <span>, как показано на рис. 8.8. Этот элемент <span>
также будет использоваться для отображения соответствующих сообще-
ний валидации, если валидация на стороне сервера окончится неудачей,
и форма будет отображена повторно.
Рис. 8.8 Сообщения валидации могут быть показаны в ассоциированном элементе
<span> с по мощью соответствующего тег-хелпера
Любые ошибки, ассоциированные со свойством Email, хранящимся
в ModelState, будут отображены в теле элемента, и у элемента будут со-
ответствующие атрибуты для подключения проверки с по мощью jQuery:
<span class="field-validation-valid" data-valmsg-for="Email"
data-valmsg-replace="true">The Email Address field is required.</span>
Ошибка валидации, отображаемая в элементе, будет заменена, когда
пользователь обновит поле Email <input>, и валидация будет выполнена
на стороне клиента.

303 Создание форм с по мощью тег-хелперов
ПРИМЕЧАНИЕ  Для получения дополнительных сведений о  Mo-
delState и валидации модели на стороне сервера см. главу 6.
Помимо отображения сообщений валидации для отдельных свойств,
также можно отобразить сводку всех сообщений в элементе <div> с по-
мощью тег-хелпера сводки валидации (Validation Summary), показан-
ного на рис. 8.9. Он отображает теги <ul>, содержащие список ошибок
ModelState.
Т ег-хелперы сообщения валидации
Т ег-хелпер сводки сообщений
о валидации
Рис. 8.9 Форма, показывающая ошибки валидации. Т ег-хелпер валидации
применяется к элементу <span> рядом с ассоциированным элементом <input>
и к элементу <div> обычно в верхней или нижней части формы
Тег-хелпер сводки сообщений применяется к  элементу <div> с  по-
мощью атрибута asp-validation-summary и  предоставления значения
перечисления ValidationSummary, например
<div asp-validation-summary="All"></div>
Перечисление ValidationSummary управляет отображаемыми значе-
ниями и имеет три возможных значения:
None – не отображать сводку (не знаю, зачем это использовать);
ModelOnly  – отображать только ошибки, не ассоциированные со
свойством;
All  – отображать ошибки, ассоциированные со свойством либо
с моделью.
Тег-хелпер сводки сообщений валидации особенно полезен, если у вас
есть ошибки, связанные с вашей страницей, которые не относятся к од-
ному свойству. Их можно добавить к состоянию модели, используя пус -
той ключ, как показано в листинге 8.8. В этом примере валидация свой-
ства прошла успешно, но мы предоставляем дополнительную проверку
на уровне модели, чтобы убедиться, что мы не пытаемся конвертировать
валюту в саму себя.

304 Глава 8 Создание форм с помощью тег-хелперов
Листинг 8.8  Добавление ошибок валидации на уровне модели
в ModelState
public class ConvertModel : PageModel
{
[BindProperty]
public InputModel Input { get; set; }
[HttpPost]
public IActionResult OnPost()
{
if(Input.CurrencyFrom == Input.CurrencyTo)
{
ModelState.AddModelError(
string.Empty,
"Cannot convert currency to itself");
}
if (!ModelState.IsValid)
{
return Page();
}
// Сохраняем где-нибудь допустимые значения и т. д.
return RedirectToPage("Checkout");
}
}
Без этого тег-хелпера ошибка на уровне модели все равно будет добав-
лена, если пользователь дважды использовал одну и ту же валюту, и фор-
ма будет отображена повторно. К  сожалению, у  пользователя не было
визуальной подсказки, указывающей на то, почему данные не были от -
правлены, – очевидно, это проблема! При добавлении тег-хелпера свод-
ки сообщений валидации ошибки на уровне модели отображаются поль-
зователю, чтобы он мог исправить проблему, как показано на рис. 8.10.
ПРИМЕЧАНИЕ  Для простоты я добавил валидацию в обработчик
страницы. Более подходящий способ может заключаться в созда-
нии специального атрибута валидации. Таким образом, ваш обра-
ботчик сохранит гибкость, соответствуя принципу единственной
ответственности.
Вы увидите, как этого добиться, в главе 20.
В этом разделе описано большинство распространенных тег-хелперов,
доступных для работы с формами, включая все части, необходимые для
создания форм конвертера валют. Они должны дать вам все необходи-
мое, чтобы вы могли приступить к созданию форм в собственных при-
ложениях.
Но формы – не единственная область, где полезны тег-хелперы; обыч-
но они применяются всякий раз, когда вам нужно смешать логику на сто-
роне сервера с генерацией HTML-кода.Невозможно конвертировать
валюту в себя.
Добавляет ошибку на уровне
модели, не привязанную
к определенному свойству,
с помощью пустого ключа.
Если есть какие-то ошибки на уровне
свойств или модели, отобразите их.

305 Создание ссылок с по мощью тег-хелпера якоря (Anchor Tag Helper)
Одинаковые валюты
вызывают ошибку
валидации на уровне
модели
Т ег-хелпер показывает
ошибки на уровне
моделиОдинаковые валюты
вызывают ошибку
валидации на уровне
модели
Без тег-хелпера
пользователь не понимает,
почему форма была
отображена повторно
Рис. 8.10 Ошибки на уровне модели отображаются только с по мощью тег-хелпера сводки
сообщений валидации. Без него у пользователей не будет никаких указаний на то, что в форме
есть ошибки, поэтому они не смогут исправить их
Один из таких примеров – создание ссылок на другие страницы ваше-
го приложения с по мощью генерации URL-адресов на основе маршрути-
зации. Если учесть, что маршрутизация спроектирована так, чтобы быть
гибкой при рефакторинге приложения, то отслеживание точных URL-
адресов, на которые должны указывать ссылки, превратится в кошмар
при сопровождении, если вам придется делать это вручную. Как и следо-
вало ожидать, для этого есть тег-хелпер: тег-хелпер анкора ссылки (An-
chor Tag Helper).
8.3 Создание ссылок с по мощью тег-хелпера
якоря (Anchor Tag Helper)
В конце главы 5 я показал, как можно генерировать URL-адреса для ссы-
лок на другие страницы в вашем приложении изнутри ваших обработ -
чиков страниц с по мощью ActionResult. Представления – еще одно рас -
пространенное место, где нужно ссылаться на другие страницы, обычно
с  по мощью элемента <a> с  атрибутом href, указывающим на соответ -
ствующий URL-адрес.
В этом разделе я  покажу, как можно использовать тег-хелпер яко-
ря, чтобы создать URL-адрес для данной страницы Razor с использова-
нием маршрутизации. Концептуально это почти идентично тому, как
тег-хелпер формы генерирует URL-адрес атрибута action, как вы виде-
ли в разделе 8.2.1. По большей части использование тег-хелпера якоря
идентично; вы предоставляете атрибуты asp-page и  asp-page-handler на -
ряду с атрибутами asp-route-*, если необходимо. Шаблоны Razor Pages
по умолчанию используют тег-хелпер якоря для создания ссылок в пане-
ли навигации с по мощью кода из следующего листинга.
Листинг 8.9  Использование тег-хелпера якоря для генерации
URL-адресов в _Layout.cshtml
<ul class="navbar-nav flex-grow-1">
<li class="nav-item">

306 Глава 8 Создание форм с помощью тег-хелперов
<a class="nav-link text-dark"
asp-area="" asp-page="/Index">Home</a>
</li>
<li class="nav-item">
<a class="nav-link text-dark"
asp-area="" asp-page="/Privacy">Privacy</a>
</li>
</ul>
Как видите, у каждого элемента <a> есть атрибут asp-page. Этот тег-
хелпер использует систему маршрутизации для генерации соответству -
ющего URL-адреса для элемента <a>, что приводит к появлению следую-
щей разметки:
<ul class="nav navbar-nav">
<li class="nav-item">
<a class="nav-link text-dark" href="/">Home</a>
</li>
<li class="nav-item">
<a class="nav-link text-dark" href="/Privacy">Privacy</a>
</li>t
</ul>
URL-адреса используют значения по умолчанию там, где это возмож -
но, поэтому страница Razor Index генерирует просто "/" вместо "/Index".
Если вам нужно больше контроля над созданным URL-адресом, тег-
хелпер якоря предоставляет несколько дополнительных свойств, кото-
рые можно задать и которые будут использоваться при генерации URL-
адреса.
Вот атрибуты, наиболее часто используемые в Razor Pages:
asp-page – указывает на Razor Page, которая будет обрабатывать за-
прос;
asp-page-handler – указывает на обработчик страницы Razor, кото-
рая будет применяться для обработки запроса;
asp-area – устанавливает параметр маршрута области, который бу -
дет использоваться. Области могут быть применены для предостав-
ления дополнительного уровня организации вашего приложения1;
asp-host – если он задан, то ссылка будет указывать на предостав-
ленный хост и генерировать абсолютный URL-адрес вместо относи-
тельного;
asp-protocol – устанавливает, какую следует генерировать: ссылку
http или https. Если он задан, то будет генерировать абсолютный
URL-адрес вместо относительного;
1 Я  не буду подробно останавливаться на этих вопросах в  данной книге. Это
необязательный аспект MVC, который часто используется только в крупных
проектах. Вы можете прочитать о них здесь: https://docs.microsoft.com/en-us/
aspnet/core/mvc/controllers/areas?view=aspnetcore-5.0.

307 Сброс кеша с по мощью тег-хелпера добавления версии (Append Version Tag Helper)
asp-route-*  – задает параметры маршрута для использования во
время генерации. Его можно добавлять несколько раз для разных
параметров маршрута.
Используя тег-хелпер якоря и его атрибуты, вы генерируете свои URL-
адреса с по мощью системы маршрутизации, как описано в главе 5. Это
уменьшает дублирование в вашем коде, удаляя жестко запрограммиро-
ванные URL-адреса, которые в противном случае нужно было бы встра-
ивать во все ваши представления.
Если вы обнаружите, что пишете повторяющийся код в своей размет -
ке, скорее всего, кто-то уже написал тег-хелпер, который может помочь
вам. Тег-хелпер добавления версии (Append Version Tag Helper), о кото-
ром идет речь в следующем разделе, – отличный пример использования
тег-хелперов для уменьшения количества необходимого кода.
8.4 Сброс кеша с по мощью тег-хелпера
добавления версии (Append Version Tag Helper)
Распространенная проблема, возникающая и  при разработке, и  когда
приложение отправляется в промышленное окружение, – это гарантия
того, что все браузеры используют самые последние файлы. Из сообра-
жений производительности браузеры часто кешируют файлы локально
и повторно используют их для последующих запросов, вместо того что-
бы вызывать приложение каждый раз, когда запрашивается файл.
Обычно это замечательно  – большинство статических ресурсов на
вашем сайте редко меняются, поэтому их кеширование значительно
снижает нагрузку на ваш сервер. Возьмем изображение логотипа вашей
компании – как часто оно меняется? Если на каждой странице есть ваш
логотип, то кеширование изображения в браузере имеет большой смысл.
Но что будет, если его поменять? Вы хотите, чтобы пользователи по-
лучали обновленные ресурсы, как только они станут доступны. Более
важным требованием может быть, если меняются файлы Java Script, ас -
социированные с  вашим сайтом. Если пользователи в  конечном итоге
будут использовать кешированные версии Java Script, они могут увидеть
странные ошибки, или им может показаться, что ваше приложение не-
исправно.
Такая головоломка часто встречается в веб-разработке, и один из са-
мых распространенных способов справиться с ней – использовать стро-
ку запроса со сбросом кеша.
ОПРЕДЕЛЕНИЕ  Строка	 запроса	 со	сбросом	 кеша добавляет пара-
метр запроса к URL-адресу, например ?v=1. Браузеры будут кеши-
ровать ответ и использовать его для последующих запросов к URL-
адресу. Когда ресурс изменяется, строка запроса также изменяется,
например ?v=2. Браузеры будут рассматривать это как запрос но-
вого ресурса и будут делать новый запрос.

308 Глава 8 Создание форм с помощью тег-хелперов
Самая большая проблема с этим подходом заключается в том, что он
требует, чтобы вы обновляли URL-адрес каждый раз, когда меняется изо-
бражение, файл CSS или Java Script. Это шаг, совершаемый вручную. Он
требует обновлять все места, где упоминается ресурс, поэтому ошибки
неизбежны. Но тег-хелперы спешат на помощь! Когда вы добавляете эле-
мент <script>, <img> или <link> в свое приложение, то можете исполь-
зовать тег-хелперы для автоматической генерации строки запроса со
сбросом кеша:
<script src="~/js/site.js" asp-append-version="true"></script>
Атрибут asp-append-version загрузит файл, на который указывает
ссылка, и сгенерирует уникальный хеш на основе его содержимого. За-
тем он добавляется в виде уникальной строки запроса к URL-адресу ре-
сурса:
<script src="/js/site.js?v=EWaMeWsJBYWmL2g_KkgXZQ5nPe"></script>
Поскольку это значение является хешем содержимого файла, оно
останется неизменным до тех пор, пока файл не изменится, поэтому
файл будет кешироваться в браузерах пользователей. Но если файл из-
менен, изменится хеш содержимого, а следовательно, и строка запроса.
Это гарантирует, что браузеры всегда получают самые свежие файлы для
вашего приложения и вам не нужно беспокоиться о ручном обновлении
каждого URL-адреса при каждом изменении файла.
До сих пор в этой главе вы видели, как использовать тег-хелперы для
форм, создания ссылок и сброса кеша. Вы также можете использовать их
для условной визуализации разной разметки в зависимости от текуще-
го окружения. Здесь используется техника, которую вы еще не видели.
И тег-хелпер объявляется как совершенно отдельный элемент.
8.5 Использование условной разметки
с помощью тег-хелпера окружения
Во многих случаях вам нужно визуализировать разный HTML-код в сво-
их шаблонах Razor в зависимости от того, работает ваш веб-сайт в окру -
жении разработки или в промышленном окружении.
Например, в окружении разработки обычно необходимо, чтобы ваши
ресурсы Java Script и  CSS были подробными и  удобными для чтения,
но в промышленном окружении вы обрабатываете эти файлы, чтобы
сделать их как можно меньше. Еще один пример – желание применить
баннер к  приложению при запуске в  тестовом окружении, который
удаляется при переходе в промышленное окружение, как показано на
рис. 8.11.

309 Использование условной разметки с помощью тег-хелпера окружения
Рис. 8.11 Предупреждающий баннер будет отображаться всякий раз,
когда вы работаете в тестовом окружении, чтобы его легко было отличить
от промышленного окружения
ПРИМЕЧАНИЕ  Вы узнаете, как сконфигурировать приложение
для нескольких окружений, в главе 11.
Вы уже видели, как использовать C# для добавления операторов if
в разметку, поэтому вполне возможно использовать эту технику для до-
бавления дополнительного элемента div в свою разметку, когда текущее
окружение имеет заданное значение. Если предположить, что перемен-
ная env содержит текущее окружение, то можно использовать что-то
вроде этого:
@if(env == "Testing" || env == "Staging")
{
<div class="warning">You are currently on a testing environment</div>
}
В этом нет ничего плохого, но лучше использовать тег-хелперы, чтобы
ваша разметка была чистой и удобочитаемой. К счастью, ASP .NET Core
поставляется с  EnvironmentTagHelper, который можно использовать для
достижения того же результата немного яснее:
<environment include="Testing,Staging">
<div class="warning">You are currently on a testing environment</div>
</environment>
Этот тег-хелпер немного отличается от тех, что вы видели раньше.
Вместо того чтобы дополнять существующий HTML-элемент с по мощью
атрибута asp-, весь	элемент является тег-хелпером. Он полностью отве-
чает за создание разметки и использует атрибут для ее настройки.
Функционально этот тег-хелпер идентичен разметке C# (хотя сейчас
я скрыл, как найти переменную env), но он более декларативен по своей

310 Глава 8 Создание форм с помощью тег-хелперов
функции, нежели альтернатива C#. Очевидно, что вы можете использо-
вать любой из подходов, но лично мне нравится HTML-подобная при-
рода тег-хелперов.
Мы подошли к  концу главы, посвященной тег-хелперам, а  вместе
с  ней и  нашему первому знакомству с  созданием традиционных веб-
приложений, отображающих HTML-код для пользователей. В последней
части книги мы вернемся к шаблонам Razor, и вы узнаете, как создавать
собственные компоненты, такие как специальные тег-хелперы и компо-
ненты представления. На данный момент у вас есть все необходимое для
создания сложных макетов Razor – специальные компоненты могут по-
мочь привести ваш код в порядок.
Первая часть этой книги представляет собой краткий обзор того, как
создавать приложения Razor Page с по мощью ASP .NET Core. Теперь у вас
есть основа, чтобы приступить к  созданию простых приложений ASP .
NET Core. Во второй части этой книги я покажу вам некоторые дополни-
тельные функции, которые вам понадобятся для создания полноценных
приложений. Но прежде чем перейти к этой теме, я использую одну гла-
ву, чтобы обсудить создание веб-API.
Ранее я упоминал подход с использованием веб-API, при котором ваше
приложение обслуживает данные с применением фреймворка MVC, но
вместо того, чтобы возвращать удобный для пользователя HTML-код,
оно возвращает данные в формате JSON. В следующей главе вы узнаете,
как и для чего создавать веб-API, познакомитесь с альтернативной си-
стемой маршрутизации, разработанной для API, и узнаете, как генери-
ровать ответы на запросы в формате JSON.
Резюме
С помощью тег-хелперов можно привязать свою модель данных
к  HTML-элементам, что упрощает создание динамического HTML-
кода, который удобен для редактора.
Как и в случае с Razor в целом, тег-хелперы предназначены только для
отрисовки HTML-кода на стороне сервера. Нельзя использовать их не-
посредственно в таких фреймворках, как Angular или React.
Тег-хелперы могут быть автономными элементами или могут быть
прикреплены к  существующему HTML-коду с  по мощью атрибутов.
Это позволяет настраивать HTML-элементы и добавлять совершенно
новые элементы.
Тег-хелперы могут настраивать элементы, к которым они прикрепле-
ны, добавлять дополнительные атрибуты и настраивать способ своего
отображения в HTML. Это может значительно уменьшить объем раз-
метки, которую вам нужно писать.
Тег-хелперы могут отображать несколько атрибутов в одном элемен-
те. Это упрощает настройку тег-хелпера, поскольку можно установить
несколько отдельных значений.

311 Резюме
Можно добавить атрибуты asp-page и  asp-page-handler к  элемен-
ту <form>, чтобы задать URL-адрес action с по мощью функции Razor
Pages  генерации URL-адресов.
Значения маршрута для использования во время маршрутизации
указываются с по мощью тег-хелпера формы, используя атрибуты asp-
route-*. Эти значения применяются для сборки конечного URL-адреса
или передаются как данные запроса.
Тег-хелпер формы также создает скрытое поле, которое можно ис -
пользовать для предотвращения атак CSRF. Оно добавляется автома-
тически и является важной мерой для обеспечения безопасности.
Можно прикрепить тег-хелпер метки к тегу <label> с по мощью атри-
бута asp-for. Он генерирует соответствующий атрибут for и заголовок
на основе атрибута [Display] Data-Annotations и имени свойства Pa-
geModel.
Тег-хелпер ввода задает для атрибута type элемента <input> соот -
ветствующее значение на основе Type привязанного свойства и всех
примененных к нему DataAnnotations. Он также генерирует атрибуты
data-val-*, необходимые для валидации на стороне клиента, что зна-
чительно сокращает объем HTML-кода, который вам нужно писать.
Чтобы активировать валидацию на стороне клиента, нужно добавить
в  представление необходимые файлы Java Script для проверки с  ис -
пользованием jQuery.
Тег-хелпер раскрывающегося списка может создавать раскрывающие-
ся элементы <select>, а также списки прокрутки, используя атрибуты
asp-for и  asp-items. Чтобы создать элемент <select> множественно-
го выбора, привяжите элемент к свойству IEnumerable модели пред-
ставления. Можно использовать эти подходы для создания нескольких
разных стилей поля выбора.
Элементы, поставляемые в  атрибуте asp-for, должны быть IEnu me-
rable<SelectListItem>. При попытке привязки другого типа вы по-
лучите ошибку компиляции в  представлении Razor. Можно создать
IEnumerable<SelectListItem> для enum TEnum, используя вспомогатель-
ный метод Html.GetEnumSelectList<TEnum>(). Это избавит вас от необ-
ходимости самостоятельного написания кода отображения.
Тег-хелпер раскрывающегося списка будет генерировать элементы
<optgroup>, если у  элементов, предоставленных в  атрибуте asp-for,
есть ассоциированный SelectListGroup в свойстве Group. Группы мож -
но использовать для разделения элементов в списках выбора.
Любые дополнительные элементы <option>, добавленные в разметку
Razor, будут переданы в окончательный HTML-код. Можно использо-
вать эти дополнительные элементы для легкого добавления опции
«без выбора» к элементу <select>.
Тег-хелпер сообщений валидации используется для визуализации со-
общений об ошибках валидации для данного свойства на стороне кли-
ента и на стороне сервера. Это обеспечивает важную связь с вашими
пользователями, когда в  элементах есть ошибки. Используйте атри-

312 Глава 8 Создание форм с помощью тег-хелперов
бут asp-validation-for, чтобы прикрепить этот тег-хелпер к элементу
<span>.
Тег-хелпер сводки сообщений валидации используется для отображе-
ния ошибок валидации для модели, а также для отдельных свойств.
Можно использовать свойства на уровне модели для отображения
дополнительной проверки, которая не применяется только к одному
свойству. Используйте атрибут asp-validation-summary, чтобы присо-
единить этот тег-хелпер к элементу <div>.
Можно сгенерировать URL-адрес <a> с по мощью тег-хелпера якоря. Он
использует маршрутизацию для генерации URL-адреса href с исполь-
зованием атрибутов asp-page, asp-page-handler и  asp-route-*, предо-
ставляя вам все возможности маршрутизации.
Вы можете добавить атрибут asp-append-version к элементам <link>,
<script> и  <img>, чтобы обеспечить возможность сброса кеша в зави-
симости от содержимого файла. Это гарантирует, что пользователи
смогут кешировать файлы по соображениям производительности, но
при этом всегда получать их последнюю версию.
Можно использовать тег-хелпер окружения для условной визуали-
зации разного HTML-кода на основе текущего окружения, в котором
выполняется приложение. Его можно применять, чтобы при желании
отображать совершенно разный HTML-код в разных окружениях.

9Создание	веб-API
для мобильных
и клиентских	приложений
с помощью	MVC
В этой главе:
создание контроллера веб-API для возврата клиентам
ответа в формате JSON;
использование маршрутизации на основе атрибутов
для настройки ваших URL-адресов;
создание ответа с использованием согласования
содержимого;
применение общих соглашений с по мощью атрибута
[ApiController].
В предыдущих пяти главах вы проработали каждый уровень приложения
ASP .NET Core с  отрисовкой на стороне сервера, используя Razor Pages
для визуализации HTML-кода в браузере. В этой главе вы увидите дру -
гой взгляд на приложение ASP .NET Core. Вместо того чтобы использовать
Razor Pages, мы рассмотрим веб-API, которые служат серверной частью
для одностраничных приложений на стороне клиента и мобильных при-
ложений.
Многое из того, что вы уже узнали, можно применить к веб-API; они
используют один и тот же паттерн проектирования MVC и  концепции
маршрутизации и выполняют те же привязки модели и валидацию. От -
личие от традиционных веб-приложений заключается в первую очередь
в части представления MVC. Вместо того чтобы возвращать HTML-код,

314 Глава 9 Создание веб-API для мобильных и клиентских приложений
они возвращают данные в формате JSON или XML, которые клиентские
приложения используют для управления своим поведением или обнов-
ления пользовательского интерфейса.
В этой главе вы узнаете, как определять контроллеры и  действия,
и увидите, насколько похожи они на уже знакомые вам страницы Razor
и контроллеры. Вы узнаете, как создать модель API для возврата данных
и кодов состояния HTTP в ответ на запрос способом, понятным клиент -
ским приложениям.
Изучив, как паттерн проектирования MVC применяется к  веб-API,
вы увидите, как маршрутизация работает с веб-API. Мы посмотрим, как
маршрутизация	 на	основе	атрибутов повторно использует многие из тех
же концепций, описанных в  главе 5, но применяет их к  методам дей-
ствий, а не к страницам Razor.
Одной из важных функций, добавленных в ASP .NET Core 2.1, был атри-
бут [ApiController]. Он применяет несколько общих соглашений, ис -
пользуемых в веб-API, что уменьшает объем кода, который вы должны
написать самостоятельно. В разделе 9.5 вы узнаете, как автоматические
сообщения 400 Bad Request для недопустимых запросов, вывод парамет -
ров привязки модели и объекты ProblemDetails могут упростить созда-
ние API-интерфейсов.
Вы также узнаете, как форматировать модели API, возвращаемые ва-
шими методами действий, используя согласование содержимого, чтобы
гарантировать, что вы сгенерируете ответ, который может понять вызы-
вающий клиент. В рамках этой темы вы узнаете, как добавить поддержку
дополнительных форматов, таких как XML, чтобы можно было генери-
ровать ответы в формате XML, если их запрашивает клиент.
Одним из замечательных аспектов ASP .NET Core является разнообра-
зие приложений, которые можно создавать с его помощью. Способность
с  легкостью создавать обобщенный HTTP веб-API дает возможность
использовать ASP .NET Core в бóльшем количестве ситуаций, чем этого
можно было бы достичь с  по мощью одних только традиционных веб-
при ложений. Но стоит ли создавать веб-API и почему? В первом разделе
этой главы я расскажу о причинах, по которым вы, возможно, захотите
или не захотите это делать.
9.1 Что такое веб-API, и когда его следует
использовать?
Традиционные веб-приложения обрабатывают запросы, возвращая
пользователю HTML-код, который отображается в веб-браузере. Вы мо-
жете легко создавать приложения такого рода, используя Razor Pages для
генерации HTML-кода с по мощью шаблонов Razor, как вы видели в по-
следних главах. Это распространенный и хорошо понятный подход, но
современный разработчик приложений также может рассматривать ряд
других возможностей, как показано на рис. 9.1.

315 Что такое веб-API, и когда его следует использовать?
Клиент Сервер
Синхронный запрос по протоколу HTTP
Асинхронный запрос через HTTP
Синхронный или асинхронный
запрос через HTTPОтвет: веб-страница HTML
Ответ: частичные данные страницы
в формате JSON или XML
Ответ: данные в формате JSON,
XML или двоичном формате</>
{ }
{ }Традиционное
веб-приложение
# REST API
Служба удаленного
вызова процедур
Рис. 9.1 Современные разработчики должны учитывать ряд различных
потребителей своих приложений. Как и обычные пользователи с веб-браузерами,
это могут быть одностраничные приложения, мобильные приложения или что-то
иное
Одностраничные приложения на стороне клиента стали популярны-
ми в последние годы с развитием таких фреймворков, как Angular, React
и Vue. Эти фреймворки обычно используют Java Script, который запуска-
ется в веб-браузере пользователя, для создания HTML-кода, который они
видят и с которым взаимодействуют. Сервер отправляет этот начальный
код Java Script в браузер, когда пользователь впервые обращается к при-
ложению. Браузер пользователя загружает Java Script и инициализирует
одностраничное приложение перед загрузкой любых данных приложе-
ния с сервера.
ПРИМЕЧАНИЕ  Blazor WebAssembly – это новый захватывающий
фреймворк для создания одностраничных приложений. Он по-
зволяет писать приложение, которое запускается в браузере, как
и другие одностраничные приложения, но вместо Java Script при-
меняет C# и шаблоны Razor, используя новый веб-стандарт WebAs-

316 Глава 9 Создание веб-API для мобильных и клиентских приложений
sembly. В этой книге я не рассматриваю Blazor, поэтому если хоти-
те узнать больше, то рекомендую книгу «Blazor	 в действии» Криса
Сейнти.
После загрузки одностраничного приложения в  браузер обмен дан-
ными с сервером по-прежнему осуществляется по протоколу HTTP , но
вмес  то того, чтобы отправлять HTML-код непосредственно в  браузер
в ответ на запросы, приложение на стороне сервера отправляет данные
(обычно в таком формате, как JSON) приложению на стороне клиента.
Затем SPA анализирует данные и  генерирует соответствующий HTML-
код, который увидит пользователь, как показано на рис.  9.2. Конечная
точка приложения на стороне сервера, с которой клиент обменивается
данными, иногда называется веб-API.
Первоначальные запросы скачивают
клиентское приложение Blazor
Последующие запросы получают
данные в формате JSON
Рис. 9.2 Пример клиентского одностраничного приложения, где используется Blazor
WebAssembly. Первоначальные запросы загружают файлы приложения в браузер,
а последующие запросы извлекают данные из веб-API в формате JSON
ОПРЕДЕЛЕНИЕ  Веб-API предоставляет несколько URL-адресов,
которые можно использовать, чтобы получить доступ к данным на
сервере или изменить их. Обычно к нему обращаются по протоко-
лу HTTP .
В наши дни мобильные приложения стали обычным явлением,
и с точки зрения серверного приложения они похожи на клиентские од-
ностраничные приложения. Мобильное приложение обычно обменива-
ется данными с серверным приложением, используя HTTP Web API, по-
лучая данные в распространенном формате, таком как JSON, совсем как
в одностраничном приложении. Затем оно изменяет пользовательский
интерфейс приложения в зависимости от получаемых данных.
Последний вариант использования веб-API – это приложение, пред-
назначенное для частичного или единственного потребления другими

317 Что такое веб-API, и когда его следует использовать?
серверными службами. Представьте, что вы создали веб-приложение
для отправки электронных писем. Создав веб-API, вы можете разре-
шить другим разработчикам приложений использовать вашу службу
электронной почты, отправляя вам адрес электронной почты и сообще-
ние. Практически все языки и платформы имеют доступ к HTTP-биб-
лиотеке, которую они могут использовать для доступа к вашей службе
из кода.
Это все, что нужно для веб-API. Он предоставляет ряд конечных точек
(URL-адресов), куда клиентские приложения могут отправлять запросы
и получать от них данные. Они используются для управления поведени-
ем клиентских приложений, а также для предоставления всех данных,
которые необходимы клиентским приложениям для отображения пра-
вильного пользовательского интерфейса.
Нужно ли вам веб-API для приложения ASP .NET Core, зависит от типа
приложения, которое вы хотите создать. Если вы знакомы с фреймвор-
ками для разработки приложений на стороне клиента, вам нужно разра-
ботать мобильное приложение или у вас уже настроен конвейер сборки
SPA, скорее всего, вы захотите добавить веб-API, которые они могут ис -
пользовать для доступа к вашему приложению.
Одним из преимуществ использования веб-API является то, что он
может служить универсальной серверной частью для всех ваших кли-
ентских приложений. Например, вы можете начать с создания клиент -
ского приложения, использующего веб-API. Позже вы можете добавить
мобильное приложение, применяющее тот же веб-API, с небольшими из-
менениями или без изменений, необходимых для вашего кода ASP .NET
Core.
Если вы новичок в веб-разработке, вам нужно вызывать приложение
извне веб-браузера или вы не хотите прилагать усилия, связанные с на-
стройкой клиентского приложения, то вам, вероятно, изначально не по-
надобятся веб-API. Вы можете придерживаться создания пользователь-
ского интерфейса с по мощью Razor Pages и, несомненно, будете очень
продуктивны!
ПРИМЕЧАНИЕ  Несмотря на то что в  отрасли произошел сдвиг
в  сторону фреймворков для разработки приложений на стороне
клиента, отрисовка на стороне сервера с использованием Razor по-
прежнему актуальна. Какой подход выберете вы, во многом будет
зависеть от ваших предпочтений при создании приложений тра-
диционным способом по сравнению с использованием Java Script
на стороне клиента.
При этом не стоит беспокоиться о добавлении веб-API в приложение
заранее. Добавить их позже очень просто, поэтому всегда можно изна-
чально игнорировать их и добавлять по мере необходимости. Во многих
случаях это будет лучшим подходом.

318 Глава 9 Создание веб-API для мобильных и клиентских приложений
Одностраничные приложения и ASP.NET Core
Кросс-платформенный и легкий дизайн ASP.NET Core означает, что он хо-
рошо подходит для использования его в качестве серверной части для вы-
бранного вами фреймворка. Учитывая тематику этой книги и широкий спектр
одностраничных приложений в  целом, я  не буду рассматривать здесь An-
gular, React или другие фреймворки. Вместо этого я предлагаю обратиться
к  ресурсам, соответствующим выбранному вами фреймворку. В  издатель-
стве Manning можно найти книги по всем распространенным Java Script-
фреймворкам для создания клиентских приложений, а также по Blazor:
 «React в действии» Марка Тиленса Томаса (Manning, 2018);
 «Angular в действии» Джереми Уилкена (Manning, 2018);
  «Vue.js в  действии» Эрика Хэнчетта и  Бенджамина Листвона (Manning,
2018);
 «Blazer в действии» Криса Сейнти (Manning, 2021).
После того как вы убедились, что вам нужен веб-API для вашего при-
ложения, его легко будет создать, поскольку он встроен в ASP .NET Core.
В следующем разделе вы увидите, как создать проект с веб-API и свой
первый контроллер API.
9.2 Создание первого проекта веб-API
В этом разделе вы узнаете, как создать проект с веб-API в ASP .NET Core
и свои первые контроллеры веб-API. Вы увидите, как использовать ме-
тоды действий контроллера для обработки HTTP-запросов и объекты Ac-
tionResult для генерации ответа.
Некоторые думают, что паттерн проектирования MVC применяется
только к  приложениям, которые напрямую визуализируют пользова-
тельский интерфейс, например представления Razor, которые вы видели
в предыдущих главах. В ASP .NET Core паттерн MVC одинаково хорошо
применяется при создании веб-API, но часть представления	 MVC пред-
полагает создание удобного для машины ответа, а не ответа, удобного
для пользователя.
Параллельно с этим вы создаете контроллеры веб-API в ASP .NET Core
точно так же, как создаете традиционные контроллеры MVC. Единствен-
ное, что их отличает с точки зрения кода, – это тип возвращаемых дан-
ных: контроллеры MVC обычно возвращают объект ViewResult, а конт -
роллеры веб-API  – низкоуровневые объекты .NET из своих методов
действий или IActionResult, например StatusCodeResult, как вы видели
в главе 4.
ПРИМЕЧАНИЕ  Это отличается от предыдущей версии ASP .NET,
где стеки MVC и веб-API были полностью независимыми. ASP .NET
Core объединяет два стека в единый подход (и добавляет сюда Ra-

319 Создание первого проекта веб-API
zor Pages), благодаря чему можно безболезненно использовать лю-
бой вариант в проекте!
Чтобы вы представляли, с чем работаете, на рис. 9.3 показан результат
вызова конечной точки веб-API из вашего браузера. Вместо дружествен-
ного HTML-интерфейса вы получаете данные, которые можно легко ис -
пользовать в коде. В этом примере веб-API возвращает список названий
фруктов в формате JSON в виде строковых значений при запросе URL-
адреса /fruit.
Рис. 9.3 Т естирование веб-API путем доступа к URL-адресу в браузере.
Выполняется запрос с по мощью метода GET к URL-адресу /fruit, который
возвращает List <string>, закодированный в формате JSON в массив строк
ПОДСКАЗКА  Доступ к веб-API обычно осуществляется одностра-
ничными или мобильными приложениями из кода, но, получив
прямой доступ к URL-адресу в веб-браузере, можно просмотреть
данные, возвращаемые API.
Приложения ASP .NET Core 5.0 также включают в себя полезную конеч-
ную точку для тестирования и изучения разрабатываемого вами проекта
с веб-API под названием Swagger UI, как показано на рис. 9.4. Это позво-
ляет просматривать конечные точки в приложении и ожидаемые ответы
и экспериментировать с отправкой запросов.
ПРИМЕЧАНИЕ  Пользовательский интерфейс Swagger основан
на стандартной спецификации OpenAPI (ранее известной как
Swagger, www. openapis.org), которая по умолчанию активирована
в приложениях с веб-API. OpenAPI предоставляет способ докумен-
тирования вашего API, чтобы вы могли автоматически генериро-
вать клиентов для взаимодействия с  ним в  десятках различных
языков. Дополнительные сведения об OpenAPI и Swagger в прило-
жениях ASP .NET Core см. 	на странице http://mng.bz/QmjR.
Можно создать новый проект веб-API в Visual Studio, используя тот же
подход New Project, который вы видели в главе 2. Создайте новое при-
ложение ASP .NET Core, указав имя проекта, и, когда дойдете до диало-
гового окна New Project, выберите ASP . NET Core Web API, как показано
на рис. 9.5. Если вы используете интерфейс командной строки, то можно
создать аналогичный шаблон с применением dotnet new webapi -o Web-
Application1.

320 Глава 9 Создание веб-API для мобильных и клиентских приложений
Путь к файлу
определения swagger/
OpenAPI, управляющему
пользовательским
интерфейсом Swagger
Имя контроллера
Доступные URL-адреса
и их HTTP-методы
Отправка запроса выбранной
конечной точке
Подробная информация
о запросе к API
Код состояния ответа,
заголовки и тело
Рис. 9.4 Шаблоны веб-API ASP.NET Core 5.0 по умолчанию настроены на использование
пользовательского интерфейса Swagger. Он предоставляет удобную веб-страницу для изучения
вашего веб-API и взаимодействия с ним. По умолчанию этот пользовательский интерфейс
активирован только в окружении разработки, но его также можно включить в промышленном
окружении, если хотите
Убедитесь, что выбрано
.NET Core
Выберите веб-API
ASP .NET CoreУбедитесь, что выбрано ASP .NET Core 5.0
Убедитесь, что для схемы
аутентификации задано
значение No Authentication
Убедитесь, что отмечена
опция Configure for HTTP
и снят флажок напротив
опции Enable Docker Support
Щелкните Create, чтобы
сгенерировать приложение
из выбранного шаблона
Рис. 9.5 Экран шаблона веб-приложения. Этот экран следует после диалогового окна
Configure Your Project и позволяет настроить шаблон, который будет генерировать ваше
приложение. Выберите шаблон веб-API ASP.NET Core, чтобы создать проект веб-API

321 Создание первого проекта веб-API
Шаблон API настраивает проект ASP .NET Core только для контроллеров
веб-API. Эта конфигурация происходит в файле Startup.cs, как показано
в листинге 9.1. Если вы сравните этот шаблон со своими проектами Razor
Pages, то увидите, что проект Web API использует метод AddControllers()
вместо AddRazorPages() в методе ConfigureServices.
Кроме того, контроллеры API добавляются вместо Razor Pages путем
вызова метода MapControllers() в методе UseEndpoints. Шаблон веб-API
по умолчанию также добавляет сервисы и конечные точки Swagger, необ-
ходимые для пользовательского интерфейса Swagger, показанного ранее
на рис. 9.4. Если вы используете в проекте и Razor Pages, и веб-API, то
нужно будет добавить все эти вызовы методов в свое приложение.
Листинг 9.1 Класс Startup для проекта веб-API по умолчанию
public class Startup
{
public void ConfigureServices(IServiceCollection services)
{
services.AddControllers();
services.AddSwaggerGen(c =>
{
c.SwaggerDoc("v1", new OpenApiInfo {
Title = "DefaultApiTemplate", Version = "v1" });
});
}
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
if (env.IsDevelopment())
{
app.UseDeveloperExceptionPage();
app.UseSwagger();
app.UseSwaggerUI(c => c.SwaggerEndpoint(
"/swagger/v1/swagger.json", "DefaultApiTemplate v1"));
}
app.UseHttpsRedirection();
app.UseRouting();
app.UseAuthorization();
app.UseEndpoints(endpoints =>
{
endpoints.MapControllers();
});
}
}
Файл Startup.cs в листинге 9.1 инструктирует ваше приложение найти
все контроллеры API в приложении и настроить их в  EndpointMiddleware.
Каждый метод действия становится конечной точкой и может получать
запросы, когда RoutingMiddleware сопоставляет входящий URL-адрес
с методом действия.Метод AddControllers добавляет
в ваше приложение необходимые
сервисы для контроллеров API.
Добавляет
сервисы,
необходимые
для создания
документа
спецификации
Swagger/
OpenAPI.
Добавляет промежуточное ПО Swagger UI
для изучения вашего веб-API.
Метод MapControllers настраивает
действия контроллера API в вашем
приложении как конечные точки.

322 Глава 9 Создание веб-API для мобильных и клиентских приложений
ПРИМЕЧАНИЕ  Необязательно использовать отдельные проекты
для контроллеров Razor Pages и Web API, но я предпочитаю делать
это там, где возможно. Есть определенные аспекты (например, об-
работка ошибок и аутентификация), которые упрощаются за счет
использования этого подхода. Конечно, при запуске двух отдель-
ных приложений есть свои трудности!
Можно добавить контроллер веб-API в  свой проект, создав новый
файл с расширением .cs в любом месте проекта. Обычно они помеща-
ются в папку Controllers, но это не является техническим требованием.
В листинге 9.2 показан код, который использовался для создания веб-
API, показанного на рис. 9.3. Этот банальный пример подчеркивает сход-
ство с традиционными контроллерами MVC.
Листинг 9.2 Простой контроллер веб-API
[ApiController]
public class FruitController : ControllerBase
{
List<string> _fruit = new List<string>
{
"Pear",
"Lemon",
"Peach"
};
[HttpGet("fruit")]
public IEnumerable<string> Index()
{
return _fruit;
}
}
Веб-API обычно используют атрибут [ApiController] (введенный
в .NET Core 2.1) на контроллерах API и являются производными от класса
ControllerBase. Базовый класс предоставляет несколько вспомогатель-
ных методов для генерации результатов, а атрибут [ApiController] ав-
томатически применяет некоторые общие соглашения, как вы увидите
в разделе 9.5.
СОВЕТ  Существует также базовый класс Controller, который
обычно используется, когда вы применяете контроллеры MVC
с представлениями Razor. Он не является обязательным для конт -
рол леров веб-API, поэтому класс ControllerBase – наиболее под-
ходящий вариант.Контроллеры веб-API обычно используют атрибут
[ApiController] для принятия общепринятых соглашений.
Класс ControllerBase предоставляет
несколько полезных функций
для создания IActionResults.
Возвращаемые данные обычно
берутся из модели приложения
в реальном приложении.
Атрибут [HttpGet] определяет
шаблон маршрута, используемый
для вызова действия.
Название метода действия, Index,
не используется для маршрутизации.
Это может быть любое другое имя. Контроллер предоставляет единственный метод
действия, который возвращает список фруктов.

323 Создание первого проекта веб-API
В листинге 9.2 видно, что метод действия Index возвращает список
строк непосредственно из метода действия. Когда вы возвращаете дан-
ные из такого действия, то предоставляете модель API для запроса. Кли-
ент получит эти данные. Они форматируются в соответствующий ответ,
представление списка в  формате JSON, как показано на рис.  9.3, и  от -
правляются обратно в браузер с кодом состояния 200 OK.
СОВЕТ  ASP .NET Core по умолчанию форматирует данные в фор-
мате JSON. В разделе 9.6 вы увидите, как форматировать возвра-
щаемые данные другими способами.
URL-адрес, по которому предоставляется действие контроллера веб-
API, обрабатывается так же, как и в случае с традиционными контрол-
лерами MVC и страницами Razor – используя маршрутизацию. Атрибут
[HttpGet("fruit")], примененный к  методу Index, указывает, что ме-
тод должен использовать шаблон маршрута "fruit" и отвечать на GET-
запросы. Подробнее о  маршрутизации атрибутов вы узнаете в  разде-
ле 9.5.
В листинге 9.2 данные возвращаются непосредственно из метода дей-
ствия, но вам не нужно этого делать. Вместо этого вы можете вернуть
объект ActionResult, и часто это и требуется. В зависимости от желаемого
поведения вашего API иногда вам может понадобиться вернуть данные,
а в других случаях вам нужно будет вернуть низкоуровневый код состоя-
ния HTTP , указывающий, был ли запрос успешным. Например, если вы-
полняется вызов API с запросом сведений о продукте, которого не су -
ществует, вы можете вернуть код состояния 404 Not Found.
В листинге 9.3 показан пример такого случая. Здесь видно еще одно
действие с тем же классом FruitController, что и раньше. Данный метод
предоставляет клиентам возможность получить конкретный фрукт по
идентификатору, который, как мы предполагаем, в этом примере явля-
ется его индексом в списке _fruit, который мы определили в предыду -
щем листинге. Привязка модели используется, чтобы задать значение
параметра id из запроса.
ПРИМЕЧАНИЕ  Контроллеры API используют привязку модели,
как вы видели в  главе 6, для привязки параметров метода дей-
ствия к входящему запросу. Привязка модели и валидация рабо-
тают точно так же, как и в случае с Razor Pages: вы можете привя-
зать запрос к простым примитивам, а также к сложным объектам
C#. Единственная разница состоит в  том, что модели PageModel
со свойствами [BindProperty] не существует – можно выполнить
привязку только к параметрам метода действия.

324 Глава 9 Создание веб-API для мобильных и клиентских приложений
Листинг 9.3  Действие веб-API, возвращающее IActionResult
для обработки условий ошибки
[HttpGet("fruit/{id}")]
public ActionResult<string> View(int id)
{
if (id >= 0 && id < _fruit.Count)
{
return _fruit[id];
}
return NotFound();
}
В успешном пути для метода действия параметр id имеет значение
больше 0 и меньшее, чем количество элементов в списке _fruit. Если это
правда, то значение элемента возвращается вызывающему компоненту.
Как и в листинге 9.2, это достигается простым прямым возвратом данных,
что генерирует код состояния 200 и возвращает элемент в теле ответа, как
показано на рис. 9.6. Также можно было бы вернуть данные с по мощью
объекта OkResult, возвращая Ok(_fruit [id]), используя вспомогатель-
ный метод Ok1 класса ControllerBase – под капотом результат идентичен.
Данные
возвращаются
в теле ответа
Ответ отправляется с кодом
состояния 200 OK
Рис. 9.6 Данные, возвращаемые из метода действия, сериализуются в тело ответа,
и он генерирует ответ с кодом состояния 200 OK
1 Некоторым становится не по себе, когда они видят фразу «вспомогательный
метод», но во вспомогательных методах класса ControllerBase нет ничего вол-
шебного – это сокращение для создания нового IActionResult заданного типа.
Впрочем, не нужно верить мне на слово. Вы всегда можете просмотреть исход-
ный код базового класса на GitHub по адресу http://mng.bz/goG8.Определяет шаблон маршрута
для метода действия.Метод действия возвращает
ActionResult<string>, поэтому
он может возвращать строку
или объект ActionResult.
Элемент может быть возвращен только
в том случае, если значение id является
допустимым индексом элемента _fruit.
При прямом возврате будут возвращены
данные с кодом состояния 200.
NotFound возвращает объект NotFoundResult,
который отправит код состояния 404.

325 Создание первого проекта веб-API
Если параметр id находится за пределами списка _fruit, метод вы-
зывает метод NotFound для создания объекта NotFoundResult. При выпол-
нении этот метод генерирует код состояния 404 Not Found. Атрибут [Api-
Controller] автоматически преобразует ответ в стандартный экземпляр
ProblemDetails, как показано на рис. 9.7.
Атрибут [ApiResponse] создает
экземпляр ProblemDetails,
сериализованный в JSON, в качестве
тела ответа
Ответ отправляется с кодом
состояния 404 Not Found
Рис. 9.7  Атрибут [ApiController] преобразует ответы об ошибках (в данном случае ответ 404)
в стандартный формат ProblemDetails
ОПРЕДЕЛЕНИЕ  ProblemDetails  – это веб-спецификация для
предо ставления машиночитаемой ошибки для HTTP API. Подроб-
нее о них – в разделе 9.5.
Один аспект из листинга 9.3, который может вас сбить с толку, заклю-
чается в том, что в случае успеха мы возвращаем строку, но в сигнатуре
метода View говорится, что мы возвращаем ActionResult<string>. Как та-
кое возможно? Почему это не ошибка компилятора?
В обобщенном типе ActionResult<T> для этого используются некото-
рые особенности языка C# для работы с неявными преобразованиями1.
Использование типа ActionResult<T> имеет два преимущества:
вы можете вернуть либо экземпляр T, либо реализацию объекта Ac-
tionResult, например NotFoundResult, из того же метода. Это может
быть удобно, как в листинге 9.3;
это обеспечивает лучшую интеграцию с поддержкой OpenAPI в ASP .
NET Core.
Вы можете возвращать любой тип ActionResult из контроллеров веб-
API, но обычно это будут экземпляры StatusCodeResult, которые задают
ответ на определенный код состояния, с  ассоциированными данными
или без них. Например, NotFoundResult и  OkResult являются производ-
ными от StatusCodeResult. Еще один часто используемый код состоя-
ния – это 400 Bad Request, который обычно возвращается, когда данные,
предоставленные в запросе, не проходят валидацию. Его можно сгене-
рировать с по мощью BadRequestResult. Во многих случаях атрибут [Api-
1 Как этого добиться? См. исходный код на странице http://mng.bz/5j27 .

326 Глава 9 Создание веб-API для мобильных и клиентских приложений
Controller] может автоматически сгенерировать для вас ответы с кодом
400, как вы увидите в разделе 9.5.
СОВЕТ  В главе 4 вы познакомились с различными объектами Ac-
tionResult. BadRequestResult, OkResult и  NotFoundResult – все они
являются производными от StatusCodeResult и  задают соответ -
ствующий код состояния для своего типа (200, 404 и 400 соответ -
ственно). Использование этих классов-оболочек делает намерения
вашего кода более ясными, вместо того чтобы полагаться на то, что
другие разработчики поймут значение различных номеров кодов
состояния.
Как только вы вернули ActionResult (или другой объект) из своего
конт роллера, он сериализуется в соответствующий ответ. Это работает
несколькими способами, в зависимости от:
форматеров, которые поддерживает ваше приложение;
данных, которые вы возвращаете из своего метода;
форматов данных, которые запрашивающий клиент может обраба-
тывать.
О форматерах и сериализации данных вы подробнее узнаете в разде-
ле 9.6, но, прежде чем мы продолжим, стоит изучить параллели между
традиционными приложениями с отрисовкой на стороне сервера и ко-
нечными точками веб-API. Эти два понятия похожи, поэтому важно уста-
новить общие закономерности и различия.
9.3 Применение паттерна проектирования MVC
к веб-API
В предыдущей версии ASP .NET компания Microsoft использовала обоб-
щенный термин «Web API» для создания фреймворка ASP .NET Web API.
Этот фреймворк, как и следовало ожидать, использовался для создания
конечных точек HTTP , которые могли возвращать данные в  формате
JSON или XML в ответ на запросы.
Фреймворк ASP .NET Web API был полностью отделен от фреймворка
MVC, хотя в нем использовались аналогичные объекты и парадигмы. Ба-
зовые веб-стеки для них были совершенно разными и не могли взаимо-
действовать друг с другом.
В ASP .NET Core все изменилось. Теперь у вас есть единый фреймворк,
который можно использовать для создания как традиционных веб-
приложений, так и  веб-API. Тот же базовый фреймворк используется
в сочетании с контроллерами веб-API, Razor Pages и контроллерами MVC
с представлениями. Вы уже сами это видели; веб-API контроллер Fruit-
Controller, созданный вами в разделе 9.2, очень похож на контроллеры
MVC, которые вы мельком видели в предыдущих главах.

327 Применение паттерна проектирования MVC к веб-API
Следовательно, даже если вы создаете приложение, полностью состо-
ящее из веб-API, без использования отрисовки HTML-кода на стороне
сервера, паттерн проектирования MVC все равно применим. Независи-
мо от того, создаете ли вы традиционные веб-приложения или веб-API,
вы можете структурировать свое приложение практически одинаково.
Надеюсь, теперь вы хорошо знакомы с тем, как ASP .NET Core обраба-
тывает запросы. Но на всякий случай на рис. 9.8 показано, как фрейм-
ворк обрабатывает типичный запрос к  приложению Razor Pages после
прохождения через конвейер промежуточного ПО. В этом примере по-
казано, как может выглядеть запрос на просмотр доступных фруктов на
традиционном веб-сайте продуктового магазина.
1.  Получен запрос к URL-адресу
/fruit/apples
2.  Компонент маршрутизации сопоставляет
запрос с файлом Fruit.cshtml и получает
параметр маршрута category = apples
5.  Обработчик страницы предоставляет
подробные сведения о яблоках и другие
данные, необходимые представлению,
в виде свойств PageModel3.  Параметры метода для обработчика
страницы Razor и свойства
[BindProperty] привязываются
и проверяются, и выполняется
обработчик страницы
4.  Обработчик страницы вызывает
сервисы, составляющие модель
приложения, для извлечения данных,
необходимых для визуализации
представления
6.  Представление использует
предоставленные данные
для генерации ответа в виде
HTML-кода, который возвращается
пользователю через конвейер
промежуточного ПОЗапрос
Модель привязки
Модель привязкиПривязка модели
Валидация модели
Состояние модели
Обработчик страницы
Страница Razor
ПредставлениеСервисы
Взаимодействие
с базой данныхМодель
предметной
области
Модель
приложения
PageModel
HTMLКомпонент
маршрутизации
Рис. 9.8 Обработка запроса к традиционному приложению Razor Pages, в котором
представление генерирует HTML-ответ, отправляемый обратно пользователю. Эта диаграмма
теперь должна быть вам хорошо знакома!
RoutingMiddleware направляет запрос на просмотр всех фруктов, пере-
численных в категории apples, на страницу Razor, Fruit.cshtml. Затем End-

328 Глава 9 Создание веб-API для мобильных и клиентских приложений
pointMiddleware создает модель привязки, проверяет ее, задает ее в ка-
честве свойства PageModel и задает свойство ModelState в базовом классе
PageModel с подробной информацией обо всех ошибках валидации. Об-
работчик страницы взаимодействует с  моделью приложения, вызывая
сервисы, обращаясь к базе данных и получая все необходимые данные.
Наконец, страница Razor выполняет свое представление Razor, ис -
пользуя PageModel для генерации ответа HTML. Ответ возвращается через
конвейер промежуточного ПО и отправляется в браузер пользователя.
Как бы это изменилось, если бы запрос пришел из клиентского или мо-
бильного приложения? Если вы хотите использовать машиночитаемый
формат JSON вместо HTML, насколько велика разница? Как показано на
рис. 9.9, ответ – «она совсем небольшая». Основные изменения связаны
с переключением с Razor Pages на контроллеры и действия, но, как вы
видели в главе 4, оба подхода используют одни и те же общие парадигмы.
1.  Получен запрос к URL-адресу
/fruit/apples
2.  Компонент маршрутизации сопоставляет
запрос с методом класса FruitController
и получает параметр маршрута
category = apples
5.  Контроллер выбирает форматер JSON
и передает ему модель API, содержащую
данные для возврата3.  Параметры метода для метода
действия View привязываются
и проверяются, и выполняется метод
действия
4.  Метод действия вызывает сервисы,
составляющие модель приложения,
для извлечения данных, необходимых
для модели API
6.  Форматер использует
предоставленный API для генерации
JSON-ответа, который возвращается
в одностраничное/мобильное
приложение через конвейер
промежуточного ПОЗапрос
Модель привязки
Модель привязкиПривязка модели
Валидация модели
Состояние модели
Обработчик страницы
Страница Razor
ПредставлениеСервисы
Взаимодействие
с базой данныхМодель
предметной
области
Модель
приложения
PageModel
HTMLКомпонент
маршрутизации
Рис. 9.9 Вызов конечной точки веб-API в веб-приложении для онлайн-торговли.
Заштрихованная часть диаграммы идентична той, что изображена на рис. 9.8

329 Применение паттерна проектирования MVC к веб-API
Как и раньше, компонент маршрутизации выбирает конечную точку
для вызова на основе входящего URL-адреса. Для контроллеров API это
контроллер и действие, а не страница Razor.
После маршрутизации идет привязка модели, в которой связыватель
создает модель привязки и заполняет ее значениями из запроса. Веб-API
часто принимают данные в  бóльшем количестве форматов, чем Razor
Pages, например XML, но в остальном процесс привязки модели такой
же, как и для запроса Razor Pages. Валидация происходит таким же обра-
зом, и свойство ModelState в базовом классе ControllerBase заполняется
ошибками валидации.
ПРИМЕЧАНИЕ  Веб-API используют форматеры	 ввода, чтобы при-
нимать данные, отправляемые им в различных форматах. Обычно
это форматы JSON или XML, но можно создавать форматеры ввода
для любого типа, например CSV. Я показываю, как активировать
форматер ввода XML, в разделе 9.6. Как создать собственный фор-
матер ввода, можно увидеть на странице http://mng.bz/e5gG.
Метод действия эквивалентен обработчику Razor Page; он точно так
же взаимодействует с моделью приложения. Это важный момент; путем
отделения поведения вашего приложения в модель приложения, вместо
того чтобы включать его в свои страницы и сами контроллеры, можно
повторно использовать бизнес-логику своего приложения с нескольки-
ми парадигмами пользовательского интерфейса.
СОВЕТ  По возможности делайте обработчики страниц и  конт -
роллеры максимально простыми. Перенесите все решения бизнес-
логики в  сервисы, которые улучшат модель вашего приложения,
и  следите за тем, чтобы ваши страницы Razor и  контроллеры API
были сосредоточены на механике взаимодействия с пользователем.
После того как модель приложения вернет данные, необходимые для
обслуживания запроса – объекты фруктов в категории apples, – вы уви-
дите первое существенное различие между контроллерами API и Razor
Pages. Вместо того чтобы добавлять значения в  PageModel для использо-
вания в  представлении, Razor метод действия создает модель	API. Это
аналог PageModel, но в  ней нет данных, используемых для генерации
представления HTML. Она содержит данные, которые будут отправлены
обратно в ответе.
ОПРЕДЕЛЕНИЕ  Модели представления и  PageModel содержат
данные, необходимые для построения ответа, и метаданные о том,
как это сделать. Обычно модели API содержат только те данные,
которые должны быть возвращены в ответе.
Когда мы изучали приложение Razor Pages, то использовали PageModel
в сочетании с шаблоном представления Razor для создания окончатель-

330 Глава 9 Создание веб-API для мобильных и клиентских приложений
ного ответа. В приложении Web API мы используем API-модель в соче-
тании с  форматером	 вывода. Форматер вывода, как следует из названия,
сериализует модель API в машиночитаемый ответ, такой как JSON или
XML. Он формирует букву «V» в веб-API-версии MVC, выбирая соответ -
ствующее представление возвращаемых данных.
Наконец, что касается приложения Razor Pages, сгенерированный от -
вет затем отправляется обратно через конвейер промежуточного ПО,
проходя через каждый из сконфигурированных компонентов, и возвра-
щается обратно к исходному вызывающему компоненту.
Надеюсь, параллели между Razor Pages и веб-API очевидны; бóльшая
часть поведения идентична – меняется только ответ. Все, от момента по-
ступления запроса до взаимодействия с моделью приложения, очень по-
хоже в обеих парадигмах.
Большинство различий между Razor Pages и веб-API связаны не с тем,
как фреймворк работает под капотом, а с тем, как используются разные
парадигмы. Например, в следующем разделе вы узнаете, как конструк -
ции маршрутизации, которые мы рассматривали в главе 5, используются
с веб-API с по мощью маршрутизации на основе атрибутов.
9.4 Маршрутизация на основе атрибутов:
связывание методов действий
с URL-адресами
В этом разделе вы узнаете о маршрутизации на основе атрибутов: ме-
ханизме связывания действий контроллера API с заданным шаблоном
маршрута. Вы увидите, как связать действия контроллера с определен-
ными HTTP-методами, такими как GET и POST, и как избежать дублиро-
вания в своих шаблонах.
Мы подробно рассматривали шаблоны маршрутов в главе 5 в контекс -
те Razor Pages, и вам будет приятно узнать, что точно такие же шаблоны
маршрутов используются и с контроллерами API. Единственная разница
заключается в том, как вы указываете шаблоны: с Razor Pages вы исполь-
зуете директиву @page, а с контроллерами API – атрибуты маршрутизации.
ПРИМЕЧАНИЕ  Как Razor Pages, так и контроллеры API использу -
ют маршрутизацию	 на	основе	атрибутов	 под капотом. Альтерна-
тивный вариант, маршрутизация	 на	основе	соглашений, обычно ис -
пользуется с традиционными контроллерами и представлениями
MVC. Как уже обсуждалось ранее, я не рекомендую использовать
данный подход, поэтому в этой книге не рассматриваю маршру -
тизацию на основе соглашений.
С помощью маршрутизации на основе атрибутов вы декорируете
каждый метод действия в контроллере API атрибутом и предоставляете

331 Маршрутизация на основе атрибутов: связывание методов действий
ассоциированный шаблон маршрута для метода действия, как показано
в следующем листинге.
Листинг 9.4 Пример маршрутизации на основе атрибутов
public class HomeController: Controller
{
[Route("")]
public IActionResult Index()
{
/* Реализация метода */
}
[Route("contact")]
public IActionResult Contact()
{
/* Реализация метода */
}
}
Каждый атрибут [Route] определяет шаблон маршрута, который дол-
жен быть ассоциирован с  методом действия. В  приведенном примере
URL-адрес / сопоставляется напрямую с  методом Index, а  URL-адрес
/contact – с методом Contact.
Маршрутизация на основе атрибутов сопоставляет URL-адреса с опре-
деленным методом действия, но один метод действия по-прежнему
может иметь несколько шаблонов маршрутов и, следовательно, может
соответствовать нескольким URL-адресам. Каждый шаблон должен объ-
являться со своим собственным атрибутом RouteAttribute, как показано
в  этом листинге, представляющим собой каркас веб-API для гоночной
игры.
Листинг 9.5  Маршрутизация на основе атрибутов с несколькими
атрибутами
public class CarController
{
[Route("car/start")]
[Route("car/ignition")]
[Route("start-car")]
public IActionResult Start()
{
/* Реализация метода */
}
[Route("car/speed/{speed}")]
[Route("set-speed/{speed}")]
public IActionResult SetCarSpeed(int speed)
{
/* Реализация метода */
}
}Действие Index будет выполнено, когда
будет выполнен запрос к URL-адресу /.
Действие Contact будет выполнено, когда
будет выполнен запрос к URL-адресу /contact.
Метод Start будет выполнен
при совпадении любого из этих
шаблонов маршрута.
Имя метода действия не влияет
на шаблон маршрута.
Шаблон RouteAttribute может содержать
параметры маршрута, в данном случае {speed}.

332 Глава 9 Создание веб-API для мобильных и клиентских приложений
В этом листинге показаны два разных метода действий, к каждому из ко-
торых можно получить доступ из нескольких URL-адресов. Например, ме-
тод Start будет выполнен при запросе любого из следующих URL-адресов:
/car/start;
/car/ignition;
/start-car.
Эти адреса полностью независимы от имен контроллера и  методов
действия; важно только значение RouteAttribute.
ПРИМЕЧАНИЕ  По умолчанию при использовании RouteAttri-
bute имена контроллера и действия не влияют на URL-адреса или
шаблоны маршрутов.
Шаблоны, используемые в  атрибутах маршрута, являются стандарт -
ными шаблонами маршрута. Это те же шаблоны, которые вы использова-
ли в главе 5. Можно применить литеральные сегменты и определить па-
раметры маршрутов, которые будут извлекать значения из URL-адреса,
как показано в  предыдущем листинге с  участием метода SetCarSpeed.
Данный метод определяет два шаблона маршрута, каждый из которых
определяет параметр маршрута, {speed}.
СОВЕТ  В  этом примере я  использовал несколько атрибутов
[Route] для каждого действия, но лучше всего предоставлять дей-
ствие по одному URL-адресу. Так ваш API будет проще понять,
и другим приложениям будет легче потреблять его.
Параметры маршрута обрабатываются так же, как и для Razor Pages, –
они представляют собой сегмент URL-адреса, который может меняться.
Что касается Razor Pages, то параметры маршрута в  ваших шаблонах
RouteAttribute могут:
быть необязательными;
иметь значения по умолчанию;
использовать ограничения маршрута.
Например, можно было бы обновить метод SetCarSpeed из предыду -
щего листинга, чтобы ограничить параметр маршрута {speed} целым
числом и значением по умолчанию, равным 20, например:
[Route("car/speed/{speed=20:int}")]
[Route("set-speed/{speed=20:int}")]
public IActionResult SetCarSpeed(int speed)
ПРИМЕЧАНИЕ  Как мы уже обсуждали в главе 5, не стоит исполь-
зовать ограничения маршрута для валидации. Например, если вы
вызовете предыдущий маршрут "set-speed /{speed=20:int}" с не-
допустимым значением скорости, /set-speed/oops, то получите
ответ 404 Not Found, поскольку маршрут не совпадает. Без ограни-
чения int вы получите более разумный ответ 400 Bad Request.

333 Маршрутизация на основе атрибутов: связывание методов действий
Если вам удалось разобраться с маршрутизацией в главе 5, то марш-
рутизация с  по мощью контроллеров API не должна преподнести вам
никаких сюрпризов. Одна вещь, которую вы, возможно, станете заме-
чать, когда начнете использовать маршрутизацию на основе атрибутов
с контроллерами API, – это количество повторов. Razor Pages устраняет
множество повторов, используя условные обозначения для вычисления
шаблонов маршрутов на основе имени файла Razor Page.
К счастью, есть несколько функций, которые могут сделать вашу жизнь
немного проще. В частности, объединение атрибутов маршрута и заме-
ны маркера может помочь вам уменьшить дублирование в коде.
9.4.1 Сочетание атрибутов маршрута, чтобы
ваши шаблоны маршрутов следовали принципу DRY
Добавление атрибутов маршрута ко всем своим контроллерам API мо-
жет быть немного утомительным занятием, особенно если вы в основ-
ном следуете соглашениям, в которых ваши маршруты имеют стандарт -
ный префикс, такой как "api" или имя контроллера. Как правило, нужно
убедиться, что вы следуете принципу DRY (don’t repeat yourself), когда
речь идет об этих строках. В следующем листинге показаны два метода
действия с несколькими атрибутами [Route] (этот листинг приводится
здесь только в показательных целях. По возможности придерживайтесь
одного атрибута на каждое действие!).
Листинг 9.6 Дублирование в шаблонах RouteAttribute
public class CarController
{
[Route("api/car/start")]
[Route("api/car/ignition")]
[Route("/start-car")]
public IActionResult Start()
{
/* Реализация метода */
}
[Route("api/car/speed/{speed}")]
[Route("/set-speed/{speed}")]
public IActionResult SetCarSpeed(int speed)
{
/* Реализация метода */
}
}
Здесь довольно много дублирования  – вы добавляете "api/car"
к большинству своих маршрутов. Предположительно, если бы вы реши-
ли написать вместо этого "api/vehicles", вам пришлось бы просмотреть
каждый атрибут и обновить его. Такой код так и напрашивается на опе-
чатку!В нескольких шаблонах маршрутов
используется один и тот же префикс api/car.

334 Глава 9 Создание веб-API для мобильных и клиентских приложений
Чтобы облегчить ситуацию, можно применить атрибуты RouteAttri-
bute к контроллерам в дополнение к методам действий, как вы вкратце
видели в главе 5. Когда и у контроллера, и у метода действия есть атрибут
маршрута, общий шаблон маршрута для метода рассчитывается путем
объединения двух шаблонов.
Листинг 9.7 Объединение шаблонов RouteAttribute
[Route("api/car")]
public class CarController
{
[Route("start")]
[Route("ignition")]
[Route("/start-car")]
public IActionResult Start()
{
/* Реализация метода */
}
[Route("speed/{speed}")]
[Route("/set-speed/{speed}")]
public IActionResult SetCarSpeed(int speed)
{
/* Реализация метода */
}
}
Данное сочетание атрибутов может уменьшить дублирование в шаб-
лонах маршрутов и упростить добавление или изменение префиксов (на-
пример, поменять "car" на " vehicle") для нескольких методов действия.
Чтобы игнорировать атрибут RouteAttribute контроллера и создать абсо-
лютный шаблон маршрута, начните шаблон маршрута метода действия
с  косой черты (/). Применение RouteAttribute контроллера уменьшает
дублирование, но есть способ лучше – использовать замену маркера.
9.4.2 Использование замены маркера для уменьшения
дублирования при маршрутизации на основе
атрибутов
Возможность сочетать маршруты атрибутов удобна, но какое-то дубли-
рование все равно остается, если вы добавляете к маршрутам префикс
с именем контроллера или если в шаблонах маршрутов всегда использу -
ется имя действия. Если хотите, можно сделать еще проще!
Маршруты атрибутов поддерживают автоматическую замену марке-
ров [action] и [controller] в маршрутах атрибутов. Они будут заменены
именами действия и  контроллера (без суффикса «Controller») соответ -
ственно. Маркеры заменяются после объединения всех атрибутов, по-
этому это полезно, если у вас есть иерархии наследования контроллеров.
В следующем листинге показано, как создать класс BaseController, ко -Объединяется для
получения шаблона
«api/car/start».Объединяется для
получения шаблона
«api/car/ignition».
Не объединяется, потому что начинается
с / и дает шаблон «start-car».
Объединяется для получения шаблона
«api/car/speed/{speed}».
Не объединяется, потому что
начинается с / и дает шаблон
«/set-speed/{speed}».

335 Маршрутизация на основе атрибутов: связывание методов действий
торый можно использовать, чтобы применить согласованный префикс
шаблона маршрута ко всем контроллерам API в вашем приложении.
Листинг 9.8 Замена маркера в RouteAttributes
[Route("api/[controller]")]
public abstract class BaseController { }
public class CarController : BaseController
{
[Route("[action]")]
[Route("ignition")]
[Route("/start-car")]
public IActionResult Start()
{
/* Реализация метода */
}
}
ВНИМАНИЕ!  Если вы используете замену для маркеров [action]
или [controller], помните, что переименование классов и мето-
дов приведет к  изменению вашего открытого API. Если вас это
беспокоит, можно вместо этого использовать статические строки,
такие как "car".
В сочетании с тем, что вы узнали в главе 5, мы рассмотрели почти все,
что нужно знать о маршрутизации на основе атрибутов. Есть еще одна
вещь, на которую следует обратить внимание: обработка различных ти-
пов HTTP-методов, таких как GET и POST.
9.4.3 Обработка HTTP-методов с по мощью маршрутизации
на основе атрибутов
В Razor Pages HTTP-методы, такие как GET или POST, не участвуют в про-
цессе маршрутизации. Компонент RoutingMiddleware определяет, какую
страницу Razor выполнять, исключительно на основе шаблона марш-
рута, ассоциированного со страницей Razor. HTTP-метод используется
только перед выполнением страницы Razor, чтобы решить, какой обра-
ботчик страницы выполнить: например, OnGet для метода GET или On-
Post для метода POST.
С контроллерами API все работает немного иначе. Для контроллеров
API HTTP-метод принимает участие в  самом процессе маршрутиза-
ции, поэтому GET-запрос можно маршрутизировать на одно действие,
а POST-запрос – на другое, даже	если	запрос	использовал	 один	и тот	же
URL-адрес. Этот паттерн, в котором HTTP-метод является важной частью
маршрутизации, распространен в проектировании HTTP API.Можно применять атрибуты к базовому
классу, а производные классы будут
наследовать их.
Замена маркера происходит последней,
поэтому [controller] заменяется на «car»,
а не «base».
Объединяет и заменяет
маркеры, чтобы получить
шаблон «api/car/start».Объединяет и заменяет
маркеры, чтобы
получить шаблон
«api/car/ignition».
Не объединяется с базовыми атрибутами, потому
что начинается с /, и поэтому остается «start-car».

336 Глава 9 Создание веб-API для мобильных и клиентских приложений
Например, представьте, что вы создаете API для управления своим ка-
лендарем и хотите иметь возможность составлять список встреч и соз-
давать их. Ну что же, традиционная служба REST могла бы определить
следующие URL-адреса и HTTP-методы:
GET /appointments – создать список всех ваших встреч;
POST /appointments – создать новую встречу.
Обратите внимание, что эти две конечные точки используют один
и тот же URL-адрес; отличается только HTTP-метод. Атрибут [Route], ко -
торый мы использовали до сих пор, отвечает на все HTTP-запросы, а для
нас это не годится – мы хотим выбрать другое действие на основе комби-
нации URL-адреса и метода. Такой паттерн распространен при создании
веб-API, и, к счастью, его легко смоделировать в ASP .NET Core.
ASP .NET Core предоставляет набор атрибутов, которые можно ис -
пользовать, чтобы указать, на какой метод должно отвечать действие.
Например:
[HttpPost] обрабатывает только POST-запросы;
[HttpGet] обрабатывает только запросы GET-запросы;
[HttpPut] обрабатывает только запросы PUT-запросы.
Подобные атрибуты существуют для всех стандартных HTTP-методов,
таких как DELETE и OPTIONS. Эти атрибуты можно использовать вме-
сто атрибута [Route], чтобы указать, что метод действия должен соот -
ветствовать одному HTTP-методу, как показано в следующем листинге.
Листинг 9.9  Использование атрибутов HTTP-метода с маршрутизацией
на основе атрибутов
public class AppointmentController
{
[HttpGet("/appointments")]
public IActionResult ListAppointments()
{
/* Реализация метода */
}
[HttpPost("/appointments")]
public IActionResult CreateAppointment()
{
/* Реализация метода */
}
}
Если ваше приложение получает запрос, совпадающий с  шабло-
ном маршрута метода действия, но не совпадающий с  нужным HTTP-
методом, вы получите ошибку 405 Method not allowed. Например, если вы
отправите запрос с по мощью метода DELETE на URL-адрес /appointments
из предыдущего листинга, то получите ответ с ошибкой 405.
Маршрутизация на основе атрибутов использовалась с контроллерами
API с первых дней существования ASP .NET Core, поскольку она позволя-Выполняется только в ответ на GET-запрос
к URL-адресу /appointments.
Выполняется только в ответ на POST-запрос
к URL-адресу /appointments.

337 Использование общепринятых соглашений с атрибутом [ApiController]
ет строго контролировать URL-адреса, предоставляемые вашим прило-
жением. Когда вы будете создавать контроллеры API, вам придется по-
стоянно писать какой-то повторяющийся код. Атрибут [ApiController],
появившийся в ASP .NET Core 2.1, разработан для того, чтобы справиться
с некоторыми из этих проблем и сократить объем шаблонного кода.
9.5 Использование общепринятых соглашений
с атрибутом [ApiController]
В этом разделе вы узнаете об атрибуте [ApiController] и о том, как с его
помощью можно уменьшить объем кода, который необходимо писать
для создания согласованных контроллеров веб-API. Вы узнаете об ис -
пользуемых в нем соглашениях, о том, почему они полезны и как их от -
ключить, если понадобится.
Атрибут [ApiController] появился в  .NET Core 2.1, дабы упростить
процесс создания контроллеров веб-API. Чтобы понять, что он делает,
полезно взглянуть на пример того, как написать контроллер веб-API
без атрибута [ApiController], и сравнить его с кодом, необходимым для
того, чтобы добиться того же, но уже с атрибутом.
Листинг 9.10 Создание контроллера веб-API без атрибута [ApiController]
public class FruitController : ControllerBase
{
List<string> _fruit = new List<string>
{
"Pear", "Lemon", "Peach"
};
[HttpPost("fruit")]
public ActionResult Update([FromBody] UpdateModel model)
{
if (!ModelState.IsValid)
{
return BadRequest(
new ValidationProblemDetails(ModelState));
}
if (model.Id < 0 || model.Id > _fruit.Count)
{
return NotFound(new ProblemDetails()
{
Status = 404,
Title = "Not Found",
Type = "https://tools.ietf.org/html/rfc7231"
+ "#section-6.5.4",
});
}В этом примере cписок строк служит
моделью приложения.Веб-API используют маршрутизацию
на основе атрибутов для определения
шаблонов маршрутов.
Атрибут [FromBody]
указывает на то, что
параметр должен
быть привязан
к телу запроса.Нужно проверить, была
ли валидация модели
успешной, и вернуть ответ
с кодом состояния 400, если
она не удалась.
Если отправленные
данные не содержат
допустимого
идентификатора, вернуть
ответ 404 ProblemDetails.

338 Глава 9 Создание веб-API для мобильных и клиентских приложений
_fruit[model.Id] = model.Name;
return Ok();
}
public class UpdateModel
{
public int Id { get; set; }
[Required]
public string Name { get; set; }
}
}
В этом примере демонстрируется множество распространенных функ -
ций и паттернов, используемых с контроллерами веб-API:
контроллеры веб-API считывают данные из тела запроса, обычно
отправляемого в формате JSON. Чтобы тело читалось как JSON, а не
как значения формы, необходимо применить атрибут [FromBody]
к параметрам метода, чтобы убедиться, что оно правильно привя-
зано к модели;
как обсуждалось в  главе 6, после привязки выполняется валида-
ция модели, но нужно действовать в соответствии с результатами
валидации. Вы должны вернуть ответ 400 Bad Request, если предо-
ставленные значения не прошли валидацию. Обычно требуется
предоставить подробную информацию о  том, почему запрос был
недействительным: это делается в  листинге 9.10 путем возврата
объекта ValidationProblemDetails в теле ответа, созданного из Mo-
del State;
каждый раз, когда вы возвращаете статус ошибки, например 404 Not
Found, по возможности нужно возвращать сведения о проблеме, ко-
торые позволят вызывающему компоненту диагностировать проб-
лему. В ASP .NET Core это рекомендуется делать с по мощью класса
ProblemDetails.
Код из листинга 9.10 представляет то, что вы могли видеть в контрол-
лере API ASP .NET Core до	.NET Core 2.1. Появление атрибута [ApiCon-
troller] в .NET Core 2.1 (и его последующие улучшения в более поздних
версиях) делает тот же самый код намного проще, как показано в следу -
ющем листинге.
Листинг 9.11 Создание контроллера веб-API с атрибутом [ApiController]
[ApiController]
public class FruitController : ControllerBase
{
List<string> _fruit = new List<string>
{
"Pear", "Lemon", "Peach"
};Обновляем модель и возвращаем ответ
с кодом состояния 200.
UpdateModel действителен только
в том случае, если указано значение Name,
как установлено атрибутом [Required].
При добавлении атрибута [ApiController]
применяется несколько соглашений,
общих для контроллеров API.

339 Использование общепринятых соглашений с атрибутом [ApiController]
[HttpPost("fruit")]
public ActionResult Update(UpdateModel model)
{
if (model.Id < 0 || model.Id > _fruit.Count)
{
return NotFound();
}
_fruit[model.Id] = model.Name;
return Ok();
}
public class UpdateModel
{
public int Id { get; set; }
[Required]
public string Name { get; set; }
}
}
Если вы сравните листинги 9.10 и 9.11, то увидите, что весь выделен-
ный жирным шрифтом код из листинга 9.10 можно удалить и заменить
атрибутом [ApiController] из листинга 9.11. Атрибут [ApiController] ав -
томатически применяет к вашим контроллерам несколько соглашений:
маршрутизация	 на	основе	атрибутов – 	вы должны использовать
маршрутизацию на основе атрибутов со своими контроллерами;
нельзя использовать маршрутизацию на основе соглашений. Ско-
рее всего, вы и не будете, так как мы обсуждали именно подход на
основе атрибутов для контроллеров веб-API;
автоматические	 ответы	 с кодом	 400 – в главе 6 я сказал, что всег-
да нужно проверять значение ModelState.IsValid в  обработчиках
страниц Razor и действиях MVC, но атрибут [ApiController] делает
это за вас, добавляя фильтр. Подробнее о фильтрах мы поговорим
в главе 13;
вывод	источника	 привязки	 модели – если атрибута [ApiController]
нет, то предполагается, что сложные типы передаются в виде значе-
ний формы	 в теле запроса. В случае с веб-API данные гораздо чаще
передаются в формате JSON, что обычно требует добавления атрибу -
та [FromBody]. Атрибут [ ApiController] позаботится об этом за вас;
ProblemDetails для	кодов	ошибок  – часто нужно вернуть согласо-
ванный набор данных при возникновении ошибки в API. Problem-
Details – это тип, основанный на веб-стандарте, который служит
этими согласованными данными. Атрибут [ApiController] будет
перехватывать любые коды состояния ошибки, возвращаемые ва-
шим контроллером (например, 404 Not Found), и автоматически пре-
образовывать их в тип ProblemDetails.Атрибут [FromBody]
предполагается для сложных
параметров метода действия.
Модель проверяется
автоматически, и если
она недействительна,
то возвращается ответ
с кодом состояния 400.
Коды состояния ошибки автоматически
преобразуются в объект ProblemDetails.

340 Глава 9 Создание веб-API для мобильных и клиентских приложений
Ключевой особенностью атрибута [ApiController] является исполь-
зование формата Problem Details для возврата ошибок в согласованном
формате для всех ваших контроллеров1. Типичный объект ProblemDe-
tails выглядит примерно так, как показано ниже. Это пример объекта
ValidationProblemDetails, автоматически сгенерированного для недо-
пустимого запроса:
{
type: "https://tools.ietf.org/html/rfc7231#section-6.5.1"
title: "One or more validation errors occurred."
status: 400
traceId: "|17a2706d-43736ad54bed2e65."
errors: {
name: ["The name field is required."]
}
}
Соглашения [ApiController] могут значительно уменьшить количест -
во шаблонного кода, который вам приходится писать. Они также обеспе-
чивают единообразие всего вашего приложения. Например, вы можете
быть уверены, что все ваши контроллеры будут возвращать один и тот
же тип ошибки, ValidationProblemDetails (подтип ProblemDetails), если
получен неверный запрос.
Преобразование всех ошибок в ProblemDetails
Атрибут [ApiController] гарантирует, что все ответы об ошибках, возвраща-
емые вашими контроллерами API, преобразуются в объекты ProblemDetails,
что обеспечивает согласованность ответов об ошибках во всем приложении.
Единственная проблема заключается в том, что контроллеры API – не един­
ственное, что может вызывать ошибки. Например, если получен URL-адрес,
который не соответствует какому-либо действию в ваших контроллерах, ко-
нечный компонент конвейера промежуточного ПО, который мы обсуждали
в главе 3, сгенерирует ответ 404 Not Found. Поскольку эта ошибка генери-
руется за пределами контроллеров API, ProblemDetails использоваться не
будет. Точно так же, когда ваш код генерирует исключение, вы хотите, чтобы
оно возвращалось как объект ProblemDetails, но по умолчанию этого не
происходит.
В главе 3 я описал несколько типов промежуточного ПО для обработки оши-
бок, которые вы могли бы использовать, чтобы справиться с такими случая-
ми, но справиться со всеми крайними может быть непросто. Я предпочитаю
применять созданный сообществом пакет Hellang.Middleware.ProblemDe-
tails, который сделает это за вас. Прочитать о том, как использовать его, мож -
но в моем блоге по адресу http://mng.bz/Gx7D.
1 Problem Details – это предлагаемый стандарт обработки ошибок машиночита-
емым способом, который набирает популярность. Его спецификацию можно
найти по адресу: https://tools.ietf.org/html/rfc7807 .

341 Генерация ответа от модели
Как это часто бывает в ASP .NET Core, ваша работа будет более продук -
тивной, если вы будете следовать соглашениям, а не пытаться с ними бо-
роться. Однако если какие-то соглашения вам не нравятся или вы хотите
их изменить, можно легко это сделать.
Можно настроить соглашения, используемые вашим приложением,
вызвав метод ConfigureApiBehaviorOptions() объекта IMvcBuilder, воз-
вращаемого из метода AddControllers() в  файле Startup.cs. Например,
можно отключить автоматические ответы с кодом 400 при ошибке вали-
дации, как показано в следующем листинге.
Листинг 9.12 Настройка поведения атрибута [ApiAttribute]
public class Startup
{
public void ConfigureServices(IServiceCollection services)
{
services.AddControllers()
.ConfigureApiBehaviorOptions(options =>
{
options.SuppressModelStateInvalidFilter = true;
})
}
// ...
}
Возможность настройки каждого аспекта ASP .NET Core  – одна из
функций, которая отличает его от предыдущей версии ASP .NET. ASP .NET
Core настраивает подавляющее большинство своих внутренних компо-
нентов, используя один из двух механизмов – внедрение зависимостей
или конфигурирование объекта Options при добавлении сервиса в при-
ложение. Вы увидите это в главах 10 (внедрение зависимостей) и 11 (объ-
ект Options).
В следующем разделе вы узнаете, как управлять форматом данных,
возвращаемых вашими контроллерами веб-API, будь то JSON, XML или
другой формат.
9.6 Генерация ответа от модели
Мы подошли к последней теме этой главы: форматирование ответа. Сей-
час контроллеры API часто возвращают данные в формате JSON, но это
не	всегда так. В данном разделе вы узнаете о согласовании содержимого
и о том, как активировать дополнительные форматы вывода, такие как
XML. Вы также узнаете о важном изменении в форматере JSON для ASP .
NET Core 3.0.
Рассмотрим следующий сценарий: вы создали метод действия веб-API
для возврата списка автомобилей, как показано в  следующем листин-
ге. Он вызывает метод модели вашего приложения, который возвраща-Управляем применяемыми соглашениями
с по мощью лямбда-функции конфигурации.
Отключит автоматические ответы с кодом
состояния 400 на недопустимые запросы.

342 Глава 9 Создание веб-API для мобильных и клиентских приложений
ет список данных контроллеру. Теперь нужно отформатировать ответ
и вернуть его вызывающему компоненту.
Листинг 9.13 Контроллер веб-API для возврата списка автомобилей
[ApiController]
public class CarsController : Controller
{
[HttpGet("api/cars")]
public IEnumerable<string> ListCars()
{
return new string[]
{ "Nissan Micra", "Ford Focus" };
}
}
В разделе 9.2 вы видели, что можно возвращать данные непосред-
ственно из метода действия, и  в  этом случае промежуточное ПО фор-
матирует их и возвращает отформатированные данные вызывающему
компоненту. Но как оно узнает, какой формат использовать? В  конце
концов, можно сериализовать их, используя JSON, как XML или даже
с по мощью простого вызова метода ToString().
Процесс определения формата данных для отправки клиентам обыч-
но известен как согласование	 содержимого. В общих чертах это работает
следующим образом: клиент отправляет заголовок, указывающий типы
контента, который он может понять, – заголовок Accept, – а сервер вы-
бирает один из них, форматирует ответ и отправляет в ответе заголовок
content-type, указывающий, какой тип был выбран.
Заголовки Accept и content-type
Заголовок Accept отправляется клиентом как часть запроса, чтобы указать
тип содержимого, который может обработать клиент. Он состоит из несколь-
ких MIME-типов1, с дополнительными весовыми коэффициентами (от 0 до
1), чтобы указать, какой тип будет предпочтительнее. Например, заголовок
application/json,text/xml;q=0.9,text/plain;q=0.6  указывает на то, что
клиент может принимать форматы JSON, XML и простой текст с весовыми
коэффициентами 1.0, 0.9 и 0.6 соответственно. JSON имеет весовой коэффи-
циент 1.0, поскольку явного коэффициента предоставлено не было. Весовые
коэффициенты можно использовать во время согласования содержимого
для выбора оптимального представления для обеих сторон.
Заголовок content-type описывает данные, отправленные в  запросе или
ответе. Он содержит MIME-тип данных с необязательной кодировкой сим-
волов. Например, заголовок application/json; charset=utf-8 будет указы-
вать на то, что тело запроса или ответ – это формат JSON, закодированный
с использованием UTF-8.
1 Дополнительную информацию о MIME-типах см. в документации Mozilla на
странице https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/
MIME_types.Действие выполняется
с запросом к /api/cars.
Модель API, содержащая данные, –
это IEnumerable <string>.
Эти данные обычно берутся
из модели приложения.

343 Генерация ответа от модели
Вы не обязаны отправлять только	 тот заголовок content-type, которо-
го ожидает клиент, а в некоторых случаях вы даже не сможете обраба-
тывать типы, которые он запрашивает. Что, если в запросе указано, что
он может принимать только таблицы Excel? Вряд ли вы это поддержите,
даже если это единственный заголовок content-type, который содержит -
ся в запросе.
Когда вы возвращаете модель API из метода действия, независимо от
того, делаете ли вы это напрямую (как в листинге 9.13) или через OkResult
либо другой StatusCodeResult, ASP .NET Core всегда будет что-то возвра-
щать. Если он не может удовлетворить какому-либо из типов, указанных
в заголовке Accept, то он будет использовать формат JSON по умолчанию.
На рис. 9.10 показано, что хотя был запрошен ответ в формате XML, конт -
роллер API отформатировал ответ в формате JSON.
ПРИМЕЧАНИЕ  В  предыдущей версии ASP .NET объекты сериа-
лизовались в  JSON, используя стиль написания PascalCase, когда
свойства начинаются с прописной буквы. В ASP .NET Core по умол-
чанию объекты сериализуются с использованием стиля camelCase,
когда свойства начинаются со строчной буквы.
Запрос отправляется в веб-API с типом
заголовка Accept: text/xml
Приложение ASP .NET Core не настроено
для возврата text/xml, поэтому
по умолчанию оно возвращает JSON
Рис. 9.10 Несмотря на то что запрос был сделан с заголовком Accept: "text/xml",
ответ пришел в формате JSON, поскольку сервер не был настроен на возврат ответа
в формате XML
Как бы ни отправлялись данные, они сериализуются с по мощью реа-
лизации IOutputFormatter. ASP .NET Core поставляется с ограниченным
количеством форматеров из коробки, но, как и всегда, можно легко до-
бавить дополнительные форматеры или изменить их способ работы по
умолчанию.
9.6.1 Настройка форматеров по умолчанию:
добавляем поддержку XML
Форматеры веб-API в ASP .NET Core являются полностью настраиваемыми.
По умолчанию настроены только форматеры для обычного текста (text/

344 Глава 9 Создание веб-API для мобильных и клиентских приложений
plain), HTML (text/html) и JSON (application/json). Учитывая распростра-
ненный вариант использования одностраничных и  мобильных прило-
жений, этого будет достаточно в большинстве случаев. Но иногда нужно
иметь возможность возвращать данные в другом формате, например XML.
Newtonsoft.Json и System.T ext.Json
Пакет Newtonsoft.Json, также известный как Json.NET, долгое время был ка-
ноническим способом работы с JSON в .NET. Он совместим со всеми сущест -
вующими версиями .NET и, несомненно, знаком практически всем разра-
ботчикам .NET. Его охват был настолько велик, что даже ASP.NET Core стал
зависеть от него!
Все изменилось с появлением в ASP.NET Core 3.0 новой библиотеки System.
Text.Json, ориентированной на производительность. Начиная с версии 3.0 ASP.
NET Core по умолчанию использует System.Text.Json вместо Newtonsoft.Json.
Основное различие между этими библиотеками заключается в том, что Sys-
tem.Text.Json очень требовательна к JSON. Обычно она десериализует только
те данные JSON, которые соответствуют ее ожиданиям. Например, System.
Text.Json не выполняет десериализацию JSON, в котором строки заключают -
ся в одинарные кавычки – нужно использовать двойные.
Если вы создаете новое приложение, то обычно это не проблема – вы быстро
научитесь генерировать правильный формат JSON. Но если вы переносите
приложение из ASP.NET Core 2.0 или получаете данные в формате JSON от сто-
роннего приложения, то эти ограничения могут стать серьезным препятствием.
К счастью, можно легко вернуться к библиотеке Newtonsoft.Json. Установи-
те пакет Microsoft.AspNetCore.Mvc.NewtonsoftJson в свой проект и обновите
метод AddControllers() из файла Startup.cs:
services.AddControllers()
.AddNewtonsoftJson();
Так вы переключите форматеры ASP.NET Core на использование Newtonsoft.
Json вместо System.Text.Json. Дополнительные сведения о различиях между
библиотеками см. в статье на странице http://mng.bz/0mRJ. Дополнительные
советы о том, когда следует переключаться на форматер Newtonsoft.Json, см.
в  разделе «Добавление поддержки формата JSON на основе Newtonsoft.
Json» по адресу http://mng.bz/zx11.
Можно добавить вывод XML в  свое приложение, добавив форматер
вывода. Форматеры вашего приложения конфигурируются в  Startup.cs
путем настройки объекта IMvcBuilder, возвращаемого из метода AddCon-
trollers(). Чтобы добавить форматер вывода XML1, используйте сле-
дующий код:
1 Технически таким образом вы также добавляете и  форматер	 ввода	 XML, а это
означает, что ваше приложение теперь может также получать формат XML
в запросах. Подробное описание форматеров, включая создание собственного
форматера, см. в документации на странице http://mng.b z/e5gG.

345 Генерация ответа от модели
services.AddControllers()
.AddXmlSerializerFormatters();
Благодаря этому простому изменению ваши контроллеры API теперь
могут форматировать ответы как XML. Выполнение того же запроса, что
и на рис. 9.10, с включенной поддержкой XML означает, что приложение
будет учитывать значение text/xml для принимаемого заголовка accept.
Форматер сериализует массив string в XML по запросу, а не в JSON по
умолчанию, как показано на рис. 9.11.
Запрос отправляется в веб-API с типом
заголовка Accept: text/xml
После добавления форматеров XML
заголовок Accept может
учитываться, поэтому вместо
ответа в формате JSON по умолчанию
возвращается text/xml
Рис. 9.11 После добавления форматера вывода XML значение text/xml заголовка
Accept учитывается, и ответ может быть сериализован в XML
Это пример согласования содержимого, когда клиент указал, какие
форматы он может обрабатывать, а сервер выбирает один из них в за-
висимости от того, что он может создать. Данный подход является ча-
стью протокола HTTP , но есть некоторые особенности, о  которых сле-
дует знать, когда вы используете его в ASP .NET Core. Вы нечасто будете
встречаться с ними, но знать о них нужно обязательно, чтобы не попасть
впросак!
9.6.2 Выбор формата ответа с помощью согласования
содержимого
Согласование содержимого – это когда клиент сообщает, какие типы дан-
ных он может принимать, используя заголовок Accept, а сервер выбирает
наиболее подходящий из них, который он может обработать. В целом это
работает так, как и следовало ожидать: сервер форматирует данные, ис -
пользуя тип, понятный клиенту.
В реализации ASP .NET Core есть несколько особых случаев, которые
стоит учитывать:
по умолчанию ASP .NET Core возвращает только MIME-типы appli-
cation/json, text/plain и  text/html. Можно добавить дополнитель-

346 Глава 9 Создание веб-API для мобильных и клиентских приложений
ные форматеры IOutputFormatter, чтобы сделать доступными дру -
гие типы, как вы видели в предыдущем разделе в случае с  text/xml;
по умолчанию если вы возвращаете null в качестве модели API, будь
то из метода действия или путем передачи null в StatusCodeResult,
промежуточное ПО вернет ответ 204 No Content;
когда вы возвращаете строку в  качестве модели API, если не за-
дан заголовок Accept, промежуточное ПО отформатирует ответ как
text/plain;
когда вы используете любой другой класс в  качестве модели API
и  либо отсутствует заголовок Accept, либо не запрашивается ни
один из поддерживаемых форматов, будет использоваться первый
форматер, который может сгенерировать ответ (обычно по умолча-
нию JSON);
если промежуточное ПО обнаружит, что запрос, вероятно, исходит
от браузера (заголовок Accept содержит * / *), то он не будет исполь-
зовать согласование содержимого. Вместо этого он отформатирует
ответ, как если бы заголовок Accept не был предоставлен, используя
форматер по умолчанию.
Эти настройки по умолчанию относительно разумны, но они, безуслов-
но, могут доставить вам немало неприятностей, если вы о них не знаете.
В частности, последний пункт, когда ответ на запрос из браузера практи-
чески всегда форматируется как JSON, определенно подловил меня при
попытке протестировать XML-запросы локально!
Как и следовало ожидать, все эти правила можно настроить; вы може-
те легко изменить поведение по умолчанию в своем приложении, если
оно не соответствует вашим требованиям. Например, в следующем лис -
тинге, взятом из файла Startup.cs, показано, как заставить промежуточ-
ное ПО учитывать заголовок браузера Accept и удалить форматер text/
plain для строк.
Листинг 9.14 Настройка MVC с учетом заголовка Accept в веб-API
public void ConfigureServices(IServiceCollection services)
{
services.AddControllers(options =>
{
options.RespectBrowserAcceptHeader = true;
options.OutputFormatters.RemoveType<StringOutputFormatter>();
});
}
В большинстве случаев согласование содержимого должно работать
«из коробки», независимо от того, создаете вы одностраничное прило-
жение или мобильное. В некоторых случаях вы можете обнаружить, что
вам нужно обойти обычные механизмы согласования содержимого для
определенных методов действий, и существует ряд способов сделать это, У AddControllers есть
перегруженный вариант, который
принимает лямбда-функцию.
По умолчанию имеет значение false, можно
задать и ряд других свойств.Удаляет форматер вывода, который
форматирует строки как text/plain.

347 Резюме
но я не буду описывать их в данной книге, поскольку обнаружил, что мне
редко приходится их использовать. Дополнительные сведения см. в до-
кументации Microsoft на странице http://mng.bz/zx11.
На этом мы подошли к концу главы, посвященной веб-API, и вместе
с тем к первой части этой книги! Это был довольно насыщенный тур по
ASP .NET Core с упором на Razor Pages и паттерн MVC. Зайдя так дале-
ко, вы теперь обладаете всеми знаниями, необходимыми для создания
прос  тых приложений с использованием Razor Pages или создания сер-
вера веб-API для своего одностраничного либо мобильного приложения.
Во второй части мы затронем несколько заманчивых тем: вы узнае-
те детали, необходимые для сборки полноценных приложений, такие
как добавление пользователей в приложение, сохранение данных в базе
данных и развертывание приложения.
В главе 10 мы рассмотрим внедрение зависимостей в  ASP .NET Core
и то, как оно помогает создавать слабосвязанные приложения. Вы узнае-
те, как зарегистрировать сервисы фреймворка ASP .NET Core в  контей-
нере и настроить собственные классы как сервисы с внедрением зави-
симостей. Наконец, вы увидите, как заменить встроенный контейнер
сторонней альтернативой.
Резюме
Веб-API предоставляет ряд методов или конечных точек, которые
можно использовать для доступа к данным или их изменения на сер-
вере. Обычно к нему обращаются по протоколу HTTP из мобильных
или клиентских веб-приложений.
Методы действий веб-API могут возвращать данные напрямую или
использовать тип ActionResult<T> для генерации произвольного от -
вета.
Если вы возвращаете несколько типов результата из метода действия,
то сигнатура метода должна возвращать ActionResult<T>.
Веб-API следуют тому же паттерну проектирования MVC, что и тра-
диционные веб-приложения. Форматеры, генерирующие окончатель-
ный ответ, формируют представление.
Данные, возвращаемые действием веб-API, называются моделью API.
Она содержит данные, которые промежуточное ПО сериализует и от -
правит обратно клиенту. Это отличается от моделей представления
и PageModels, которые содержат и данные, и метаданные о том, как
сгенерировать ответ.
Веб-API ассоциируются с  шаблонами маршрутов путем применения
атрибутов RouteAttributes к методам действий. Это дает вам полный
контроль над URL-адресами, образующими API вашего приложения.
Атрибуты маршрута, применяемые к  контроллеру, объединяются
с атрибутами методов действий, чтобы сформировать окончательный
шаблон. Они также сочетаются с  атрибутами унаследованных базо-

348 Глава 9 Создание веб-API для мобильных и клиентских приложений
вых классов. Можно использовать унаследованные атрибуты, чтобы
уменьшить объем дублирующегося кода в атрибутах, например если
вы используете общий префикс в маршрутах.
По умолчанию имена контроллера и действия не имеют отношения
к URL-адресам или шаблонам маршрутов, когда вы используете марш-
рутизацию на основе атрибутов. Однако можно использовать марке-
ры "[controller]" и  "[action]" в своих шаблонах маршрутов, чтобы
уменьшить повторы. Они будут заменены на имена текущего конт -
роллера и действия.
Атрибуты [HttpPost] и  [HttpGet] позволяют делать выбор между дей-
ствиями на основе HTTP-метода запроса, когда два действия соответ -
ствуют одному и тому же URL-адресу. Это распространенный паттерн
в приложениях RESTful.
Атрибут [ApiController] применяет несколько общепринятых согла-
шений к вашим контроллерам. Контроллеры, декорированные атри-
бутом, будут автоматически привязываться к  телу запроса, вместо
того чтобы использовать значения формы, автоматически сгенериру -
ют ответ 400 Bad Request для недопустимых запросов и будут возвра-
щать объекты ProblemDetails для ошибок кода состояния. Это может
значительно сократить объем шаблонного кода, который вам прихо-
дится писать.
Вы можете контролировать, какое из соглашений применять, исполь-
зуя метод ConfigureApiBehaviorOptions() и предоставив лямбда-выра-
жение конфигурации. Это полезно, например, если нужно подогнать
свой API к существующей спецификации.
По умолчанию ASP .NET Core форматирует модель API, возвращаемую
из контроллера веб-API, как JSON. Практически каждая платформа
может обрабатывать JSON, что делает ваш API высокосовместимым.
В отличие от предыдущей версии ASP .NET, данные в  формате JSON
сериализуются с  использованием стиля camelCase, а  не PascalCase.
Следует учитывать это изменение, если вы получаете ошибки или от -
сутствующие значения при переходе с ASP .NET на ASP .NET Core.
В ASP .NET Core 3.0 и последующих версиях используется System.Text.
Json, представляющая собой строгую высокопроизводительную биб-
лиотеку для сериализации и десериализации JSON. Этот сериализатор
можно заменить на обычный форматер Newtonsoft.Json, вызвав метод
AddNewtonsoftJson() на возвращаемом значении метода services.Ad-
dControllers().
Согласование содержимого происходит, когда клиент указывает тип
данных, которые он может обработать, а сервер на основе этого вы-
бирает возвращаемый формат. Это позволяет нескольким клиентам
вызывать ваш API и получать данные в понятном им формате.
По умолчанию ASP .NET Core может возвращать text/plain, text/html
и application/json, но можно добавить дополнительные форматеры,
если нужно поддерживать другие форматы.
Можно добавить форматеры XML, вызвав метод AddXmlSerializer-
Formatters() для возвращаемого значения метода services.AddCon-

349 Резюме
trollers() в своем классе Startup. Это позволит вам форматировать
ответ в формате XML, а также получить XML в теле запроса.
Согласование содержимого не используется, если заголовок Accept со -
держит * / *, как в большинстве браузеров. Вместо этого ваше прило-
жение будет использовать форматер по умолчанию, JSON. Вы можете
отключить данный параметр, изменив параметр RespectBrowserAc-
ceptHeader при добавлении сервисов контроллера MVC в Startup.cs.

Часть	II
Создание	полноценных
приложений
В  первой части мы рассмотрели много вопросов. Вы видели, как при-
ложение ASP .NET Core собирается из промежуточного ПО, и мы подробно
рассмотрели фреймворк Razor Pages. Вы видели, как применять его для
создания традиционных приложений с отрисовкой на стороне сервера
с использованием синтаксиса Razor и как создавать API-интерфейсы для
мобильных и клиентских приложений.
Во второй части мы подробно рассмотрим фреймворк и  различные
компоненты, которые вам неизбежно понадобятся, когда вы захотите
создавать более сложные приложения. К концу этой части вы сможете
создавать динамические приложения, настроенные под конкретных
пользователей, которые можно развертывать в нескольких окружениях
с разной конфигурацией.
ASP .NET Core использует внедрение зависимостей во всех своих биб-
лиотеках, поэтому важно понимать, как работает этот паттерн проекти-
рования. В главе 10 я расскажу о внедрении зависимостей, для чего оно
используется и как настроить сервисы в своих приложениях для его ис -
пользования.
В главе 11 рассматривается система конфигурации ASP .NET Core, по-
зволяющая передавать значения конфигурации в  приложение из ряда
источников – файлов JSON, переменных окружения и многих других. Вы
узнаете, как настроить приложение для использования разных значе-
ний в зависимости от окружения, в котором оно выполняется, и как при-

351 Создание полноценных приложений
вязать строго типизированные объекты к вашей конфигурации, чтобы
уменьшить количество ошибок времени выполнения.
Большинству веб-приложений требуется какое-то хранилище данных,
поэтому в главе 12 я расскажу об Entity Framework Core (EF Core). Это но-
вая кросс-платформенная библиотека, упрощающая подключение ваше-
го приложения к базе данных. EF Core сама по себе заслуживает отдель-
ной книги, поэтому я приведу только краткое введение и порекомендую
отличную книгу Джона Смита «Entity	 Framework	 Core	в действии», второе
издание (Manning, 2021). Я покажу вам, как создать базу данных, а также
как вставлять, обновлять и запрашивать простые данные.
В главах с 13 по 15 мы рассмотрим, как создавать более сложные при-
ложения. Вы увидите, как добавить в свои приложения систему аутенти-
фикации и авторизации ASP .NET Core Identity, чтобы пользователи мог -
ли заходить в него и наслаждаться индивидуальным интерфейсом. Вы
узнаете, как защитить свои приложения с по мощью авторизации, чтобы
гарантировать, что только определенные пользователи могут получить
доступ к  определенным действиям, и  увидите, как провести рефакто-
ринг своего приложения, чтобы извлечь общий код из страниц Razor
и контроллеров API, используя фильтры.
В последней главе этой части я  расскажу о  шагах, необходимых для
запуска приложения, в том числе о том, как развернуть свое приложение
в IIS, как настроить URL-адреса, которые будет слушать ваше приложе-
ние, и как оптимизировать клиентские ресурсы для повышения произ-
водительности.

10Конфигурация	сервисов
с по	мощью	внедрения
зависимостей
В этой главе:
преимущества внедрения зависимостей;
как ASP.NET Core использует внедрение зависимостей;
конфигурирование сервисов для работы с внедрением
зависимостей;
выбор правильного жизненного цикла ваших сервисов.
В первой части этой книги вы познакомились с основами создания при-
ложений с по мощью ASP .NET Core. Вы узнали, как комбинировать про-
межуточное ПО для создания своего приложения и  как использовать
паттерн MVC для создания традиционных веб-приложений с по мощью
Razor Pages и веб-API. Это дало вам инструменты для создания простых
приложений.
В данной главе вы увидите, как использовать внедрение	 зависимостей
в  приложениях ASP .NET Core. Внедрение зависимостей  – это паттерн
проектирования, который помогает писать слабосвязанный код. ASP .
NET Core широко использует данный паттерн как внутри фреймворка,
так и в создаваемых вами приложениях, поэтому вам нужно будет ис -
пользовать его во всех приложениях, кроме самых тривиальных.
Возможно, вы слышали о внедрении зависимостей раньше и, вероятно,
даже использовали его в  собственных приложениях. Если это так, тогда
данная глава не должна преподнести вам много сюрпризов. Если вы рань-

353 Введение во внедрение зависимостей
ше не использовали внедрение зависимостей, не бойтесь. Я позабочусь,
чтобы вы успели сделать это к тому времени, как глава будет пройдена!
Эта глава начинается со  знакомства с  внедрением зависимостей,
с принципами, которыми оно руководствуется, и с объяснения причин,
по которым вам следует использовать его. Вы увидите, как ASP .NET Core
использует внедрение зависимостей на протяжении всей своей реализа-
ции и почему вы должны делать то же самое при написании собственных
приложений.
Когда у вас будет четкое понимание концепции, вы увидите, как при-
менять его к собственным классам. Вы узнаете, как настроить приложение
так, чтобы платформа ASP .NET Core могла создавать ваши классы за вас, из-
бавляя вас от боли, связанной с созданием новых объектов вручную в коде.
Ближе к концу главы вы узнаете, как контролировать продолжительность
использования своих объектов, и о подводных камнях, о которых следует
помнить, когда вы начинаете писать собственные приложения.
В главе 19 мы рассмотрим некоторые более сложные способы исполь-
зования внедрения зависимостей, в том числе как подключить сторон-
ний контейнер внедрения зависимостей. А пока вернемся к основам: что
такое внедрение зависимостей и для чего оно нужно?
10.1 Введение во внедрение зависимостей
Этот раздел призван дать вам общее представление о  том, что такое
внед рение зависимостей, почему следует знать о нем и как его исполь-
зует ASP .NET Core. Сама тема выходит далеко за рамки одной этой главы.
Если вам нужна более подробная информация, то я настоятельно реко-
мендую вам ознакомиться со статьями Мартина Фаулера в интернете1.
СОВЕТ  Для более глубокого ознакомления со многими примерами
на C# я рекомендую взять книгу Стивена ван Дойрсена и Марка Зе-
манна «Принципы	внедрения	зависимостей, 	практики	и паттерны» .
ASP .NET Core изначально разрабатывался как модульный фреймворк,
который должен придерживаться «хороших» практик разработки про-
граммного обеспечения. Как и в случае с любым другим программным
обеспечением, то, что считается передовой практикой, со временем ме-
няется, но принципы SOLID2 хорошо себя зарекомендовали в объектно-
ориентированном программировании.
1 Cайт Мартина Фаулера https://martinfowler.com – это кладезь передового опы-
та. Одну из наиболее подходящих статей к этой главе можно найти на страни-
це www.martinfo wler.com/articles/injection.html.
2 SOLID  – это мнемонический акроним для принципов единственной ответ -
ственности, открытости-закрытости, подстановки Лисков, разделения интер-
фейса и  инверсии зависимостей: https://en.wikipedia.org/wiki/SOLID_(object-
oriented_design).

354 Глава 10 Конфигурация сервисов с по мощью внедрения зависимостей
Исходя из этого, в  ASP .NET Core внедрение	 зависимостей (которое
иногда называют инверсией зависимости, или инверсией управления1)
встроено в основу фреймворка. Независимо от того, хотите вы использо-
вать его в коде своего приложения или нет, сами библиотеки фреймвор-
ка концептуально зависимы от него.
Я начну этот раздел с обычного сценария: класс в вашем приложении
зависит от другого класса, который, в свою очередь, зависит еще от од-
ного класса. Вы увидите, как внедрение зависимостей может помочь об-
легчить эту цепочку зависимостей и предоставить ряд дополнительных
преимуществ.
10.1.1 Преимущества внедрения зависимостей
Когда вы только начинали программировать, скорее всего, вы не сразу
стали использовать внедрение зависимостей. В  этом нет ничего уди-
вительного и  даже плохого; внедрение зависимостей добавляет опре-
деленное количество дополнительных вещей, которые часто не требу -
ются в простых приложениях или когда вы только начинаете. Но когда
все становится сложнее, внедрение зависимостей становится отличным
инструментом, помогая контролировать эту сложность.
Рассмотрим простой пример, написанный без какого-либо внедрения
зависимостей. Представьте, что пользователь зарегистрировался в  ва-
шем веб-приложении и вы хотите отправить ему электронное письмо.
Этот листинг показывает, как подойти к  данной задаче на начальном
этапе в контроллере API.
ПРИМЕЧАНИЕ  В этом примере я использую контроллер API, но
с таким же успехом мог бы использовать и страницу Razor. Конт -
роллеры Razor Pages и  API используют внедрение зависимостей
в конструктор, как вы увидите в разделе 10.2.
Листинг 10.1  Отправка электронного письма без внедрения
зависимостей при отсутствии зависимостей
public class UserController : ControllerBase
{
[HttpPost("register")]
public IActionResult RegisterUser(string username)
{
var emailSender = new EmailSender();
emailSender.SendEmail(username);
return Ok();
}
}
1 Несмотря на то что внедрение зависимостей и инверсия зависимостей свя-
заны, это две разные вещи. В этой главе я буду рассматривать оба принципа
в общих чертах, но, чтобы лучше понимать различия между ними, см. пост
Дерика Бейли под названием «Внедрение зависимостей НЕ то же самое, что
принцип инверсии зависимостей»: http://mng.bz/5jvB.Метод действия вызывается
при создании нового пользователя.
Создает новый экземпляр
класса EmailSender.
Использует новый экземпляр
для отправки электронного письма.

355 Введение во внедрение зависимостей
В этом примере действие RegisterUser класса UserController выпол-
няется, когда новый пользователь регистрируется в вашем приложении.
Так создается новый экземпляр класса EmailSender и вызывается метод
SendEmail() для отправки электронного письма. EmailSender – класс, вы-
полняющий отправку электронного письма. Представим, что он выгля-
дит как-то так:
public class EmailSender
{
public void SendEmail(string username)
{
Console.WriteLine($"Email sent to {username}!");
}
}
Console.Writeline имитирует реальный процесс отправки электрон-
ной почты.
ПРИМЕЧАНИЕ  Хотя я  использую отправку электронной почты
в качестве простого примера, на практике вам может потребовать-
ся полностью убрать этот код со своей страницы Razor и из классов
контроллера. Данный тип асинхронной задачи хорошо подходит
для использования очередей сообщений и  фонового процесса.
Подробнее см. http://mng.bz/pVWR.
Если класс EmailSender такой же простой, как и в предыдущем приме-
ре, и у него нет зависимостей, возможно, вы и не увидите необходимости
применять другой подход к созданию объектов. И в какой-то степени вы
были бы правы. Но что, если позже вы обновите реализацию EmailSender,
чтобы он сам не реализовал всю логику отправки электронной почты?
На практике для отправки электронной почты этому классу потребуется
много действий. Ему пришлось бы:
создать электронное сообщение;
сконфигурировать настройки почтового сервера;
отправить электронное письмо на почтовый сервер.
Если делать все это в одном классе, то это будет противоречить прин-
ципу единственной ответственности, поэтому в конечном итоге вы, ве-
роятно, получите класс EmailSender, который зависит от других сервисов.
На рис. 10.1 показано, как может выглядеть такая схема зависимостей.
Класс UserController хочет отправить электронное письмо с по мощью
класса EmailSender, но для этого ему также необходимо создать объекты
MessageFactory, Network-Client и  EmailServerSettings, от которых зави-
сит класс EmailSender.
У каждого класса есть ряд зависимостей, поэтому «корневой» класс,
в  данном случае UserController, должен знать, как создавать каждый
класс, от которого он зависит, а также каждый класс, от которого зависят
его зависимости. Иногда подобное называют графом	зависимостей.

356 Глава 10 Конфигурация сервисов с по мощью внедрения зависимостей
Чтобы использовать
EmailSender, UserController
должен создать все зависимости
UserController зависит
от EmailSender
EmailSender зависит
от MessageFactory и NetworkClientNetworkClient зависит
от EmailServerSettings
Рис. 10.1 Диаграмма зависимостей без внедрения зависимостей.
Класс UserController косвенно зависит от всех остальных классов, поэтому должен
создать их все
ОПРЕДЕЛЕНИЕ  Граф	зависимостей – 	это набор объектов, кото-
рые нужно создать для получения определенного запрашиваемого
«корневого» объекта.
Класс EmailSender зависит от объектов MessageFactory и  Network-Cli-
ent, поэтому они предоставляются через конструктор, как показано
здесь.
Листинг 10.2 Сервис с несколькими зависимостями
public class EmailSender
{
private readonly NetworkClient _client;
private readonly MessageFactory _factory;
public EmailSender(MessageFactory factory, NetworkClient client)
{
_factory = factory;
_client = client;
}
public void SendEmail(string username)
{
var email = _factory.Create(username);
_client.SendEmail(email);
Console.WriteLine($"Email sent to {username}!");
}
}
Кроме того, класс NetworkClient, от которого зависит класс EmailSend-
er, также зависит от объекта EmailServerSettings:EmailSender теперь зависит
от двух других классов.
Экземпляры зависимостей
предоставляются в конструкторе.
EmailSender координирует
зависимости для создания
и отправки электронного письма.

357 Введение во внедрение зависимостей
public class NetworkClient
{
private readonly EmailServerSettings _settings;
public NetworkClient(EmailServerSettings settings)
{
_settings = settings;
}
}
Это может показаться немного надуманным, но такая цепочка зави-
симостей часто встречается. Фактически если в  вашем коде этого нет,
то, вероятно, это признак того, что ваши классы слишком велики и не
следуют принципу единственной ответственности.
Итак, как это влияет на код в классе UserController? Следующий лис -
тинг показывает, как теперь вам нужно отправить электронное письмо,
если вы придерживаетесь использования ключевого слова new:
Листинг 10.3  Отправка электронной почты без внедрения
зависимостей, когда вы создаете их вручную
public IActionResult RegisterUser(string username)
{
var emailSender = new EmailSender(
new MessageFactory(),
new NetworkClient(
new EmailServerSettings
(
host: "smtp.server.com",
port: 25
))
);
emailSender.SendEmail(username);
return Ok();
}
Все это превращается в какой-то грубый код. Мы улучшили внешний
вид класса EmailSender для разделения обязанностей, и это превратило
его вызов из класса UserController в настоящую рутину. В этом коде есть
несколько проблем:
несоблюдение	 принципа	 единственной	 ответственности  – теперь
наш код отвечает и за создание объекта EmailSender, и за его исполь-
зование для отправки электронного письма;
слишком	 много	церемоний  – из одиннадцати строк кода в  методе
RegisterUser только две последние делают что-то полезное. Это за-
трудняет чтение и усложняет понимание цели метода;
привязка	 к  реализации  – если вы решите провести рефакторинг
EmailSender и  добавить еще одну зависимость, вам нужно будет
обновить все места, где он используется. Точно так же, если какая-
либо из зависимостей будет подвергнута рефакторингу, вам также
потребуется обновить этот код.Чтобы создать EmailSender,
нужно создать все его
зависимости.
Вам нужен экземпляр MessageFactory.
У NetworkClient также есть зависимости.
Вы уже углубились на два слоя,
но, возможно, их больше.
Наконец, можно отправить
электронное письмо.

358 Глава 10 Конфигурация сервисов с по мощью внедрения зависимостей
Класс UserController неявно зависит от класса EmailSender, поскольку
вручную создает сам объект как часть метода RegisterUser. Единствен-
ный способ узнать, что UserController использует EmailSender,  – просмот -
реть его исходный код. Напротив, у  EmailSender есть явные зависимости
от NetworkClient и MessageFactory, которые должны быть предоставлены
в конструкторе. Точно так же NetworkClient имеет явную зависимость от
класса EmailServerSettings.
СОВЕТ  В целом любые зависимости в вашем коде должны быть
явными. Неявные зависимости сложно рассматривать и тестиро-
вать, поэтому следует избегать их везде, где это возможно. Внедре-
ние зависимостей полезно тем, что направляет вас по этому пути.
Внедрение зависимостей направлено на решение проблемы созда-
ния графа зависимостей путем	 инвертирования цепочки зависимостей.
Вместо того чтобы UserController создавал свои зависимости вручную,
глубоко внутри деталей реализации кода, уже созданный экземпляр
EmailSender внедряется через конструктор.
Очевидно, теперь нам нужно что-то для создания объекта, поэтому
код для этого должен где-то находиться. Сервис, отвечающий за соз-
дание объекта, называется контейнером внедрения зависимостей (DI-
контейнером), или контейнером инверсии управления, как показано на
рис. 10.2.
ОПРЕДЕЛЕНИЕ  Контейнер	 внедрения	 зависимостей, или контей-
нер	инверсии	 управления, отвечает за создание экземпляров сер-
висов. Он знает, как создать экземпляр сервиса, создавая все его
зависимости и  передавая их конструктору. На протяжении всей
книги я буду называть его контейнер внедрения зависимостей.
Термин внедрение	 зависимостей часто используется как синоним ин-
версии	управления. Внедрение зависимостей – это конкретная версия бо-
лее общего принципа инверсии управления. Инверсия управления опи-
сывает паттерн, в котором фреймворк	 вызывает ваш код для обработки
запроса, вместо того чтобы вы сами писали код для парсинга запроса
из байтов на сетевой карте. Внедрение зависимостей идет дальше, по-
зволяя фреймворку создавать и ваши зависимости: вместо того чтобы
класс UserController контролировал создание экземпляра EmailSender,
он предоставляется фреймворком.
ПРИМЕЧАНИЕ  Для .NET доступно множество контейнеров внед-
рения зависимостей: Autofac, Lamar, Unity, Ninject, Simple Injec -
tor... Список можно продолжить! В  главе 19 вы увидите, как за-
менить контейнер ASP .NET Core по умолчанию на одну из этих
альтер натив.

359 Введение во внедрение зависимостей
Контейнер внедрения
зависимостей создает полный граф
зависимостей и предоставляет
UserController экземпляр
EmailSender
Контейнер внедрения зависимостей
UserController зависит
от EmailSender
EmailSender зависит
от MessageFactory и NetworkClientNetworkClient зависит
от EmailServerSettings
Рис. 10.2 Диаграмма зависимостей с использованием внедрения зависимостей.
UserController косвенно зависит от всех других классов, но ему не нужно знать,
как создавать их. Он заявляет, что ему требуется EmailSender, и контейнер
предоставляет его
Преимущество использования данного паттерна становится очевид-
ным, когда вы видите, насколько он упрощает использование зависимо-
стей. В следующем листинге показано, как выглядел бы класс UserCon-
troller, если бы вы использовали внедрение зависимостей для создания
EmailSender, вместо того чтобы делать это вручную. Все эти ключевые
слова new исчезли, и можно сосредоточиться исключительно на том, что
делает контроллер – вызывает EmailSender и возвращает объект OkResult.
Листинг 10.4  Отправка электронного письма с использованием
внедрения зависимостей
public class UserController : ControllerBase
{
private readonly EmailSender _emailSender;
public UserController(EmailSender emailSender)
{
_emailSender = emailSender;
}
[HttpPost("register")]Вместо неявного создания
зависимостей они внедряются
через конструктор.

360 Глава 10 Конфигурация сервисов с по мощью внедрения зависимостей
public IActionResult RegisterUser(string username)
{
_emailSender.SendEmail(username);
return Ok();
}
}
Одним из преимуществ контейнера внедрения зависимостей являет -
ся то, что он обладает единственной ответственностью – это создание
объектов или сервисов. Вы запрашиваете у контейнера экземпляр серви-
са, и он заботится о том, чтобы выяснить, как создать граф зависимостей,
основываясь на том, как вы его настроили.
ПРИМЕЧАНИЕ  Когда говорят о контейнерах внедрения зависи-
мостей, часто имеют в виду сервисы, что немного прискорбно, по-
скольку это один из самых перегруженных терминов в разработ -
ке программного обеспечения! В данном контексте под сервисом
подразумевается любой класс или интерфейс, который контейнер
внедрения зависимостей создает при необходимости.
Прелесть этого подхода состоит в том, что, используя явные зависимо-
сти, вам больше не придется писать беспорядочный код, который вы ви-
дели в листинге 10.3. Контейнер внедрения зависимостей может прове-
рить конструктор вашего сервиса и решить, как написать бóльшую часть
кода. Эти контейнеры всегда можно сконфигурировать, поэтому если вы
хотите описать, как вручную создать экземпляр сервиса, это можно сде-
лать, но по умолчанию в этом нет необходимости.
СОВЕТ  Можно внедрять зависимости в  сервис другими спо со-
бами, например с  по мощью внедрения свойств. Но внедрение
через конструктор является наиболее распространенным и един-
ственным способом, который изначально поддерживается в ASP .
NET Core, поэтому в этой книге я буду использовать только его.
Надеюсь, преимущества использования внедрения зависимостей
в вашем коде очевидны из этого быстрого примера, но данный принцип
предоставляет дополнительные преимущества, которые вы получаете
бесплатно. В  частности, он помогает сделать так, чтобы ваш код оста-
вался слабосвязанным, путем программирования на уровне интерфейса.
10.1.2 Создание слабосвязанного кода
Связанность – важная концепция объектно-ориентированного програм-
мирования. Она означает, как данный класс зависит от других классов
при выполнении своей функции. Слабосвязанный код не должен знать
много деталей о конкретном компоненте, чтобы его использовать.
Первоначальный пример с  классами UserController и  EmailSender  –
образец сильной связанности; вы создавали объект EmailSender напря-Метод действия легко читать
и понимать.

361 Введение во внедрение зависимостей
мую и должны были знать, как именно его подключить. Кроме того, код
было сложно протестировать. Любые попытки протестировать UserCont-
roller приведут к отправке электронного письма. Если бы вы тестирова-
ли конт роллер с по мощью набора модульных тестов, это был бы верный
способ внести ваш почтовый сервер в черный список из-за спама!
Использование EmailSender в качестве параметра конструктора и сня-
тие ответственности за создание объекта помогает уменьшить связан-
ность в системе. Если реализация EmailSender изменится так, что у него
появится еще одна зависимость, вам больше не придется одновременно
обновлять UserController.
Остается одна проблема: класс UserController по-прежнему привязан
к реализации, а не к  интерфейсу. Программирование на уровне интер-
фейса – распространенный паттерн проектирования, который помогает
еще больше уменьшить связанность системы, поскольку в этом случае
вы не привязаны к одной реализации.
Это особенно полезно, если вы делаете классы тестируемыми, по-
скольку можете создавать «фиктивные» реализации своих зависимостей
в целях тестирования, как показано на рис. 10.3.
Вместо того чтобы зависеть
от конкретной реализации,
UserController зависит
от интерфейса IEmailSender
Во время выполнения можно
выбрать конкретную реализацию
для использования.
Можно даже использовать
«заглушки» для модульных тестов
Рис. 10.3 Программируя на уровне интерфейса вместо явной реализации, можно
использовать различные реализации IEmailSender в разных сценариях, например
MockEmailSender в модульных тестах
СОВЕТ  Вы можете выбирать из множества различных фреймвор-
ков, используемых для предоставления имитированной реализа-
ции зависимостям. Мой любимый фреймворк – Moq, но NSubsti-
tute и FakeItEasy также популярны.
В качестве примера можно создать интерфейс IEmailSender, который
будет реализовывать EmailSender:
public interface IEmailSender
{
public void SendEmail(string username);
}
Тогда UserController может зависеть от этого интерфейса, а  не от
конк ретной реализации EmailSender, как показано в следующем листин-

362 Глава 10 Конфигурация сервисов с по мощью внедрения зависимостей
ге. Это позволит использовать другую реализацию во время модульных
тестов, например DummyEmailSender.
Листинг 10.5 Использование интерфейсов с внедрением зависимостей
public class UserController : ControllerBase
{
private readonly IEmailSender _emailSender;
public UserController(IEmailSender emailSender)
{
_emailSender = emailSender;
}
[HttpPost("register")]
public IActionResult RegisterUser(string username)
{
_emailSender.SendEmail(username);
return Ok();
}
}
Ключевым моментом здесь является то, что клиентский код, UserCon-
troller, не заботится о том, как реализована зависимость, а только о том,
что он реализует интерфейс IEmailSender и предоставляет метод Send-
Email. Код приложения теперь не зависит от реализации.
Надеюсь, принципы, лежащие в основе внедрения зависимостей, ка-
жутся разумными – имея слабосвязанный код, легко полностью изме-
нить или заменить реализации. Но по-прежнему остается вопрос: как
приложение узнает, что в промышленном окружении нужно использо-
вать EmailSender вместо DummyEmailSender? Процесс сообщения вашему
контейнеру внедрения зависимостей «когда вам нужен IEmailSender, ис -
пользуйте EmailSender» называется регистрацией.
ОПРЕДЕЛЕНИЕ  Вы регистрируете сервисы в контейнере внедре-
ния зависимостей, чтобы он знал, какую реализацию использовать
для каждого запрашиваемого сервиса. Обычно это выглядит как
«для интерфейса X используйте реализацию Y».
То, как именно вы регистрируете свои интерфейсы и типы в контей-
нере, может варьироваться в  зависимости от конкретной реализации
контейнера, но принципы, как правило, одинаковы. В ASP .NET Core есть
простой контейнер внедрения зависимостей «из коробки». Посмотрим,
как он используется при типичном запросе.
10.1.3 Внедрение зависимостей в ASP.NET Core
ASP .NET Core с самого начала разрабатывался как модульный и компо-
нуемый фреймворк, с  архитектурой почти в  стиле плагинов, которая
обычно дополняется внедрением зависимостей. Следовательно, в ASP .Т еперь вы зависите от IEmailSender,
а не от конкретной реализации
класса EmailSender.
Вам все равно, какая это реализация,
если она реализует IEmailSender.

363 Введение во внедрение зависимостей
NET Core есть простой контейнер внедрения зависимостей, который ис -
пользуют все библиотеки фреймворка для регистрации себя и своих за-
висимостей.
Этот контейнер используется, например, для регистрации Razor Pages
и  инфраструктуры веб-API  – форматеров, движка представлений, си-
стемы валидации и т. д. Это всего лишь базовый контейнер, поэтому он
предоставляет только несколько методов регистрации сервисов, но его
также можно заменить на сторонний. Это может дать вам дополнитель-
ные возможности, такие как авторегистрация или внедрение с по мощью
свойств. Контейнер внедрения зависимостей встроен в модель размеще-
ния ASP .NET Core, как показано на рис. 10.4.
1.  Получен запрос к URL-адресу /RegisterUser
2.  Компонент маршрутизации
маршрутизирует запрос на действие
RegisterUser в UserController
4.  Метод RegisterUser экземпляра
UserController вызывается, передавая
модель привязки3.  Активатор контроллера
вызывает контейнер внедрения
зависимостей для создания
экземпляра UserController,
включая все его зависимостиЗапрос
Компонент
маршрутизации
Активатор
контроллера
Модель привязкиКонтейнер для внедрения зависимостей
Рис. 10.4 Модель размещения ASP.NET Core использует контейнер внедрения
зависимостей, чтобы разрешить зависимости при создании контроллеров
Модель размещения извлекает зависимости из контейнера, когда они
необходимы. Если фреймворк определяет, что из-за входящего URL-
адреса /route требуется UserController, активатор контроллера, отвеча-
ющий за создание экземпляра контроллера, API запросит у контейнера
реализацию IEmailSender.
ПРИМЕЧАНИЕ   Паттерн, где класс вызывает контейнер внедре-
ния зависимостей напрямую, чтобы запросить класс, называется
сервис-локатор. По большому счету следует пытаться избегать ис -
пользования этого паттерна в своем коде; включайте свои зави-

364 Глава 10 Конфигурация сервисов с по мощью внедрения зависимостей
симости в  качестве аргументов конструктора напрямую, и  пусть
контейнер предоставит их вам1.
Контейнер должен знать, что создавать при запросе IEmailSender,
по этому нужно зарегистрировать реализацию, такую как EmailSender,
в контейнере. После регистрации реализации контейнер может внедрять
ее куда угодно. Это означает, что вы можете внедрять сервисы, связан-
ные с фреймворком, в собственные сервисы, если они зарегистрированы
в контейнере. Это также означает, что вы можете зарегистрировать аль-
тернативные версии сервисов фреймворка, и фреймворк будет автома-
тически использовать их вместо тех, что есть по умолчанию.
Гибкость точного выбора того, как и какие компоненты вы сочетаете
в своих приложениях, является одним из преимуществ внедрения зави-
симостей. В следующем разделе вы узнаете, как сконфигурировать внед-
рение зависимостей в собственном приложении ASP .NET Core, исполь-
зуя встроенный контейнер.
10.2 Использование контейнера внедрения
зависимостей
В предыдущих версиях ASP .NET использование внедрения зависимостей
было совершенно необязательным. Напротив, для создания всех прило-
жений ASP .NET Core, кроме самых простых, требуется некоторая степень
внедрения зависимостей. Как я уже упоминал, от нее зависит базовый
фреймворк, поэтому такие вещи, как использование Razor Pages и конт -
роллеров API, требуют конфигурирования необходимых сервисов.
В этом разделе вы узнаете, как зарегистрировать эти сервисы фрейм-
ворка во встроенном контейнере, а  также как зарегистрировать соб-
ственные сервисы. После регистрации сервисов вы можете использовать
их в качестве зависимостей и внедрять их в любые сервисы своего при-
ложения.
10.2.1 Добавление сервисов фреймворка ASP.NET Core
в контейнер
Как я уже писал ранее, ASP .NET Core использует внедрения зависимостей
для конфигурирования своих внутренних компонентов, а также ваших
собственных сервисов. Чтобы использовать эти компоненты во время
выполнения, контейнер внедрения зависимостей должен знать обо всех
необходимых ему классах. Они регистрируются в методе ConfigureSer-
vices вашего класса Startup.
1 Вы можете прочитать об антипаттерне сервис-локатор в  книге «Принципы
внедрения	 зависимостей, 	практики	 и паттерны» Стивена ван Дерсена и Марка
Симанна (Manning, 2019): http://mng.bz/6g4o.

365 Использование контейнера внедрения зависимостей
ПРИМЕЧАНИЕ  Контейнер внедрения зависимостей настраи-
вается в методе ConfigureServices вашего класса Startup в файле
Startup.cs.
Теперь вы думаете: «Подождите, мне нужно самому настроить внут -
ренние компоненты?» Не паникуйте. Хотя в определенном смысле это
так и есть – вам нужно явно зарегистрировать компоненты в контейне-
ре в своем приложении, – все библиотеки, которые вы будете использо-
вать, предоставляют удобные методы расширения, которые позаботятся
о мельчайших деталях. Эти методы настраивают все, что вам нужно, од-
ним махом, вместо того чтобы делать все вручную.
Например, фреймворк Razor Pages предоставляет метод расширения
AddRazorPages(), который вы видели в  главах 2, 3 и  4. Вызовите метод
расширения в методе ConfigureServices класса Startup.
Листинг 10.6  Регистрация сервисов MVC в контейнере внедрения
зависимостей
public void ConfigureServices(IServiceCollection services)
{
services.AddRazorPages();
}
Проще некуда. Под капотом этот вызов регистрирует несколько ком-
понентов в контейнере внедрения зависимостей, используя те же самые
API. Вы вскоре это увидите, когда будете регистрировать собственные
сервисы.
СОВЕТ  Метод AddControllers() регистрирует необходимые сер-
висы для контроллеров API, как вы видели в главе 9. Существует
аналогичный метод AddControllersWithViews(), если вы использу -
ете контроллеры MVC с представлениями Razor, и метод AddMvc(),
чтобы добавить их все!
Большинство нетривиальных библиотек, которые вы добавляете
в свое приложение, будут иметь сервисы, которые нужно добавить в кон-
тейнер. По соглашению каждая библиотека, имеющая необходимые сер-
висы, должна предоставить метод расширения Add*(), который можно
вызвать в методе ConfigureServices.
Невозможно точно узнать, какие библиотеки потребуют от вас до-
бавления сервисов в   контейнер; обычно для этого нужно обратиться
к документации тех библиотек, которые вы используете. Если вы забу -
дете добавить их, то можете обнаружить, что функции не работают, или
можете получить исключение, подобное тому, что показано на рис. 10.5.
Следите за этим и обязательно регистрируйте все сервисы, которые вам
нужны.Метод расширения AddRazorPages
добавляет все необходимые сервисы
в IServiceCollection.

366 Глава 10 Конфигурация сервисов с по мощью внедрения зависимостей
Рис. 10.5 Если вам не удастся вызвать AddRazorPages в ConfigureServices, то вы
получите дружественное сообщение об исключении во время выполнения
Также стоит отметить, что некоторые методы расширения Add*() по-
зволяют указывать дополнительные параметры при их вызове, часто
с по мощью лямбда-выражения. Можно рассматривать это как настройку
установки сервиса в  ваше приложение. Например, если вы хотите по-
грузиться в детали, то метод AddControllers предоставляет множество
возможностей для тонкой настройки своего поведения, как показано
в сниппете IntelliSense на рис. 10.6.
Рис. 10.6 Конфигурирование сервисов при добавлении их в коллекцию сервисов. Функция
AddControllers() позволяет конфигурировать множество внутренних компонентов сервисов
контроллера API. Аналогичные параметры доступны и в функции AddRazorPages()
После того как вы добавили необходимые сервисы фреймворка, мож -
но переходить к делу и зарегистрировать собственные сервисы, чтобы
вы могли использовать внедрение зависимостей в своем коде.

367 Использование контейнера внедрения зависимостей
10.2.2 Регистрация собственных сервисов в контейнере
В первом разделе этой главы я описал систему отправки электронных
писем, когда новый пользователь регистрируется в вашем приложении.
Первоначально UserController вручную создавал экземпляр EmailSend-
er, но впоследствии мы провели рефакторинг и внедрили в конструктор
экземпляр IEmailSender.
Последним шагом для выполнения этого рефакторинга является на-
стройка ваших сервисов с  по мощью контейнера внедрения зависимо-
стей. Это позволяет контейнеру узнать, что использовать, когда ему
нужно разрешить зависимость IEmailSender. Если вы не зарегистрируете
свои сервисы, то получите исключение во время выполнения, как по-
казано на рис. 10.7. К счастью, это полезное исключение. Оно позволяет
узнать, какой сервис не был зарегистрирован (IEmailSender) и какой сер-
вис в нем нуждался (UserController).
!1.  Получен запрос
к URL-адресу /user/register
2.  Активатор контроллера вызывает
контейнер внедрения зависимостей
для создания экземпляра
UserController, включая его
зависимости4.  Исключение передается обратно
по конвейеру промежуточного ПО
и потом пользователю.
DeveloperExceptionPageMiddleware
отображает ошибку в браузере
3.  Поскольку IEmailSender не был
зарегистрирован, контейнер
не может создавать UserController,
поэтому выбрасывает исключение
InvalidOperationExceptionЗапрос
Маршрутизация
Активатор
контроллера
Контейнер для внедрения зависимостей
Рис. 10.7  Если вы не зарегистрируете все необходимые зависимости в ConfigureServices,
то получите исключение во время выполнения, сообщающее, какой сервис не был
зарегистрирован
Чтобы полностью сконфигурировать приложение, необходимо заре-
гистрировать EmailSender и все его зависимости в контейнере, как по-
казано на рис. 10.8.

368 Глава 10 Конфигурация сервисов с по мощью внедрения зависимостей
Сервисы и реализации
регистрируются попарноДля каждой пары указывается тип
запрашиваемого сервиса и тип реализации,
который нужно создать
Это могут быть разные типы, в которых
реализация осуществляет сервис,
например EmailSender, реализующий
IEmailSenderВ качестве альтернативы сервис
и реализация могут быть одним и тем
же типом, как, например, в случае
с NetworkClient и MessageFactory
Рис. 10.8 Конфигурирование контейнера внедрения зависимостей в вашем
приложении включает в себя сообщение ему, какой тип использовать при запросе
данного сервиса, например «Используйте EmailSender, когда требуется
IEmailSender»
Конфигурирование внедрения зависимостей состоит из ряда утверж -
дений о сервисах в вашем приложении. Например:
если сервису требуется IEmailSender, используйте экземпляр Email-
Sender;
если сервису требуется NetworkClient, используйте экземпляр Net-
workClient;
если сервису требуется MessageFactory, используйте экземпляр Mes-
sageFactory.
ПРИМЕЧАНИЕ  Вам также необходимо будет зарегистрировать
в контейнере объект EmailServerSettings – в следующем разделе
мы сделаем это немного по-другому.
Данные утверждения выполняются путем вызова различных методов
Add* в IServiceCollection в  методе ConfigureServices. Каждый метод
предоставляет контейнеру три составляющие регистрации:
тип	сервиса – 	TService. Это класс или интерфейс, который будет за-
прошен в  качестве зависимости. Часто это интерфейс, например
IEmail Sender, но иногда это может быть и конкретный тип, напри-
мер NetworkClient или MessageFactory;
тип	реализации – TService или TImplementation. Это класс, который
контейнер должен создать, чтобы разрешить зависимость. Это дол-
жен быть конкретный тип, например EmailSender. Это может быть
то же самое, что и тип сервиса, как у  NetworkClient и MessageFactory;
жизненный	 цикл – transient, singleton или scoped. Определяет, как
долго должен использоваться экземпляр сервиса. Подробнее о жиз-
ненном цикле я расскажу в разделе 10.3.
В следующем листинге показано, как сконфигурировать EmailSender
и его зависимости в своем приложении с по мощью трех разных мето-

369 Использование контейнера внедрения зависимостей
дов: AddScoped<TService>, AddSingleton<TService> и  AddScoped<TService,
TImplementation>. Так вы говорите контейнеру, как создавать каждый из
экземпляров TService, когда они потребуются.
Листинг 10.7  Регистрация сервисов в контейнере внедрения
зависимостей
public void ConfigureServices(IServiceCollection services)
{
services.AddControllers();
services.AddScoped<IEmailSender, EmailSender>();
services.AddScoped<NetworkClient>();
services.AddSingleton<MessageFactory>();
}
Вот и  все, что нужно для внедрения зависимостей! Это может пока-
заться немного волшебным1, но вы просто даете контейнеру инструкции
о том, как собрать все составные части. Вы даете ему рецепт, как пригото-
вить перец чили, измельчить салат и натереть сыр, чтобы, когда вы попро-
сите буррито, он мог собрать все ингредиенты воедино и подать вам еду!
Тип сервиса и  тип реализации одинаковы для NetworkClient и  Mes-
sageFactory, поэтому нет необходимости указывать один и тот же тип
дважды в методе AddScoped. Отсюда и более простая сигнатура.
ПРИМЕЧАНИЕ  Экземпляр EmailSender регистрируется только
как IEmailSender, поэтому его нельзя получить, запросив конкрет -
ную реализацию EmailSender; вы должны использовать интерфейс
IEmailSender.
Эти обобщенные методы – не единственный способ зарегистрировать
сервисы в контейнере. Вы также можете предоставлять объекты напрямую
или с по мощью лямбда-функций, как вы увидите в следующем разделе.
10.2.3 Регистрация сервисов с использованием объектов
и лямбда-функций
Как я упоминал ранее, я зарегистрировал не совсем все сервисы, необхо-
димые для UserController. Во всех моих предыдущих примерах Network-
Client зависит от EmailServerSettings, который вам также потребуется
зарегистрировать в контейнере, чтобы ваш проект работал без исклю-
чений.
1 Под капотом встроенный контейнер внедрения зависимостей ASP .NET Core
использует оптимизированное отражение для создания зависимостей, но раз-
ные контейнеры могут использовать другие подходы.Вы используете контроллеры API, поэтому
необходимо вызвать метод AddControllers.
Всякий раз, когда вам
потребуется IEmailSender,
используйте EmailSender.
Всякий раз, когда вам требуется
NetworkClient, используйте
NetworkClient.Всякий раз, когда вам требуется
MessageFactory, используйте
MessageFactory.

370 Глава 10 Конфигурация сервисов с по мощью внедрения зависимостей
Я избегал регистрации этого объекта в предыдущем примере, потому
что вам нужно использовать несколько иной подход. Предыдущие мето-
ды Add* применяют обобщенные типы для указания типа регистрируе-
мого класса, но не дают никаких указаний на то,	 как создать экземпляр
этого типа. Контейнер делает ряд предположений, которых вы должны
придерживаться:
это должен быть класс конкретного типа;
у класса должен быть только один «допустимый» конструктор, кото-
рый может использовать контейнер;
чтобы конструктор был «допустимым», все аргументы конструкто-
ра должны быть зарегистрированы в контейнере, или они должны
быть аргументами со значением по умолчанию.
ПРИМЕЧАНИЕ  Эти ограничения применяются к простому встро-
енному контейнеру. Если вы решите использовать в  своем при-
ложении сторонний контейнер, у  него может быть другой набор
ограничений.
Класс EmailServerSettings не соответствует этим требованиям, так как
требует, чтобы вы указали в конструкторе host и port, которые являются
строками без значений по умолчанию:
public class EmailServerSettings
{
public EmailServerSettings(string host, int port)
{
Host = host;
Port = port;
}
public string Host { get; }
public int Port { get; }
}
Нельзя регистрировать эти примитивные типы в контейнере; было бы
странно, если бы кто-то сказал: «Для каждого аргумента конструктора
string в любом типе используйте значение "smtp.server.com"».
Вместо этого вы можете самостоятельно создать экземпляр объекта
EmailServerSettings и передать его контейнеру, как показано ниже. Кон-
тейнер использует предварительно сконструированный объект всякий
раз, когда требуется экземпляр объекта EmailServerSettings.
Листинг 10.8  Предоставление экземпляра объекта при регистрации
сервисов
public void ConfigureServices(IServiceCollection services)
{
services.AddControllers();
services.AddScoped<IEmailSender, EmailSender>();

371 Использование контейнера внедрения зависимостей
services.AddSingleton<NetworkClient>();
services.AddScoped<MessageFactory>();
services.AddSingleton(
new EmailServerSettings
(
host: "smtp.server.com",
port: 25
));
}
Это отлично работает, если вам нужен только один экземпляр EmailSer-
verSettings в вашем приложении – один	и тот	же	объект будет исполь-
зоваться везде. Но что, если вам нужно создавать новый объект каждый
раз, когда он запрашивается?
ПРИМЕЧАНИЕ  Когда один и тот же объект используется при каж -
дом запросе, он называется одиночным	 объектом, или синглтоном.
Если вы создаете объект и  передаете его в  контейнер, он всегда
регистрируется как одиночный объект. Вы также можете заре-
гистрировать любой класс с  по мощью метода AddSingleton<T>(),
и  контейнер будет использовать только один экземпляр во всем
приложении. Подробное обсуждение одиночных объектов наря-
ду с другими видами	жизненного	 цикла	 приводится в разделе 10.3.
Жизненный цикл – это время, в течение которого контейнер дол-
жен использовать данный объект, чтобы разрешать зависимости
сервиса.
Вместо предоставления одного экземпляра, который контейнер всег -
да будет использовать, также можно предоставить функцию, которую
контейнер вызывает, когда ему нужен экземпляр типа, как показано на
рис. 10.9.
Экземпляр EmailServerSettings требуется
контейнеру внедрения зависимостей,
чтобы создать экземпляр NetworkClient
Вместо того чтобы создать экземпляр EmailServerSettings
напрямую с помощью конструктора, контейнер вызывает
предоставленную функцию и использует возвращаемый
экземпляр NetworkClientКонтейнер
для внедрения зависимостей
Рис. 10.9 Можно зарегистрировать функцию в контейнере, которая будет
вызываться всякий раз, когда потребуется новый экземпляр сервиса
Самый простой способ сделать это – использовать лямбда-функцию
(анонимный делегат), в которой при необходимости контейнер создает
новый объект EmailServerSettings. Этот экземпляр EmailServerSettings
будет использоваться всякий раз,
когда требуется экземпляр.

372 Глава 10 Конфигурация сервисов с по мощью внедрения зависимостей
Листинг 10.9  Использование лямбда-функции для регистрации
зависимости
public void ConfigureServices(IServiceCollection services)
{
services.AddMvc();
services.AddScoped<IEmailSender, EmailSender>();
services.AddSingleton<NetworkClient>();
services.AddScoped<MessageFactory>();
services.AddScoped(
provider =>
new EmailServerSettings
(
host: "smtp.server.com",
port: 25
));
}
В этом примере я  изменил жизненный цикл созданного объекта
EmailServerSettings и предоставил фабричную лямбда-функцию, кото-
рая возвращает новый объект EmailServerSettings. Каждый раз, когда
контейнеру требуется новый объект EmailServerSettings, он выполняет
функцию и использует новый объект, который она возвращает.
Когда вы используете лямбда-функцию для регистрации своих серви-
сов, вам предоставляется экземпляр IServiceProvider во время выпол-
нения, который в листинге 10.9 называется provider. Это открытый API
самого контейнера внедрения зависимостей, который предоставляет
функцию GetService(). Если вам нужно получить зависимости для соз-
дания экземпляра вашего сервиса, можно обратиться к  контейнеру во
время выполнения таким образом, но по возможности этого следует из-
бегать.
СОВЕТ  По возможности избегайте вызова функции GetService()
в  фабричных методах. Лучше отдайте предпочтение внедрению
через конструктор – оно более эффективно.
Открытые обобщенные типы и внедрение зависимостей
Как уже упоминалось, нельзя использовать обобщенные методы регистра-
ции с EmailServerSettings, потому что он использует примитивные типы
(в данном случае строку) в своем конструкторе. Также нельзя использовать
эти методы для регистрации открытых обобщенных типов.
Открытые обобщенные типы – это типы, содержащие параметр обобщен-
ного типа, например Repository<T>. Обычно этот тип используется для
определения базового поведения, которое можно использовать с несколь-
кими обобщенными типами. Например, в  Repository<T> можно внедрить
IRepository<Customer> в свои сервисы, которые должны внедрить, напри-
мер, экземпляр DbRepository<Customer>.Поскольку вы предоставляете
функцию для создания объекта,
вы не ограничены одиночным
объектом.
Лямбда-функция
предоставляется
как экземпляр
IServiceProvider.Конструктор вызывается каждый раз,
когда требуется объект EmailServerSettings,
а не только один раз.

373 Использование контейнера внедрения зависимостей
Чтобы зарегистрировать эти типы, необходимо использовать другой пере-
груженный вариант методов Add*. Например:
services.AddScoped(typeof(IRespository<>), typeof(DbRepository<>));
Это гарантирует, что всякий раз, когда конструктору сервиса требуется IRes-
pository<T>, контейнер внедряет экземпляр DbRepository<T>.
На данном этапе все ваши зависимости зарегистрированы. Но класс
ConfigureServices выглядит немного хаотично, не так ли? Все полностью
зависит от личных предпочтений, но мне нравится группировать свои
сервисы в логические группы и создавать для них методы расширения,
как в следующем листинге. Здесь создается эквивалент метода расши-
рения AddControllers() – приятный и простой API для регистрации. По
мере того как вы будете добавлять все больше и больше функций в свое
приложение, я думаю, вы тоже его оцените.
Листинг 10.10  Создание метода расширения, чтобы было проще
добавить несколько сервисов
public static class EmailSenderServiceCollectionExtensions
{
public static IServiceCollection AddEmailSender(
this IServiceCollection services)
{
services.AddScoped<IEmaиilSender, EmailSender>();
services.AddSingleton<NetworkClient>();
services.AddScoped<MessageFactory>();
services.AddSingleton(
new EmailServerSettings
(
host: "smtp.server.com",
port: 25
));
return services;
}
}
Создав предыдущий метод расширения, метод ConfigureServices на-
много проще понять!
public void ConfigureServices(IServiceCollection services)
{
services.AddControllers();
services.AddEmailSender();
}
До сих пор вы видели, как регистрировать простые внедрения за-
висимостей, когда у  вас есть одна-единственная реализация сервиса.
В некоторых сценариях вы можете обнаружить, что у вас есть несколь-Создаем метод
расширения
в IServiceCollection
с помощью ключевого
слова «this».
Вырезаем и вставляем
код регистрации
из ConfigureService.
По соглашению возвращаем IServiceCollection,
чтобы разрешить цепочку методов.

374 Глава 10 Конфигурация сервисов с по мощью внедрения зависимостей
ко реализаций интерфейса. В следующем разделе вы увидите, как заре-
гистрировать их в контейнере, чтобы они соответствовали вашим тре-
бованиям.
10.2.4 Многократная регистрация сервиса в контейнере
Одним из преимуществ программирования на уровне интерфейса яв-
ляется то, что вы можете создавать несколько реализаций сервиса. На-
пример, представьте, что вы хотите создать более обобщенную версию
IEmail Sender, чтобы иметь возможность отправлять сообщения через
SMS или Facebook, так же как и по электронной почте. Вы создаете для
этого интерфейс:
public interface IMessageSender
{
public void SendMessage(string message);
}
а также несколько реализаций: EmailSender, SmsSender и  FacebookSender.
Но как зарегистрировать эти реализации в контейнере? И как внедрить
их в UserController? Ответ может отличаться в зависимости от того, хо-
тите ли вы использовать все реализации в своем потребителе или только
одну из них.
внедрение  нескольких  реализаций  интерфейса
Представьте, что вы хотите отправить сообщение, используя каждую
из реализаций IMessageSender всякий раз, когда регистрируется новый
пользователь, так чтобы он получал электронное письмо, SMS и сообще-
ние в Facebook, как показано на рис. 10.10.
1.  Новый пользователь регистрируется
в вашем приложении и вводит свои
данные, вызывая метод действия
RegisterUser2.  Ваше приложение отправляет
ему приветствие по электронной
почте, SMS и через Facebook,
используя реализацию IMessageSender
Рис. 10.10 Когда пользователь регистрируется в вашем приложении, он вызывает
метод RegisterUser, который отправляет ему электронное письмо, SMS и сообщение
в Facebook с по мощью классов IMessageSender
Самый простой способ сделать это – зарегистрировать все реализа-
ции сервисов в  своем контейнере внедрения зависимостей, чтобы он
внедрял по одному экземпляру каждого типа в  UserController. UserCon-
troller затем может использовать простой цикл foreach для вызова ме-
тода SendMessage() для каждой реализации, как показано на рис. 10.11.

375 Использование контейнера внедрения зависимостей
Контейнер для внедрения зависимостей1.  Во время запуска несколько реализаций
IMessageSender регистрируются
в контейнере внедрения зависимостей
с использованием обычных методов Add *
2.  Контейнер создает по одному экземпляру
каждой реализации IMessageSender
и внедряет их в UserController как
IEnumerable <IMessageSender>
3.  Метод RegisterUser в UserController
перебирает экземпляры IMessageSender
и вызывает для каждого SendMessage
Рис. 10.11 Можно зарегистрировать несколько реализаций сервиса в контейнере,
как, например, IEmailSender в этом примере. Вы можете получить экземпляр
каждой из этих реализаций, затребовав IEnumerable<IMessageSender>
в конструкторе UserController
Вы регистрируете несколько реализаций одного и  того же сервиса
в контейнере внедрения зависимостей, точно так же, как и для отдель-
ных реализаций, используя методы расширения Add*. Например:
public void ConfigureServices(IServiceCollection services)
{
services.AddControllers();
services.AddScoped<IMessageSender, EmailSender>();
services.AddScoped<IMessageSender, SmsSender>();
services.AddScoped<IMessageSender, FacebookSender>();
}
Затем можно внедрить IEnumerable<IMessageSender> в  UserController,
как показано в следующем листинге. Контейнер внедряет массив IMes-
sageSender, содержащий по одной из зарегистрированных вами реализа-
ций в том же порядке, в каком вы их регистрировали. Затем можно ис -
пользовать стандартный цикл foreach в методе RegisterUser для вызова
метода SendMessage() для каждой реализации.
Листинг 10.11  Внедрение нескольких реализаций сервиса
в потребителя
public class UserController : ControllerBase
{
private readonly IEnumerable<IMessageSender> _messageSenders;
public UserController(
IEnumerable<IMessageSender> messageSenders)При запросе
IEnumerable будет
внедрен массив
IMessageSender.

376 Глава 10 Конфигурация сервисов с по мощью внедрения зависимостей
{
_messageSenders = messageSenders;
}
[HttpPost("register")]
public IActionResult RegisterUser(string username)
{
foreach (var messageSender in _messageSenders)
{
messageSender.SendMessage(username);
}
return Ok();
}
}
ВНИМАНИЕ!  Вы должны использовать IEnumerable<T> в качест -
ве аргумента конструктора для внедрения всех зарегистрирован-
ных типов сервиса, T. Несмотря на то что внедрение будет сде-
лано путем создания массива T[], нельзя использовать T[] или
ICollection<T> в  качестве аргумента конструктора. Это вызовет
исключение InvalidOperationException, подобное тому, что вы ви-
дели на рис. 10.7.
Достаточно просто внедрить все зарегистрированные реализации
сервиса, но что, если вам нужна только одна? Как контейнер узнает, ка-
кую из них использовать?
внедрение  одной  реализации  при реГистрации  нескольких  сервисов
Представьте, что вы уже зарегистрировали все реализации IMessageSen-
der; что происходит, если у вас есть сервис, которому требуется только
одна из них? Например:
public class SingleMessageSender
{
private readonly IMessageSender _messageSender;
public SingleMessageSender(IMessageSender messageSender)
{
_messageSender = messageSender;
}
}
Контейнер должен выбрать одну реализацию IMessageSender для внед-
рения в этот сервис, из трех доступных. Для этого используется	 последняя
зарегистрированная реализация – FacebookSender из предыдущего при-
мера.
ПРИМЕЧАНИЕ  Контейнер внедрения зависимостей будет ис -
пользовать последнюю зарегистрированную реализацию сервиса
при разрешении одного экземпляра сервиса.При запросе
IEnumerable будет
внедрен массив
IMessageSender.
Каждый IMessageSender
в IEnumerable – это другая
реализация.

377 Использование контейнера внедрения зависимостей
Это может быть особенно полезно для замены встроенных регистра-
ций собственными сервисами. Если у вас есть собственная реализация
сервиса, которая, как вы знаете, зарегистрирована в библиотечном ме-
тоде расширения Add*, можно переопределить эту регистрацию, заре-
гистрировав собственную. Контейнер внедрения зависимостей будет
использовать вашу реализацию всякий раз, когда запрашивается един-
ственный экземпляр сервиса.
Основным недостатком данного подхода является то, что вы по-
прежнему получаете несколько зарегистрированных реализаций  – вы
можете внедрить IEnumerable<T>, как и раньше. Иногда нужно условно
зарегистрировать сервис, чтобы у  вас была только одна зарегистриро-
ванная реализация.
условная  реГистрация  сервисов  с поМощью  TRyadd
Иногда нужно добавить реализацию сервиса, только если она еще не
была добавлена. Это особенно полезно для авторов библиотек; они мо-
гут создать реализацию интерфейса по умолчанию и зарегистрировать
ее только в том случае, если пользователь еще не зарегистрировал соб-
ственную реализацию.
В пространстве имен Microsoft.Extensions.DependencyInjection.Ex-
tensions можно найти несколько методов расширения для условной ре-
гистрации, например TryAddScoped. Он проверяет, не зарегистрирован
ли сервис в контейнере, перед тем как вызвать метод AddScoped для реа-
лизации. В следующем листинге показано, как можно условно добавить
SmsSender, только если нет существующих реализаций IMessageSender.
Поскольку вы ранее регистрировали EmailSender, контейнер будет игно-
рировать регистрацию SmsSender, поэтому она не будет доступна в ва-
шем приложении.
Листинг 10.12  Условное добавление сервиса с по мощью метода
TryAddScoped
public void ConfigureServices(IServiceCollection services)
{
services.AddScoped<IMessageSender, EmailSender>();
services.TryAddScoped<IMessageSender, SmsSender>();
}
Такой код часто не имеет большого смысла на уровне приложения, но
может быть полезен, если вы создаете библиотеки для использования
в нескольких приложениях. Например, ASP .NET Core использует TryAdd*
во многих местах, что позволяет легко регистрировать альтернативные
реализации внутренних компонентов в собственном приложении, если
вы этого хотите.
Вы также можете заменить ранее зарегистрированную реализацию
с по мощью метода расширения Replace(). К сожалению, API этого мето-EmailSender
зарегистрирован
в контейнере.
Уже существует реализация IMessageSender,
поэтому SmsSender не зарегистрирован.

378 Глава 10 Конфигурация сервисов с по мощью внедрения зависимостей
да не так удобен, как методы TryAdd. Чтобы заменить ранее зарегистри-
рованный IMessageSender на SmsSender, нужно использовать
services.Replace(new ServiceDescriptor(
typeof(IMessageSender), typeof(SmsSender), ServiceLifetime.Scoped
));
СОВЕТ  При использовании метода Replace() вы должны указать
тот же жизненный цикл, который использовался для регистрации
заменяемого сервиса.
Мы довольно подробно рассмотрели регистрацию зависимостей.
Преж  де чем перейти к  жизненному циклу зависимостей, сделаем не-
большое отступление и рассмотрим два способа, помимо конструктора,
для внедрения зависимостей в ваше приложение.
10.2.5 Внедрение сервисов в методы действий,
обработчики страниц и представления
В разделе 10.1 я упоминал, что контейнер внедрения зависимостей ASP .
NET Core поддерживает только внедрение через конструктор, но есть
еще три места, где можно использовать внедрение зависимостей:
методы действий;
методы обработчика страницы;
шаблоны представлений.
В этом разделе я кратко расскажу об этих трех вариантах, о том, как
они работают и когда вы, возможно, захотите их использовать.
внедрение  сервисов  непосредственно  в Методы  действий
и обработки  страниц  с поМощью  атрибута  [FRoMseRVices ]
Контроллеры API обычно содержат несколько методов действий, кото-
рые логически связаны друг с другом. Например, можно сгруппировать
все методы действий, связанные с  управлением учетными записями
пользователей, в одном контроллере. Это позволяет применять фильтры
и авторизацию ко всем методам действий сразу, как вы увидите в гла-
ве 13.
По мере добавления дополнительных методов действия к  контрол-
леру вы, возможно, обнаружите, что контроллеру требуются дополни-
тельные сервисы для реализации новых методов. При внедрении через
конструктор все эти зависимости предоставляются через конструктор.
Это означает, что контейнер внедрения зависимостей должен создавать
все зависимости для каждого метода действия в контроллере, даже если
ни одна из них не требуется для вызываемого метода.
Рассмотрим, например, листинг 10.13. Здесь показан класс UserCon-
troller с двумя методами-заглушками: RegisterUser и  PromoteUser. Для
каждого метода действия требуется своя зависимость, поэтому будут соз-

379 Использование контейнера внедрения зависимостей
даны и внедрены обе зависимости, вне зависимости от того, какой метод
действия вызывается запросом. Если у  IPromotionService или IMessage-
Sender много зависимостей, то контейнеру, возможно, придется создать
множество объектов для сервиса, который часто не используется.
Листинг 10.13 Внедрение сервисов в контроллер через конструктор
public class UserController : ControllerBase
{
private readonly IMessageSender _messageSender;
private readonly IPromotionService _promoService;
public UserController(
IMessageSender messageSender, IPromotionService promoService)
{
_messageSender = messageSender;
_promoService = promoService;
}
[HttpPost("register")]
public IActionResult RegisterUser(string username)
{
_messageSender.SendMessage(username);
return Ok();
}
[HttpPost("promote")]
public IActionResult PromoteUser(string username, int level)
{
_promoService.PromoteUser(username, level);
return Ok();
}
}
Если вы знаете, что создание сервиса особенно затратно, то можете
внедрить его как зависимость в метод действия напрямую, а не в конст -
руктор контроллера. Это гарантирует, что контейнер создаст зависи-
мость только тогда, когда вызывается конкретный метод действия, а не
любой метод действия контроллера.
ПРИМЕЧАНИЕ  В целом ваши контроллеры должны быть доста-
точно связными, чтобы в таком подходе не было необходимости.
Если вы обнаружите, что у вас есть контроллер, который зависит
от множества сервисов, каждый из которых используется одним
методом действия, возможно, стоит подумать о его разделении.
Можно напрямую внедрить зависимость в  метод действия, передав
ее в качестве параметра методу с по мощью атрибута [FromServices]. Во
время привязки модели фреймворк будет разрешать параметр из кон-
тейнера, а не из значений запроса. Ниже показано, как переписать лис -
тинг 10.13, чтобы использовать атрибут [FromServices] вместо внедре-
ния конструктора.И IMessageSender,
и IPromotionService внедряются
в конструктор каждый раз.
Метод RegisterUser использует
только IMessageSender.
Метод PromoteUser использует
только IPromotionService.

380 Глава 10 Конфигурация сервисов с по мощью внедрения зависимостей
Листинг 10.14  Внедрение сервисов в контроллер с использованием
атрибута [FromServices]
public class UserController : ControllerBase
{
[HttpPost("register")]
public IActionResult RegisterUser(
[FromServices] IMessageSender messageSender,
string username)
{
messageSender.SendMessage(username)
return Ok();
}
[HttpPost("promote")]
public IActionResult PromoteUser(
[FromServices] IPromotionService promoService,
string username, int level)
{
promoService.PromoteUser(username, level)
return Ok();
}
}
У вас может возникнуть соблазн использовать атрибут [FromServices]
во всех своих методах действий, но я бы посоветовал чаще использовать
стандартное внедрение через конструктор. Использование конструкто-
ра в качестве единого местоположения, объявляющего все зависимости
класса, может быть полезно, поэтому я использую атрибут [FromServices]
только в тех редких случаях, когда создание экземпляра зависимости за-
тратно и используется лишь в одном методе действия.
Атрибут [FromServices] можно применять точно так же и с Razor Pages.
Можно внедрить сервисы в обработчик страницы Razor, а не в конструк -
тор, как показано в листинге 10.15.
СОВЕТ  То, что вы можете внедрять сервисы в обработчики стра-
ниц, не значит, что вы должны это делать. Страницы Razor по сво-
ей сути созданы небольшими и связными, поэтому лучше просто
использовать внедрение через конструктор.
Листинг 10.15  Внедрение сервисов на страницу Razor с использованием
атрибута [FromServices]
public class PromoteUserModel: PageModel
{
public void OnGet()
{
}
public IActionResult OnPost(
[FromServices] IPromotionService promoService,
string username, int level)Атрибут [FromServices]
гарантирует, что IMessageSender
разрешен из контейнера
внедрения зависимостей.
IMessageSender доступен
только в RegisterUser.
IPromotionService разрешается
из контейнера и внедряется
как параметр.
Т олько метод PromoteUser может
использовать IPromotionService.
Обработчик OnGet не требует никаких сервисов.
IPromotionService разрешается
из контейнера и внедряется
как параметр.

381 Использование контейнера внедрения зависимостей
{
promoService.PromoteUser(username, level);
return RedirectToPage("success");
}
}
В целом, если вы обнаружите, что вам нужно использовать атрибут
[FromServices], следует сделать шаг назад и внимательно посмотреть на
свой контроллер или страницу Razor. Скорее всего, вы пытаетесь делать
слишком много всего в одном классе. Вместо того чтобы обойти пробле-
му с по мощью [FromServices], подумайте о том, чтобы разделить класс
или перенести какое-то поведение в сервисы модели приложения.
внедрение  сервисов  в шаблоны  представлений
Внедрение зависимостей в конструктор – рекомендуемый подход, но что,
если у вас нет конструктора? В частности, как внедрить сервисы в шаблон
представления Razor, если вы не контролируете создание шаблона?
Представьте, что у вас есть простой сервис HtmlGenerator, который по-
может вам сгенерировать HTML-код в ваших шаблонах представления.
Вопрос в том, как передать этот сервис шаблонам, если вы уже зарегист -
рировали его в контейнере внедрения зависимостей.
Один из вариантов – внедрить сервис HtmlGenerator на страницу Razor
с по мощью внедрения через конструктор и предоставить его как свой-
ство в PageModel, как вы видели в главе 7. Часто это самый простой под-
ход, но в некоторых случаях вам, возможно, не нужны будут ссылки на
данный сервис в  PageModel. В таких случаях можно напрямую внедрить
его в свои шаблоны представления.
ПРИМЕЧАНИЕ  Некоторым не нравится, когда сервисы в  пред-
ставления внедряют таким образом. Определенно не следует внед-
рять сервисы, связанные с бизнес-логикой, но думаю, что для сер-
висов, связанных с генерацией HTML-кода, это имеет смысл.
Можно внедрить сервис в шаблон Razor с по мощью директивы @in-
ject, указав тип, который нужно будет внедрить, и имя внедряемого сер-
виса в шаблоне.
Листинг 10.16  Внедрение сервиса в шаблон представления Razor
с помощью директивы @inject
@inject HtmlGenerator htmlHelper
<h1>The page title</h1>
<footer>
@htmlHelper.Copyright()
</footer>
Внедрение сервисов напрямую в представления может быть полезным
способом предоставления сервисов, связанных с пользовательским ин-Т олько обработчик страницы
OnPost может использовать
IPromotionService.
Внедряет экземпляр HtmlGenerator
в представление htmlHelper.
Использует внедренный сервис,
вызывая экземпляр htmlHelper.

382 Глава 10 Конфигурация сервисов с по мощью внедрения зависимостей
терфейсом своим шаблонам представлений без необходимости зависеть
от сервиса в  PageModel. Вы, вероятно, заметите, что вам не нужно часто
использовать такой вариант, но это полезный инструмент.
Мы довольно подробно рассмотрели регистрацию и  использование
зависимостей, но есть один важный аспект, о котором я лишь упомянул:
жизненный цикл или когда контейнер создает новый экземпляр серви-
са. Понимание времени жизни сервиса имеет решающее значение для
работы с  контейнерами внедрения зависимостей, поэтому важно уде-
лять им пристальное внимание при регистрации своих сервисов.
10.3 Жизненный цикл: когда создаются сервисы?
Всякий раз, когда у контейнера запрашивается конкретный зарегистри-
рованный сервис, например экземпляр IMessageSender, он может делать
одно из двух:
создать и вернуть новый экземпляр сервиса;
вернуть существующий экземпляр сервиса.
Жизненный	 цикл сервиса управляет поведением контейнера по отно-
шению к этим двум параметрам. Он определяется во время регистрации
сервиса и  диктует, когда контейнер будет повторно использовать су -
ществующий экземпляр сервиса, чтобы разрешать зависимости сервиса,
а когда создаст новый.
ОПРЕДЕЛЕНИЕ  Жизненный	 цикл сервиса  – это продолжитель-
ность существования экземпляра сервиса в  контейнере, прежде
чем он создаст новый экземпляр.
Важно понять последствия использования разных жизненных циклов,
используемых в ASP .NET Core, поэтому в этом разделе рассматривается
каждый доступный вариант цикла и то, когда нужно его использовать.
В частности, вы увидите, как жизненный цикл влияет на то, как часто
контейнер внедрения зависимостей создает новые объекты. В  разде-
ле 10.3.4 я покажу вам паттерн, на который следует обратить внимание,
когда зависимость с коротким жизненным циклом «захватывается» за-
висимостью с длительным циклом.
Это может вызвать некоторые трудности с отладкой, поэтому важно
помнить это при конфигурировании вашего приложения.
В ASP .NET Core можно указать три разных типа жизненных цикла при
регистрации сервиса во встроенном контейнере:
Transient – каждый раз, когда запрашивается сервис, создается но-
вый экземпляр. Это означает, что потенциально у вас могут быть
разные экземпляры одного и того же класса в одном и том же графе
зависимостей;
Scoped – в пределах области применения все запросы сервиса будут
предоставлять вам один и тот же объект. Для разных областей вы

383 Жизненный цикл: когда создаются сервисы?
получите разные объекты. В ASP .NET Core каждый веб-запрос полу -
чает свою область применения;
Singleton – вы всегда будете получать один и тот же экземпляр сер-
виса, независимо от области видимости.
ПРИМЕЧАНИЕ  Эти концепции хорошо согласуются с  концеп-
циями в большинстве других контейнеров, но терминология час -
то отличается. Если вы имеете дело со сторонним контейнером,
убедитесь, что вы понимаете, как концепции жизненного цикла
согласуются со встроенным контейнером ASP .NET. Core.
Чтобы проиллюстрировать поведение каждого цикла, я воспользуюсь
простым примером. Представьте, что у вас есть класс DataContext, у ко -
торого есть подключение к базе данных, как показано в листинге 10.17.
У него есть одно-единственное свойство RowCount, отображающее число
строк в таблице базы данных Users. Для этого примера мы эмулируем
вызов базы данных, задав количество строк в конструкторе, поэтому вы
будете получать одно и то же значение каждый раз, когда будете вызы-
вать свойство RowCount для данного экземпляра DataContext. Разные	 эк-
земпляры будут возвращать разное значение RowCount.
Листинг 10.17  Класс DataContext, генерирующий случайное значение
RowCount в своем конструкторе
public class DataContext
{
static readonly Random _rand = new Random();
public DataContext()
{
RowCount = _rand.Next(1, 1_000_000_000);
}
public int RowCount { get; }
}
У вас также есть класс Repository, который зависит от класса Data-
Context, как показано в  следующем листинге. Он также предоставляет
свойство RowCount, но оно делегирует вызов экземпляру DataContext. Не -
зависимо от значения, с которым был создан экземпляр DataContext, Re-
pository отобразит то же значение.
Листинг 10.18  Класс Repository, зависящий от экземпляра класса
DataContext
public class Repository
{
private readonly DataContext _dataContext;
public Repository(DataContext dataContext)
{
_dataContext = dataContext;
}Генерирует случайное число
от 1 до 1 000 000 000.
Свойство только для чтения задано
в конструкторе, поэтому оно всегда
возвращает одно и то же значение.
Экземпляр DataContext
предоставляется с использованием
внедрения зависимостей.

384 Глава 10 Конфигурация сервисов с по мощью внедрения зависимостей
public int RowCount => _dataContext.RowCount;
}
Наконец, у вас есть класс Razor Page RowCountModel, который напрямую
зависит от обоих этих классов. Когда активатор Razor Page создает эк -
земпляр класса RowCountModel, контейнер внедряет экземпляры классов
DataContext и  Repository. Чтобы создать экземпляр Repository, он так -
же создает второй экземпляр DataContext. В ходе двух запросов в общей
сложности потребуется четыре экземпляра класса DataContext, как по-
казано на рис. 10.12.
Контейнер для внедрения зависимостей Контейнер для внедрения зависимостей
Первый запрос Второй запрос
Для каждого запроса требуются два экземпляра
DataContext, чтобы собрать экземпляр
RowCountModel Для двух запросов требуется всего четыре
экземпляра DataContext
Рис. 10.12 Контейнер внедрения зависимостей использует два экземпляра класса
DataContext для каждого запроса. В зависимости от жизненного цикла, в котором
зарегистрирован тип DataContext, контейнер может создать один, два или четыре
разных экземпляра DataContext
RowCountModel записывает значение RowCount, возвращаемое из Repos-
itory и DataContext как свойства PageModel. Затем они визуализируются
с по мощью шаблона Razor (это не показано).
Листинг 10.19  Класс RowCountModel зависит от классов DataContext
и Repository
public class RowCountModel : PageModel
{
private readonly Repository _repository;
private readonly DataContext _dataContext;
public RowCountPageModel(
Repository repository,
DataContext dataContext)RowCount возвращает то же значение,
что и текущий экземпляр DataContext.
DataContext и Repository передаются
с использованием внедрения
зависимостей.

385 Жизненный цикл: когда создаются сервисы?
{
_repository = repository;
_dataContext = dataContext;
}
public void OnGet()
{
DataContextCount = _dataContext.RowCount;
RepositoryCount = _repository.RowCount;
}
public int DataContextCount { get; set ;}
public int RepositoryCount { get; set ;}
}
Цель этого примера  – изучить взаимосвязь между четырьмя эк -
земплярами класса DataContext в зависимости от жизненных циклов,
которые вы используете для регистрации сервисов в  контейнере.
Я  генерирую случайное число в  DataContext как способ однозначной
идентификации экземпляра DataContext, но вы можете рассматривать
это как текущее количество пользователей, вошедших на ваш сайт, или,
например, количества товара на складе на определенный момент вре-
мени.
Я начну с самого короткого типа жизненного цикла, transient, перейду
к  распространенному типу scoped, а  затем мы рассмотрим синглтоны.
Наконец, я покажу серьезную ловушку, на которую следует обратить вни-
мание при регистрации сервисов в своих приложениях.
10.3.1 Transient: все уникально
В контейнере ASP .NET Core кратковременные (transient) сервисы всегда
создаются заново, когда они необходимы, чтобы разрешить зависимо-
сти. Вы можете регистрировать свои сервисы, используя методы расши-
рения AddTransient:
services.AddTransient<DataContext>();
services.AddTransient<Repository>();
При такой регистрации каждый раз, когда требуется зависимость,
контейнер будет создавать новую. Это применимо как	между  запросами,
так и внутри запросов; экземпляр класса DataContext, внедренный в  Re-
pository, будет отличаться от того, что внедрен в RowCountModel.
ПРИМЕЧАНИЕ  Кратковременные зависимости могут приводить
к  появлению разных экземпляров одного и того же типа внутри
одного графа зависимостей.
На рис. 10.13 показаны результаты, которые вы получаете от двух по-
следовательных запросов, когда используете кратковременный жизнен-
ный цикл для обоих сервисов. Обратите внимание, что по умолчанию DataContext и Repository передаются
с использованием внедрения
зависимостей.
При вызове обработчик страницы
извлекает и записывает RowCount
из обеих зависимостей.
Счетчики предоставляются
в PageModel и визуализируются
в HTML-код в представлении Razor.

386 Глава 10 Конфигурация сервисов с по мощью внедрения зависимостей
экземпляры страницы Razor и контроллера API также являются кратко-
временными и всегда создаются заново.
Рис. 10.13 При регистрации с использованием кратковременного жизненного цикла все
четыре объекта DataContext различаются. Это можно увидеть по четырем разным числам,
отображаемым в ходе двух запросов
Кратковременные жизненные циклы могут привести к  созданию
большого количества объектов, поэтому они имеют смысл для легковес -
ных сервисов без состояния. Это равносильно вызову new каждый раз,
когда вам понадобится новый объект, поэтому имейте это в виду, ког -
да будете использовать данный цикл. Вы вряд ли будете слишком часто
применять его; большинство ваших сервисов, вероятно, будут использо-
вать жизненный цикл типа scoped.
10.3.2 Scoped: давайте держаться вместе
Жизненный цикл типа scoped указывает на то, что один-единственный
экземпляр объекта будет использоваться в пределах заданной области,
но разные экземпляры будут использоваться между разными областя-
ми. В ASP .NET Core область применения соответствует запросу, поэтому
в  рамках одного запроса контейнер будет использовать один и тот же
объект, чтобы удовлетворять всем зависимостям.
В предыдущем примере это означает, что в  рамках одного запроса
(одна область применения) во всем графе зависимостей будет исполь-
зоваться один и тот же экземпляр DataContext. DataContext, внедренный
в Repository, будет тем же экземпляром, что и внедренный в  RowCount-
Model.
В следующем запросе вы будете находиться в другой области, поэто-
му контейнер создаст новый экземпляр DataContext, как показано на
рис. 10.14. Как видите, разные экземпляры означают разные RowCountMo-
del для каждого запроса.
Вы можете зарегистрировать зависимости как scoped с по мощью ме-
тодов расширения AddScoped. В этом примере я зарегистрировал Data-
Context как scoped и оставил Repository как transient, но вы бы в этом
случае получили те же результаты, если бы оба они были scoped:
services.AddScoped<DataContext>()

387 Жизненный цикл: когда создаются сервисы?
Рис. 10.14 Scoped-зависимости используют один и тот же экземпляр DataContext в одном
запросе, но новый экземпляр для отдельного запроса. Следовательно, значения RowCount
идентичны внутри запроса
Из-за природы веб-запросов часто можно встретить сервисы, регист -
рируемые как scoped-зависимости в ASP .NET Core. Контексты базы дан-
ных и сервисы аутентификации – распространенные примеры сервисов,
которые должны быть ограничены запросом  – все, что вы хотите со-
вместно использовать в своих сервисах в рамках	 одного запроса, но не-
обходимо изменить между  запросами.
В целом вы встретите множество сервисов, зарегистрированных с ис -
пользованием данного жизненного цикла, особенно это касается всего,
что использует базу данных или зависит от конкретного запроса. Но не-
которые сервисы не нуждаются в изменении между запросами, напри-
мер сервис, вычисляющий площадь круга или возвращающий текущее
время в разных часовых поясах. Для них более подходящим может быть
жизненный цикл singleton.
10.3.3 Singleton: может быть только один
Синглтон, или одиночка, – это паттерн, появившийся еще до внедрения
зависимостей; контейнер обеспечивает его надежную и  простую в  ис -
пользовании реализацию. Синглтон концептуально прост: экземпляр
сервиса создается при первой необходимости (или во время регистра-
ции, как в разделе 10.2.3), и все. Вы всегда будете получать один и тот же
экземпляр, внедренный в ваши сервисы.
Данный паттерн особенно полезен для объектов, создание которых
связано с большими затратами, которые содержат данные для совмест -
ного использования в запросах, или объектов, не имеющих состояния.
Последние два момента важны – любой сервис, зарегистрированный как
синглтон, должен быть потокобезопасным.
ПРЕДУПРЕЖДЕНИЕ  Сервисы-одиночки должны быть потоко-
безопасными в веб-приложении, поскольку обычно они будут ис -
пользоваться несколькими потоками во время конкурентных за-
просов.

388 Глава 10 Конфигурация сервисов с по мощью внедрения зависимостей
Посмотрим, что означает использование синглтонов на примере под-
счета строк. Я  могу обновить регистрацию DataContext, чтобы он стал
одиночкой в ConfigureServices:
services.AddSingleton<DataContext>();
Затем можно дважды вызвать RowCountModel и наблюдать результаты
на рис. 10.15. Видно, что каждый экземпляр вернул одно и то же значе-
ние, указывая на то, что все четыре экземпляра DataContext – это один
и тот же экземпляр.
Рис. 10.15 Любой сервис, зарегистрированный как синглтон, всегда будет возвращать один
и тот же экземпляр. Следовательно, все вызовы RowCount возвращают одно и то же значение
как внутри запроса, так и между запросами
Синглтоны удобны для объектов, которые необходимо использовать
совместно или которые являются неизменяемыми и их затратно созда-
вать. Сервис кеширования должен быть синглтоном, поскольку всем за-
просам нужно использовать его совместно. Однако он должен быть пото-
кобезопасным. Точно так же можно зарегистрировать объект настроек,
загружаемый с удаленного сервера как синглтон, если вы загружаете на-
стройки один раз при запуске и повторно используете их в течение всего
жизненного цикла вашего приложения.
На первый взгляд, выбор жизненного цикла сервиса может показаться
не слишком сложным, но есть одна серьезная «ловушка», которая может
поджидать вас, в чем вы скоро убедитесь.
10.3.4 Следите за захваченными зависимостями
Представьте, что вы настраиваете жизненный цикл для примеров с клас -
сами DataContext и  Repository. Вы думаете о  предложениях, которые
я предоставил, и выбираете следующие циклы:
DataContext – scoped, поскольку он должен использоваться совмест -
но для одного запроса;
Repository – singleton, поскольку он не имеет собственного состоя-
ния и является потокобезопасным, так почему бы и нет?

389 Жизненный цикл: когда создаются сервисы?
ВНИМАНИЕ!  Данная конфигурация жизненного цикла предна-
значена для изучения ошибки – не используйте ее в коде, иначе
столкнетесь с аналогичной проблемой!
К сожалению, вы создали захваченную	 зависимость, потому что внед-
ряете scoped-объект, DataContext, в синглтон, Repository. Поскольку это
синглтон, один и тот же экземпляр класса Repository используется на
протяжении всего жизненного цикла приложения, поэтому внедренный
в  него объект DataContext тоже  будет существовать весь жизненный
цикл приложения, хотя	при	каждом	 запросе	следует	 использовать	 новый.
На рис. 10.16 показан сценарий, в котором новый экземпляр DataContext
создается для каждой области, но экземпляр внутри Repository находит -
ся там в течение всего жизненного цикла приложения.
Контейнер для внедрения зависимостей Контейнер для внедрения зависимостей
Первый запрос Второй запрос
Поскольку репозиторий был зарегистрирован как
синглтон, DataContext, который он использует,
также будет действовать как синглтон, даже если
он зарегистрирован как scoped Зависимость DataContext была захвачена
репозиторием, что нарушило жизненный цикл
scoped
Рис. 10.16 DataContext зарегистрирован как scoped-зависимость, но Repository –
это синглтон. Даже если вы ожидаете новый DataContext для каждого запроса,
Repository захватывает внедренный DataContext и заставляет вас повторно
использовать его на протяжении жизненного цикла приложения
Захваченные зависимости могут вызывать небольшие ошибки, кото-
рые трудно устранить, поэтому всегда следует за ними присматривать.
Такие зависимости относительно легко внедрить, поэтому всегда все
внимательно обдумывайте при регистрации синглтона.
ПРЕДУПРЕЖДЕНИЕ  Сервис должен использовать только те зави-
симости, жизненный цикл которых превышает или эквивалентен
жизненному циклу сервиса. Сервис, зарегистрированный как сингл-
тон, может безопасно использовать только singleton- зависимости.
Сервис, зарегистрированный как scoped, может безопасно исполь-

390 Глава 10 Конфигурация сервисов с по мощью внедрения зависимостей
зовать scoped- или singleton-зависимости. Кратковременный сервис
может использовать зависимости с любым жизненным циклом.
Здесь я должен упомянуть, что в этом предостережении есть проблеск
надежды. ASP .NET Core автоматически проверяет эти типы захваченных
зависимостей и выбросит исключение при запуске приложения, если об-
наружит их, как показано на рис. 10.17.
В окружении разработки вы получите
исключение, когда контейнер внедрения
зависимостей обнаружит захваченную
зависимость
Сообщение об исключении описывает,
какой сервис был захвачен…
…и какой сервис захватил
зависимость
Рис. 10.17  При включении ValidateScopes контейнер внедрения зависимостей
выбросит исключение, когда будет создавать сервис с захваченной зависимостью.
По умолчанию эта проверка включена только для окружения разработки
Такая проверка влияет на производительность, поэтому по умолчанию
она активируется, только когда ваше приложение работает в окружении
разработки, но это должно помочь обнаружить большинство проблем
такого рода. Можно включить или отключить эту проверку независимо
от окружения, задав параметр ValidateScopes при создании HostBuilder
в Program.cs, как показано в листинге 10.20.
Листинг 10.20  Задаем свойство ValidateScopes для постоянной
проверки областей применения
public class Program
{
public static void Main(string[] args)
{
CreateHostBuilder(args).Build().Run();
}
public static IHostBuilder CreateHostBuilder(string[] args) =>
Host.CreateDefaultBuilder(args)
.ConfigureWebHostDefaults(webBuilder =>
{
webBuilder.UseStartup<Startup>();
})
.UseDefaultServiceProvider(options =>
{
options.ValidateScopes = true;Конструктор по умолчанию задает
ValidateScopes для проверки только
в окружении разработки.
Можно
переопределить
проверку валидации
с по мощью
расширения
UseDefault -
ServiceProvider.Если задать здесь значение true,
то будут проверяться области
во всех окружениях, а это влияет
на производительность.

391 Жизненный цикл: когда создаются сервисы?
options.ValidateOnBuild = true;
});
}
В листинге 10.20 показан еще один параметр, который можно акти-
вировать, ValidateOnBuild. Он идет еще дальше. Когда он включен, кон-
тейнер внедрения зависимостей при запуске приложения проверяет на-
личие зависимостей, зарегистрированных для каждого сервиса, который
необходимо создать. Если этого не происходит, он генерирует исключе-
ние, как показано на рис. 10.18, сообщая о неправильной конфигурации.
Это также влияет на производительность, поэтому по умолчанию до-
ступно только в окружении разработки, но очень полезно, чтобы указать
на все пропущенные регистрации сервисов1.
Рис. 10.18 Если ValidateOnBuild активирован, при запуске приложения контейнер
проверит, может ли он создать все зарегистрированные сервисы. Если он находит
сервис, который не может создать, то выбрасывает исключение. По умолчанию такая
проверка включена только для окружения разработки
На этом наше знакомство с внедрением зависимостей в ASP .NET Core
подошло к концу. Теперь вы знаете, как добавить сервисы фреймворка
в свое приложение с по мощью методов расширения Add*, например Ad-
dRazorPages(), а  также как регистрировать собственные сервисы с  по-
мощью контейнера внедрения зависимостей. Надеюсь, это поможет вам
сохранить код слабосвязанным и им легко будет управлять.
В следующей главе мы рассмотрим модель конфигурации ASP .NET
Core. Вы увидите, как загружать настройки из файла во время выполне-
ния, как безопасно хранить конфиденциальные настройки и как заста-
вить приложение вести себя по-разному в зависимости от того, на какой
машине оно работает. Мы даже будем немного использовать внедрение
зависимостей; оно присутствует в ASP .NET Core повсюду!
1 К сожалению, контейнер не может отловить все ошибки. Список предостере-
жений и исключений см. в посте моего блога: http://mng.bz/QmwG.ValidateOnBuild проверяет,
что для каждого зарегистрированного сервиса
зарегистрированы все его зависимости.

392 Глава 10 Конфигурация сервисов с по мощью внедрения зависимостей
Резюме
Внедрение зависимостей встроено в ASP .NET Core. Необходимо убе-
диться, что ваше приложение добавляет все зависимости фреймворка
в класс Startup, или вы получите исключение во время выполнения,
когда контейнер внедрения зависимостей не сможет найти нужные
сервисы.
Граф зависимостей – это набор объектов, которые необходимо создать
для разработки конкретного запрашиваемого «корневого» объекта.
Контейнер внедрения зависимостей занимается созданием всех этих
зависимостей за вас.
Вы должны стремиться использовать явные зависимости вместо не-
явных в  большинстве случаев. ASP .NET Core использует аргументы
конструктора для явного объявления зависимостей.
При обсуждении внедрения зависимостей термин сервис	использует -
ся для описания любого класса или интерфейса, зарегистрированного
в контейнере.
Вы регистрируете сервисы в  контейнере внедрения зависимостей,
чтобы он знал, какую реализацию следует использовать для каждого
запрашиваемого сервиса. Обычно это имеет вид «для интерфейса X
используйте реализацию Y».
Контейнер внедрения зависимостей или инверсии управления отве-
чает за создание экземпляров сервисов. Он знает, как создать экземп-
ляр сервиса, создавая все его зависимости и передавая их в конструк -
тор сервиса.
Встроенный по умолчанию контейнер поддерживает только внедре-
ние через конструктор. Если требуются другие виды внедрения зави-
симостей, такие как внедрение через свойства, можно использовать
сторонний контейнер.
Вы должны регистрировать сервисы в  контейнере, вызывая методы
расширения Add* для IServiceCollection в методе ConfigureServices
класса Startup. Если вы забыли зарегистрировать сервис, который ис -
пользуется фреймворком или в собственном коде, то получите исклю-
чение InvalidOperationException во время выполнения.
Регистрируя свои сервисы, вы описываете три вещи: тип сервиса, тип
реализации и жизненный цикл. Тип сервиса определяет, какой класс
или интерфейс будет запрашиваться как зависимость. Тип реализа-
ции – класс, который контейнер должен создать для выполнения за-
висимости. Жизненный цикл – как долго должен использоваться эк -
земпляр сервиса.
Можно зарегистрировать сервис, используя обобщенные методы, если
класс конкретный и  все аргументы конструктора зарегистрированы
в контейнере или имеют значения по умолчанию.
Можно предоставить экземпляр сервиса во время регистрации, и этот
экземпляр будет зарегистрирован как синглтон. Это может быть по-
лезно, если у вас уже есть экземпляр сервиса.

393 Резюме
Можно предоставить фабричную лямбда-функцию, которая описыва-
ет, как создать экземпляр сервиса с любым выбранным вами жизнен-
ным циклом. Можно использовать этот подход, когда ваши сервисы
зависят от других сервисов, которые доступны только после запуска
приложения.
По возможности избегайте вызова метода GetService() в фабричных
методах. Вместо этого используйте внедрение через конструктор  –
оно более эффективно.
Можно зарегистрировать несколько реализаций сервиса. Затем вы мо-
жете внедрить IEnumerable<T>, чтобы получить доступ ко всем реали-
зациям во время выполнения.
Если вы внедряете один экземпляр сервиса с множественной регист -
рацией, контейнер внедряет последнюю зарегистрированную реали-
зацию.
Можно использовать методы расширения TryAdd*, чтобы гаранти-
ровать, что реализация регистрируется только в том случае, если не
было зарегистрировано никакой другой реализации сервиса. Это мо-
жет быть полезно для авторов библиотек при добавлении сервисов по
умолчанию, при этом позволяя потребителям переопределить заре-
гистрированные сервисы.
Жизненный цикл сервиса определяется во время регистрации. Он
диктует контейнеру внедрения зависимостей, когда повторно исполь-
зовать существующий экземпляр сервиса, чтобы удовлетворять зави-
симостям сервиса, и когда создать новый.
Кратковременный (transient) означает, что каждый раз, когда запра-
шивается сервис, создается новый экземпляр.
Scoped означает, что в пределах области действия все запросы сервиса
будут давать один и тот же объект. Для разных областей вы получите
разные объекты. В ASP .NET Core каждый веб-запрос получает свою об-
ласть действия.
Вы всегда будете получать один и тот же экземпляр singleton-сервиса
независимо от области действия.
Сервис должен использовать только те зависимости, жизненный цикл
которых больше или равен жизненному циклу сервиса.

11Конфигурирование
приложения	ASP.NETCore
В этой главе:
загрузка настроек от нескольких поставщиков
конфигурации;
безопасное хранение конфиденциальных настроек;
использование строго типизированных объектов
настроек;
использование разных настроек в разных окружениях
размещения.
В первой части этой книги вы познакомились с основами создания при-
ложения ASP .NET Core и узнали, как использовать паттерн MVC для соз-
дания традиционного веб-приложения или веб-API. Как только вы нач-
нете создавать реальные приложения, то быстро поймете, что вам нужно
настраивать различные параметры во время развертывания, без необхо-
димости повторной компиляции приложения. В этой главе рассматрива-
ется, как этого добиться в ASP .NET Core, используя конфигурацию.
Конфигурация звучит скучно, правда? Но должен признаться, что мо-
дель конфигурации – одна из моих любимых частей ASP .NET Core. Ее
очень легко использовать, и она намного элегантнее, чем в предыдущих
версиях ASP .NET. В разделе 11.3 вы узнаете, как загружать значения из
множества источников – файлов JSON, переменных окружения и аргу -
ментов командной строки – и объединять их в единый объект конфигу -
рации.

395 Представляем модель конфигурации ASP.NET Core
Вдобавок ко всему ASP .NET Core дает возможность легко привязать
эту конфигурацию к строго типизированным объектам параметров. Это
простые POCO-классы, которые формируются из объекта конфигура-
ции и которые можно внедрять в свои сервисы, как вы увидите в раз-
деле  11.4. Это позволяет красиво инкапсулировать настройки для раз-
личных функций в своем приложении.
В последнем разделе этой главы вы узнаете об окружении	 размещения
ASP .NET Core. Вы часто хотите, чтобы ваше приложение работало по-
разному в разных ситуациях, например при запуске на компьютере раз-
работчика или при развертывании на рабочем сервере. Такие ситуации
называются окружениями. Если приложение будет знать, в каком окру -
жении оно работает, то сможет загружать другую конфигурацию и соот -
ветственно изменять свое поведение.
Прежде чем начать, вернемся к основам: что такое конфигурация, для
чего она нам и как ASP .NET Core справляется с этими требованиями?
11.1 Представляем модель конфигурации
ASP.NET Core
В этом разделе я кратко опишу, что мы понимаем под конфигурацией
и для чего ее можно использовать в приложениях ASP .NET Core. Конфи-
гурация – это набор внешних параметров, предоставляемых приложе-
нию, который так или иначе контролирует его поведение. Обычно он
состоит из комбинации настроек и секретов, которые приложение будет
загружать во время выполнения.
ОПРЕДЕЛЕНИЕ  Настройка – 	это любое значение, изменяющее
поведение вашего приложения. Секрет – 	это особый тип настрой-
ки, содержащий конфиденциальные данные, такие как пароль,
API-ключ для сторонней службы или строка подключения.
Перед тем как мы начнем, есть очевидный вопрос. Нужно подумать,
для чего вам нужна конфигурация приложения и что нужно настроить.
Как правило, нужно выносить из кода приложения в конфигурацию все,
что можно рассматривать как настройку или секрет. Таким образом,
можно легко изменить эти значения во время развертывания, без не-
обходимости повторно компилировать приложение.
Например, у  вас может быть приложение, которое показывает рас -
положение ваших магазинов. У вас может быть настройка строки под-
ключения к базе данных, в которой вы храните подробную информацию
о магазинах, а также такие настройки, как местоположение по умолча-
нию для отображения на карте, используемый по умолчанию уровень
масштабирования и API-ключ для доступа к API Карт Google, как показа-
но на рис. 11.1. Если вы храните эти настройки и секреты за пределами
своего кода, то это хорошая практика, так как позволяет легко настраи-
вать их без необходимости повторной компиляции.

396 Глава 11 Конфигурирование приложения ASP.NETCore
Рис. 11.1 Можно хранить местоположение карты по умолчанию, уровень
масштабирования и API-ключ сопоставления в конфигурации и загружать их во
время выполнения. Важно хранить секреты, такие как API-ключи, в конфигурации за
пределами кода
Здесь также присутствует и аспект безопасности; вам не нужно жестко
кодировать секретные значения, такие как API-ключи или пароли, в свой
код, где они могут быть переданы в систему контроля версий и стать об-
щедоступными. Даже значения, встроенные в ваше скомпилированное
приложение, можно извлечь, поэтому по возможности лучше вынести
их за его пределы.
Практически каждый веб-фреймворк предоставляет механизм для за-
грузки конфигурации, и предыдущая версия ASP .NET в этом ничем не
отличалась. В  ней использовался элемент <appsettings> из файла web.
config для хранения пар конфигурации «ключ-значение». Во время вы-
полнения вы использовали статический (*вам уже страшно?*) класс Con-
figurationManager для загрузки значения данного ключа из файла.
Можно было делать и более сложные вещи, используя настраиваемые
разделы конфигурации, но это было неудобно и, по моему опыту, ис -
пользовалось редко.
ASP .NET Core дает вам полностью обновленный интерфейс. На самом
базовом уровне вы по-прежнему указываете пары «ключ-значение» как

397 Конфигурирование приложения с по мощью метода CreateDefaultBuilder
строки, но вместо того, чтобы получать эти значения из одного файла,
теперь вы можете загружать их из нескольких источников. Можно за-
гружать значения из файлов, но теперь они могут иметь любой формат:
JSON, XML, YAML и т. д. Кроме того, вы можете загружать значения из
переменных окружения, аргументов командной строки, базы данных
или из удаленной службы. Или можете создать собственного поставщи-
ка	конфигурации.
ОПРЕДЕЛЕНИЕ  ASP .NET Core использует поставщиков	 конфигу-
рации для загрузки пар «ключ-значение» из множества источни-
ков. Приложения могут использовать множество различных по-
ставщиков конфигурации.
У модели конфигурации ASP .NET Core также есть концепция пере-
определения	 параметров. Каждый поставщик конфигурации может опре-
делять собственные настройки или переопределять настройки от пре-
дыдущего поставщика. Вы увидите эту невероятно полезную функцию
в действии в разделе 11.3.
ASP .NET Core упрощает привязку пар «ключ-значение», которые
определены как строки, strings, к классам настройки POCO, которые вы
определяете в своем коде. Такая модель сильно типизированной конфи-
гурации позволяет легко логически сгруппировать настройки по задан-
ной функции и хорошо поддается модульному тестированию.
Прежде чем перейти к деталям загрузки конфигурации от поставщи-
ков, мы сделаем шаг назад и посмотрим,	 где происходит этот процесс –
внутри HostBuilder. Для приложений ASP .NET Core 5.0, созданных с ис -
пользованием шаблонов по умолчанию, это всегда происходит внутри
метода Host.CreateDefaultBuilder() из файла Program.cs.
11.2 Конфигурирование приложения с по мощью
метода CreateDefaultBuilder
Как вы видели в главе 2, шаблоны по умолчанию в ASP .NET Core 5.0 ис -
пользуют метод CreateDefaultBuilder. Это вспомогательный метод,
устанавливающий некоторые значения по умолчанию для вашего при-
ложения. В данном разделе мы рассмотрим этот метод, чтобы увидеть
все вещи, которые он конфигурирует, и для чего они используются.
Листинг 11.1  Использование метода CreateDefaultBuilder
для настройки конфигурации
public class Program
{
public static void Main(string[] args)
{
CreateHostBuilder(args).Build().Run();Т очка входа для вашего
приложения создает
IHostBuilder, собирает IHost
и вызывает метод Run.

398 Глава 11 Конфигурирование приложения ASP.NETCore
}
public static IHostBuilder CreateHostBuilder(string[] args) =>
Host.CreateDefaultBuilder(args)
.ConfigureWebHostDefaults(webBuilder =>
{
webBuilder.UseStartup<Startup>();
});
}
В главе 2 я не упоминал его, поскольку вам редко придется менять его
для простых приложений. Но по мере роста приложения и если вы хоти-
те изменить способ загрузки конфигурации для вашего приложения, то,
возможно, вы обнаружите, что нужно разбить его на части.
В этом листинге представлен обзор метода CreateDefaultBuilder, по -
этому вы можете увидеть, как устроен HostBuilder.
Листинг 11.2 Метод Host.CreateDefaultBuilder
public static IHostBuilder CreateDefaultBuilder(string[] args)
{
var builder = new HostBuilder()
.UseContentRoot(Directory.GetCurrentDirectory())
.ConfigureHostConfiguration(config =>
{
// Настройка поставщика конфигурации
})
.ConfigureAppConfiguration((hostingContext, config) =>
{
// Настройка поставщика конфигурации
})
.ConfigureLogging((hostingContext, logging) =>
{
logging.AddConfiguration(
hostingContext.Configuration.GetSection("Logging"));
logging.AddConsole();
logging.AddDebug();
})
.UseDefaultServiceProvider((context, options) =>
{
var isDevelopment = context.HostingEnvironment
.IsDevelopment();
options.ValidateScopes = isDevelopment;
options.ValidateOnBuild = isDevelopment;
});
return builder;
}CreateDefaultBuilder
устанавливает ряд значений
по умолчанию, включая
конфигурацию.
Создание
экземпляра
HostBuilder.Корень содержимого определяет каталог,
в котором можно найти файлы конфигурации.
Конфигурирует настройки
размещения, такие как определение
окружения размещения.
Конфигурирует настройки
приложения, а это и есть
тема данной главы.
Настраивает
инфраструктуру
журналирования.
Конфигурирует контейнер
внедрения зависимостей,
при необходимости
активируя настройки
проверки.
Возвращает HostBuilder для дальнейшей
конфигурации путем вызова дополнительных
методов перед вызовом метода Build().

399 Создание объекта конфигурации для вашего приложения
Первый метод, вызываемый в  HostBuilder,  – это UseContentRoot. Он
сообщает приложению, в каком каталоге можно найти любую конфигу -
рацию или просмотреть файлы, которые потребуются позже. Обычно это
папка, в которой запущено приложение, отсюда и вызов метода GetCur-
rentDirectory.
СОВЕТ  ContentRoot – это	 не то место, где хранятся статические
файлы, к которым браузер может получить доступ напрямую, – это
WebRoot, обычно wwwroot.
Метод ConfigureHostingConfiguration() – это место, где ваше прило-
жение определяет, в каком окружении (HostingEnvironment) оно работает
в настоящее время. Фреймворк ищет переменные окружения и аргумен-
ты командной строки по умолчанию, чтобы определить, работает при-
ложение в окружении разработки или в промышленном окружении. По-
дробнее об окружении размещения вы узнаете в разделе 11.5.
ConfigureLogging – то место, где можно указать параметры журнали-
рования для своего приложения. Мы подробно рассмотрим журналиро-
вание в главе 17; пока достаточно знать, что метод CreateDefaultBuilder
настраивает его за вас.
Последний вызов в  CreateDefaultBuilder, UseDefaultServiceProvider
настраивает ваше приложение на использование встроенного контей-
нера внедрения зависимостей, а также задает параметры ValidateScopes
и ValidateOnBuild на основе текущего окружения, HostingEnvironment.
При запуске приложения в окружении разработки приложение автома-
тически проверяет зависимости, о которых вы узнали в главе 10.
Метод ConfigureAppConfiguration() находится в  центре внимания
раздела 11.3. Именно здесь вы загружаете настройки и секреты своего
приложения независимо от того, находятся ли они в файлах JSON, пере-
менных окружения или аргументах командной строки. В  следующем
разделе вы увидите, как использовать этот метод для загрузки значений
конфигурации от различных поставщиков с по мощью конструкции ASP .
NET Core ConfigurationBuilder.
11.3 Создание объекта конфигурации
для вашего приложения
В этом разделе мы познакомимся с самой сутью системы конфигурации.
Вы узнаете, как загружать настройки из нескольких источников, как
они хранятся внутри ASP .NET Core и как они могут переопределять дру -
гие значения, создавая «уровни» конфигурации. Вы также узнаете, как
безопас но хранить секреты, обеспечивая их доступность при запуске
своего приложения.
В разделе 11.2 вы видели, как можно использовать метод Create De-
fault Builder, чтобы создать экземпляр IHostBuilder. IHostBuilder от -

400 Глава 11 Конфигурирование приложения ASP.NETCore
вечает за настройку многих аспектов приложения, включая систему
конфигурации в методе ConfigureAppConfiguration. Этому методу пере-
дается экземпляр ConfigurationBuilder, который используется для опре-
деления конфигурации вашего приложения.
Модель конфигурации ASP .NET Core основана на двух основных кон-
струкциях: ConfigurationBuilder и IConfiguration.
ПРИМЕЧАНИЕ  ConfigurationBuilder описывает, как построить
окончательное представление конфигурации для вашего прило-
жения, а IConfiguration содержит сами значения конфигурации.
Настройка конфигурации описывается путем добавления ряда объек -
тов IConfigurationProvider в  ConfigurationBuilder в методе Configure-
AppConfiguration. Они описывают, как загрузить пары «ключ-значение»
из определенного источника; например, JSON-файл или переменные
окружения, как показано на рис. 11.2. Вызов метода Build() запрашивает
у каждого из этих поставщиков значения, которые они содержат, чтобы
создать экземпляр IConfigurationRoot.
ПРИМЕЧАНИЕ  При вызове метода Build() создается экземпляр
IConfigurationRoot, реализующий IConfiguration. Обычно вы бу -
дете работать с интерфейсом IConfiguration в своем коде.
1.  Вы начинаете с создания экземпляра
ConfigurationBuilder2.  Вы добавляете поставщиков
в построитель, используя различные
методы расширения. Эти поставщики
могут получать значения конфигурации
из нескольких источников
3.  При вызове метода Build() значения от каждого поставщика
загружаются и сохраняются  в IConfigurationRoot
Рис. 11.2 Использование ConfigurationBuilder для создания экземпляра IConfiguration.
Поставщики конфигурации добавляются в построитель с по мощью методов расширения.
Вызов метода Build() запрашивает у каждого поставщика создание IConfigurationRoot, который
реализует IConfiguration

401 Создание объекта конфигурации для вашего приложения
ASP .NET Core поставляется с поставщиками конфигурации для загруз-
ки данных из распространенных местоположений:
файлы JSON;
XML-файлы;
переменные окружения;
аргументы командной строки;
файлы INI.
Если они не соответствуют вашим требованиям, то можно найти мно-
жество альтернатив на GitHub и NuGet или написать свой (это несложно).
Например, можно использовать официальный поставщик Azure Key
Vault1 или поставщик файлов YAML, который написал я2.
Во многих случаях поставщика по умолчанию будет достаточно.
В  частности, большинство шаблонов начинаются с  файла appsettings.
json, который содержит множество настроек в зависимости от выбран-
ного вами шаблона. В следующем листинге показан файл по умолчанию,
сгенерированный шаблоном Web App ASP .NET Core 5.0 без аутентифи-
кации.
Листинг 11.3  Файл appsettings.json по умолчанию,
созданный веб-шаблоном ASP.NET Core
{
"Logging": {
"LogLevel": {
"Default": "Information",
"Microsoft": "Warning",
"Microsoft.Hosting.Lifetime": "Information"
}
},
"AllowedHosts": "*"
}
Как видите, этот файл в основном содержит настройки для управле-
ния ведением журнала, но сюда также можно добавить дополнительную
конфигурацию для своего приложения.
ВНИМАНИЕ!  Не храните в этом файле конфиденциальные зна-
чения, такие как пароли, ключи API или строки подключения. Вы
увидите, как безопасно хранить их, в разделе 11.3.3.
Добавление собственных значений конфигурации включает в себя до-
бавление пары «ключ-значение» в JSON-файл. Хорошей идеей будет ис -
пользовать «пространство имен» для ваших настроек, создав корневой
объект для связанных настроек, как в  показанном здесь объекте Map-
Settings.
1 Поставщик Azure Key Vault доступен в NuGet по адресу http://mng.bz/OEKj.
2 Его можно найти на GitHub по адресу http://mng.bz/Yqdj.

402 Глава 11 Конфигурирование приложения ASP.NETCore
Листинг 11.4  Добавление дополнительных значений конфигурации
в файл appsettings.json
{
"Logging": {
"LogLevel": {
"Default": "Information",
"Microsoft": "Warning",
"Microsoft.Hosting.Lifetime": "Information"
}
},
"AllowedHosts": "*",
"MapSettings": {
"DefaultZoomLevel": 9,
"DefaultLocation": {
"latitude": 50.500,
"longitude": -4.000
}
}
}
Я вложил новую конфигурацию в родительский ключ MapSettings; так
мы создаем «секцию», которая будет полезна позже, когда дело дойдет
до привязки ваших значений к  объекту POCO. Я  также вложил ключи
latitude и  longitude в ключ DefaultLocation. Вы можете создать любую
структуру, которая вам нравится; поставщик конфигурации прочитает
их без проблем. Кроме того, можно хранить их как данные любого типа –
в данном случае это числа, – но имейте в виду, что поставщик будет чи-
тать и хранить их как строки.
СОВЕТ  Ключи конфигурации в  вашем приложении не	чувстви-
тельны к регистру, поэтому имейте это в виду при загрузке из по-
ставщиков, у которых ключи чувствительны к регистру.
Теперь, когда у вас есть файл конфигурации, пора вашему приложе-
нию загрузить его с  по мощью конструкции ConfigurationBuilder. Для
этого вернемся к методу ConfigureAppConfiguration(), предоставляемо-
му HostBuilder из файла Program.cs.
11.3.1 Добавление поставщика конфигурации
в файле Program.cs
В шаблонах по умолчанию в ASP .NET Core используется вспомогатель-
ный метод CreateDefaultBuilder для начальной загрузки HostBuilder для
вашего приложения, как вы видели в разделе 11.2. В рамках этой конфи-
гурации метод CreateDefaultBuilder вызывает метод ConfigureAppCon-
figuration и устанавливает ряд поставщиков конфигурации по умолча-
нию, которые мы рассмотрим более подробно в этой главе: Вкладываем всю
конфигурацию в ключ
MapSettings.Значения могут быть числами
в файле JSON, но при чтении они
будут преобразованы в строки.
Можно создавать глубоко вложенные структуры
для лучшей организации значений конфигурации.

403 Создание объекта конфигурации для вашего приложения
поставщик	 файлов	JSON –	загружает настройки из файла в форма-
те JSON, appsettings.json, а также загружает настройки из необяза-
тельного файла для конкретного окружения, appsettings.ENVIRON-
MENT.json. Я покажу, как использовать эти файлы, в разделе 11.5;
пользовательские	 секреты  – загружает секреты, которые надежно
хранятся во время разработки;
переменные	 окружения – загружает переменные окружения в качест -
ве переменных конфигурации. Они отлично подходят для хранения
секретов в промышленном окружении;
аргументы	 командной	 строки – использует значения, переданные
в качестве аргументов при запуске приложения.
Использование построителя по умолчанию привязывает вас к этому
набору, но он не обязателен. Если вы хотите использовать другие постав-
щики конфигурации, то можете создать собственный экземпляр Host-
Builder. Если вы воспользуетесь этим подходом, то нужно будет настро-
ить все, что делает CreateHostBuilder: журналирование, конфигурацию
размещения, конфигурацию поставщика сервисов, а также конфигура-
цию бизнес-логики вашего приложения.
Альтернативный подход  – дополнить дополнительные	 поставщики
конфигурации дополнительным вызовом ConfigureAppConfiguration,
как показано в  следующем листинге. Это позволит добавить дополни-
тельных поставщиков, кроме тех, что привнесены CreateHostBuilder.
В следующем листинге вы явно очищаете список поставщиков по умол-
чанию, что позволяет полностью настроить, откуда загружается конфи-
гурация, без замены значений по умолчанию, которые CreateHostBuild-
er добавляет для журналирования, и т. д.
Листинг 11.5  Загрузка файла appsettings.json с использованием
своего HostBuilder
public class Program
{
public static void Main(string[] args)
{
CreateHostBuilder(args).Build().Run();
}
public static IHostBuilder CreateHostBuilder(string[] args) =>
Host.CreateDefaultBuilder(args)
.ConfigureAppConfiguration(AddAppConfiguration)
.ConfigureWebHostDefaults(webBuilder =>
{
webBuilder.UseStartup<Startup>();
});
public static void AddAppConfiguration(
HostBuilderContext hostingContext,
IConfigurationBuilder config)
{Добавляет
функцию настройки
конфигурации
в HostBuilder.
HostBuilder предоставляет контекст
размещения и экземпляр
ConfigurationBuilder.

404 Глава 11 Конфигурирование приложения ASP.NETCore
config.Sources.Clear();
config.AddJsonFile("appsettings.json", optional: true);
}
СОВЕТ  В  листинге 11.5 я  извлек конфигурацию в  статический
вспомогательный метод AddAppConfiguration, но вы также можете
встроить его в виде лямбда-выражения.
HostBuilder создает экземпляр ConfigurationBuilder перед вызовом
метода ConfigureAppConfiguration. Все, что вам нужно сделать, – это до-
бавить поставщиков конфигурации для своего приложения.
В этом примере вы добавили одного поставщика конфигурации JSON,
вызвав метод расширения AddJsonFile и указав имя файла. Вы также за-
дали для optional значение true. Так вы сообщаете поставщику конфигу -
рации пропускать файлы, которые он не может найти во время выполне-
ния, вместо того чтобы выбрасывать исключение FileNotFoundException.
Обратите внимание, что метод расширения просто регистрирует постав-
щика на данном этапе, но еще не пытается загрузить файл.
Вот и все! Экземпляр HostBuilder отвечает за вызов метода Build(),
который генерирует IConfiguration, представляющий ваш объект кон-
фигурации. Затем он регистрируется в контейнере внедрения зависимо-
стей, чтобы вы могли внедрить его в свои классы. Обычно он внедряется
в конструктор класса Startup, чтобы можно было использовать его в ме-
тодах Configure и ConfigureServices:
public class Startup
{
public Startup(IConfiguration config)
{
Configuration = config;
}
public IConfiguration Configuration { get; }
}
ПРИМЕЧАНИЕ  ConfigurationBuilder создает экземпляр ICon-
figurationRoot, реализующий IConfiguration. Он регистрируется
как IConfiguration в контейнере, а не в  IConfigurationRoot. ICon-
figuration – один из интерфейсов, которые вы можете добавить
в конструктор Startup.
На данном этапе в результате выполнения конструктора Startup у вас
есть полностью загруженный объект конфигурации. Но что с ним делать?
IConfiguration хранит конфигурацию в виде набора пар «ключ-значение».
Вы можете получить доступ к любому значению по его ключу, используя
стандартный синтаксис словаря. Например, можно использовать
var zoomLevel = Configuration["MapSettings:DefaultZoomLevel"]; Очищает поставщиков, настроенных
по умолчанию в CreateDefaultBuilder.Добавляет поставщика конфигурации JSON,
предоставляя имя файла конфигурации.

405 Создание объекта конфигурации для вашего приложения
чтобы получить сконфигурированный уровень увеличения для своего
приложения. Обратите внимание, что я использовал двоеточие (:), чтобы
выделить отдельный раздел. Точно так же, чтобы получить ключ lati-
tude, можно использовать
Configuration["MapSettings:DefaultLocation:Latitude"];
ПРИМЕЧАНИЕ  Если запрашиваемый ключ конфигурации не су -
ществует, вы получите значение null.
Также можно получить целый раздел конфигурации, используя метод
GetSection(section), который возвращает IConfigurationSection, реали-
зующий IConfiguration. Он забирает часть конфигурации и сбрасывает
пространство имен. Еще один способ получить ключ latitude:
Configuration.GetSection("MapSettings")["DefaultLocation:Latitude"];
Доступ к таким значениям настроек полезен в методах ConfigureSer-
vices и Configure класса Startup, когда вы настраиваете свое приложение.
При настройке приложения для подключения к базе данных, например,
вы часто будете загружать строку подключения из объекта Configuration
(вы увидите конкретный пример в  следующей главе, когда мы будем
изучать   Entity Framework Core).
Если вам нужно получить доступ к подобному объекту конфигурации
из классов, отличных от Startup, то можно применить внедрение зави-
симостей, чтобы использовать его как зависимость в конструкторе ваше-
го сервиса. Но доступ к конфигурации с по мощью строковых ключей не
особенно удобен; вместо этого следует попытаться использовать строго
типизированную конфигурацию, как вы увидите в разделе 11.4.
Пока что, вероятно, все это выглядит немного запутанным и зауряд-
ным для загрузки настроек из файла JSON, и  я  согласен, что так оно
и есть. Система конфигурации ASP .NET Core лучше всего проявляет себя
в том случае, если у вас есть несколько поставщиков.
11.3.2 Использование нескольких поставщиков
для переопределения значений конфигурации
Вы видели, что ASP .NET Core использует паттерн Построитель	 для соз-
дания объекта конфигурации, но пока вы сконфигурировали только од-
ного поставщика. При добавлении поставщиков важно учитывать по-
рядок, в котором вы их добавляете, поскольку он определяет порядок,
в котором значения конфигурации добавляются в базовый словарь. Зна-
чения конфигурации от более поздних поставщиков будут перезаписы-
вать значения с тем же ключом от более ранних поставщиков.
ПРИМЕЧАНИЕ  Следует повторить: важен порядок, в котором вы
добавляете поставщиков конфигурации в  ConfigurationBuilder.
Поставщики, зарегистрированные позже, могут перезаписывать
значения более ранних поставщиков.

406 Глава 11 Конфигурирование приложения ASP.NETCore
Рассматривайте поставщиков конфигурации как добавление «слоев»
значений конфигурации к стеку, где каждый слой может перекрывать-
ся несколькими или всеми вышележащими слоями, как показано на
рис. 11.3. Когда вы вызываете метод Build(), ConfigurationBuilder объ -
единяет эти слои в один, чтобы создать окончательный набор значений
конфигурации, хранящихся в IConfiguration.
Каждый поставщик добавляет в стек
уровень значений конфигурации
Переменные
окружения
appsettings.json
sharedsettings.jsonВызов метода Build()
сворачивает стек, используя
самые верхние значения
конфигурации, если смотреть
сверхуЗначения в верхней части
вертикального среза –
это окончательные
значения, находящиеся
в IConfiguration
Рис. 11.3 Каждый поставщик конфигурации добавляет в ConfigurationBuilder
«слой» значений. Вызов метода Build() сворачивает эту конфигурацию. Более
поздние поставщики перезапишут значения конфигурации с теми же ключами, что
и предыдущие поставщики
Обновите свой код, чтобы загрузить конфигурацию от трех разных по-
ставщиков конфигурации – двух поставщиков JSON и поставщика пере-
менных окружения, – добавив их в  ConfigurationBuilder. В листинге 11.6
я показал только метод AddAppConfiguration для краткости.
Листинг 11.6 Загрузка от нескольких поставщиков в файле Startup.cs
public class Program
{
/* Дополнительная конфигурация класса Program */
public static void AddAppConfiguration(
HostBuilderContext hostingContext,
IConfigurationBuilder config)
{
config.Sources.Clear();
config
.AddJsonFile("sharedSettings.json", optional: true)
.AddJsonFile("appsettings.json", optional: true)
.AddEnvironmentVariables();
}
}
Такой многослойный дизайн может быть полезен для ряда вещей. По
сути, он позволяет объединить значения конфигурации из нескольких
разных источников в один связный объект. Чтобы закрепить это на прак -
тике, рассмотрим значения конфигурации, приведенные на рис. 11.4.Загружает конфигурацию
из другого файла конфигурации
JSON перед файлом appsettings.json.
Добавляет переменные окружения машины
в качестве поставщика конфигурации.

407 Создание объекта конфигурации для вашего приложения
sharedsettings.json
appsettings.json
Переменные окружения IConfigurationКаждый поставщик конфигурации добавляет несколько
значений конфигурации в финальный IConfiguration.
Они добавляются в том порядке, в каком были
добавлены провайдеры в ConfigurationBuilder
Переменные окружения загружаются после файла
appsettings.json, поэтому значение «localDB;»
для MyAppConString заменяется на «productionDB;»
Рис. 11.4 Конечный IConfiguration включает в себя значения от каждого
поставщика. И файл appsettings.json, и переменные окружения содержат ключ
MyAppConnString. Поскольку переменные окружения добавляются позже,
используется это значение конфигурации
Большинство настроек у  каждого поставщика уникальны и  добав-
ляются в  финальный IConfiguration. Но ключ "MyAppConnString" при-
сутствует и в файле appsettings.json, и как переменная окружения. По-
скольку поставщик переменных окружения добавлен после поставщиков
JSON, значение конфигурации переменной окружения используется
в IConfiguration.
Возможность сопоставлять конфигурацию от нескольких поставщи-
ков – удобная черта сама по себе, но такой дизайн особенно полезен,
когда речь идет о работе с конфиденциальными значениями конфигу -
рации, такими как строки подключения и пароли. В следующем разделе
показано, как решить эту проблему локально в окружении разработки
и на рабочих серверах.
11.3.3 Безопасное хранение секретов конфигурации
Как только вы создадите нетривиальное приложение, вы обнаружите,
что вам нужно где-то хранить некоторые конфиденциальные данные.
Это может быть пароль, строка подключения или, например, API-ключ
для удаленной службы.
Хранить эти значения в файле appsettings.json – как правило, плохая
идея, поскольку вы ни при каких обстоятельствах не должны передавать
секреты в систему управления версиями; количество секретных ключей
API, которые фиксируют в GitHub, просто ужасно! Вместо этого гораздо

408 Глава 11 Конфигурирование приложения ASP.NETCore
лучше хранить эти значения за пределами папки своего проекта, куда
они не попадут случайно.
Это можно сделать несколькими способами, но самые простые и час -
то используемые подходы состоят в использовании переменных окру -
жения для секретов на рабочем сервере и User Secrets, если вы делаете
это локально.
Ни один из подходов не является по-настоящему безопасным, по-
скольку они не хранят значения в зашифрованном виде. Если ваша ма-
шина скомпрометирована, злоумышленники смогут прочитать сохра-
ненные значения, потому что они хранятся в виде открытого текста. Они
предназначены для того, чтобы помочь вам избежать передачи секретов
системе управления версиями.
СОВЕТ  Azure Key Vault1  – безопасная альтернатива, поскольку
хранит зашифрованные значения в Azure. Но вам все равно потре-
буется использовать следующий подход для сохранения сведений
о подключении Azure Key Value. Еще один популярный вариант –
Vault от компании Hashicorp (w ww.vaultproject.io/), который можно
запустить локально или в облаке.
Какой бы подход вы ни использовали для хранения секретов своего
приложения, убедитесь, если это возможно, что вы не храните их в си-
стеме управления версиями. Даже частные репозитории не могут оста-
ваться частными вечно, поэтому лучше проявлять осторожность.
сохранение  секретов  в переМенных  окружения  в проМышленноМ  окружении
Можно добавить поставщика конфигурации переменной окружения
с по мощью метода расширения AddEnvironmentVariables, как вы уже ви-
дели в листинге 11.6. Он добавляет все переменные окружения на вашем
компьютере в виде пар «ключ-значение» в объекте  конфигурации.
ПРИМЕЧАНИЕ  Поставщик переменных окружения добавляет -
ся по умолчанию в  CreateDefaultBuilder, как вы видели в разде-
ле 11.2.
Можно создавать те же иерархические разделы в переменных окруже-
ния, которые вы обычно видите в файлах JSON, используя двоеточие (:)
или двойное подчеркивание (__) для разграничения секции, например
MapSettings:MaxNumberOfPoints или MapSettings__MaxNumberOfPoints.
СОВЕТ  В  некоторых окружениях, например в  Linux, двоеточие
в  переменных окружения не допускается, и  вместо него нужно
1 Поставщик конфигурации Azure Key Vault доступен в  виде пакета NuGet
Microsoft.Extensions.Configuration.AzureKeyVault. Дополнительные сведения
о том, как использовать его в своем приложении, см. на странице http://mng.
bz/BR7v .

409 Создание объекта конфигурации для вашего приложения
использовать двойное подчеркивание. Двойное подчеркивание
в переменных окружения будет преобразовано в двоеточие, когда
те будут импортированы в объект IConfiguration. При извлечении
значений из IConfiguration в свое приложение всегда следует ис -
пользовать двоеточие.
Подход с использованием переменных окружения особенно полезен,
когда вы публикуете свое приложение в автономное окружение, такое
как выделенный сервер, Azure или контейнер Docker. Вы можете уста-
новить переменные окружения на своей промышленной машине или
контейнере Docker, и  поставщик прочитает их во время выполнения,
переопределив значения по умолчанию, указанные в  файлах appset -
tings.json1.
Для машины, используемой при разработке, переменные окружения
менее полезны, так как все ваши приложения будут использовать те же
значения. Например, если задать переменную окружения Connection-
Strings__DefaultConnection, она будет добавляться для каждого прило-
жения, которое вы запускаете локально. Похоже, от этого больше хлопот,
чем пользы!
Для разработки можно использовать Менеджер пользовательских
сек ретов (User Secrets Manager). Он эффективно добавляет переменные
окружения для каждого приложения, поэтому у вас могут быть разные
настройки для каждого приложения, но хранить вы их будете в другом
месте, отличном от самого приложения.
хранение  секретов  с поМощью  Менеджера  пользовательских  секретов
в окружении  разработки
Идея пользовательских секретов (User Secrets) состоит в  том, чтобы
упрос  тить хранение секретов за пределами дерева проекта приложения.
Это похоже на переменные окружения, но используется уникальный
ключ для каждого приложения, чтобы хранить секреты отдельно.
ВНИМАНИЕ!  Секреты не зашифрованы, поэтому их нельзя счи-
тать безопасными. Тем не менее этот способ лучше хранения
в папке проекта.
Настройка User Secrets требует немного больше усилий, чем использо-
вание переменных окружения, поскольку вам нужно настроить инстру -
мент для их чтения и записи, добавить поставщика конфигурации User
Secrets и определить уникальный ключ для своего приложения.
1  ASP .NET Core по умолчанию включает поставщика User Secrets. На-
бор средств разработки .NET также включает в себя глобальный ин-
струмент для работы с секретами из командной строки.
1 Инструкции по установке переменных окружения для вашей операционной
системы см. на странице http://mng.bz/d4OD .

410 Глава 11 Конфигурирование приложения ASP.NETCore
2  Если вы используете Visual Studio, щелкните проект правой кноп-
кой мыши и выберите Manage User Secrets. После этого откроется
редактор файла secrets.json, в котором можно сохранить свои пары
«ключ-значение», как если бы это был файл appsettings.json, как
показано на рис. 11.5.
Рис. 11.5 Выберите Manage User Secrets, чтобы открыть редактор для приложения
User Secrets. Можно использовать этот файл для хранения секретов при локальной
разработке вашего приложения. Они хранятся за пределами папки вашего проекта
и не попадут в систему управления версиями
3  Добавьте уникальный идентификатор в свой файл с расширением
.csproj. Visual Studio делает это автоматически, когда вы нажимаете
Manage User Secrets, но если вы используете командную строку,
то нужно будет добавить его самостоятельно. Обычно используется
уникальный идентификатор, например GUID:
<PropertyGroup>
<UserSecretsId>96eb2a39-1ef9-4d8e-8b20-8e8bd14038aa</UserSecretsId>
</PropertyGroup>
4  Если вы не используете Visual Studio, то можно добавить секрет
с по мощью командной строки:
dotnet user-secrets set "MapSettings:GoogleMapsApiKey" F5RJT9GFHKR7
или отредактировать файл secret.json напрямую с по мощью свое-
го любимого редактора. Точное расположение этого файла зависит

411 Создание объекта конфигурации для вашего приложения
от вашей операционной системы и может отличаться. Обратитесь
к документации для получения подробной информации1.
Уф, как много всего, а если вы настраиваете HostBuilder, то это еще не
все! Вам необходимо обновить приложение, чтобы загрузить User Secrets
во время выполнения с  по мощью метода расширения AddUserSecrets
в методе ConfigureAppConfiguration:
if(env.IsDevelopment())
{
configBuilder.AddUserSecrets<Startup>();
}
ПРИМЕЧАНИЕ  Рекомендуется использовать поставщика User
Secrets только в  окружении разработки, а  не в  промышленном
окружении, поэтому в предыдущем фрагменте вы условно добав-
ляете поставщика в  ConfigurationBuilder. В промышленном окру -
жении нужно использовать переменные окружения или Azure Key
Vault, как уже обсуждалось ранее. Все это настраивается должным
образом по умолчанию, если вы используете метод Host.Creat-
eDefaultBuilder().
У данного метода есть несколько перегруженных вариантов, но самый
простой – это обобщенный метод, который можно вызвать, передавая
класс Startup вашего приложения в качестве аргумента типа. Поставщик
User Secrets должен прочитать свойство UserSecretsId, которое вы (или
Visual Studio) добавили в файл с расширением .csproj. Класс Startup ра-
ботает как ссылка, чтобы указать, какая сборка содержит это свойство.
ПРИМЕЧАНИЕ  Если вам интересно, пакет User Secrets исполь-
зует свойство UserSecretsId в вашем файле с расширением .csproj
для создания атрибута UserSecretsIdAttribute на уровне сборки.
Затем поставщик считывает этот атрибут во время выполнения,
чтобы определить UserSecretsId приложения, и, таким образом,
генерирует путь к файлу secrets.json.
И вот оно – безопасное хранение ваших секретов за пределами пап-
ки проекта во время разработки. Это может показаться излишним, но
если у вас есть нечто, что вы считаете конфиденциальным, к нему можно
получить доступ удаленно, и вам нужно загрузить это в конфигурацию,
то настоятельно рекомендую вам использовать переменные окружения
или User Secrets.
На этом пора оставить поставщиков конфигурации, но, прежде чем
это сделать, я бы хотел показать вам один трюк системы конфигурации
ASP .NET Core: перезагрузку файлов на лету.
1 Secret Manager Tool сохраняет файл secrets.json в профиле пользователя. По-
дробнее о нем можно узнать на странице http://mng.bz/ryAg, а об инструмен-
тах .NET – на странице http://mng.bz/VdmX.

412 Глава 11 Конфигурирование приложения ASP.NETCore
11.3.4 Перезагрузка значений конфигурации при их изменении
Помимо безопасности, отсутствие необходимости перекомпилировать
приложение каждый раз, когда вы хотите настроить значение, является
одним из преимуществ использования конфигурации и настроек. В пре-
дыдущей версии ASP .NET изменение настройки путем редактирования
файла web.config приведет к тому, что ваше приложение необходимо бу -
дет перезапустить. Ждать, пока приложение запустится, прежде чем оно
сможет обслуживать запросы, было немного затруднительно.
В ASP .NET Core вы, наконец, получаете возможность редактировать
файл и автоматически обновлять конфигурацию приложения без пере-
компиляции или перезапуска.
Часто упоминаемый сценарий, в  котором вы, возможно, могли бы
найти это полезным,  – это когда вы пытаетесь отладить приложение
в  промышленном окружении. Обычно журналирование настраивается
на один из этих уровней:
ошибка (Error);
предупреждение (Warning);
информация (Information);
отладка (Debug).
Каждая из этих настроек более подробна, чем предыдущая, но так -
же предоставляет больше контекста. По умолчанию можно настро-
ить свое приложение так, чтобы оно регистрировало только записи
предупреж  дений и ошибок в промышленном окружении, дабы не соз-
давать слишком много лишних записей в журнале. Наоборот, если вы
пытаетесь отладить какую-то проблему, вам нужно как можно больше
информации, поэтому, возможно, вы захотите использовать уровень
журнала Debug.
Возможность изменять конфигурацию во время выполнения означа-
ет, что вы можете легко включить дополнительные уровни журналиро-
вания, когда сталкиваетесь с проблемой, а затем переключить их обрат -
но, отредактировав файл appsettings.json.
ПРИМЕЧАНИЕ  Как правило, перезагрузка доступна только для
файловых поставщиков, в отличие от переменных окружения или
поставщика User Secrets.
Можно активировать перезагрузку файлов конфигурации при до-
бавлении любого из файловых поставщиков в  ConfigurationBuilder.
Методы расширения Add*File включают в себя перегруженный вариант
с  параметром reloadOnChange. Если задано значение true, то приложе-
ние будет отслеживать файловую систему для поиска изменений в файле
и, если понадобится, инициирует полную повторную сборку IConfigura-
tion. В этом листинге показано, как добавить перезагрузку конфигура-
ции в файл appsettings.json, загруженный внутри метода AddAppConfigu-
ration.

413 Использование строго типизированных настроек с паттерном Options
Листинг 11.7 Перезагрузка appsettings.json при изменении файла
public class Program
{
/* Дополнительная конфигурация класса Program */
public static void AddAppConfiguration(
HostBuilderContext hostingContext,
IConfigurationBuilder config)
{
config.AddJsonFile(
"appsettings.json",
optional: true
reloadOnChange: true);
}
}
После этого любые изменения, внесенные в  файл, будут отражены
в IConfiguration. Но, как я  сказал в  начале этой главы, IConfiguration
не является предпочтительным способом передачи настройки в вашем
приложении. Вместо этого, как вы увидите в следующем разделе, следует
отдавать предпочтение строго типизированным объектам POCO.
11.4 Использование строго типизированных
настроек с паттерном Options
В этом разделе вы узнаете о  строго типизированной конфигурации
и паттерне Options. Это предпочтительный способ доступа к конфигу -
рации в  ASP .NET Core. Используя строго типизированную конфигура-
цию, можно избежать проблем с опечатками при доступе к ней, что так -
же упрощает тестирование классов, поскольку вы можете использовать
простые объекты POCO, вместо того чтобы полагаться на абстракцию
IConfiguration.
Большинство примеров, которые я  показывал до сих пор, касались
передачи	 значений в  IConfiguration, а не того, как их использовать. Вы
уже видели, что можно получить доступ к ключу, используя синтаксис
словаря Configuration["key"], но применение таких строковых ключей
кажется беспорядочным и может привести к появлению опечаток.
Вместо этого ASP .NET Core предлагает использовать строго типизиро-
ванные настройки. Это объекты POCO, которые вы определяете и создае-
те. Они представляют собой небольшой набор настроек, ограниченных
одной функцией в вашем приложении.
В следующем листинге показаны настройки для вашего компонен-
та локатора магазина и  настройки отображения, чтобы настроить до-
машнюю страницу приложения. Они разделены на два разных объекта
с  ключами "MapSettings" и  "AppDisplaySettings", соответствующими
различным областям приложения, на которые они влияют.IConfiguration будет собран снова,
если файл appsettings.json изменится.

414 Глава 11 Конфигурирование приложения ASP.NETCore
Листинг 11.8 Разделение настроек на объекты в файле appsettings.json
{
"MapSettings": {
"DefaultZoomLevel": 6,
"DefaultLocation": {
"latitude": 50.500,
"longitude": -4.000
}
},
"AppDisplaySettings": {
"Title": "Acme Store Locator",
"ShowCopyright": true
}
}
Самый простой способ сделать настройки домашней страницы до-
ступными в  файле Index.cshtml – внедрить IConfiguration в  PageModel
и получить доступ к значениям, используя синтаксис словаря:
public class IndexModel : PageModel
{
public IndexModel(IConfiguration config)
{
var title = config["HomePageSettings:Title"];
var showCopyright = bool.Parse(
config["HomePageSettings:ShowCopyright"]);
}
}
Но это не лучший способ, на мой взгляд, слишком много строк! А этот
bool.Parse? Фу! Вместо этого можно использовать специальные строго
типизированные объекты со всей присущей им безопасностью типов
и достоинствами IntelliSense.
Листинг 11.9  Внедрение строго типизированных параметров
в PageModel с по мощью IOptions <T>
public class IndexModel: PageModel
{
public IndexModel(IOptions<AppDisplaySettings> options)
{
AppDisplaySettings settings = options.Value;
var title = settings.Title;
bool showCopyright = settings.ShowCopyright;
}
}Настройки, относящиеся к разделу
локатора магазинов в приложении.
Общие настройки, связанные
с внешним видом приложения.
Можно внедрить строго типизированный
класс параметров, используя интерфейс
оболочки IOptions<>.
Свойство Value
предоставляет объект
настроек POCO.
Объект настроек содержит свойства, которые привязаны
к значениям конфигурации во время выполнения.Связыватель также может преобразовывать
строковые значения напрямую в примитивные типы.

415 Использование строго типизированных настроек с паттерном Options
Система конфигурации ASP .NET Core включает связыватель, который
может принимать коллекцию значений конфигурации и привязывать их
к строго типизированному объекту, классу	 options. Это похоже на кон-
цепцию привязки модели из главы 6, где значения запроса были при-
вязаны к классам модели привязки POCO.
В этом разделе показано, как настроить привязку значений конфи-
гурации к классу options и как убедиться, что он перезагружается, когда
меняются базовые значения конфигурации. Мы также рассмотрим раз-
личные типы объектов, которые можно привязать.
11.4.1 Знакомство с интерфейсом IOptions
В ASP .NET Core были введены строго типизированные настройки, позво-
ляющие коду конфигурации придерживаться принципа единой ответ -
ственности и разрешать внедрение классов конфигурации в виде явных
зависимостей. Такие настройки также упрощают тестирование; вместо
того чтобы создавать экземпляр IConfiguration для тестирования служ -
бы, можно создать экземпляр класса параметров POCO.
Например, AppDisplaySettings, показанный в предыдущем примере,
может быть простым классом, предоставляя только значения, относя-
щиеся к домашней странице:
public class AppDisplaySettings
{
public string Title { get; set; }
public bool ShowCopyright { get; set; }
}
Ваши классы параметров не должны быть абстрактными и  иметь
конст руктор public без параметров, чтобы привязка работала корректно.
Связыватель установит все открытые свойства, совпадающие со значе-
ниями конфигурации, как вы вскоре увидите.
СОВЕТ  Вы не ограничены примитивными типами, такими как
string и  bool; также можно использовать вложенные сложные
типы. Система параметров привяжет секции к  сложным свой-
ствам. См. 	исходный код для этой книги в качестве примера.
Чтобы упростить привязку значений конфигурации к вашим специ-
альным классам параметров POCO, ASP .NET Core представляет интер-
фейс IOptions<T>. Это простой интерфейс с  одним свойством Value,
которое содержит ваш сконфигурированный класс POCO во время вы-
полнения. Классы параметров настраиваются в  секции ConfigureSer-
vices класса Startup, как показано здесь.

416 Глава 11 Конфигурирование приложения ASP.NETCore
Листинг 11.10  Конфигурирование классов параметров
с по мощью Configure<T> в файле Startup.cs
public IConfiguration Configuration { get; }
public void ConfigureServices(IServiceCollection services)
{
services.Configure<MapSettings>(
Configuration.GetSection("MapSettings"));
services.Configure<AppDisplaySettings>(
Configuration.GetSection("AppDisplaySettings"));
}
СОВЕТ  Необязательно использовать одно и то же имя для секции
и класса, как это делаю я в листинге 11.10; это просто условное со-
глашение, которому я люблю следовать. С этим соглашением мож -
но использовать оператор nameof(), чтобы снизить вероятность
опечаток, например вызвав GetSection(nameof(MapSettings)).
Каждый вызов Configure<T> внутренне выполняет следующие дей-
ствия.
1  Создает экземпляр ConfigureOptions<T>, который указывает, что
IOptions<T> должен быть настроен на основе конфигурации.
Если Configure<T> вызывается несколько раз, будут использоваться
несколько объектов ConfigureOptions<T>. Все они могут быть при-
менены для создания конечного объекта, почти так же, как ICon-
figuration создается из нескольких слоев.
2  Каждый экземпляр ConfigureOptions<T> привязывает секцию ICon-
figuration к  экземпляру класса POCO, T. Он задает все открытые
свойства класса параметров на основе ключей в предоставленном
ConfigurationSection.
Помните, что имя секции («MapSettings» в листинге 11.10) может
иметь любое значение; оно не обязательно должно совпадать с на-
званием вашего класса параметров.
3  Интерфейс IOptions<T> регистрируется в  контейнере внедрения
зависимостей как синглтон, с последним привязанным объектом
POCO в свойстве Value.
Последний шаг позволяет внедрять классы параметров в контроллеры
и сервисы путем внедрения IOptions<T>, как вы уже видели. Это дает вам
инкапсулированный, строго типизированный доступ к значениям кон-
фигурации. Больше никаких «магических» строк!
ВНИМАНИЕ!  Если вы забыли вызвать Configure<T> и  внедрить
IOptions<T> в свои сервисы, это не вызовет ошибку, но класс па-
раметров T не будет ни к чему привязан, и в его свойствах будут
только значения по умолчанию.Привязывает секцию
MapSettings к классу
параметров POCO
MapSettings.
Привязывает секцию
AppDisplaySettings
к классу параметров
POCO AppDisplaySettings.

417 Использование строго типизированных настроек с паттерном Options
Привязка класса T к ConfigurationSection происходит, когда вы впер-
вые запрашиваете IOptions<T>. Объект регистрируется в  контейнере
внедрения зависимостей как синглтон, поэтому привязывается только
один раз.
В этой настройке есть один недостаток: нельзя использовать параметр
reloadOnChange, который я описывал в разделе 11.3.4, чтобы перезагру -
зить строго типизированные классы параметров при использовании
IOptions<T>. IConfiguration все равно будет перезагружен, если вы от -
редактируете свои файлы appsettings.json, но это не распространяется
на класс параметров.
Если это покажется вам шагом назад или даже каким-то неприятным
фактором, не волнуйтесь. У  IOptions<T> для таких случаев есть двоюрод-
ный брат IOptionsSnapshot<T>.
11.4.2 Перезагрузка строго типизированных параметров
с по мощью IOptionsSnapshot
В предыдущем разделе вы использовали IOptions<T> для обеспечения
строго типизированного доступа к конфигурации. Это дало прекрасную
инкапсуляцию настроек для конкретного сервиса, но с одним недостат -
ком: класс параметров никогда не меняется, даже если вы измените ба-
зовый файл конфигурации, из которого он был загружен, например app-
settings.json.
Часто это не проблема (в любом случае не следует изменять файлы на
рабочих серверах в реальной ситуации), но если вам нужна такая функ -
циональность, то можно использовать интерфейс IOptionsSnaphot<T>.
Концептуально IOptionsSnaphot<T> идентичен IOptions<T> в том, что
это строго типизированное представление секции конфигурации. Раз-
ница состоит в том, когда и как часто при использовании каждого из них
создаются объекты параметров POCO.
IOptions<T> – экземпляр создается один раз при первом использо-
вании. Он всегда содержит конфигурацию с момента создания эк -
земпляра объекта.
IOptionsSnapshot<T> – при необходимости создается новый экземп-
ляр, если с момента создания последнего экземпляра базовая кон-
фигурация изменилась.
IOptionsSnaphot<T> автоматически настраивается для классов опций
в то же самое время, что и  IOptions<T>, поэтому его можно использовать
в своих сервисах точно так же. В следующем листинге показано, как об-
новить домашнюю страницу IndexModel, чтобы всегда получать послед-
ние значения конфигурации в строго типизированном классе парамет -
ров AppDisplaySettings.

418 Глава 11 Конфигурирование приложения ASP.NETCore
Листинг 11.11  Внедрение перезагружаемых параметров с по мощью
IOptionsSnapshot<T>
public class IndexModel: PageModel
{
public IndexModel(
IOptionsSnapshot<AppDisplaySettings> options)
{
AppDisplaySettings settings = options.Value;
var title = settings.Title;
}
}
Каждый раз, когда вы редактируете файл настроек и  вызываете пе-
резагрузку IConfiguration, IOptionsSnapshot<AppDisplaySettings> бу -
дет создаваться повторно. Новый объект AppDisplaySettings создается
с  новыми значениями конфигурации и  будет использоваться для по-
следующего внедрения зависимостей. Конечно, пока вы снова не отре-
дактируете файл! Все просто: обновите свой код, чтобы использовать
IOptionsSnapshot<T> вместо IOptions<T> везде, где вам это нужно.
Важным моментом при использовании шаблона параметров является
дизайн самих классов опций POCO. Обычно это простые наборы свойств,
но нужно помнить несколько вещей, чтобы не застрять во время отлад-
ки, выясняя, почему привязка не сработала.
11.4.3 Разработка классов параметров для автоматической
привязки
Я уже коснулся некоторых требований к  классам POCO для работы со
связывателем IOptions<T>, но следует помнить о нескольких правилах.
Первый ключевой момент заключается в том, что связыватель будет
создавать экземпляры ваших классов параметров с использованием от -
ражения, поэтому эти классы должны:
быть неабстрактными;
иметь конструктор по умолчанию (без параметров).
Если ваши классы удовлетворяют этим двум пунктам, связыватель бу -
дет перебирать все свойства класса и выполнит привязку любого свой-
ства, какого сможет. В самом широком смысле связыватель может при-
вязывать любое свойство:
которое является открытым;
у которого есть метод получения – связыватель не будет записывать
свойства, у которых есть только метод установки;
у которого есть метод установки или, для сложных типов, ненулевое
значение;
которое не является индексатором. IOptionsSnapshot<T> будет обновляться,
если изменятся базовые значения конфигурации.
Свойство Value
предоставляет объект
настроек POCO,
как и для IOptions<T>.Объект настроек будет совпадать со значениями
конфигурации в какой-то момент, а не при первом запуске.

419 Использование строго типизированных настроек с паттерном Options
В следующем листинге показан обширный класс параметров со мно-
жеством различных типов свойств, некоторые из которых допустимы
для привязки, а некоторые – нет.
Листинг 11.12  Класс параметров, содержащий свойства, пригодные
и непригодные для привязки
public class TestOptions
{
public string String { get; set; }
public int Integer { get; set; }
public SubClass Object { get; set; }
public SubClass ReadOnly { get; } = new SubClass();
public Dictionary<string, SubClass> Dictionary { get; set; }
public List<SubClass> List { get; set; }
public IDictionary<string, SubClass> IDictionary { get; set; }
public IEnumerable<SubClass> IEnumerable { get; set; }
public ICollection<SubClass> IEnumerable { get; }
= new List<SubClass>();
internal string NotPublic { get; set; }
public SubClass SetOnly { set => _setOnly = value; }
public SubClass NullReadOnly { get; } = null;
public SubClass NullPrivateSetter { get; private set; } = null;
public SubClass this[int i] {
get => _indexerList[i];
set => _indexerList[i] = value;
}
public List<SubClass> NullList { get; }
public Dictionary<int, SubClass> IntegerKeys { get; set; }
public IEnumerable<SubClass> ReadOnlyEnumerable { get; }
= new List<SubClass>();
public SubClass _setOnly = null;
private readonly List<SubClass> _indexerList
= new List<SubClass>();
public class SubClass
{
public string Value { get; set; }
}
}
Как показано в листинге, связыватель обычно поддерживает коллек -
ции – реализации и интерфейсы. Если свойство коллекции уже инициа-
лизировано, оно будет использоваться, но связыватель также может
создавать для них вспомогательные поля. Если ваше свойство реализует
любое из следующих классов, связыватель создаст List<> соответствую-
щего типа в качестве объекта:
IReadOnlyList<>;
IReadOnlyCollection<>;
ICollection<>;
IEnumerable<>.Связыватель также будет
выполнять привязку
коллекций, включая
интерфейсы; словари
должны иметь строковые
ключи.
Связыватель
может
привязывать
простые
и сложные
типы объектов
и свойства
только для
чтения
со значением
по умолчанию.Связыватель не может привязать закрытые
свойства, у которых есть только
метод установки или значение null,
или если это свойства индексатора.
Эти свойства
коллекции
нельзя
привязать.
Резервные поля для реализации
свойств SetOnly и Indexer –
не привязаны напрямую.

420 Глава 11 Конфигурирование приложения ASP.NETCore
ПРЕДУПРЕЖДЕНИЕ  Невозможно выполнить привязку к  свой-
ству IEnumerable<>, которое уже было инициализировано, посколь-
ку базовый тип не предоставляет функцию Add. Можно	 выполнить
привязку к  IEnumerable<>, если вы оставите его начальное значе-
ние равным null.
Точно так же связыватель создаст Dictionary<,> в качестве вспомога-
тельного поля для свойств со словарными интерфейсами, если они ис -
пользуют ключи string:
IDictionary<string,> ;
IReadOnlyDictionary<string,> .
ВНИМАНИЕ!  Нельзя привязывать словари с ключами, не являю-
щимися строковыми, такими как int. Чтобы увидеть примеры
привязки типов коллекций, см. исходный код для этой книги.
Понятно, что здесь есть немало нюансов, но если придерживаться
простых случаев из предыдущего примера, то все будет в порядке. Обя-
зательно проверьте свои файлы JSON на наличие опечаток!
СОВЕТ  Паттерн Параметры чаще всего используется для привяз-
ки классов POCO к конфигурации, но вы также можете настроить
свои строго типизированные классы настроек в коде путем предо-
ставления лямбда-функции функции Configure. Например, ser-
vices.Configure<TestOptions>(opt => opt.Value=true).
Он широко используется в ASP .NET Core, но не все являются его поклон-
никами. В следующем разделе вы увидите, как использовать строго типи-
зированные настройки и связыватель конфигурации без этого паттерна.
11.4.4 Связывание строго типизированных настроек
без интерфейса IOptions
Интерфейс IOptions во многом каноничен в ASP .NET Core – он исполь-
зуется основными библиотеками ASP .NET Core и имеет различные удоб-
ные функции для привязки строго типизированных настроек.
Однако во многих случаях он дает мало преимуществ потребителям
строго типизированных объектов настроек. Сервисы должны зависеть
от интерфейса IOptions, но затем немедленно извлекать «настоящий»
объект, вызывая IOptions<T>.Value. Это может быть особенно неприят -
но, если вы создаете многократно используемую библиотеку, которая по
своей сути не связана с ASP .NET Core, так как вы должны предоставить
интерфейс IOptions<T> во всех открытых API.
К счастью, связыватель конфигурации, отображающий объекты ICon-
figuration в строго типизированные объекты настроек, по своей сути не

421 Использование строго типизированных настроек с паттерном Options
привязан к  IOptions. В листинге 11.13 показано, как вручную привязать
строго типизированный объект настроек к секции конфигурации и за-
регистрировать его в контейнере внедрения зависимостей.
Листинг 11.13  Настройка строго типизированных параметров
без IOptions в файле Startup.cs
public IConfiguration Configuration { get; }
public void ConfigureServices(IServiceCollection services)
{
var settings = new MapSettings ();
Configuration.GetSection("MapSettings").Bind(settings);
services.AddSingleton(settings);
}
Теперь можно внедрить объект MapSettings напрямую в свои сервисы
без лишних церемоний, необходимых для использования IOptions<Map-
Settings>.
public class MyMappingController
{
private readonly MapSettings _settings;
public MyMappingController(MapSettings settings)
{
_settings = settings;
}
}
Если вы воспользуетесь этим подходом, то не получите выгоды от воз-
можности перезагрузки строго типизированных настроек или от некото-
рых более продвинутых способов использования IOptions, но в большин-
стве случаев это не такая уж и большая проблема. В целом мне нравится
данный подход, но, как и всегда, подумайте о том, что вы теряете, прежде
чем использовать его.
СОВЕТ  В главе 19 я показываю один такой сценарий, в котором
вы настраиваете объект IOptions, используя сервисы в своем кон-
тейнере внедрения зависимостей. Чтобы увидеть другие продви-
нутые сценарии, см. http://mng.bz/DR7y , или просмотрите посты,
посвященные IOptions в  моем блоге, например этот: http://mng.
bz/l1Aj.
На этом мы подошли к концу раздела, посвященного строго типизи-
рованным настройкам. В следующем разделе мы рассмотрим, как дина-
мически изменять настройки во время выполнения на основе окруже-
ния, в котором работает ваше приложение. Создаем новый экземпляр
объекта MapSettings.
Привязываем секцию
MapSettings в IConfiguration
к объекту настроек.Регистрируем объект настроек
как одиночный.

422 Глава 11 Конфигурирование приложения ASP.NETCore
11.5 Настройка приложения для нескольких
окружений
В этом разделе вы узнаете об окружениях размещения в ASP .NET Core.
Вы увидите, как определить, в каком окружении работает приложение
и как изменять используемые значения конфигурации в зависимости от
окружения. Это позволяет легко переключаться между различными на-
борами значений конфигурации в промышленном окружении по срав-
нению с окружением разработки, например.
Любое приложение, попадающее в  промышленное окружение, ско-
рее всего, будет работать в нескольких окружениях. Например, если вы
создаете приложение с  доступом к  базе данных, возможно, на вашем
компью  тере работает небольшая база данных, которую вы используете
при разработке. В промышленном окружении на сервере будет работать
совершенно другая база данных.
Другое распространенное требование – разный уровень журналирова-
ния в зависимости от того, где работает ваше приложение. В окружении
разработки можно генерировать большое количество записей журнала,
так как это помогает при отладке, но как только вы перейдете в промыш-
ленное окружение, такое количество может оказаться неподъемным.
Вам нужно будет регистрировать предупреждения и  ошибки, а  также,
возможно, записи на уровне информации, но определенно не записи
журнала уровня отладки!
Чтобы справиться с этими требованиями, нужно убедиться, что ваше
приложение загружает разные значения конфигурации в  зависимости
от окружения, в котором оно работает: загружать строку подключения
к промышленной базе данных в промышленном окружении и т. д. Нужно
учитывать три аспекта:
как ваше приложение определяет, в каком окружении оно работает;
как вы загружаете различные значения конфигурации в зависимо-
сти от текущего окружения;
как изменить окружение для конкретной машины.
В данном разделе по очереди рассматривается каждый из этих вопро-
сов, чтобы вы легко могли отличить свою машину, используемую в окру -
жении разработки, от рабочих серверов и действовать соответствующим
образом.
11.5.1 Определение окружения размещения
Как вы видели в разделе 11.2, метод ConfigureHostingConfiguration – это
место, где вы определяете, как ваше приложение вычисляет окружение
размещения. По умолчанию CreateDefaultBuilder использует, что, на-
верное, неудивительно, переменную окружения для определения теку -
щего окружения. HostBuilder ищет переменную окружения ASPNETCORE_
ENVIRONMENT и использует ее для создания объекта IHostEnvironment.

423 Настройка приложения для нескольких окружений
ПРИМЕЧАНИЕ  Можно использовать либо переменную окруже-
ния DOTNET_ENVIRONMENT, либо ASPNETCORE_ENVIRONMENT. Значение
ASPNETCORE_ переопределяет значение DOTNET_, если заданы оба.
В этой книге я использую версию с ASPNETCORE_.
Интерфейс IHostEnvironment предоставляет ряд полезных свойств,
касающихся контекста запуска вашего приложения. Некоторые из них
вы уже видели, например ContentRootPath, которое указывает на папку,
содержащую файлы содержимого приложения, например файлы appset -
tings.json. Здесь нас интересует свойство EnvironmentName.
Свойству IHostEnvironment.EnvironmentName задано значение пере-
менной окружения ASPNETCORE_ENVIRONMENT, поэтому это может быть что
угодно, но в большинстве случаев нужно придерживаться трех часто ис -
пользуемых значений:
"Development";
"Staging";
"Production".
ASP .NET Core включает в  себя несколько вспомогательных методов
для работы с этими тремя значениями, поэтому вам будет легче, если вы
будете их придерживаться. В частности, когда вы тестируете, работает ли
ваше приложение в определенном окружении, нужно использовать один
из следующих методов расширения:
IHostEnvironment.IsDevelopment();
IHostEnvironment.IsStaging();
IHostEnvironment.IsProduction();
IHostEnvironment.IsEnvironment(string environmentName).
Все эти методы проверяют переменную окружения без учета регистра,
поэтому вы не получите никаких трудно воспроизводимых ошибок во
время выполнения, если не используете прописные буквы для записи
значения переменной окружения.
СОВЕТ  По возможности используйте с  EnvironmentValue методы
расширения IHostEnvironment вместо прямого сравнения строк,
поскольку они проверяют совпадение без учета регистра.
IHostEnvironment не делает ничего, кроме предоставления сведений
о  вашем текущем окружении, но его можно использовать по-разному.
В главе 8 вы познакомились с тег-хелпером окружения, который исполь-
зовали для отображения и сокрытия HTML-кода в зависимости от теку -
щего окружения. Теперь вы знаете, откуда он получал информацию, –
IHostEnvironment.
Можно использовать аналогичный подход для настройки загружаемых
значений конфигурации во время выполнения, загружая разные файлы
в  окружении разработки или промышленном окружении. Это распро-
страненная практика, принятая в большинстве шаблонов ASP .NET Core,
а также во вспомогательном методе CreateDefaultBuilder.

424 Глава 11 Конфигурирование приложения ASP.NETCore
11.5.2 Загрузка файлов конфигурации для конкретного
окружения
Значение EnvironmentName определяется на ранней стадии процесса на-
чальной загрузки вашего приложения, до того, как будет создан Configu-
rationBuilder, переданный в  ConfigureAppConfiguration. Это означает,
что вы можете динамически изменять то, какие поставщики конфигура-
ции добавляются в построитель, а следовательно, какие значения кон-
фигурации загружаются, при создании IConfiguration.
Распространенный шаблон – это наличие необязательного файла app-
settings.ENVIRONMENT.json для конкретного окружения, который загру -
жается после файла appsettings.json по умолчанию. В данном листинге
показано, как этого добиться, если вы настраиваете метод ConfigureApp-
Configuration в файле Program.cs.
Листинг 11.14  Добавление файлов appsettings.json
для конкретного окружения
public class Program
{
public static void AddAppConfiguration(
HostBuilderContext hostingContext,
IConfigurationBuilder config)
{
var env = hostingContext.HostingEnvironment;
config
.AddJsonFile(
"appsettings.json",
optional: false)
.AddJsonFile
$"appsettings.{env.EnvironmentName}.json",
optional: true);
}
}
Здесь глобальный файл appsettings.json содержит настройки, при-
менимые к большинству окружений. Дополнительные необязательные
файлы, appsettings.Development.json, appsettings.Staging.json и  appset -
tings.Production.json, впоследствии добавляются в  ConfigurationBuilder,
в зависимости от текущего EnvironmentName.
Любые настройки в  этих файлах будут перезаписывать значения из
глобального файла appsettings.json, если в них есть такой же ключ. Это
позволяет настроить журналирование таким образом, чтобы регистри-
ровать больше информации, чем в обычном режиме, только в окруже-
нии разработки и  переключаться на более избирательные логи в  про-
мышленном окружении.
Еще один распространенный шаблон – полное добавление или уда-
ление поставщиков конфигурации в зависимости от окружения. Напри-
мер, можно использовать поставщика User Secrets при локальной разра-Т екущее окружение
IHostEnvironment доступно
для HostBuilderContext.
Базовый appsettings.json
обычно делается обязательным.
Добавляет необязательный файл JSON для конкретного
окружения, имя которого зависит от окружения.

425 Настройка приложения для нескольких окружений
ботке, а Azure Key Vault – в промышленном окружении. В этом листинге
показано, как применять IHostEnvironment для условного включения по-
ставщика User Secrets только в окружении разработки.
Листинг 11.15  Условное включение поставщика конфигурации
User Secrets
public class Program
{
/* Дополнительная конфигурация класса Program */
public static void AddAppConfiguration(
HostBuilderContext hostingContext,
IConfigurationBuilder config)
{
var env = hostingContext.HostingEnvironment
config
.AddJsonFile(
"appsettings.json",
optional: false)
.AddJsonFile(
$"appsettings.{env.EnvironmentName}.json",
optional: true);
if(env.IsDevelopment())
{
builder.AddUserSecrets<Startup>();
}
}
}
Также нередко можно настраивать конвейер промежуточного ПО
своего приложения на основе окружения. В главе 3 вы познакомились
с компонентом DeveloperExceptionPageMiddleware и узнали, как исполь-
зовать его при локальной разработке. В следующем листинге показано,
как использовать IHostEnvironment для управления конвейером таким
образом, чтобы при нахождении в окружении для обкатки или промыш-
ленном окружении ваше приложение использовало компонент Excep-
tionHandlerMiddleware.
Листинг 11.16  Использование окружения размещения для настройки
конвейера промежуточного ПО
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
if (env.IsDevelopment())
{
app.UseDeveloperExceptionPage();
}
else
{
app.UseExceptionHandler("/Error");
}Методы расширения
делают проверку
окружения простой
и явной.
В окружении для обкатки и промышленном окружении
поставщик User Secrets не будет использоваться.
В окружении разработки компонент
DeveloperExceptionPageMiddleware
добавляется в конвейер.
В окружении для обкатки и промышленном
окружении вместо этого конвейер
использует ExceptionHandlerMiddleware.

426 Глава 11 Конфигурирование приложения ASP.NETCore
app.UseHttpsRedirection();
app.UseStaticFiles();
app.UseRouting();
app.UseAuthorization();
app.UseEndpoints(endpoints =>
{
endpoints.MapRazorPages();
});
}
ПРИМЕЧАНИЕ  В  листинге 11.16 мы внедрили IWebHostEnvi-
ronment вместо IHostEnvironment. Данный интерфейс расширяет
IHostEnvironment, добавляя свойство WebRootPath  – путь к  папке
wwwroot в вашем приложении. Здесь нам этот путь не нужен, но
полезно знать о его существовании!
Можно внедрить IHostEnvironment в любое место своего приложения,
но я бы не советовал использовать его в собственных сервисах, кроме
классов Startup и Program. Намного лучше использовать поставщика кон-
фигурации для настройки строго типизированных параметров на осно-
ве текущего окружения размещения и  внедрять эти настройки в  свое
приложение.
Как бы это ни было полезно, но когда вы задаете IHostEnvironment
с переменной окружения, это может выглядеть немного громоздко, если
вы хотите переключаться между разными окружениями во время тести-
рования. Лично я всегда забываю, как задавать переменные окружения
в  различных операционных системах, которые использую. Последний
навык, которому я хотел бы научить вас, – как задавать окружение раз-
мещения при локальной разработке.
11.5.3 Задаем окружение размещения
В этом разделе я покажу вам несколько способов, с по мощью которых
можно задать окружение размещения во время разработки. Это упро-
щает тестирование поведения конкретного приложения в разных окру -
жениях без необходимости менять окружение для всех приложений на
компьютере.
Если ваше приложение ASP .NET Core не может найти переменную
окружения ASPNETCORE_ENVIRONMENT при запуске, то по умолчанию ис -
пользуется промышленное окружение, как показано на рис.  11.6. Это
озна чает, что при развертывании в промышленном окружении вы буде-
те использовать правильный вариант.
СОВЕТ  По умолчанию текущее окружение размещения отобра-
жается в  консоли при запуске. Это может быть полезно, чтобы
быст ро удостовериться в  том, что переменная окружения подо-
брана правильно.

427 Настройка приложения для нескольких окружений
Если HostBuilder не сможет найти переменную
ASPNETCORE_ENVIRONMENT во время
выполнения, по умолчанию приложение будет
запускаться в промышленном окружении
Рис. 11.6 По умолчанию приложения ASP.NET Core запускаются в промышленном
окружении.  Можно переопределить это, задав переменную ASPNETCORE_ENVIRONMENT
Еще один вариант – использовать файл launchSettings.json для управ-
ления окружением. Все приложения ASP .NET Core по умолчанию вклю-
чают этот файл в папку Properties. Файл launchSettings.json определяет
профили для запуска вашего приложения.
СОВЕТ  Профили можно использовать для запуска приложения
с другими переменными окружения, а также для имитации запус -
ка в Windows за IIS с по мощью профиля IIS Express. Лично я редко
пользуюсь этим профилем, даже для Windows, и всегда выбираю
профиль «проект».
Типичный файл launchSettings.json показан в  следующем листинге.
В  нем определены два профиля: "IIS Express" и  "StoreViewerApplica-
tion". Последний профиль эквивалентен использованию команды dot-
net run для запуска проекта и  по соглашению называется так же, как
и проект, содержащий файл launchSettings.json.
Листинг 11.17  Типичный файл launchSettings.json, определяющий
два профиля
{
"iisSettings": {
"windowsAuthentication": false,
"anonymousAuthentication": true,
"iisExpress": {
"applicationUrl": "http://localhost:53846",
"sslPort": 44399
}
},
"profiles": {
"IIS Express": {
"commandName": "IISExpress",
"launchBrowser": true,
"environmentVariables": {
"ASPNETCORE_ENVIRONMENT": "Development"
}
},Определяет настройки для работы
за IIS или использования профиля
IIS Express.
Профиль IIS Express используется
по умолчанию в Visual Studio в Windows.Если указано значение true, браузер
запускается при запуске приложения.
Определяет специальные переменные
окружения для профиля.  Задает для
окружения значение Development.

428 Глава 11 Конфигурирование приложения ASP.NETCore
"StoreViewerApplication": {
"commandName": "Project",
"launchBrowser": true,
"environmentVariables": {
"ASPNETCORE_ENVIRONMENT": "Development"
},
"applicationUrl":
" https://localhost:5001;http://localhost:5000"
}
}
}
Преимущество локального использования файла launchSettings.json
заключается в том, что он позволяет задавать «локальные» переменные
окружения проекта. Например, в листинге 11.17 окружение задано как
окружение разработки. Это позволяет использовать разные переменные
окружения для каждого проекта и даже для каждого профиля и сохра-
нять их в системе управления версиями.
Вы можете выбрать профиль в  Visual Studio, используя раскрываю-
щийся список рядом с кнопкой Debug на панели инструментов, как по-
казано на рис. 11.7. Можно выбрать профиль для запуска из командной
строки, используя команду dotnetrun--launch-profile <Profile Name>.
Если вы не укажете профиль, то будет использован первый профиль типа
«проект». Если вы не хотите использовать какой-либо профиль, то долж-
ны явно игнорировать файл launchSettings.json с  по мощью команды
dotnetrun--no-launch-profile.
Рис. 11.7 Можно выбрать профиль для использования в Visual Studio из раскрывающегося
списка, щелкнув по кнопке Debug. По умолчанию Visual Studio использует профиль IIS Express.
Профиль по умолчанию, запускающийся с по мощью команды dotnet run, первый профиль типа
«проект» – в данном случае это StoreViewerApplication
Если вы используете Visual Studio, то также можете редактировать
файл launchSettings.json визуально: дважды щелкните по узлу «Свой-
ства» и выберите вкладку «Отладка». На рис. 11.8 видно, что в качестве
значения переменной ASPNETCORE_ENVIRONMENT указан профиль окруже-Профиль «проект», эквивалентный
вызову команды dotnet run в проекте.
Если указано
значение
true, браузер
запускается
при запуске
приложения.У каждого профиля могут быть
разные переменные окружения.
Определяет URL-адреса, которые приложение
будет прослушивать в этом профиле.

429 Настройка приложения для нескольких окружений
ния разработки; любые изменения, сделанные на этой вкладке, отража-
ются в файле launchSettings.json.
Выберите профиль для редактирования
Настройте команду, запускаемую
профилем при выполнении
Добавьте переменные окружения,
используемые только с этим профилем
Рис. 11.8 Если хотите, то можно использовать Visual Studio для редактирования файла
launchSettings.json. Изменения будут синхронизированы между файлом launchSettings.json
и диалоговым окном «Свойства»
Файл launchSettings.json предназначен только для локальной разра-
ботки; по умолчанию он не развертывается на рабочих серверах. Хотя
это можно сделать, но обычно оно того не стоит. Переменные окруже-
ния – более подходящий вариант.
Еще один последний прием, который я использовал, – это аргументы
командной строки. Например, можно настроить окружение для обкатки
таким образом:
dotnet run --no-launch-profile --environment Staging
Обратите внимание, что вам также необходимо передать --no-launch-
profile при наличии файла launchSettings.json; в  противном случае
прио ритет имеют значения в файле.
На этом мы подошли к концу главы, посвященной конфигурации. Это
не особо увлекательная тема, но конфигурация является неотъемлемой
частью всех приложений. Модель поставщика конфигурации ASP .NET
Core обрабатывает широкий спектр сценариев, позволяя хранить пара-
метры и секреты в различных местах.
Простые настройки можно сохранить в файле appsettings.json, где их
легко изменить во время разработки, и  их можно перезаписать с  по-
мощью файлов JSON для конкретного окружения. Между тем ваши сек -
реты и  конфиденциальные настройки могут храниться за пределами
файла проекта в диспетчере User Secrets или как переменные окружения,
что дает вам и гибкость, и безопасность одновременно – пока вы не за-
писываете свои секреты в файл appsettings.json!
В следующей главе мы кратко рассмотрим новый инструмент объект -
но-реляционного отображения, который хорошо сочетается с  ASP .NET

430 Глава 11 Конфигурирование приложения ASP.NETCore
Core: Entity Framework Core. В этой книге мы только слегка затронем его,
но вы узнаете, как загружать и сохранять данные, создавать базу данных
из своего кода и обновлять ее, по мере того как он будет расти и меняться.
Резюме
Все, что можно считать настройкой или секретом, обычно хранится
как значение конфигурации.
ASP .NET Core использует поставщиков конфигурации для загрузки
пар «ключ-значение» из различных источников. Приложения могут
использовать множество разных поставщиков.
ConfigurationBuilder описывает, как создать окончательное пред-
ставление конфигурации для вашего приложения, а  IConfiguration
содержит сами значения конфигурации.
Вы создаете объект конфигурации, добавляя поставщиков конфигу -
рации к экземпляру ConfigurationBuilder с использованием методов
расширения, таких как AddJsonFile().
HostBuilder создает для вас экземпляр ConfigurationBuilder и вызы-
вает метод Build() для создания экземпляра IConfiguration.
ASP .NET Core включает в себя, среди прочего, встроенные поставщики
для файлов JSON, XML, файлов окружения и  аргументов командной
строки. Для множества других поставщиков, таких как файлы YAML
и Azure Key Vault, существуют готовые Nuget-пакеты.
Важен порядок, в  котором вы добавляете поставщиков в  Configura-
tionBuilder; поставщики, добавленные позже, заменяют значения на-
строек, определенных в предыдущих поставщиках.
Ключи конфигурации не чувствительны к регистру.
Можно получить настройки из IConfiguration напрямую, используя
синтаксис индексатора, например Configuration["MySettings:Value"].
Метод CreateDefaultBuilder настраивает JSON, переменные окруже-
ния, аргументы командной строки и поставщиков User Secrets секре-
тов пользователя за вас. Можно настроить поставщиков конфигура-
ции, используемых в приложении, вызвав ConfigureAppConfiguration.
В промышленном окружении храните секреты в  переменных окру -
жения. Их можно загрузить после файловых настроек в построителе
конфигурации.
На машинах, используемых для разработки, удобнее использовать
User Secrets Manager, нежели переменные окружения. Он хранит сек -
реты в профиле пользователя вашей ОС, за пределами папки проекта.
Имейте в  виду, что ни переменные окружения, ни инструмент User
Secrets Manager не шифруют секреты, они просто хранят их в местах,
которые с  наименьшей вероятностью станут открытыми, поскольку
находятся за пределами папки вашего проекта.
Файловые поставщики, такие как JSON-поставщик, могут автомати-
чески перезагружать значения конфигурации при изменении файла.

431 Резюме
Это позволяет обновлять значения конфигурации в реальном време-
ни, без перезапуска приложения.
Используйте строго типизированные классы параметров POCO для
доступа к конфигурации в приложении.
Используйте метод расширения Configure<T>() в  ConfigureServices
для привязки своих объектов параметров POCO в  ConfigurationSec-
tion.
Можно внедрить интерфейс IOptions<T> в  свои сервисы с  по мощью
внедрения зависимостей. Вы можете получить доступ к строго типи-
зированному объекту параметров свойства Value.
Можно настроить объекты IOptions<T> в коде вместо использования
значений конфигурации, передав лямбда-функцию методу Configu-
re().
Если вы хотите перезагрузить объекты параметров POCO при измене-
нии конфигурации, используйте интерфейс IOptionsSnapshot<T>.
Приложениям, работающим в разных окружениях, окружении разра-
ботки и промышленном окружении, например, часто требуются раз-
ные значения конфигурации.
ASP .NET Core определяет текущее окружение размещения с по мощью
переменной окружения ASPNETCORE_ENVIRONMENT. Если она не задана,
предполагается, что это промышленное окружение.
Можно настроить окружения размещения локально с по мощью файла
launchSettings.json. Это позволяет привязать переменные окружения
к конкретному проекту.
Текущее окружение размещения предоставляется как интерфейс
IHostEnvironment. Вы можете проверить наличие конкретного окру -
жения с  по мощью методов IsDevelopment(), IsStaging() и  IsProduc-
tion().
Можно использовать объект IHostEnvironment для загрузки файлов,
относящихся к  текущему окружению, например appsettings.Produc -
tion.json.

12Cохраняем данные
с Entity Framework	Core
В этой главе:
что такое библиотека Entity Framework Core
и почему нужно ее использовать;
добавление Entity Framework Core в приложение
ASP.NET Core;
построение модели данных и ее использование
для создания базы данных;
запросы, создание и обновление данных
с по мощью Entity Framework Core.
Большинству приложений, которые вы будете создавать с по мощью ASP .
NET Core, нужно будет хранить и загружать данные. Даже для тех приме-
ров, которые применялись до сих пор в этой книге, предполагалось, что
вы используете некое хранилище данных,  чтобы сохранять валютные
курсы, содержимое корзины пользователя и места расположения мага-
зинов.  По большей части я об этом не говорил, но обычно все эти данные
хранятся в базе данных.
Работа с базами данных зачастую может представлять собой довольно
неуклюжий процесс. Вам нужно управлять подключениями к базе дан-
ных, транслировать данные из своего приложения в формат, понятный
базе данных, и решать кучу других нюансов. Можно делать это разными
способами, но я  сосредоточусь на использовании библиотеки, создан-
ной преимущественно для NET Core и .NET 5.0: Entity Framework Core (EF

433 Cохраняем данные с Entity Framework Core
Core). EF Core – это библиотека, позволяющая легко и быстро создавать
код для доступа к базе данных для приложений ASP .NET Core. Она созда-
на по образцу популярной библиотеки Entity Framework 6.x, но содержит
значительные изменения. Это означает, что она стоит особняком сама
по себе, и это больше, чем просто апгрейд.
Цель данной главы – предоставить краткий обзор библиотеки EF Core
и  рассказать, как использовать ее в своих приложениях, чтобы быст ро
выполнять запросы к базе данных и сохранять в ней данные. Вы научи-
тесь подключать свое приложение к базе данных и управлять изменени-
ями схемы базы данных, но я не буду рассматривать ни одну из этих тем
подробно.
ПРИМЕЧАНИЕ  Для более подробного знакомства с EF Core я ре-
комендую книгу «Entity Framework	 Core	в действии», 2-е изд., Джона
П. Смита (Manning, 2021). Кроме того, вы можете прочитать о биб-
лиотеке EF Core и ее двоюродном брате, Entity Framework, на стра-
нице https://docs.microsoft.com/ef/core/.
Раздел 12.1 знакомит вас с библиотекой EF Core и объясняет, почему
вы, возможно, захотите использовать ее в своих приложениях. Вы узнае-
те, как дизайн EF Core помогает быстро обработать структуру базы дан-
ных и уменьшить неприятные моменты при взаимодействии с ней.
В разделе 12.2 вы узнаете, как добавить EF Core в приложение ASP .NET
Core и сконфигурировать ее с по мощью системы конфигурации ASP .NET
Core. Вы увидите, как создать модель для своего приложения, представ-
ляющую данные, которые вы будете хранить в базе данных, и как под-
ключить ее к контейнеру внедрения зависимостей ASP .NET Core.
ПРИМЕЧАНИЕ  В этой и остальной части книги я буду использо-
вать LocalDB – урезанную версию SQL Server. LocalDB устанавлива-
ется как часть Visual Studio 2019 (когда вы выбираете рабочую на-
грузку ASP .NET and Web Development) и предоставляет легковесное
ядро SQL Server1. Очень небольшая часть кода специфична для SQL
Server, поэтому вы сможете следовать примерам, используя дру -
гую базу данных, если хотите. Пример кода к этой книге включает
в себя версию, использующую, например, SQLite.
Независимо от того, насколько тщательно вы проектируете исходную
модель данных, придет время, когда вам нужно будет ее изменить. В раз-
деле 12.3 я покажу, как с легкостью обновить свою модель и применить
эти изменения к самой базе данных. При этом всю тяжелую работу за вас
будет делать EF Core.
После конфигурирования EF Core и  создания базы данных в  разде-
ле 12.4 показано, как использовать библиотеку в коде приложения. Вы
1 Подробнее о  LocalDB можно узнать из документации Microsoft на странице
http://mng.b z/5jEa.

434 Глава 12 Cохраняем данные с Entity Framework Core
увидите, как создавать, читать, обновлять и  удалять записи, а  также
узнае те о паттернах, которые следует использовать при проектировании
доступа к данным.
В разделе 12.5 я  выделю несколько вопросов, которые следует учи-
тывать при использовании EF Core в рабочем приложении. Одна-един-
ственная глава, посвященная EF Core, может предложить только краткое
знакомство со всеми связанными с этой темой концепциями, поэтому
если вы решите использовать EF Core в собственных приложениях, осо-
бенно если вы впервые применяете такую библиотеку доступа к данным,
то настоятельно рекомендую прочитать дополнительную литературу,
когда вы освоите основы, приведенные в этой главе.
Прежде чем перейти к коду, посмотрим, что такое EF Core, какие проб-
лемы он решает и когда вы, возможно, захотите использовать этот ин-
струмент.
12.1 Знакомство с Entity Framework Core
Код доступа к базе данных присутствует во всех веб-приложениях. Соз-
даете ли вы приложение для электронной торговли, блог или очередной
технологический прорыв, скорее всего, вам потребуется взаимодейство-
вать с базой данных.
К сожалению, взаимодействие с базами данных из кода приложения
часто оказывается запутанным делом, и можно использовать множество
различных подходов. Например, такая простая задача, как чтение дан-
ных из базы данных, требует работы с  сетевыми подключениями, на-
писания операторов SQL и обработки данных результатов. В экосистеме
.NET есть целый ряд библиотек, которые можно использовать для этого,
начиная от низкоуровневых библиотек ADO.NET и заканчивая высоко-
уровневой абстракцией, такой как EF Core.
В этом разделе описано, что такое EF Core и какие проблемы эта биб-
лиотека призвана решать. Я расскажу о мотивации, побуждающей к ис -
пользованию такой абстракции, как EF Core, и о том, как она помогает
преодолеть разрыв между кодом вашего приложения и  базой данных.
В рамках этого рассказа я представляю некоторые компромиссы, на ко-
торые вы можете пойти, используя ее в своих приложениях. Это долж -
но помочь вам решить, подходит ли она вам. Наконец, мы рассмотрим
пример отображения из кода приложения в базу данных, чтобы понять
основные концепции EF Core.
12.1.1 Что такое EF Core?
EF Core – это библиотека, предоставляющая объектно-ориентированный
способ доступа к базам данных. Она действует как инструмент объект -
но-реляционного отображения (ORM), взаимодействуя с базой данных
и отображая ответы базы данных в классы и объекты .NET, как показано
на рис. 12.1.

435 Знакомство с Entity Framework Core
Приложение .NETКлассы .NET отображаются
в таблицы, а свойства –
в столбцы
Ссылки между типами
отображаются в связи
по внешнему ключу между
таблицами
Каждый объект (экземпляр
класса) отображается
в строку в таблицеКласс Products
Класс CategoryПродукты
ПродуктыПродуктыКатегорииБаза данных
Рис. 12.1 EF Core отображает классы и объекты .NET в таблицы и строки базы данных
ОПРЕДЕЛЕНИЕ  С  помощью инструмента объектно-реляцион-
ного отображения можно управлять базой данных, используя кон-
цепции объектно-ориентированного программирования, такие
как классы и объекты, путем отображения их в таблицы и столбцы
базы данных.
Библиотека EF Core основана на существующих библиотеках Entity
Framework (в настоящее время до версии 6.x). Она была создана как часть
.NET Core для кросс-платформенной работы, но с учетом дополнитель-
ных целей. В частности, команда EF Core хотела создать высокопроизво-
дительную библиотеку, которую можно было бы использовать при рабо-
те с широким спектром баз данных.
Существует множество различных типов баз данных, но, вероятно,
наиболее часто используемым семейством являются реляционные базы
данных, доступ к которым осуществляется с по мощью языка структури-
рованных запросов (SQL). Это основа EF Core – библиотека может рабо-
тать с Microsoft SQL Server, MySQL, Postgres и многими другими реляци-
онными базами данных. У нее даже есть отличная функция, InMemory
Provider, которую можно использовать при тестировании для создания
временной базы данных. EF Core использует модель провайдера, поэто-
му поддержку других реляционных баз данных можно будет подключить
позже, когда они станут доступны.
ПРИМЕЧАНИЕ  Начиная с .NET Core 3.0, EF Core теперь также ра-
ботает с  нереляционными, NoSQL или документоориентированны-

436 Глава 12 Cохраняем данные с Entity Framework Core
ми базами данных, такими как Cosmos DB. Однако в  этой книге
я  буду рассматривать отображение только в  реляционные базы
данных, поскольку это наиболее распространенный вариант по
моему опыту. Исторически сложилось так, что бóльшая часть до-
ступа к данным, особенно в экосистеме .NET, осуществлялась с ис -
пользованием реляционных баз данных, поэтому в целом это по-
прежнему наиболее популярный подход.
Это объясняет, что такое EF Core, но не отвечает на вопрос, для чего
нужно использовать эту библиотеку. Почему бы не получать доступ
к  базе данных напрямую с  по мощью традиционных библиотек ADO.
NET? Большинство аргументов в пользу использования EF Core можно
применить к ORM в целом. Так каковы же ее преимущества?
12.1.2 Зачем использовать инструмент
объектно-реляционного отображения?
Одно из самых больших преимуществ ORM – это скорость, с которой вы
можете разрабатывать приложение. Вы можете оставаться на знакомой
территории объектно-ориентированного .NET, часто даже без необхо-
димости напрямую управлять базой данных или писать собственный
SQL-код.
Представьте, что у вас есть сайт для онлайн-торговли и вы хотите за-
грузить подробную информацию о продукте из базы данных. Используя
низкоуровневый код доступа к базе данных, вам нужно будет открыть
соединение с базой данных, написать необходимый SQL-код, используя
правильные имена таблиц и  столбцов, прочитать данные по соедине-
нию, создать POCO-объект для хранения данных и вручную задать свой-
ства объекта, конвертируя данные в правильный формат по мере необ-
ходимости. Звучит неудобно, не правда ли?
Такой инструмент объектно-реляционного отображения, как EF Core,
позаботится об этом за вас. Он обрабатывает соединение с базой данных,
генерирует SQL-код и отображает данные на объекты POCO. Все, что вам
нужно предоставить, – это LINQ-запрос, описывающий данные, которые
вы хотите получить.
Инструменты объектно-реляционного отображения служат высоко-
уровневыми абстракциями по отношению к базам данных, поэтому они
могут значительно сократить объем связующего кода, который необхо-
димо написать для взаимодействия с базой данных. На самом базовом
уровне они заботятся об отображении SQL-операторов в объекты и на-
оборот, но большинство из них идут еще дальше и  предоставляют до-
полнительные функции.
Такие ORM-инструменты, как EF Core, отслеживают, какие свойства
были изменены для объектов, которые они получают из базы данных. Это
позволяет загружать объект из базы данных, отображая его из таб  лицы
базы данных, изменить его в коде .NET, а затем попросить ORM-инст ру-
мент обновить ассоциированную запись в базе данных. Он определит,

437 Знакомство с Entity Framework Core
какие свойства изменились, и предоставит операторы обновления для
соответствующих столбцов, сэкономив вам кучу работы.
Как это часто бывает при разработке программного обеспечения, ис -
пользование такого рода инструментов имеет свои недостатки. Одно из
самых больших преимуществ ORM-инструментов (это также их ахил-
лесова пята) – они скрывают от вас базу данных. Иногда такой высо-
кий уровень абстракции может привести к возникновению проблемных
шаблонов запросов к базе данных в ваших приложениях. Классический
пример – проблема N + 1, когда один запрос к базе данных превраща-
ется в отдельные запросы для каждой отдельной строки в таблице базы
данных.
Еще один часто упоминаемый недостаток  – производительность.
ORM-инструменты – это абстракции нескольких концепций, поэтому по
своей сути они выполняют больше работы, чем если бы вы вручную соз-
давали каждую часть доступа к данным в своем приложении. Большин-
ство ORM-инструментов, включая EF Core, жертвуют производительно-
стью ради простоты разработки.
Тем не менее если вы знаете об этих подводных камнях, то нередко
можете значительно упростить код, необходимый для взаимодействия
с базой данных. Как и во всех остальных ситуациях, если абстракция вам
подходит, используйте ее, в  противном случае не делайте этого. Если
у вас минимальные требования к доступу к базе данных или вам нужна
максимальная производительность, то возможно, что такой вариант, как
EF Core, вам не подойдет.
Альтернативный способ – получить лучшее из обоих миров: исполь-
зовать ORM-инструмент для быстрой разработки основной части своего
приложения, а затем вернуться к низкоуровневым API, таким как ADO.
NET, для тех немногих областей, которые оказываются проблемными
местами в приложении.
Таким образом, можно получить достаточно хорошую производитель-
ность, используя EF Core и жертвуя производительностью ради времени
разработки, оптимизируя только те области, которые в этом нуждаются.
Даже если вы решите применять ORM-инструмент в  своем прило-
жении, для .NET доступно множество различных вариантов, одним из
которых является EF Core. Подходит ли он вам, будет зависеть от необ-
ходимых вам функций и  компромиссов, на которые вы готовы пойти,
чтобы их получить. В следующем разделе EF Core сравнивается с другим
предложением от компании Microsoft, Entity Framework, но есть много
иных альтернатив, которые можно рассмотреть, например Dapper и NHi-
bernate. У каждой из них есть свой набор компромиссов.
12.1.3 Когда следует выбирать EF Core?
Компания Microsoft разработала EF Core как переосмысление зрелой
технологии Entity Framework 6.x (EF 6.x), появившейся в 2008 году. После
десяти лет разработки EF 6.x представляет собой стабильное и  много-
функциональное средство объектно-реляционного отображения.

438 Глава 12 Cохраняем данные с Entity Framework Core
Напротив, EF Core  – сравнительно	 новый проект. API-интерфейсы
EF Core спроектированы так, чтобы быть близкими к API-интерфейсам
EF 6.x – хотя они и не идентичны, но основные компоненты были полно-
стью переписаны. Следует рассматривать EF Core как нечто, отличное от
EF 6.x.
Microsoft поддерживает как EF Core, так и EF 6.x. Оба инструмента бу -
дут постоянно улучшаться, так что же выбрать? Необходимо учесть не-
сколько вещей:
кросс-платформенность – EF Core 5.0 нацелен на .NET Standard, по-
этому его можно использовать в  кросс-платформенных приложе-
ниях, нацеленных на .NET Core 3.0 или более поздние версии. На-
чиная с  версии 6.3, EF 6.x также является кросс-платформенным,
с  некоторыми ограничениями при работе в  .NET 5.0, такими как
отсутствие поддержки проектировщиков;
провайдеры	 баз	данных – EF 6.x и EF Core позволяют подключаться
к различным типам баз данных с по мощью подключаемых провай-
деров. Число провайдеров EF Core растет, но в случае с EF 6.x их не
так много, особенно если вы хотите запустить EF 6.x на .NET 5.0.
Если для используемой вами базы данных нет провайдера, это мо-
жет стать серьезной проблемой!
производительность – 	производительность EF 6.x была своего рода
черной меткой в    его послужном списке, поэтому EF Core стремится
исправить это. EF Core разработан, чтобы быть быстрым и легковес -
ным, значительно превосходя EF 6.x. Но вряд ли когда-либо удастся
достичь производительности более легковесного ORM-инструмента,
такого как Dapper, или SQL-операторов, написанных вручную;
функции – именно в функциях вы обнаружите наибольшее разли-
чие между EF 6.x и EF Core, хотя в случае с EF Core 5.0 эта разница
меньше, чем когда-либо прежде. У EF Core теперь имеется мно  жест -
во функций, которых нет в EF 6.x (операторы пакетной обработки,
генерация ключей на стороне клиента, база данных в памяти для
тестирования). В  EF Core по-прежнему отсутствуют некоторые
функции по сравнению с EF 6.x, такие как отображение хранимых
процедур и подход Table-Per-Concrete-Type (TPC), но поскольку EF
Core находится в  стадии активной разработки, эти функции сто-
ят в очереди на реализацию1. Напротив, EF 6.x, скорее всего, ждут
только дополнительные улучшения и  исправления ошибок, но не
су щест венное добавление функций.
Являются ли эти компромиссы и  ограничения проблемой для вас,
будет во многом зависеть от конкретного приложения. Помня об этих
ограничениях, гораздо проще начать новое приложение, чем пытаться
обойти их позже.
1 Подробный список различий функций EF 6.x и EF Core можно найти на стра-
нице http://mng.bz/GxgA .

439 Знакомство с Entity Framework Core
СОВЕТ  EF Core подходит не везде, но рекомендуется использо-
вать его вместо EF 6.x для новых приложений. Убедитесь, что вы
понимаете возможные компромиссы, и следите за рекомендация-
ми от команды EF на странице https://docs.microsoft.com/ef/efcore-
and-ef6.
Если вы работаете над новым приложением ASP .NET Core, хотите ис -
пользовать ORM-инструмент для быстрой разработки и вам не требуют -
ся какие-либо недоступные функции, тогда EF Core – отличный канди-
дат. Он также поддерживается различными другими подсистемами ASP .
NET Core. Например, в  главе 14 вы увидите, как использовать EF Core
с системой проверки аутентификации ASP .NET Core Identity для управ-
ления пользователями в приложениях.
Прежде чем углубиться в подробности применения EF Core, я опишу
приложение, которое мы будем использовать в  качестве примера для
этой главы. Мы рассмотрим детали приложения и базы данных, а также
как использовать EF Core для обмена данных.
12.1.4 Отображение базы данных в код приложения
EF Core фокусируется на обмене данными между приложением и базой
данных, поэтому, чтобы продемонстрировать это, нам нужно приложе-
ние. В этой главе в качестве примера используется простое кулинарное
приложение, в котором перечислены рецепты и которое позволяет про-
сматривать ингредиенты рецепта, как показано на рис. 12.2. Пользова-
тели могут просматривать рецепты, добавлять новые, редактировать их
и удалять старые.
Очевидно, что это простое приложение, но оно содержит все необхо-
димые вам взаимодействия между базой данных и двумя его	 сущностя-
ми: Recipe и Ingredient.
ОПРЕДЕЛЕНИЕ  Сущность  – это класс .NET, отображаемый EF
Core в базу данных. Это классы, которые вы определяете обычно
как классы POCO, которые можно сохранять и  загружать путем
отображения в таблицы базы данных с по мощью EF Core.
При взаимодействии с  EF Core вы в  основном будете использовать
сущности POCO и  контекст	 базы	данных, производный от класса EF Core,
DbContext. Классы сущностей  – это объектно-ориентированные пред-
ставления таблиц в базе данных; они представляют данные, которые вы
хотите сохранить в базе данных. Класс DbContext используется в прило-
жении как для конфигурирования EF Core, так и для доступа к базе дан-
ных во время выполнения.
ПРИМЕЧАНИЕ   Потенциально можно иметь несколько классов
DbContext в  своем приложении и даже можно сконфигурировать
их для интеграции с различными базами данных.

440 Глава 12 Cохраняем данные с Entity Framework Core
Нажмите View, чтобы открыть страницу с подробными
сведениями о рецепте. На ней приведены
ингредиенты, связанные с этим рецептом
На главной странице приложения
отображается список всех текущих рецептов
Нажмите Create, чтобы добавить
в приложение новый рецепт Вы также можете отредактировать
или удалить рецепт
Рис. 12.2 В кулинарном приложении перечислены рецепты. Вы можете
просматривать, обновлять и удалять их или создавать новые
Когда ваше приложение впервые использует EF Core, EF Core созда-
ет внутреннее представление базы данных на основе свойств DbSet<T>
класса DbContext вашего приложения и самих классов сущностей, как по-
казано на рис. 12.3.
Для нашего приложения с рецептами EF Core создаст модель класса
Re cipe, поскольку она представлена в классе AppDbContext как DbSet<Re-
cipe>. Кроме того, EF Core будет перебирать все свойства Recipe, искать
типы, о которых не знает, и добавлять их в свою внутреннюю модель.
В  нашем приложении коллекция Ingredients в  Recipe предоставляет
сущность Ingredient как ICollection<Ingredient>, поэтому EF Core мо-
делирует сущность соответствующим образом.
Каждая сущность отображается в таблице в базе данных, но EF Core так -
же отображает связи между сущностями. В каждом рецепте может быть
много ингредиентов, но каждый ингредиент (у которого есть имя, коли-
чест во и единица измерения) принадлежит одному рецепту, поэтому такой
тип связи называется «многие к одному». EF Core использует эти сведения
для правильного моделирования эквивалентной структуры базы данных.
ПРИМЕЧАНИЕ  Два разных рецепта, скажем рыбный пирог и ку -
рица с лимоном, могут использовать ингредиент с одинаковым на-
званием и количеством, например сок одного лимона, но, по сути,
это два разных экземпляра. Если вы обновите рецепт курицы с ли-
моном, чтобы использовать два лимона, вы не захотите, чтобы это
изменение автоматически привело к обновлению рецепта рыбно-
го пирога, чтобы в нем тоже использовались два лимона!

441 Добавляем EF Core в приложение
DbContext приложения служит точкой входа
для всех взаимодействий с EF Core
1.  EF Core ищет все свойства DbSet
в DbContext (Recipes) и добавляет их
в свою внутреннюю модель
2.  Она сканирует все свойства
известных сущностей
на наличие связанных типов
и добавляет их в свою
внутреннюю модель
3.  EF Core использует связи
между классами .NET, чтобы
моделировать связи между
таблицами базы данныхВнутренняя
модель EF
Ingredients IngredientRecipes RecipeAddDbContext Приложение .NET
Рис. 12.3 EF Core создает внутреннюю модель модели данных вашего приложения,
исследуя типы в вашем коде. Она добавляет все типы, указанные в свойствах
DbSet<T> класса DbContext, и все связанные типы
EF Core использует внутреннюю модель, которую создает при взаи-
модействии с базой данных. Это гарантирует построение правильного
SQL-кода для создания, чтения, обновления и удаления сущностей.
Хорошо, пора писать код! В следующем разделе вы приступите к соз-
данию приложения с  рецептами. Вы увидите, как добавить EF Core
в приложение ASP .NET Core, сконфигурировать провайдер базы данных
и спроектировать модель данных вашего приложения.
12.2 Добавляем EF Core в приложение
В этом разделе мы сосредоточимся на установке и  настройке EF Core
в приложении рецептов. Вы узнаете, как установить необходимые паке-
ты NuGet и как создать модель данных для своего приложения. Посколь-
ку в этой главе мы говорим об EF Core, я не буду вдаваться в подробности
создания приложения в целом – в качестве основы я создал простое при-
ложение Razor Pages.
ПОДСКАЗКА  Образец кода для этой главы показывает состояние
приложения на трех разных этапах: в конце раздела 12.2, в конце
раздела 12.3 и в конце главы. Он также включает в себя примеры
с использованием провайдеров LocalDB и SQLite.

442 Глава 12 Cохраняем данные с Entity Framework Core
Взаимодействие с EF Core в приложении, использующееся в качестве
примера, происходит на уровне сервисов, который инкапсулирует весь
доступ к данным за пределами фреймворка Razor Pages, как показано на
рис. 12.4. Это позволяет разделить задачи и сделать сервисы доступными
для тестирования.
1. Получен запрос на URL-адрес /recipes
2.  Запрос маршрутизируется на страницу
Razor Page, Recipes/Index.cshtml
3.  Обработчик страницы вызывает
RecipeService для получения списка
моделей RecipeSummary4.  RecipeService вызывает EF Core
для загрузки рецептов из базы данных
и использует их для создания списка
RecipeSummary
5.  PageModel предоставляет список
RecipeSummary, возвращенный
RecipeService для использования
представлением с целью отрисовки
HTMLЗапрос
Промежуточное ПО
маршрутизации
Обработчик страницы
Модель данных
Представление
HTMLRecipeSummaryEF Core
DBIndexModelRecipeService
Рис. 12.4 Обработка запроса путем загрузки данных из базы данных с по мощью EF Core.
Взаимодействие с EF Core ограничено только RecipeService – страница Razor не обращается
к EF Core напрямую
Процесс добавления EF Core в  приложение состоит из нескольких
этапов.
1  Выбрать провайдера базы данных, например Postgres, SQLite или
MS SQL Server.
2 Установить пакеты NuGet для EF Core.
3  Спроектировать класс DbContext своего приложения и  сущности,
составляющие модель данных.
4  Зарегистрировать этот класс в  контейнере внедрения зависимо-
стей ASP .NET Core.
5  Использовать EF Core для создания миграции, описывающей вашу
модель данных.
6  Применить миграцию к базе данных, чтобы обновить схему базы
данных.
Это уже может показаться вам немного сложным, но мы рассмотрим
шаги 1–4 в этом разделе и шаги 5–6 в разделе 12.3, поэтому это не зай-
мет много времени. Учитывая ограниченное пространство данной гла-

443 Добавляем EF Core в приложение
вы, я  буду придерживаться соглашений EF Core по умолчанию в  коде,
который показываю. EF Core – гораздо более настраиваемая библиотека,
чем может показаться на первый взгляд, но я рекомендую вам по воз-
можности придерживаться значений по умолчанию. В конечном итоге
это облегчит вам жизнь.
Первый шаг в настройке EF Core – решить, с какой базой данных вы
хотите взаимодействовать. Вполне вероятно, что это будет продиктова-
но клиентом или политикой вашей компании, но все же стоит подумать
о выборе.
12.2.1 Выбор провайдера базы данных и установка EF Core
EF Core поддерживает ряд баз данных с по мощью модели провайдера.
Модульная природа EF Core означает, что вы можете использовать один
и тот же высокоуровневый API для программирования с различными ба-
зами данных, а EF Core знает, как сгенерировать необходимый код, за-
висящий от реализации, и операторы SQL.
Вероятно, у вас уже есть на примете база данных, когда вы запускае-
те свое приложение, и вам будет приятно узнать, что EF Core работает
с большинством популярных баз данных.
Добавление поддержки базы данных включает в себя добавление пра-
вильного пакета NuGet в  файл с расширением .csproj. Например:
PostgreSQL – Npgsql.EntityFrameworkCore.PostgreSQL;
Microsoft	SQL	Server – Microsoft.EntityFrameworkCore.SqlServer;
MySQL – MySql.Data.EntityFrameworkCore;
SQLite – Microsoft.EntityFrameworkCore.SQLite.
Компания Microsoft занимается сопровождением некоторых пакетов
провайдеров баз данных, часть из них сопровождается сообществом раз-
работчиков ПО с открытым исходным кодом, а для каких-то пакетов мо-
жет потребоваться платная лицензия (например, для провайдера Oracle),
поэтому обязательно проверьте свои требования. Список провайдеров
можно найти на странице https://docs.microsoft.com/ef/core/providers.
Провайдер базы данных устанавливается в  приложение так же, как
и любая другая библиотека: путем добавления пакета NuGet в файл с рас -
ширением .csproj из вашего проекта и запуска команды dotnet restore из
командной строки (или можно позволить Visual Studio выполнить вос -
становление автоматически).
EF Core по своей сути является модульной библиотекой, поэтому вам
потребуется установить несколько пакетов. Я  использую провайдера
базы данных SQL Server с LocalDB для приложения с рецептами, поэтому
буду применять пакеты SQL Server:
Microsoft.EntityFrameworkCore.SqlServer – это основной пакет провай-
дера базы данных для использования EF Core во время выполнения.
Он также содержит ссылку на основной пакет EF Core NuGet;
Microsoft.EntityFrameworkCore.Design – содержит совместно исполь-
зуемые компоненты времени проектирования для EF Core.

444 Глава 12 Cохраняем данные с Entity Framework Core
СОВЕТ  Вам также понадобится установить инструменты команд-
ной строки, которые помогут вам создавать и обновлять базу дан-
ных. Я покажу, как их установить, в разделе 12.3.1.
В листинге 12.1 показан файл приложения с рецептами с расширени-
ем .csproj после добавления пакетов EF Core. Помните, что вы добавляете
пакеты NuGet как элементы PackageReference.
Листинг 12.1 Установка EF Core в приложение ASP.NET Core
<Project Sdk="Microsoft.NET.Sdk.Web">
<PropertyGroup>
<TargetFramework>net5.0</TargetFramework>
</PropertyGroup>
<ItemGroup>
<PackageReference
Include="Microsoft.EntityFrameworkCore.SqlServer"
Version="5.0.0" />
<PackageReference
Include="Microsoft.EntityFrameworkCore.Design"
Version="5.0.0" />
</ItemGroup>
</Project>
После установки и восстановления этих пакетов у вас есть все необхо-
димое, чтобы приступить к созданию модели данных для вашего прило-
жения. В следующем разделе мы создадим классы сущностей и  DbContext
для приложения с рецептами.
12.2.2 Создание модели данных
В разделе 12.1.4 я привел обзор того, как EF Core создает внутреннюю
модель базы данных из класса DbContext и моделей сущностей. Помимо
этого механизма обнаружения, EF Core – довольно гибкая библиотека,
позволяющая определять сущности так, как вы хотите, как классы POCO.
Некоторые инструменты объектно-реляционного отображения требу -
ют, чтобы ваши сущности наследовали от определенного базового класса,
или вы должны декорировать свои модели атрибутами, чтобы описать,
как их отображать. EF Core в значительной степени отдает предпочтение
подходу с использованием соглашений, а не конфигурации, как видно
в этом листинге. В нем показаны классы сущностей Recipe и  Ingredient
вашего приложения.
Листинг 12.2 Определение классов сущностей EF Core
public class Recipe
{
public int RecipeId { get; set; }Приложение предназначено
для .NET 5.0.
Установите соответствующий
пакет NuGet для выбранной
# БД.
Содержит совместно
используемые компоненты
времени проектирования
для EF Core.

445 Добавляем EF Core в приложение
public string Name { get; set; }
public TimeSpan TimeToCook { get; set; }
public bool IsDeleted { get; set; }
public string Method { get; set; }
public ICollection<Ingredient> Ingredients { get; set; }
}
public class Ingredient
{
public int IngredientId { get; set; }
public int RecipeId { get; set; }
public string Name { get; set; }
public decimal Quantity { get; set; }
public string Unit { get; set; }
}
Эти классы соответствуют определенным соглашениям по умолча-
нию, которые EF Core использует для создания картины отображаемой
базы данных. Например, у класса Recipe есть свойство RecipeId, а у клас -
са Ingredient – свойство IngredientId. EF Core определяет этот шаблон
суффикса Id как указание на первичный ключ таблицы.
ОПРЕДЕЛЕНИЕ  Первичный ключ таблицы  – это значение, ко-
торое однозначно идентифицирует строку среди всех остальных
в таблице. Часто это int или Guid.
Еще одно соглашение, которое мы видим здесь, – это свойство RecipeId
класса Ingredient. EF Core интерпретирует его как внешний	 ключ, указы-
вающий на класс Recipe. В сочетании с  ICollection<Ingredient> в клас -
се Recipe это представляет связь типа «многие к одному», где у каждого
рецепта имеется множество ингредиентов, но каждый ингредиент при-
надлежит только одному рецепту, как показано на рис. 12.5.
Объект Recipe может иметь много
ингредиентов, обозначенных
ICollection <Ingredient>
Каждый ингредиент принадлежит одному рецепту,
на что указывает свойство RecipeId в Ingredient
Связь «многие к одному»
между объектами соответствует
связи по внешнему ключу
между таблицами базы данныхRecipeIngredient Ingredient
Resipes Ingredients
Рис. 12.5 Связь типа «многие к одному» в коде преобразуется в связь по внешнему
ключу между таблицамиВ классе Recipe может быть
множество ингредиентов,
представленных ICollection.

446 Глава 12 Cохраняем данные с Entity Framework Core
ОПРЕДЕЛЕНИЕ  Внешний	 ключ в  таблице указывает на первич-
ный ключ другой таблицы, образуя связь между двумя строками.
Здесь задействованы и многие другие соглашения, такие как имена,
которые EF Core будет использовать для таблиц и столбцов базы данных,
или типы столбцов базы данных, которые будут использоваться для каж -
дого свойства, но я не буду обсуждать их здесь. В документации по EF
Core содержится подробная информация обо всех соглашениях, а также
о том, как настроить их для своего приложения: https://docs.microsoft.
com/ef/core/modeling/.
Вы также можете использовать атрибуты DataAnnotations для декори-
рования классов сущностей, управляя такими вещами, как именование
столбцов или длина строки. EF Core будет использовать эти атрибуты,
чтобы переопределить соглашения по умолчанию.
Помимо сущностей, вы также определяете класс DbContext. Это серд-
це вашего приложения, используемое для всех вызовов к базе данных.
Создайте собственный класс DbContext, в  данном случае это AppDbCon-
text, и наследуйте его от базового класса DbContext, как показано ниже.
Он предоставляет DbSet<Recipe>, позволяющий EF Core обнаружить
и отобра зить сущность Recipe. Таким образом вы можете предоставить
несколько экземпляров DbSet<> для каждой из сущностей верхнего уров-
ня своего приложения.
Листинг 12.3 Определение класса DbContext
public class AppDbContext : DbContext
{
public AppDbContext(DbContextOptions<AppDbContext> options)
: base(options) { }
public DbSet<Recipe> Recipes { get; set; }
}
AppDbContext  – это простой класс, который содержит список ваших
корневых сущностей, но вы можете делать с ним гораздо больше вещей
в более сложном приложении. При желании можно полностью настроить
способ отображения сущностей в базу данных, но для этого приложения
мы будем использовать значения по умолчанию.
ПРИМЕЧАНИЕ  Мы не указали класс Ingredient в  классе AppDb-
Context, но он будет смоделирован EF Core, как он предоставляется
в Recipe. Вы по-прежнему можете получить доступ к объектам In-
gredient в базе данных, но для этого нужно использовать свойство
Ingredients сущности Recipe, как будет показано в разделе 12.4.
В этом простом примере ваша модель данных состоит из трех классов:
AppDbContext, Recipe и  Ingredient. Эти две сущности будут отображены
в таблицы, а  их столбцы – в  свойства, и  вы будете использовать класс
App DbContext для доступа к ним.Объект параметров
конструктора, содержащий
такие сведения, как строка
подключения.Вы будете использовать свойство Recipes
для выполнения запроса к базе данных.

447 Добавляем EF Core в приложение
ПРИМЕЧАНИЕ  Это типичный подход Code-first (сначала код), но
если у вас есть действующая база данных, можно автоматически
сгенерировать сущности EF и класса DbContext. (Более подробную
информацию можно найти в  статье Microsoft «Реверс-инжини-
ринг» на странице http://mng.bz/mgd4.)
Модель данных завершена, но мы еще не совсем готовы ее использо-
вать. Ваше приложение не знает, как создать AppDbContext, а  AppDbCon-
text нужна строка подключения, чтобы можно было взаимодействовать
с базой данных. В следующем разделе мы рассмотрим обе эти проблемы
и закончим настройку EF Core в приложении.
12.2.3 Регистрация контекста данных
Как и в случае с любым другим сервисом в ASP .Net Core, нужно зарегист -
рировать AppDbContext в контейнере внедрения зависимостей. При реги-
страции контекста вы также конфигурируете провайдера базы данных
и задаете строку подключения, чтобы EF Core знала, как взаимодейство-
вать с базой данных.
AppDbContext регистрируется в методе ConfigureServices файла Start -
up.cs. EF Core предоставляет для этой цели обобщенный метод расши-
рения AddDbContext<T>, который принимает функцию конфигурации для
экземпляра DbContextOptionsBuilder. Этот конструктор можно использо-
вать, чтобы задать множество внутренних свойств EF Core. При желании
он позволяет полностью заменить внутренние сервисы EF Core.
Конфигурация вашего приложения, опять же, простая и удобная, как
видно из следующего листинга. Вы задаете провайдера базы данных с по-
мощью метода расширения UseSqlServer, доступного из пакета Micro soft.
EntityFrameworkCore.SqlServer, и передаете ему строку подключения.
Листинг 12.4  Регистрация DbContext в контейнере внедрения
зависимостей
public void ConfigureServices(IServiceCollection services)
{
var connString = Configuration
.GetConnectionString("DefaultConnection");
services.AddDbContext<AppDbContext>(
options => options.UseSqlServer(connString));
// Добавляем другие сервисы;
}
ПРИМЕЧАНИЕ  Если вы используете другого провайдера базы
данных, например провайдера для SQLite, то вам нужно будет вы-
звать соответствующий метод Use* объекта options при регистра-
ции AppDbContext.Строка подключения берется
из конфигурации, из раздела
ConnectionStrings.
Регистрируем DbContext,
используя его в качестве
обобщенного параметра. Указываем провайдера базы данных
в параметрах настройки для DbContext.

448 Глава 12 Cохраняем данные с Entity Framework Core
Строка подключения является типичным секретом, как мы уже обсуж -
дали в предыдущей главе, поэтому загрузка ее из конфигурации имеет
смысл. Во время выполнения будет использоваться правильная строка
конфигурации для вашего текущего окружения, поэтому вы можете ис -
пользовать разные базы данных при локальной разработке или в про-
мышленном окружении.
ПОДСКАЗКА  Можно настроить AppDbContext другими способами
и предоставить строку подключения, например, с по мощью мето-
да OnConfiguring, но я рекомендую способ, показанный здесь для
веб-сайтов ASP .NET Core.
Теперь у вас есть DbContext, AppDbContext, зарегистрированный в кон-
тейнере внедрения зависимостей, и  модель данных, соответствующая
вашей базе данных. Вы готовы приступить к использованию EF Core, но
единственное, чего у вас нет, – это базы данных! В следующем разделе
вы увидите, как с легкостью можно использовать интерфейс командной
строки .NET, чтобы гарантировать актуальность своей базы данных с по-
мощью модели данных EF Core.
12.3 Управление изменениями
с помощью миграций
В этом разделе вы узнаете, как с по мощью миграций генерировать SQL-
код, чтобы синхронизировать схему базы данных с моделью данных при-
ложения. Вы узнаете, как создать начальную миграцию и использовать
ее для разработки базы данных. Затем вы обновите свою модель данных,
создадите вторую миграцию и воспользуетесь ею для обновления схемы
базы данных.
Известно, что управление изменениями схемы	 баз данных, например
когда вам нужно добавить новую таблицу или новый столбец, является
сложной задачей. Код вашего приложения явно привязан к конкретной
версии базы данных, и нужно убедиться, что они всегда синхронизиро-
ваны.
ОПРЕДЕЛЕНИЕ  Схема – это способ организации данных в базе
данных, в том числе таблиц, столбцов и связей между ними.
При развертывании приложения вы обычно можете удалить старый
код или исполняемый файл и заменить его новым кодом – работа сдела-
на. Если вам нужно отменить изменение, удалите новый код и разверни-
те старую версию приложения.
Сложность с базами данных состоит в том, что они содержат данные!
Это означает, что невозможно пренебречь этим, создавая новую базу
данных при каждом развертывании.

449 Управление изменениями с помощью миграций
Существует общепринятая передовая практика, которая состоит
в том, чтобы явно версионировать схему базы данных наряду с кодом
приложения. Это можно сделать несколькими способами, но обычно
нужно сохранить разницу между предыдущей схемой и  новой, часто
в виде SQL-скрипта. Затем можно использовать такие библиотеки, как
DbUp и  FluentMigrator1, чтобы отслеживать, какие скрипты были при-
менены, и обеспечивать актуальность схемы своей базы данных. Кроме
того, можно использовать внешние инструменты, чтобы они делали это
за вас.
EF Core предоставляет собственную версию управления схемой, кото-
рую называют миграциями. Миграции позволяют управлять изменения-
ми схемы базы данных при изменении модели данных EF Core. Мигра-
ция – это файл с кодом C# в вашем приложении, который определяет,
как изменилась модель данных – какие столбцы были добавлены, новые
сущности и т. д. Миграции обеспечивают запись того, как развивалась
схема вашей базы данных, будучи частью вашего приложения, поэтому
схема всегда синхронизируется с моделью данных приложения.
Можно использовать инструменты командной строки, чтобы создать
новую базу данных из миграций или обновить существующую базу дан-
ных, применив к ней новые миграции. Вы даже можете откатить мигра-
цию, в результате чего база данных обновится до предыдущей схемы.
ПРЕДУПРЕЖДЕНИЕ  Применение миграций изменяет базу дан-
ных, поэтому всегда нужно помнить о  потере данных. Если вы
удалите таблицу из базы данных с  по мощью миграции, а  затем
выполните откат, то таблица будет воссоздана заново, но данные,
которые ранее содержались в ней, исчезнут навсегда!
В этом разделе вы увидите, как создать первую миграцию и использо-
вать ее для создания базы данных. Затем вы обновите свою модель дан-
ных, создадите вторую миграцию и воспользуетесь ею для обновления
схемы базы данных.
12.3.1 Создаем первую миграцию
Прежде чем вы сможете создавать миграции, нужно установить необхо-
димые инструменты. Это можно сделать двумя основными способами:
консоль	 диспетчера	 пакетов  – командлеты PowerShell можно ис -
пользовать в консоли диспетчера пакетов Visual Studio. Вы можете
установить их напрямую из консоли или добавить в свой проект па-
кет Microsoft.EntityFrameworkCore.Tools;
инструменты	 командной	 строки	.NET – кросс-платформенный на-
бор инструментов, которые можно запускать из командной строки
и  который расширяет набор средств разработки .NET. Вы можете
1 DbUp (https://github.com/DbUp/DbUp) и FluentMigrator (https://github.com/flu-
entmigrator/fluentmigrator) являются проектами с открытым исходным кодом.

450 Глава 12 Cохраняем данные с Entity Framework Core
установить эти инструменты глобально на свой компьютер, выпол-
нив команду dotnet tool install --global dotnet-ef1.
В этой книге я буду использовать кросс-платформенные инструменты
командной строки .NET, но если вы знакомы с EF 6.x или предпочитае-
те использовать консоль диспетчера пакетов Visual Studio, существуют
эквивалентные команды для всех этих шагов2. Проверить правильность
установки инструмента .NET EF Core можно, запустив команду dotnet
ef. Должен появиться экран справки, похожий на тот, что показан на
рис. 12.6.
Рис. 12.6 Выполняем команду dotnet ef, чтобы проверить правильность установки
инструментов .NET EF Core
СОВЕТ  Если при выполнении предыдущей команды вы получи-
ли сообщение No executable found matching command 'dotnet-ef'
(Не найден исполняемый файл, соответствующий команде 'dotnet-
ef'), убедитесь, что вы установили глобальный инструмент EF Core
с  по мощью команды dotnet tool install --global dotnet-ef. Как
правило, необходимо запускать команду dotnet ef из папки про-
екта, в которой вы зарегистрировали AppDbContext (не на уровне
папки решения).
Установив инструменты EF Core и  сконфигурировав контекст базы
данных, можно создать свою первую миграцию, выполнив следующую
команду из папки веб-проекта и указав имя миграции – в данном случае
InitialSchema:
dotnet ef migrations add InitialSchema
1 Кроме того, можно установить эти инструменты локально, используя файл	ма-
нифеста	 инструмента. Чтобы узнать, как это сделать, см. статью в моем блоге:
https://andrewlock.net/new-in-net-core-3-local-tools/.
2 Документацию по командлетам PowerShell можно найти на странице https://
docs.microsoft.com/ef/core/miscellaneous/cli/powershell.

451 Управление изменениями с помощью миграций
Эта команда создает три файла в папке Migrations:
файл	миграции  – файл в  формате Timestamp_MigrationName.cs.
Здесь описаны действия, которые нужно предпринять в базе дан-
ных, такие как создание таблицы или добавление столбца. Обратите
внимание, что сгенерированные здесь команды зависят от провай-
дера	базы	данных, основываясь на провайдере, сконфигурирован-
ном в вашем проекте;
файл	Migration	 designer.cs – этот файл описывает внутреннюю мо-
дель вашей модели данных EF Core на	момент	создания	миграции;
AppDbContextModelSnapshot.cs  – описывает текущую внутреннюю
модель EF Core. Он будет обновлен, когда вы добавите еще одну ми-
грацию, поэтому всегда должен быть таким же, как текущая послед-
няя миграция.
EF Core может использовать файл AppDbContextModelSnapshot.cs для
определения предыдущего состояния базы данных при создании новой
миграции, не взаимодействуя с базой данных напрямую.
Эти три файла инкапсулируют процесс миграции, но при добавлении
миграции в самой базе данных ничего не обновляется. Для этого нужно
выполнить другую команду, чтобы применить миграцию к базе данных.
СОВЕТ  Вы можете и должны заглянуть внутрь файла миграции,
созданного EF Core, чтобы проверить, что он будет делать с вашей
базой данных, прежде чем запускать следующие команды. Береже-
ного Бог бережет!
Можно применить миграции одним из трех способов:
используя инструмент командной строки .NET;
используя командлеты PowerShell;
в коде, получив экземпляр класса AppDbContext из контейнера внед-
рения зависимостей и вызвав метод context.Database.Migrate().
Какой вариант лучше всего вам подходит, зависит от того, как вы спро-
ектировали свое приложение, как будете обновлять рабочую базу дан-
ных, и  от ваших личных предпочтений. Пока я  буду использовать ин-
струмент командной строки .NET, но некоторые из этих соображений
я рассмотрю в разделе 12.5.
Можно применить миграции к базе данных, выполнив команду
dotnet ef database update
из папки проекта своего приложения. Я не буду вдаваться в подробности
того, как она работает, но эта команда выполняет четыре шага.
1 Выполняет сборку вашего приложения.
2  Загружает сервисы, настроенные в  классе вашего приложения,
Startup, включая AppDbContext.
3  Проверяет, существует ли база данных в строке подключения Ap-
pDbContext. Если ее там нет, она ее создает.

452 Глава 12 Cохраняем данные с Entity Framework Core
4  Обновляет базу данных, применяя все миграции, которые не были
применены.
Если все настроено правильно, как я показал в разделе 12.2, то после
выполнения этой команды у вас будет установлена новая база данных,
как та, что показана на рис. 12.7.
ПРИМЕЧАНИЕ  Если при выполнении этих команд вы получае-
те сообщение об ошибке «Проект не найден», убедитесь, что вы
запускаете их в  папке проекта своего приложения, а  не в  папке
решения верхнего уровня.
Таблица __EFMigrationsHistory содержит список всех
миграций, которые были применены к базе данных
Сущности в нашей модели данных, Recipe и Recipe,
соответствуют таблицам в базе данных
Свойства сущности Recipe соответствуют столбцам
в таблице Recipes
Рис. 12.7  Применение миграции к базе данных приведет к созданию базы данных,
если она не существует, и обновлению базы данных в соответствии с внутренней
моделью данных EF Core. Список примененных миграций хранится в таблице
__EFMigrationsHistory
Когда вы применяете миграции к базе данных, EF Core создает необ-
ходимые таблицы в базе данных и добавляет соответствующие столбцы
и  ключи. Возможно, вы также заметили таблицу __EFMigrationsHistory.
EF Core использует ее для хранения имен миграций, примененных к базе
данных. В следующий раз, когда вы запустите команду dotnet ef data-
base update, EF Core сможет сравнить эту таблицу со списком миграций
в вашем приложении и применит к вашей базе данных только новые ми-
грации.
В следующем разделе мы рассмотрим, как это упрощает изменение
модели данных и  обновление схемы базы данных без необходимости
воссоздавать базу данных с нуля.
12.3.2 Добавляем вторую миграцию
Большинство приложений неизбежно развиваются, будь то из-за уве-
личения объема или сопровождения. Добавление свойств к сущностям,
добавление новых сущностей целиком и удаление устаревших классов –
все это вполне вероятные действия.
Миграции EF Core упрощают эти процессы. Представьте, что вы ре-
шили выделить вегетарианские и веганские блюда в своем приложении
с  рецептами, предоставив свойства IsVegetarian и  IsVegan в  сущности

453 Управление изменениями с помощью миграций
Recipe. Переведите ваши сущности в желаемое состояние, сгенерируйте
миграцию и примените ее к базе данных, как показано на рис. 12.8.
Класс Recipe
Properties:
+ RecipeId: int
+ Name: string
+ TimeToCook: Timespan
+ IsVegetarian: boolean
+ IsVegan: boolean
dotnet ef migrations add NewFields
20170525220541_ExtraRecipeFields.cs
dotnet ef database update
DB1.  Обновляем сущности, добавив
новые свойства и связи
2.  Создаем новую миграцию
из командной строки
и указываем имя для нее
3.  При создании миграции генерируются файл
миграции и файл конструктора миграции.
Также обновляется копия DbContext
приложения, но не обновляется база данных
4.  Вы можете применить миграцию к базе
данных с помощью командной строки.
Так вы обновите схему базы данных, чтобы
она соответствовала вашим сущностям
Рис. 12.8 Создание второй миграции и применение ее к базе данных
с по мощью инструментов командной строки
Листинг 12.5 Добавляем свойства в сущность Recipe
public class Recipe
{
public int RecipeId { get; set; }
public string Name { get; set; }
public TimeSpan TimeToCook { get; set; }
public bool IsDeleted { get; set; }
public string Method { get; set; }
public bool IsVegetarian { get; set; }
public bool IsVegan { get; set; }
public ICollection<Ingredient> Ingredients { get; set; }
}
После изменения сущностей необходимо обновить внутреннее пред-
ставление модели данных. Делается это точно так же, как и при первой
миграции, путем вызова команды dotnet ef migrations add и предостав-
ления имени миграции:
dotnet ef migrations add ExtraRecipeFields

454 Глава 12 Cохраняем данные с Entity Framework Core
Так вы создаете вторую миграцию в своем проекте путем добавления
файла миграции и файла копии .designer.cs и обновления файла AppDb-
ContextModelSnapshot.cs, как показано на рис. 12.9.
При создании миграции в ваше решение
добавляется файл с расширением .cs
с временной меткой и именем, которое
вы дали миграции
А также добавляется файл Designer.cs,
содержащий копию внутренней модели
данных EF Core на тот момент времени AppDbContextModelSnapshot
обновляется, чтобы
соответствовать копии
для новой миграции
Рис. 12.9 При добавлении второй миграции вы добавляете новый файл миграции и файл
Designer.cs, а также обновляете файл AppDbContextModelSnapshot, чтобы он соответствовал
файлу новой миграции, Designer.cs
Как и раньше, при этом создаются файлы миграции, но база данных не
изменяется. Вы можете применить миграцию и обновить базу данных,
выполнив команду
dotnet ef database update
Она сравнивает миграции в вашем приложении с таблицей __EFMig-
ra tionsHistory в  вашей базе данных, чтобы увидеть, какие мигра-
ции еще остались, а затем выполняет их. EF Core выполнит миграцию
20200511204457_Ext raRecipeFields, добавив поля IsVegetarian и  IsVegan
в базу данных, как показано на рис. 12.10.
Применяя вторую миграцию к базе данных,
вы добавляете новые поля в таблицу Recipes
Рис. 12.10 Применяя миграцию ExtraRecipeFields к базе данных, вы добавляете
поля IsVegetarian и IsVegan в таблицу рецептов
Использование миграций  – отличный способ обеспечить версион-
ность вашей базы данных наряду с кодом вашего приложения в системе
управления версиями. Вы можете легко проверить исходный код своего
приложения и воссоздать схему базы данных, которую ваше приложение
использовало в этот момент.
Миграции легко использовать, когда вы работаете в одиночку или когда
развертываете приложение на одном веб-сервере, но даже в этих случаях

455 Выполнение запроса к базе данных и сохранение в ней данных
есть важные моменты, которые следует учитывать при принятии решения
о том, как управлять своими базами данных. В  случае с  приложениями
с несколькими веб-серверами, использующими общую базу данных или
для контейнерных приложений, следует быть особенно внимательными.
Эта книга посвящена ASP .NET Core, а  не EF Core, поэтому я  не хочу
подробно останавливаться на управлении базами данных, но в  разде-
ле 12.5 указаны некоторые моменты, которые следует учитывать при ис -
пользовании миграций в промышленном окружении.
В следующем разделе мы вернемся к основной теме – определению
бизнес-логики и выполнению CRUD-операций с базой данных.
12.4 Выполнение запроса к базе данных
и сохранение в ней данных
Посмотрим, на каком этапе создания приложения с рецептами вы на-
ходитесь:
вы создали простую модель данных для приложения, состоящую из
рецептов и ингредиентов;
вы создали миграции для модели данных, чтобы обновить внутрен-
нюю модель ваших сущностей;
вы применили миграции к базе данных, так чтобы ее схема соот -
ветствовала модели EF Core.
В этом разделе мы создадим бизнес-логику для нашего приложения,
создав сервис RecipeService. Она будет обрабатывать запросы к  базе
данных для получения рецептов, создания новых рецептов и изменения
существующих. Поскольку у этого приложения простая предметная об-
ласть, я буду использовать RecipeService для обработки всех требований,
но в ваших приложениях может быть несколько сервисов, которые взаи-
модействуют друг с другом для обеспечения бизнес-логики.
Когда речь идет о простых приложениях, у вас может возникнуть со-
блазн перенести эту логику в Razor Pages. Призываю вас сопротивлять-
ся этому побуждению; извлекая свою бизнес-логику в другие сервисы,
вы отделяете HTTP-ориентированную природу Razor Pages и Web API от
базовой бизнес-логики. Благодаря этой связи вашу бизнес-логику легче
тестировать, и ее можно использовать повторно.
В нашей базе пока нет данных, поэтому лучше начать с создания ре-
цепта.
12.4.1 Создание записи
В этом разделе мы дадим пользователям возможность создавать рецепты
в приложении. Это будет форма, которую пользователь может использо-
вать для ввода всех деталей рецепта с по мощью тег-хелперов Razor, о ко-
торых вы узнали в главах 7 и 8. Ее содержимое отправляется на страницу

456 Глава 12 Cохраняем данные с Entity Framework Core
Create.cshtml, которая использует привязку модели и атрибуты валида-
ции, подтверждающие, что запрос валиден, как было показано в главе 6.
Если запрос валиден, обработчик страницы вызывает сервис Recipe-
Service для создания нового объекта Recipe в  базе данных. Поскольку
тема этой главы – EF Core, я сосредоточусь только на этом сервисе, но
вы всегда можете обратиться к исходному коду для данной книги, если
хотите увидеть, как это все сочетается друг с другом.
Бизнес-логика создания рецепта в этом приложении проста – ее нет!
Отобразите модель привязки команд, предоставленную на странице Cre-
ate.cshtml, в сущности Recipe и Ingredient, добавьте объект Recipe в класс
AppDbContext и сохраните это в базе данных, как показано на рис. 12.11.
CreateRecipeCommand
RecipeService.CreateRecipe()
Recipe
SQL RecipeId
DBЗапрос
Create.cshtml
RedirectToPageОтображаем
команду
в сущности
Сохраняем
с помощью
DbContext 1.  Запрос отправляется
на URL-адрес /Recipes/Create
с помощью POST -запроса
2.  Запрос маршрутизируется
на страницу Create.cshtml,
а тело формы привязано
к CreateRecipeCommand3.  Обработчик страницы
вызывает метод CreateRecipe
в RecipeService, передавая
CreateRecipeCommand
4.  Новый объект
Recipe создается из
CreateRecipeCommand
5.  Рецепт добавляется
в EF Core с помощью
DbContext
6.  EF Core генерирует
SQL, необходимый
для вставки новой
строки в таблицу
Recipes, и возвращает
идентификатор
рецепта новой строки7.  Обработчик страницы
использует RecipeId для
создания RedirectT oPageResult
для новой страницы с подробной
информацией о рецепте
Рис. 12.11 Вызов страницы Create.cshtml и создание новой сущности. Объект Recipe создается
из модели привязки CreateRecipeCommand и добавляется в DbContext. EF Core генерирует
SQL-код, чтобы добавить новую строку в таблицу рецептов в базе данных
ПРЕДУПРЕЖДЕНИЕ  Множество простых эквивалентных приме-
ров приложений с использованием EF или EF Core позволяют на-
прямую	 выполнять привязку к сущности Recipe в качестве модели
представления для действий MVC. К сожалению, из-за этого ваше
приложение становится уязвимым для оверпостинга, а это плохая
практика. Если вы хотите избежать использования шаблонного
кода отображения в  своих приложениях, рассмотрите возмож -
ность применения такой библиотеки, как AutoMapper (http://au-
tomapper.org/). Дополнительную информацию об оверпостинге см.
в моем посте: http://mng.bz/d48O .

457 Выполнение запроса к базе данных и сохранение в ней данных
Создание сущности в EF Core включает в себя добавление новой стро-
ки в отображаемую таблицу. Всякий раз, когда вы создаете новый рецепт,
вы также добавляете связанные сущности Ingredients. EF Core позабо-
тится о том, чтобы правильно связать все это, создав правильный иден-
тификатор RecipeId для каждого ингредиента в базе данных.
Основная часть кода, необходимого для этого примера, включает
в  себя трансляцию из CreateRecipeCommand в  сущность Recipe  – взаи-
модействие с  AppDbContext состоит всего лишь из двух методов: Add()
и SaveChangesAsync().
Листинг 12.6 Создание сущности Recipe в базе данных
readonly AppDbContext _context;
public async Task<int> CreateRecipe(CreateRecipeCommand cmd)
{
var recipe = new Recipe
{
Name = cmd.Name,
TimeToCook = new TimeSpan(
cmd.TimeToCookHrs, cmd.TimeToCookMins, 0),
Method = cmd.Method,
IsVegetarian = cmd.IsVegetarian,
IsVegan = cmd.IsVegan,
Ingredients = cmd.Ingredients?.Select(i =>
new Ingredient
{
Name = i.Name,
Quantity = i.Quantity,
Unit = i.Unit,
}).ToList()
};
_context.Add(recipe);
await _context.SaveChangesAsync();
return recipe.RecipeId;
}
Все взаимодействия с EF Core и базой данных начинаются с экземпля-
ра AppDbContext, который обычно вводится с использованием внедрения
зависимостей через конструктор. Для создания новой сущности требует -
ся выполнить три шага:
1 создать сущности Recipe и Ingredient;
2  добавить их в список отслеживаемых сущностей EF Core, применяя
_context.Add(entity);
3  использовать оператор INSERT, чтобы добавить необходимые стро-
ки в  таблицы Recipe и  Ingredient, вызвав _context.SaveChanges-
Async(). Экземпляр AppDbContext внедряется в конструктор
класса с по мощью внедрения зависимостей.CreateRecipeCommand передается
из обработчика страницы Razor.
Создаем рецепт путем
отображения из объекта
команды в сущность Recipe.
Отображаем каждую команду
CreateIngredientCommand
в сущность Ingredient.Сообщаем EF
Core, что нужно
отслеживать новые
сущности.Даем EF Core указание вести запись
сущностей в базу данных. Здесь используется
асинхронная версия команды.
EF Core заполняет поле RecipeId вашего
нового рецепта при его сохранении.

458 Глава 12 Cохраняем данные с Entity Framework Core
ПОДСКАЗКА  Существуют синхронные и  асинхронные версии
большинства команд EF Core, которые включают в  себя взаимо-
действие с  базой данных, например SaveChanges() и  SaveChang-
esAsync(). В  целом асинхронные версии позволяют приложению
обрабатывать больше одновременных подключений, поэтому при
возможности я всегда выбираю их.
Если возникает проблема, когда EF Core пытается взаимодействовать
с вашей базой данных, – например, вы не запустили миграции, чтобы об-
новить схему базы данных, – то будет выдано исключение. Здесь я этого
не показывал, но важно учитывать это в своем приложении, чтобы не
демонстрировать пользователям неприятную страницу с ошибкой, если
что-то пошло не так.
Если все идет хорошо, то EF Core обновляет все автоматически сге-
нерированные идентификаторы ваших сущностей (RecipeId для Recipe,
а также RecipeId и  IngredientId для Ingredient). Возвращайте иденти-
фикатор рецепта на страницу Razor, чтобы она могла его использовать,
например чтобы перенаправить пользователя на страницу просмотра
рецептов.
Вот и  все  – вы создали свою первую сущность с  по мощью EF Core.
В следующем разделе мы рассмотрим загрузку этих сущностей из базы
данных, чтобы их можно было увидеть в списке.
12.4.2 Загрузка списка записей
Теперь, когда вы можете создавать рецепты, нужно написать код для их
просмотра. К счастью, загружать данные в EF Core просто, широко ис -
пользуя методы LINQ, чтобы контролировать, какие поля нам нужны.
Для своего приложения вы создадите метод в  RecipeService, который
возвращает общий вид рецепта, состоящий из RecipeId, Name и TimeTo-
Cook. Все это представлено в  виде модели RecipeSummaryViewModel, как
показано на рис. 12.12.
ПРИМЕЧАНИЕ  С  технической точки зрения создание модели
представления является задачей пользовательского интерфейса,
а  не бизнес-логики. Здесь я  возвращаю их напрямую из Recipe-
Service главным образом для того, чтобы дать понять вам, что не
следует использовать сущности EF Core напрямую на своих стра-
ницах Razor Pages.
Метод GetRecipes из RecipeService концептуально прост и следует об-
щепринятому шаблону выполнения запроса к базе данных, как показано
на рис. 12.13.
EF Core использует цепочку команд LINQ для определения запро-
са, исполняемого в базе данных. Свойство DbSet<Recipe> в  AppDataCon-
text является IQueryable, поэтому вы можете использовать все обычные
предложения Select() и  Where(), которые вы бы применяли с другими

459 Выполнение запроса к базе данных и сохранение в ней данных
провайдерами IQueryable. EF Core преобразует их в инструкцию SQL для
осуществления запроса к базе данных, когда вы вызываете функцию вы-
полнения, такую как ToListAsync(), ToArrayAsync(), SingleAsync() или их
неасинхронных собратьев.
RecipeSummaryViewModelSQLRecipeService.GetRecipes()Запрос
Index.cshtml
ViewResult
DBЗапрос
с помощью
DbContext 1. Запрашивается URL-адрес /
2.  Запрос маршрутизируется на страницу
Razor, Index.cshtml, которая вызывает
RecipeService для загрузки моделей
представления3.  Метод GetRecipes использует DbContext
приложения, чтобы выполнить
запрос к базе данных для получения
данных, необходимых для моделей
представления
6.  Метод действия передает модели
представления представлению,
предоставляя их как свойства
PageModel
4.  EF Core
генерирует SQL
и выполняет
запрос к базе
данных
5.  База данных возвращает
данные в виде строк,
а EF Core отображает их для
просмотра объектов модели
Рис. 12.12 Вызов страницы Index.cshtml и выполнение запроса к базе данных для получения
списка RecipeSummaryViewModel. EF Core генерирует SQL-код для получения необходимых
полей из базы данных и отображает их для просмотра объектов модели
Доступ к свойству
DbSet AppDbContextКоманды LINQ для изменения
возвращаемых данныхВыполнение
команды запроса
Рис. 12.13 Три части запроса к базе данных с использованием EF Core
Вы также можете использовать метод расширения Select() для
отобра жения в объекты, отличные от ваших сущностей, как часть SQL-
запроса. Вы можете использовать это для выполнения эффективного за-
проса к базе данных, извлекая только нужные вам столбцы.
В листинге 12.7 показан код для получения списка моделей Recipe-
SummaryViewModel, следуя тому же базовому шаблону, что и на рис. 12.12.
Здесь используется LINQ-выражение Where для фильтрации рецептов,
помеченных как удаленные, и  предложение Select для отображения
в модели представления. Команда ToListAsync() дает указание EF Core
сгенерировать SQL-запрос, выполнить его в базе данных и создать Reci-
peSummaryViewModel из возвращаемых данных.

460 Глава 12 Cохраняем данные с Entity Framework Core
Листинг 12.7  Загрузка списка элементов с по мощью EF Core
в RecipeService
public async Task<ICollection<RecipeSummaryViewModel>> GetRecipes()
{
return await _context.Recipes
.Where(r => !r.IsDeleted)
.Select(r => new RecipeSummaryViewModel
{
Id = r.RecipeId,
Name = r.Name,
TimeToCook = $"{r.TimeToCook.TotalMinutes}mins"
})
.ToListAsync();
}
Обратите внимание, что в  методе Select вы преобразуете свойство
TimeToCook из TimeSpan в строку с использованием строковой интерпо-
ляции:
TimeToCook = $"{r.TimeToCook.TotalMinutes}mins"
Я уже говорил, что EF Core преобразует серию выражений LINQ в SQL,
но это не вся правда; EF Core не может или не знает, как преобразовать
некоторые выражения. В таких случаях, как в этом примере, EF Core на-
ходит поля из базы данных, которые ей нужны для выполнения выраже-
ния на стороне клиента, выбирает их из базы данных, а затем выполняет
выражение на C#. Это позволяет сочетать мощность и производитель-
ность вычисления на стороне базы данных без ущерба для функциональ-
ности C#.
ПРЕДУПРЕЖДЕНИЕ  Вычисление на стороне клиента – мощная
и полезная вещь, но оно может вызвать проблемы. Как правило,
последние версии EF Core будут выдавать исключение, если запрос
требует опасного вычисления на стороне клиента. Чтобы увидеть
примеры, включая то, как избежать этих проблем, см. документа-
цию на странице http://mng.bz/zxP6.
На данном этапе у  вас есть список записей, отображающий сводку
данных рецепта, поэтому следующий очевидный шаг – загрузка деталей
для отдельной записи.
12.4.3 Загрузка одной записи
В большинстве случаев загрузка отдельной записи аналогична загрузке
списка записей. Они имеют ту же общую структуру, которую вы видели
на рис. 12.13, но при загрузке одной записи обычно используется пред-
ложение Where и выполняется команда, ограничивающая данные одной
сущностью.Запрос начинается со свойства DbSet.
EF Core будет запрашивать
только те столбцы Recipe,
которые необходимы для
правильного отображения
модели представления.
Выполняем SQL-запрос и создаем
окончательные модели представления.

461 Выполнение запроса к базе данных и сохранение в ней данных
В листинге 12.8 показан код для извлечения рецепта по идентифика-
тору, следуя тому же базовому шаблону, что и раньше (рис. 12.12). Здесь
используется LINQ-выражение Where() для ограничения запроса одним
рецептом, где RecipeId == id, и есть предложение Select для отображения
в RecipeDetailViewModel. Предложение SingleOrDefaultAsync() заставит
EF Core сгенерировать SQL-запрос, выполнить его в базе данных и соз-
дать модель представления.
ПРИМЕЧАНИЕ  Предложение SingleOrDefaultAsync() возбудит
исключение, если предыдущее предложение Where вернет несколь-
ко записей.
Листинг 12.8  Загрузка отдельного элемента с по мощью EF Core
в RecipeService
public async Task<RecipeDetailViewModel> GetRecipeDetail(int id)
{
return await _context.Recipes
.Where(x => x.RecipeId == id)
.Select(x => new RecipeDetailViewModel
{
Id = x.RecipeId,
Name = x.Name,
Method = x.Method,
Ingredients = x.Ingredients
.Select(item => new RecipeDetailViewModel.Item
{
Name = item.Name,
Quantity = $"{item.Quantity} {item.Unit}"
})
})
.SingleOrDefaultAsync();
}
Обратите внимание, что помимо отображения Recipe  в RecipeDe-
tailViewModel вы также отображаете соответствующие ингредиенты
(Ingredients) для рецепта, как если бы вы работали с объектами прямо
в памяти. Это одно из преимуществ использования объектно-реляци-
онного отображения – вы можете легко отображать дочерние объекты,
позволяя EF Core решить, как лучше создать SQL-запросы для получе-
ния данных.
ПРИМЕЧАНИЕ  EF Core регистрирует все выполняемые инструк -
ции SQL как события LogLevel.Information по умолчанию, по-
этому можно легко увидеть, какие запросы выполняются к базе
данных.Идентификатор загружаемого рецепта
передается в качестве параметра.
Как и прежде,
запрос начинается
со свойства DbSet.Ограничиваем запрос рецептом
с предоставленным идентификатором.
Отображаем Recipe
в RecipeDetailViewModel.
Загружаем и отображаем
связанные ингредиенты
как часть одного и того же
запроса.
Выполняем запрос и отображаем
данные в модель представления.

462 Глава 12 Cохраняем данные с Entity Framework Core
Наше приложение определенно приобретает форму: вы можете соз-
давать новые рецепты, просматривать их все в виде списка и прокручи-
вать, чтобы увидеть отдельные рецепты с ингредиентами. Однако вскоре
кто-то сделает опечатку и захочет изменить свои данные. Для этого нуж -
но будет заняться обновлением.
12.4.4 Обновление модели
Обновление сущностей, после того как они изменились, – обычно самая
сложная часть CRUD-операций, поскольку переменных очень много. На
рис. 12.14 представлен обзор этого процесса применительно к нашему
приложению рецептов.
Command
Recipe Recipe
# SQL SQL
DB DBЧтение сущности
с помощью DbContextСохранение объекта
с помощью DbContextОбновление
свойств сущности
Обновление
связей сущностей1.  Метод обновления получает
команду, указывающую, какую
сущность обновить, и новые
значения свойств3.  Команда используется
для обновления свойств
сущности Recipe
4.  Если ингредиенты Recipe
изменились, они также
обновляются с помощью
команды2.  DbContext генерирует SQL,
необходимый для загрузки
объекта из базы данных 5.  Сохранение вызывается
в DbContext, который
генерирует необходимый
SQL для обновления
сущности в базе данных
Рис. 12.14 Обновление сущности состоит из трех этапов: чтение сущности с по-
мощью EF Core, обновление ее свойств и вызов метода SaveChangesAsync()
в DbContext, чтобы сгенерировать SQL-код для обновления правильных строк в базе
данных
Я не буду обсуждать в этой книге аспект связей, потому что обычно
это комплексная проблема, и то, как вы ее решите, зависит от специфи-
ки вашей модели данных. Вместо этого я сосредоточусь на обновлении
свойств самой сущности Recipe1.
В случае с веб-приложениями при обновлении сущности обычно вы-
полняются действия, приведенные на рис. 12.14:
1 чтение сущности из базы данных;
2 изменение свойств сущности;
3 сохранение изменений в базе данных.
1 Подробнее об обновлении связей в EF Core см. в книге «Entity	 Framework	 Core
в действии», 2-е изд., Джона П. Смита (Manning, 2021), глава 3, раздел 3.4:
http://mng.bz/w9D2.

463 Выполнение запроса к базе данных и сохранение в ней данных
Эти три шага инкапсулируются в методе RecipeService с именем Up-
dateRecipe. Этот метод принимает параметр UpdateRecipeCommand и  с о -
держит код для изменения сущности Recipe.
ПРИМЕЧАНИЕ  Как и в случае с командой Create, нельзя напря-
мую изменять сущности на странице Razor, гарантируя, что поль-
зовательский интерфейс будет отделен от бизнес-логики.
В следующем листинге показан метод RecipeService.UpdateRecipe, ко -
торый обновляет сущность Recipe. Он выполняет три шага, которые мы
определили ранее: чтение, изменение и сохранение сущности. Я извлек
код, чтобы обновить рецепт новыми значениями для вспомогательного
метода.
Листинг 12.9  Обновление существующей сущности с по мощью EF Core
в RecipeService
public async Task UpdateRecipe(UpdateRecipeCommand cmd)
{
var recipe = await _context.Recipes.FindAsync(cmd.Id);
if(recipe == null) {
throw new Exception("Unable to find the recipe");
}
UpdateRecipe(recipe, cmd);
await _context.SaveChangesAsync();
}
static void UpdateRecipe(Recipe recipe, UpdateRecipeCommand cmd)
{
recipe.Name = cmd.Name;
recipe.TimeToCook =
new TimeSpan(cmd.TimeToCookHrs, cmd.TimeToCookMins, 0);
recipe.Method = cmd.Method;
recipe.IsVegetarian = cmd.IsVegetarian;
recipe.IsVegan = cmd.IsVegan;
}
В этом примере я прочитал сущность Recipe, используя метод Find-
Async(id), предоставленный DbSet. Это простой вспомогательный ме-
тод для загрузки объекта по идентификатору, в данном случае RecipeId.
Я мог бы написать аналогичный запрос, используя LINQ:
_context.Recipes.Where(r=>r.RecipeId == cmd.Id).FirstOrDefault();
Применение методов FindAsync() или Find() немного более деклара-
тивно и короче.
СОВЕТ  Метод Find() на самом деле немного сложнее. Сначала
он проверяет, не отслеживается ли сущность в  DbContext. Если это Поиск доступен непосредственно
в Recipes и упрощает чтение
сущности по идентификатору.
Если указан недопустимый
идентификатор, значение
recipe будет равно null.Задаем новые
значения
сущности
Recipe.
Выполняем SQL, чтобы сохранить
изменения в базе данных.
Вспомогательный
метод для установки
новых свойств
сущности Recipe.

464 Глава 12 Cохраняем данные с Entity Framework Core
так (потому что сущность была уже загружена ранее в этом запро-
се), то сущность возвращается немедленно без обращения к базе
данных. Очевидно, что это быстрее, если сущность отслеживается,
а может и нет, если вы знаете, что это не так.
Вам может быть интересно, откуда EF Core знает, какие столбцы нужно
обновить при вызове метода SaveChangesAsync(). Самый простой под-
ход – обновлять каждый столбец; если поле не изменилось, то не име-
ет значения, напишете ли вы снова то же значение. Но EF Core намного
умнее.
Она внутренне отслеживает состояние всех сущностей, загружаемых
из базы данных, и создает копию всех значений свойств сущности, чтобы
можно было отслеживать, какие из них изменились. Когда вы вызываете
метод SaveChanges(), EF Core сравнивает состояние всех отслеживаемых
сущностей (в данном случае сущности Recipe) с копией отслеживания.
Все свойства, которые были изменены, включаются в  инструкцию UP -
DATE, отправляемую в базу данных, а неизмененные свойства игнори-
руются.
ПРИМЕЧАНИЕ  EF Core предоставляет другие механизмы для от -
слеживания изменений, а также параметры, чтобы полностью от -
ключить отслеживание изменений. Обратитесь к  документации
или третьей главе книги «Entity	 Framework	 Core	в действии» Джона
П. Смита, 2-е изд. (Manning, 2021) для получения подробной ин-
формации: http://mng.bz/q9PJ.
Теперь, когда вы можете обновлять рецепты, приложение с рецепта-
ми почти готово. «Но подождите, – кричите вы, – мы еще не работали
с функцией Delete!» И это правда, но на самом деле я обнаружил всего
несколько случаев, когда вам понадобится удалить данные.
Рассмотрим требования для удаления рецепта из приложения, как
показано на рис.  12.15. Вам нужно добавить (жутковатого вида) кноп-
ку «Удалить» рядом с  рецептом. После этого пользователь щелкает по
ней мышью, рецепт больше не отображается в списке, и его нельзя про-
смотреть.
Этого можно добиться, удалив рецепт из базы данных, но проблема
с данными состоит в том, что, когда они исчезают, их уже нет! Что делать,
если пользователь случайно удалил запись? Кроме того, удаление строки
из реляционной базы данных обычно влияет на другие сущности.
Например, нельзя удалить строку из таблицы Recipe в своем приложе-
нии, не удалив также все строки Ingredient, которые ссылаются на нее,
благодаря ограничению внешнего ключа для Ingredient.RecipeId.
EF Core может легко справиться с такими случаями истинного	 удале-
ния с по мощью команды DbContext.Remove(entity), но обычно при не-
обходимости удалить данные имеется	 в виду	 их «архивирование» или
сокрытие от пользовательского интерфейса. Распространенный подход

465 Выполнение запроса к базе данных и сохранение в ней данных
к работе с этим сценарием заключается в том, чтобы использовать что-
то вроде параметра «Is this entity deleted», например IsDeleted, который
я включил в сущность Recipe:
На главной странице приложения
отображается список всех текущих рецептов
При нажатии на кнопку Delete
вы возвращаетесь к списку, но удаленный
рецепт больше не отображается При нажатии кнопки View открывается страница
с подробной информацией о рецепте
Рис. 12.15 Желаемое поведение при удалении рецепта из приложения.
После щелчка по кнопке «Удалить» вы должны вернуться к основному списку,
при этом удаленный рецепт больше не отображается
public bool IsDeleted {get;set;}
Если вы воспользуетесь данным подходом, удалять данные внезап-
но станет проще, поскольку это не что иное, как обновление сущности.
Больше никаких проблем с потерянными данными и ссылочной целост -
ностью.
ПРИМЕЧАНИЕ  Основное исключение, которое я  обнаружил
в  этом шаблоне, – когда вы сохраняете информацию, позволяю-
щую установить личность ваших пользователей. В этих случаях вы,
возможно, будете обязаны (и, возможно, юридически) удалять эти
сведения из своей базы данных по запросу.
При таком подходе можно создать метод удаления в RecipeService, ко -
торый обновляет параметр IsDeleted, как показано в  следующем лис -
тинге. Кроме того, вы должны убедиться, что у  вас есть предложения
Where() во всех других методах RecipeService, чтобы гарантировать, что
вы не можете отобразить удаленный рецепт, как вы видели в листин-
ге 12.9 для метода GetRecipes().

466 Глава 12 Cохраняем данные с Entity Framework Core
Листинг 12.10 Помечаем сущности как удаленные в EF Core
public async Task DeleteRecipe(int recipeId)
{
var recipe = await _context.Recipes.FindAsync(recipeId);
if(recipe is null) {
throw new Exception("Unable to find the recipe");
}
recipe.IsDeleted = true;
await _context.SaveChangesAsync();
}
Такой подход удовлетворяет требованиям  – вы удаляете рецепт из
пользовательского интерфейса приложения, – но упрощает ряд вещей.
Это мягкое	удаление подойдет не для всех ситуаций, но я обнаружил, что
это распространенный шаблон в проектах, над которыми я работал.
СОВЕТ  В EF Core есть удобная функция – глобальные	 фильтры	 за-
просов. Они позволяют указать предложение Where на уровне моде-
ли, чтобы вы могли, например, гарантировать, что EF Core никогда
не загрузит рецепты, у которых IsDeleted имеет значение true. Это
также полезно для разделения данных в многоклиентском окру -
жении. Подробнее об этом  – на странице https://docs.microsoft.
com/ef/core/querying/filters.
Мы почти подошли к концу этой главы, посвященной EF Core. Мы рас -
смотрели основы добавления EF Core в проект и выяснили, как исполь-
зовать эту библиотеку для упрощения доступа к данным, но вам, скорее
всего, понадобится узнать больше о ней, по мере того как ваши приложе-
ния будут становиться более сложными. В заключительном разделе этой
главы я хотел бы выделить ряд вещей, которые нужно принять во вни-
мание, перед тем как использовать EF Core в своих приложениях, чтобы
вам были знакомы некоторые проблемы, с которыми вы столкнетесь по
мере роста своих приложений.
12.5 Использование EF Core в промышленных
приложениях
Эта книга посвящена ASP .NET Core, а не EF Core, поэтому я не хотел тра-
тить слишком много времени на ее изучение. Данная глава должна была
дать вам достаточно информации, чтобы приступить к  работе, но вам
непременно нужно узнать еще кое-что, прежде чем вы даже подумае-
те о том, чтобы использовать EF Core в промышленном окружении. Как
я уже неоднократно говорил, я рекомендую книгу «Entity	 Framework	 Core
в действии» для получения подробной информации об этой библиотеке Получаем сущность Recipe
по идентификатору.
Если указан недопустимый
идентификатор, значение
recipe будет равно null.Помечаем
сущность
Recipe как
удаленную.
Выполняем SQL, чтобы сохранить
изменения в базе данных.

467 Использование EF Core в промышленных приложениях
(http://mng.bz/7Vme), или вы можете изучить сайт с документацией по
EF Core: https://docs.microsoft.com/ef/core/.
Приведенные ниже темы не важны для начала работы с EF Core, но
вы быстро столкнетесь с ними, когда создадите готовое к промышлен-
ной эксплуатации приложение. Данный раздел не является предписы-
вающим руководством по решению каждой из этих проблем; это скорее
набор вещей, которые нужно принять во внимание, перед тем как вы
перейдете к промышленной эксплуатации.
Скаффолдинг	 столбцов – EF Core использует консервативные зна-
чения для таких вещей, как строковые столбцы, допуская строки
большой или неограниченной длины. На практике у вас может воз-
никнуть желание ограничить эти и другие типы данных разумными
значениями.
Валидация – 	вы можете декорировать свои сущности атрибутами
валидации DataAnnotations, но EF Core не будет автоматически
проверять значения, перед тем как сохранить их в базе данных. Это
отличается от поведения EF 6.x, в котором проверка была автома-
тической.
Параллелизм – EF Core предоставляет несколько способов для ра-
боты с  параллелизмом, когда несколько пользователей пытаются
обновить сущность одновременно. Одно из частичных решений –
использовать для своих сущностей столбцы Timestamp.
Синхронные	 и асинхронные	 команды  – EF Core предоставляет синхрон-
ные и асинхронные команды для взаимодействия с базой данных.
Часто асинхронный режим лучше подходит для веб-приложений, но
у этого аргумента есть нюансы, которые не позволяют рекомендо-
вать использование одного подхода вместо другого во всех ситуа-
циях.
EF Core – отличный инструмент для продуктивной работы при напи-
сании кода доступа к данным, но есть некоторые аспекты работы с ба-
зой данных, которые неизбежно неудобны. Проблема управления базами
данных – одна из самых сложных задач, которую приходится решать. Эта
книга посвящена ASP .NET Core, а не EF Core, поэтому я не хочу слишком
подробно останавливаться на управлении базами данных. При этом боль-
шинство веб-приложений используют какую-либо базу данных, поэтому
приведенные ниже ситуации могут повлиять на вас в какой-то момент:
автоматические	 миграции – 	если вы автоматически развертываете
свое приложение в  промышленном окружении как часть некоего
конвейера DevOps, вам неизбежно понадобится способ автомати-
ческого применения миграций к базе данных. Эту проблему мож -
но решить несколькими способами, например создать скрипт для
инструмента командной строки .NET EF Core, применить миграции
в коде запуска вашего приложения или использовать специальный
инструмент. У каждого подхода есть свои плюсы и минусы;
несколько	 веб-хостов – особое внимание следует уделять тому, есть
ли у  вас веб-серверы, на которых размещено ваше приложение

468 Глава 12 Cохраняем данные с Entity Framework Core
и которые указывают на одну и ту же базу данных. Если это так, то
применять миграции в коде запуска вашего приложения становит -
ся сложнее, так как вы должны убедиться, что только одно приложе-
ние может обновлять схему базы данных за раз;
делать	изменения	 схемы	обратно	 совместимыми – следствием под-
хода с использованием нескольких веб-хостингов является то, что
вы часто будете оказываться в  ситуации, когда ваше приложение
обращается к базе данных, у которой более новая	 схема, чем думает
приложение. Это означает, что обычно вы должны будете стремить-
ся к тому, чтобы делать изменения схемы обратно совместимыми
везде, где это возможно;
сохранение	 миграций	 в другой	 сборке – в этой главе я включил всю
свою логику в  один проект, но в  больших приложениях доступ
к данным часто осуществляется в другом проекте. Для приложений
с такой структурой необходимо использовать несколько иные ко-
манды при работе с интерфейсом командной строки .NET или ко-
мандлетами PowerShell;
наполнение	 базы	данных – когда вы впервые создаете базу данных, то
часто хотите, чтобы в ней были некие исходные данные, такие как
пользователь по умолчанию. У EF 6.x имелся встроенный механизм
для наполнения базы данных, тогда как EF Core требует, чтобы вы
сами явно заполняли базу данных.
То, как вы решите каждую из этих проблем, будет зависеть от инфра-
структуры и подхода к развертыванию, который вы применяете в сво-
ем приложении. Ни один из них не доставляет особого удовольствия, но
это – досадная необходимость. Мужайтесь – все их так или иначе можно
решить!
На этом мы подошли к  концу данной главы, посвященной EF Core.
В следующей главе мы рассмотрим одну из более сложных тем MVC и Ra-
zor Pages: конвейер фильтров и то, как можно его использовать, чтобы
уменьшить дублирование кода.
Резюме
EF Core  – инструмент объектно-реляционного отображения, позво-
ляющий взаимодействовать с базой данных путем манипулирования
стандартными классами POCO, называемыми сущностями, в прило-
жении. Это может уменьшить объем SQL-кода и необходимых знаний
о базах данных, которые нужны для продуктивной работы.
EF Core отображает классы сущностей в таблицы, свойства сущности –
в столбцы в таблицах, а экземпляры объектов сущностей – в строки
в этих таблицах. Даже если вы используете EF Core, чтобы не работать
напрямую с базой данных, необходимо учитывать это.
EF Core использует модель провайдера базы данных, позволяющую
изменять основную базу данных без изменения кода манипулирова-

469 Резюме
ния объектами. У EF Core имеются провайдеры баз данных для Micro-
soft SQL Server, SQLite, PostgreSQL, MySQL и многих других.
EF Core  – кросс-платформенная библиотека. Она обладает хорошей
производительностью для объектно-реляционного отображения,
но у нее иной набор функций, которые отличаются от тех, что были
у EF 6.x. Тем не менее EF Core рекомендуется использовать для всех
новых приложений вместо с EF 6.x.
EF Core хранит внутреннее представление сущностей в приложении
и  способ их отображения в  базу данных на основе свойств DbSet<T>
класса DbContext. EF Core создает модель на основе самих классов сущ-
ностей и любых других сущностей, на которые они ссылаются.
EF Core добавляется в приложение при добавлении пакета провайдера
базы данных NuGet. Также следует установить пакеты проектирова-
ния для EF Core. Это работает вкупе с инструментами командной стро-
ки .NET для создания и применения миграции к базе данных.
EF Core включает множество соглашений о  том, как определяются
сущности, например основные и  внешние ключи. Можно настроить
определение сущностей декларативно, используя DataAnnotations или
с по мощью механизма Fluent API.
Приложение использует DbContext для взаимодействия с EF Core и ба-
зой данных. Вы регистрируете его в контейнере внедрения зависимо-
стей, используя AddDbContext<T>, определяя провайдера базы данных
и предоставляя строку подключения. Благодаря этому DbContext ста -
новится доступен в контейнере во всем приложении.
EF Core использует миграции для отслеживания изменений в опреде-
лениях сущностей. Они используются для того, чтобы гарантировать,
что определения сущностей, внутренняя модель EF Core и схема базы
данных совпадают.
После изменения сущности можно создать миграцию с по мощью ин-
струмента командной строки .NET или командлетов PowerShell.
Чтобы создать новую миграцию, используя интерфейс командной
строки .NET, выполните команду dotnet ef migrations add NAME в папке
проекта, где NAME – это имя, которое вы хотите присвоить миграции.
Будет проведено сравнение вашей текущей копии DbContext с преды-
дущей версией и  сгенерированы необходимые инструкции SQL для
обновления вашей базы данных.
Можно применить миграцию к базе данных с по мощью команды dot-
net ef database update. Будет создана база данных, если она еще не су -
ществует, и будут применены все оставшиеся миграции.
EF Core не взаимодействует с базой данных при создании миграций,
а только когда вы явно обновляете базу данных, поэтому вы все равно
можете создавать их, когда не находитесь в сети.
Вы можете добавлять сущности в базу данных EF Core, создавая новую
сущность, e, вызвав _context.Add(e) в экземпляре контекста данных
вашего приложения, _context, и  _context.SaveChangesAsync(). Так вы
сгенерируете необходимые инструкции INSERT для добавления новых
строк в базу данных.

470 Глава 12 Cохраняем данные с Entity Framework Core
Вы можете загружать записи из базы данных, используя свойства
DbSet<T> класса DbContext. Они предоставляют интерфейс IQueryable,
поэтому вы можете использовать инструкции LINQ для фильтрации
и преобразования данных в базе данных, прежде чем они будут воз-
вращены.
Обновление сущности состоит из трех шагов: чтение сущности из
базы данных, изменение объекта и сохранение изменений в базе дан-
ных. EF Core будет отслеживать, какие свойства были изменены, чтобы
оптимизировать SQL-код, который она генерирует.
Вы можете удалять сущности в EF Core с по мощью метода Remove, но
следует тщательно подумать, нужна ли вам такая функциональность.
Часто техника мягкого	удаления	с использованием параметра IsDelet-
ed безопаснее и проще в реализации.
В этой главе рассматривается только часть вопросов, которые необхо-
димо принять во внимание при применении EF Core в своем приложе-
нии. Прежде чем использовать ее в промышленном окружении, нужно
учитывать, среди прочего, типы данных, сгенерированные для полей,
валидацию, параллелизм, наполнение исходных данных, миграции
в работающем приложении и в ситуации с веб-фермой.

13Конвейер	фильтров
MVC и Razor	Pages
В этой главе:
конвейер фильтров, и чем он отличается от промежуточного ПО;
создание собственных фильтров для рефакторинга сложных
методов действия;
использование фильтров авторизации для защиты методов
действий и Razor Pages;
прерывание выполнения конвейера фильтров, чтобы
игнорировать действие и выполнение обработчика страниц;
внедрение зависимостей в фильтры.
В первой части мы подробно рассмотрели фреймворки MVC и  Razor
Pages. Вы узнали, как используется маршрутизация для выбора метода
действия или страницы Razor, которую нужно выполнить. Вы также уви-
дели, что такое привязка модели, валидация и как сгенерировать ответ
с по мощью возврата объекта IActionResult из действий и обработчиков
страниц. В этой главе мы подробно рассмотрим фреймворки MVC и Ra-
zor Pages и познакомимся с  конвейером	 фильтров, который иногда на-
зывают конвейером	вызова	действий.
MVC и  Razor Pages используют несколько встроенных фильтров для
решения сквозных задач, таких как авторизация (контроль того, какие
пользователи к  каким методам действий и  страницам могут получить
доступ в  вашем приложении). Любое приложение с  концепцией поль-

472 Глава 13 Конвейер фильтров MVC и Razor Pages
зователей будет использовать как минимум фильтры авторизации, но
у фильтров гораздо больше возможностей.
В этой главе конвейер фильтров описывается в первую очередь в кон-
тексте запроса контроллера API. Вы узнаете, как создавать специальные
фильтры, которые можно использовать в  собственных приложениях,
и  как использовать их для уменьшения дублирования кода в  методах
действия. Вы получите представление, как настроить поведение прило-
жения для определенных действий и как применять фильтры глобально
для изменения всех действий приложения.
Вы также узнаете, как конвейер фильтров применяется к Razor Pages.
Конвейер фильтров Razor Pages почти идентичен конвейеру фильтров
контроллера MVC/API, поэтому мы сосредоточимся на их отличиях. Вы
узнаете, как использовать фильтры страниц на страницах Razor и  чем
они отличаются от фильтров действий.
Рассматривайте конвейер фильтров как конвейер промежуточного
ПО, работающий внутри MVC и Razor Pages. Подобно конвейеру проме-
жуточного ПО в ASP .NET Core, конвейер фильтров состоит из ряда ком-
понентов, соединенных в  виде некоего трубопровода, поэтому выход-
ные данные одного фильтра подаются на вход следующего.
Эта глава начинается с  рассмотрения сходств и  различий между
фильт рами и промежуточным ПО, и когда следует выбирать что-то одно
из них. Вы узнаете обо всех типах фильтров и о том, как они сочетаются,
чтобы создать конвейер фильтров для запроса, который достигает MVC
или Razor Pages.
В разделе 13.2 я  подробно расскажу вам о  каждом типе фильтров,
о том, как они вписываются в конвейер MVC и для чего их использовать.
Для каждого из них я приведу примеры реализации, которые вы можете
использовать в собственном приложении.
Ключевой особенностью фильтров является возможность прерывания
выполнения запроса путем генерации ответа и остановки прохождения
через конвейер. Это напоминает замыкание конвейера промежуточного
ПО, но есть небольшие различия. Более того, точное поведение каждого
фильтра немного отличается, и я расскажу об этом в разделе 13.3.
Обычно фильтры добавляют в  конвейер, реализуя их как атрибуты,
добавляемые в  классы контроллеров, методы действий и  Razor Pages.
К  сожалению, нельзя просто использовать внедрение зависимостей
с атрибутами из-за ограничений C#. В разделе 13.4 я покажу вам, как ис -
пользовать базовые классы ServiceFilterAttribute и  TypeFilterAttrib-
ute для активации внедрения зависимостей в фильтрах.
Прежде чем мы сможем приступить к  написанию кода, мы должны
познакомиться с основами конвейера фильтров. В первом разделе этой
главы объясняется, что такое конвейер фильтров, почему у  вас может
возникнуть желание использовать его и чем он отличается от конвейера
промежуточного ПО.

473 Что такое фильтры, и когда их использовать
13.1 Что такое фильтры, и когда
их использовать
В этом разделе вы узнаете все о конвейере фильтров. Вы увидите, как он
вписывается в жизненный цикл типичного запроса, какие есть отличия
при его использовании в MVC или Razor Pages и чем фильтры отличают -
ся от промежуточного ПО. Вы узнаете о шести типах фильтров и о том,
как добавить их в приложения, как контролировать порядок, в котором
они выполняются при обработке запроса.
Конвейер фильтров – относительно простая концепция, поскольку он
обеспечивает	 точки	подключения	 в обычном MVC-запросе, как показано
на рис. 13.1. Например, вы хотите убедиться, что пользователи могут соз-
давать или редактировать продукты в приложении для онлайн-торгов-
ли, только если они выполнили вход в приложение. Приложение будет
перенаправлять анонимных пользователей на страницу входа, вместо
того чтобы выполнить действие.
1. Получен запрос URL-адреса /api/product/1
2.  Компонент маршрутизации сопоставляет
запрос с действием Get в ProductController
и задает для id значение 1
3.  Множество различных фильтров
запускаются как часть выполнения
в промежуточном программном
обеспечении конечной точки
4.  Фильтры запускаются перед привязкой
модели, перед выполнением метода
действия, а также до и после выполнения
IActionResultЗапрос
Компонент маршрутизации
Привязка модели /
валидация
Действие
Контроллер API
Выполнение IActionResult
JSONРис. 13.1 Фильтры запускаются
в нескольких точках
EndpointMiddleware как часть
обычной обработки запроса MVC.
Аналогичный конвейер существует
и для запросов Razor PageEndpoint middleware

474 Глава 13 Конвейер фильтров MVC и Razor Pages
Если бы не было фильтров, то вам нужно было бы включить одина-
ковый код для проверки авторизованного пользователя на выполнении
каждого конкретного метода действия. При таком подходе фреймворк
MVC по-прежнему выполнял бы привязку и проверку модели, даже если
пользователь не выполнил вход.
С помощью фильтров вы можете использовать точки	подключения
в запросе MVC для выполнения общего кода во всех или какой-то их ча-
сти. Таким образом, можно делать множество разных вещей, например:
убедиться, что пользователь выполнил вход, перед выполнением
метода действия, привязки модели или валидации;
настроить выходной формат определенных методов действий;
обработать ошибки валидации модели до вызова метода действия;
перехватить исключения из метода действия и обработать их осо-
бым образом.
Во многих отношениях конвейер фильтров похож на конвейер про-
межуточного ПО, но ограничен только запросами MVC и Razor Pages. Как
и промежуточное ПО, фильтры хорошо подходят для решения сквозных
задач вашего приложения и во многих случаях являются полезным ин-
струментом для уменьшения дублирования кода.
13.1.1 Конвейер фильтров MVC
Как было показано на рис.  13.1, фильтры выполняются в  нескольких
точках запроса MVC. Линейное представление запроса MVC и конвейе-
ра фильтров, которое я использовал до сих пор, не совсем соответству -
ет тому, как работают эти фильтры. Есть пять типов фильтров, которые
применяются к запросам MVC, каждый из которых выполняется на раз-
ных	этапах фреймворка MVC, как показано на рис. 13.2.
Фильтры на каждой стадии соотносятся с определенным вариантом
использования благодаря своему конкретному расположению в конвейе-
ре относительно привязки модели, выполнения действия и выполнения
результата:
фильтры	 авторизации – запускаются первыми в конвейере, поэто-
му полезны для защиты ваших API и методов действий. Если фильтр
авторизации считает, что запрос неавторизован, он завершит за-
прос, предотвращая выполнение остальной части конвейера (или
действия);
фильтры	 ресурсов – следующими после авторизации запускаются
фильтры ресурсов. Они тоже могут выполняться в конце конвейера,
почти так же, как компоненты промежуточного ПО могут обраба-
тывать входящий запрос и исходящий ответ. Кроме того, фильтры
ресурсов могут полностью прервать выполнение конвейера запро-
сов и напрямую вернуть ответ.
Благодаря более близкому расположению в конвейере фильтры ре-
сурсов можно использовать по-разному. Можно добавить метрики
к  методу действия, предотвратить выполнение метода действия,
если запрошен неподдерживаемый тип содержимого, или, когда

475 Что такое фильтры, и когда их использовать
они выполняются перед привязкой модели, контролировать способ
работы привязки модели для этого запроса;
фильтры	 действий  – фильтры действий запускаются непосред-
ственно до и после выполнения метода действия. Поскольку при-
вязка модели уже произошла, фильтры действий позволяют управ-
лять аргументами метода – до выполнения – или могут полностью
прервать выполнение действия и вернуть другой объект IActionRe-
sult. Поскольку они тоже запускаются после выполнения действия,
то могут дополнительно настроить объект IActionResult, возвраща-
емый действием, до того, как результат действия будет выполнен;
фильтры	 исключений – фильтры исключений могут перехватывать
исключения, возникающие в конвейере фильтров, и обрабатывать
их соответствующим образом. Можно использовать фильтры ис -
ключений, чтобы написать специальный код обработки ошибок для
MVC, который может быть полезен в некоторых ситуациях. Напри-
мер, вы можете перехватить исключения в действиях API и отфор-
матировать их иначе, чем исключения на страницах Razor;
фильтры	 результатов – фильтры результатов запускаются до и пос -
ле выполнения объекта метода действия IActionResult. Вы можете
использовать фильтры результатов для управления выполнением
результата или даже прервать его выполнение.
Request Response
Фильтры авторизации запускаются первыми
для каждого MVC-запроса. Если запрос
не авторизован, выполнение конвейера
будет прервано Фильтры ресурсов также
запускаются в конце конвейера
после выполнения результата
Если где-то в конвейере
возникает исключение,
выполняется ExceptionFilter
Если метод действия
возвращает IActionResult,
фильтры результатов будут
выполняться до и после
выполнения IActionResultФильтры ресурсов запускаются следующими,
перед выполнением привязки модели
Фильтры действий запускаются до и после
выполнения метода действия. Поскольку они
запускаются после привязки модели, вы можете
использовать их для настройки аргументов,
передаваемых действиюФильтры
авторизации
Фильтры ресурсов
Привязка модели /
валидацияВызов действия
Фильтры действийФильтры
исключений
Фильтры результатов
Выполнение IActionResult
Рис. 13.2 Конвейер фильтров MVC и пять различных этапов обработки запроса. Некоторые
фильтры (ресурсов, действий и результатов) запускаются дважды, до и после оставшейся части
конвейера

476 Глава 13 Конвейер фильтров MVC и Razor Pages
Какой именно фильтр вы выберете для реализации, будет зависеть
от функциональности, которую вы пытаетесь ввести. Хотите как можно
раньше прервать выполнение запроса? Фильтры ресурсов хорошо под-
ходят для этого. Нужен доступ к параметрам метода действия? Исполь-
зуйте фильтр действий.
Рассматривайте конвейер фильтров как небольшой конвейер про-
межуточного ПО, который живет сам по себе в фреймворке MVC. Также
можно рассматривать фильтры как точки	подключения	 в процессе вызо-
ва действия MVC, позволяющие выполнять код в определенный момент
жизненного цикла запроса.
В этом разделе описывается, как конвейер фильтров работает с конт -
роллерами MVC, например для создания API. Razor Pages использует
почти идентичный конвейер фильтров.
13.1.2 Конвейер фильтров Razor Pages
Razor Pages использует ту же базовую архитектуру, что и контроллеры
API, поэтому, возможно, неудивительно, что его конвейер фильтров
практически идентичен. Единственная разница между конвейерами за-
ключается в том, что Razor Pages не использует фильтры действий, а ис -
пользует фильтры страниц, как показано на рис. 13.3.
Фильтры авторизации, ресурсов, исключений и результатов – это те
же самые фильтры, которые вы видели в конвейере MVC. Они действу -
ют одинаково, служат одним и тем же целям, и прервать их выполнение
можно таким же образом.
ПРИМЕЧАНИЕ  Эти фильтры – буквально те же классы, которые
используются в  Razor Pages и  MVC. Например, если вы создаете
фильтр исключений и регистрируете его глобально, фильтр в оди-
наковой степени будет применяться ко всем вашим контроллерам
API и страницам Razor Pages.
Отличие конвейера фильтров Razor Pages заключается в том, что он
использует фильтры	 страниц вместо фильтров действий. В отличие от
других типов фильтров, фильтры страниц запускаются в  конвейере
трижды:
после	выбора	обработчика	 страницы – после выполнения фильтров
ресурсов выбирается обработчик страницы на основе HTTP-метода
запроса и  значения маршрута {handler}, как вы узнали в  главе 5.
После выбора обработчика страницы метод фильтра страницы вы-
полняется впервые. При этом прервать выполнение конвейера на
данном этапе нельзя, а привязка модели и валидация еще не вы-
полнены;
после	привязки	 модели – после выполнения первого фильтра стра-
ницы запрос привязывается к моделям привязки страницы Razor,
и выполняется валидация. Это очень похоже на выполнение фильт -
ра действий для контроллеров API. Здесь вы можете манипулиро-

477 Что такое фильтры, и когда их использовать
вать данными, привязанными к  модели, или полностью прервать
выполнение обработчика страницы, возвращая другой объект IAc-
tionResult;
после	выполнения	 обработчика	 страницы – если вы не прерываете
выполнение обработчика страницы, то фильтр страниц запускается
в третий и последний раз после выполнения обработчика страницы.
На данном этапе вы можете настроить IActionResult, возвращае-
мый обработчиком страницы перед выполнением результата.
Request Response
Фильтры авторизации и ресурсов работают точно
так же для запросов MVC и Razor Pages
Фильтры исключений и результатов
работают точно так же для
запросов MVC и Razor PagesФильтры страниц запускаются трижды: после
выбора обработчика страницы, после привязки
модели и после выполнения обработчика
страницы
Фильтры страниц могут прервать
выполнение обработчика страниц, чтобы тот
не выполнялся, точно так же как фильтры
действия могут прервать выполнение вызова
действияФильтры
авторизации
Фильтры ресурсов
Привязка модели /
валидацияВыбор обработчика
страницыВызов обработчика
страницы
Фильтры страниц
Фильтры
исключений
Фильтры результатов
Выполнение IActionResult
Рис. 13.3 Конвейер фильтров Razor Pages и пять различных этапов обработки запроса.
Фильтры авторизации, ресурсов, исключений и результатов выполняются точно так же,
как и для конвейера MVC. Фильтры страниц – специфическая особенность Razor Pages.
Они выполняются в трех местах: после выбора обработчика страницы, после привязки модели
и валидации и после выполнения обработчика страницы
Тройное выполнение фильтров страниц немного затрудняет визуа-
лизацию конвейера, но вы можете рассматривать их просто как расши-
ренные фильтры действий. Все, что можно делать с фильтром действий,
можно делать и с фильтром страницы. Кроме того, при необходимости
вы можете выполнить подключение после выбора обработчика стра-
ницы.

478 Глава 13 Конвейер фильтров MVC и Razor Pages
СОВЕТ  При каждом выполнении фильтра осуществлется отдель-
ный метод соответствующего интерфейса, поэтому легко узнать,
в каком месте конвейера вы находитесь, и при желании выполнить
фильтр только в одном из возможных мест.
Один из основных вопросов, который я  слышу, когда кто-то узна-
ет о  фильтрах ASP .NET Core: «Зачем они нам нужны?» Если конвейер
фильтров похож на мини-конвейер промежуточного ПО, почему бы
не использовать его компонент напрямую, вместо того чтобы вводить
концепцию фильтра? Это интересный момент, о  котором я  расскажу
в следующем разделе.
13.1.3 Фильтры или промежуточное ПО: что выбрать?
Конвейер фильтров во многом похож на конвейер промежуточного ПО,
но здесь есть несколько тонких отличий, которые следует учитывать при
выборе того, какой подход использовать. При рассмотрении схожих осо-
бенностей у них есть три основные параллели:
запросы	 проходят	 через	компонент	 промежуточного	 ПО	на	пути
«внутрь», 	а  ответы	 снова	проходят	 через	него	уже	«на	выходе».
Фильт ры ресурсов, действий и результатов также являются двусто-
ронними, хотя фильтры авторизации и  исключений запускаются
только один раз для запроса, а фильтры страниц – трижды;
промежуточное	 ПО	может	завершить	 запрос,	вернув	ответ,	вместо
того	чтобы	передать	 его	более	позднему	 компоненту. Фильтры также
могут прервать выполнение конвейера, возвращая ответ;
промежуточное	 ПО	часто	используется	 для	решения	 сквозных	 задач
приложения, 	таких	как	журналирование, 	профилирование	 произво-
дительности	 и обработка	 исключений. Фильтры также подходят для
решения такого рода проблем.
И напротив, между ними есть три основных различия:
промежуточное ПО может выполняться для всех запросов; фильт -
ры будут работать только для запросов, доходящих до компонента
EndpointMiddleware и выполняющих действие контроллера API или
страницу Razor;
фильтры имеют доступ к конструкциям MVC, таким как ModelState
и IActionResults. Промежуточное ПО, как правило, не зависит от
MVC и Razor Pages и работает на «более низком уровне», поэтому не
может использовать эти концепции;
фильтры можно легко применить ко подмножеству запросов; на-
пример, всем действиям в одном контроллере или одной страни-
це Razor. Промежуточное ПО не имеет этой концепции в качестве
полноправной сущности (хотя подобного можно было бы добиться
с по мощью специальных компонентов промежуточного ПО).
Все это хорошо, но как интерпретировать эти различия? Когда и что
следует выбрать?

479 Что такое фильтры, и когда их использовать
Мне нравится рассматривать промежуточное ПО и фильтры как во-
прос специфичности. Промежуточное ПО  – более общая концепция,
которая работает с низкоуровневыми примитивами, такими как Http-
Context, поэтому имеет более широкий охват. Если необходимая вам
функциональность не имеет специфических требований, связанных
с MVC, то вы должны использовать компонент промежуточного ПО. Об-
работка исключений – отличный пример для этого; исключения могут
произойти где угодно в приложении, и вам необходимо обрабатывать
их, поэтому имеет смысл использовать компонент для обработки ис -
ключений.
С другой стороны, если вам все же нужен доступ к конструкциям MVC
или для некоторых действий MVC вам нужно иное поведение, то следует
рассмотреть возможность использования фильтра. Как ни странно, их
также можно применять и  при обработке исключений. Вам не нужно,
чтобы исключения в ваших веб-контроллерах API автоматически гене-
рировали HTML-страницы с  ошибками, когда клиент ожидает увидеть
данные в формате JSON. Вместо этого можно использовать фильтр ис -
ключений для действий веб-API, чтобы визуализировать исключения
в формате JSON, позволяя компоненту обработки исключений перехва-
тывать ошибки Razor Pages в приложении.
СОВЕТ  По возможности рассмотрите перспективу использова-
ния промежуточного ПО для решения сквозных задач. Используй-
те фильтры, когда вам нужно иное поведение для разных методов
действий или когда функциональность полагается на концепции
MVC, такие как валидация ModelState.
«Промежуточное ПО или фильтры» – тонкий вопрос, и не важно, что
вы выберете, если это вам подходит. Вы даже можете использовать ком-
поненты промежуточного ПО внутри конвейера фильтров как фильтры,
но эта тема выходит за рамки данной книги.
СОВЕТ  Промежуточное ПО в качестве фильтров появилось в ASP .
NET Core версии 1.1 и также доступно в  более поздних версиях.
Классический вариант использования – локализация запросов на
несколько языков. У меня есть серия статей о том, как использо-
вать эту функцию: http://mng.b z/RXa0.
По отдельности фильтры могут быть немного абстрактными, поэтому
в следующем разделе мы взглянем на код и узнаем, как написать соб-
ственный фильтр в ASP .NET Core.
13.1.4 Создание простого фильтра
В этом разделе я покажу вам, как создать свои первые фильтры; в раз-
деле 13.1.5 вы увидите, как применить их к контроллерам и действиям
MVC. Начнем с малого, создадим фильтры, которые просто осуществля-

480 Глава 13 Конвейер фильтров MVC и Razor Pages
ют вывод в консоль, а в разделе 13.2 рассмотрим более практичные при-
меры и обсудим некоторые их нюансы.
Фильтр определенного этапа реализуется с по мощью одной из пары
интерфейсов – одного синхронного (sync) и одного асинхронного (async):
фильтры	 авторизации – IAuthorizationFilter или IAsyncAuthoriza-
tionFilter;
фильтры	ресурсов – IResourceFilter или IAsyncResourceFilter;
фильтры	действий – IActionFilter или IAsyncActionFilter;
фильтры	страниц – IPageFilter или IAsyncPageFilter;
фильтры	 исключений – IExceptionFilter или IAsyncExceptionFilter;
фильтры	результатов – IResultFilter или IAsyncResultFilter.
Для реализации фильтра можно использовать любой класс POCO, но
обычно они реализуются как атрибуты C#, которые можно использовать
для декорирования контроллеров, действий и страниц Razor Pages, как
будет показано в  разделе 13.1.5. Синхронный и  асинхронный интер-
фейсы позволяют добиться одинаковых результатов, поэтому вариант,
который выберете вы, должен зависеть от того, требуется ли сервисам,
которые вы вызываете в фильтре, поддержка асинхронного режима.
ПРИМЕЧАНИЕ  Следует реализовать один из интерфейсов, но не
оба. Если вы реализуете оба варианта, будет использоваться только
асинхронный интерфейс.
В листинге 13.1 показан фильтр ресурсов, который реализует интер-
фейс IResourceFilter и осуществляет вывод в консоль при выполнении.
Метод OnResourceExecuting вызывается, когда запрос сначала достигает
этапа обработки, на котором вызывается фильтр ресурсов. А вот метод
OnResourceExecuted вызывается после выполнения остальной части кон-
вейера: после привязки модели, выполнения действия, выполнения ре-
зультата и запуска всех промежуточных фильтров.
Листинг 13.1  Пример фильтра ресурсов, реализующего интерфейс
IResourceFilter
public class LogResourceFilter : Attribute, IResourceFilter
{
public void OnResourceExecuting(
ResourceExecutingContext context)
{
Console.WriteLine("Executing!");
}
public void OnResourceExecuted(
ResourceExecutedContext context)
{
Console.WriteLine("Executed"");
}
} Выполняется в начале конвейера
после фильтров авторизации.
Контекст содержит HttpContext,
сведения о маршрутизации
и информацию о текущем действии.
Выполняется после привязки
модели, выполнения действия
и результата.
Содержит дополнительную контекстную
информацию, такую как IActionResult,
возвращаемую действием.

481 Что такое фильтры, и когда их использовать
Методы интерфейса просты и  аналогичны для каждого этапа кон-
вейера, передавая объект контекста в качестве параметра метода. У каж -
дого из синхронных фильтров с двумя методами есть методы *Executing
и *Executed. Тип аргумента разный для каждого фильтра, но он содержит
все сведения о конвейере.
Например, ResourceExecutingContext, передаваемый фильтру ресур-
сов, содержит сам объект HttpContext, подробные сведения о маршруте,
который выбрал это действие, детали самого действия и т. д. Контексты
для более поздних фильтров будут содержать дополнительные подроб-
ности, такие как аргументы метода действия для фильтра действий и  Mo-
del State.
Объект контекста для метода ResourceExecutedContext похож, но он
также содержит сведения о том, как исполнилась остальная часть кон-
вейера. Вы можете проверить, есть ли необработанное исключение, по-
смотреть, не было ли прервано выполнение конвейера фильтров на этом
же этапе другим фильтром, или увидеть IActionResult, используемый
для генерации ответа.
Эти мощные объекты являются ключом к расширенному поведению
фильтров, такому как прерывание выполнения конвейера и обработка
исключений. Мы будем использовать их в разделе 13.2 при создании бо-
лее сложных примеров фильтров.
Асинхронная версия фильтра ресурсов требует реализации одного
метода, как показано в листинге 13.2. Что касается синхронной версии,
то вам передается объект ResourceExecutingContext в качестве аргумен-
та и делегат, представляющий оставшуюся часть конвейера. Вы должны
вызвать этот делегат (асинхронно), чтобы выполнить оставшуюся часть
конвейера и вернуть экземпляр ResourceExecutedContext.
Листинг 13.2  Пример фильтра ресурсов, реализующего
IAsyncResourceFilter
public class LogAsyncResourceFilter : Attribute, IAsyncResourceFilter
{
public async Task OnResourceExecutionAsync(
ResourceExecutingContext context,
ResourceExecutionDelegate next)
{
Console.WriteLine("Executing async!");
ResourceExecutedContext executedContext = await next();
Console.WriteLine("Executed async!");
}
}
Реализации синхронных и асинхронных фильтров имеют небольшие
различия, но для большинства целей они идентичны. Я рекомендую по
возможности реализовать синхронную версию и возвращаться к асин-
хронной только по необходимости.Выполняется в начале конвейера
после фильтров авторизации.
Вам предоставлен делегат,
инкапсулирующий оставшуюся
часть конвейера фильтров.
Вызывается перед выполнением
остальной части конвейера.Выполняет оставшуюся часть
конвейера и получает экземпляр
ResourceExecutedContext.
Вызывается после выполнения
оставшейся части конвейера.

482 Глава 13 Конвейер фильтров MVC и Razor Pages
Вы создали несколько фильтров, поэтому мы должны посмотреть, как
использовать их в  приложении. В  следующем разделе мы рассмотрим
две конкретные проблемы: как контролировать, какие запросы выпол-
няют ваши новые фильтры, и  как контролировать порядок, в  котором
они выполняются.
13.1.5 Добавляем фильтры к действиям, контроллерам,
страницам Razor Pages и глобально
В разделе 13.1.2 мы обсуждали сходства и различия между промежуточ-
ным ПО и  фильтрами. Одно из этих различий заключается в том, что
фильтры могут быть привязаны к определенным действиям или конт -
роллерам, чтобы они запускались только для определенных запросов.
Как вариант можно применить фильтр глобально, чтобы он запускался
для каждого действия MVC и страницы Razor.
Добавляя фильтры разными способами, можно добиться разных ре-
зультатов. Представьте, что у  вас есть фильтр, который заставляет вас
выполнить вход в приложение для выполнения действия. То, как вы до-
бавляете фильтр в приложение, существенно изменит его поведение:
применение	 фильтра	 к отдельному	 действию	 или	странице	 Razor –
анонимные пользователи могут просматривать приложение как
обычно, но если они попытаются получить доступ к защищенному
действию или странице Razor, их вынудят выполнить вход;
применение	 фильтра	 к контроллеру – анонимные пользователи мо-
гут получить доступ к действиям из других контроллеров, но доступ
к любому действию на защищенном контроллере заставит их вы-
полнить вход;
применение	 фильтра	 глобально – пользователи не могут использо-
вать приложение, не выполнив вход. Любая попытка получить до-
ступ к действию или странице Razor перенаправит пользователя на
страницу входа.
ПРИМЕЧАНИЕ  В ASP .NET Core уже есть такой фильтр: Authorize-
Filter. Я расскажу о нем в разделе 13.2.1, а подробности вы узнаете
в главе 15.
Как я уже писал в предыдущем разделе, обычно фильтры создаются
как атрибуты, и для этого есть веская причина – так проще применять
их к контроллерам MVC, действиям и страницам Razor. В этом разделе
вы увидите, как применить фильтр LogResourceFilter из листинга 13.1
к действию, контроллеру, странице Razor и глобально. Уровень, на кото-
ром применяется фильтр, называется областью	действия.
ОПРЕДЕЛЕНИЕ  Область	 действия фильтра определяет, к какому
количеству действий он применяется. Она может быть ограничена
методом действия, контроллером, страницей Razor или глобально.

483 Что такое фильтры, и когда их использовать
Мы начнем с наиболее конкретной области – применим фильтры к од-
ному действию. В  следующем листинге показан пример контроллера
MVC, у которого есть два метода действия: один с фильтром LogResource-
Filter и второй без него.
Листинг 13.3 Применение фильтров к методу действия
public class RecipeController : ControllerBase
{
[LogResourceFilter]
public IActionResult Index()
{
return Ok();
}
public IActionResult View()
{
return OK();
}
}
В качестве альтернативы, если вы хотите применить один и  тот же
фильтр к каждому методу действия, можно добавить атрибут в область
контроллера, как показано в следующем листинге. Каждый метод дей-
ствия в контроллере будет использовать LogResourceFilter, без необхо-
димости специально декорировать методы.
Листинг 13.4 Применение фильтров к контроллеру
[LogResourceFilter]
public class RecipeController : ControllerBase
{
public IActionResult Index ()
{
return Ok();
}
public IActionResult View()
{
return Ok();
}
}
Что касается страниц Razor, то можно применять атрибуты к  PageModel,
как показано в следующем листинге. Фильтр применяется ко всем обра-
ботчикам страниц на странице Razor – невозможно применить фильтры
к одному обработчику; вы должны применять их на уровне страницы.
Листинг 13.5 Применение фильтров к странице Razor
[LogResourceFilter]
public class IndexModel : PageModel
{LogResourceFilter будет работать как часть
конвейера при выполнении этого действия.
У этого метода действия нет фильтров
на уровне действия.
LogResourceFilter добавляется
к каждому действию контроллера.
Каждое действие в контроллере
декорировано фильтром.
LogResourceFilter добавляется
к PageModel страницы Razor.

484 Глава 13 Конвейер фильтров MVC и Razor Pages
public void OnGet()
{
}
public void OnPost()
{
}
}
Фильтры, которые вы применяете в  качестве атрибутов к  контрол-
лерам, действиям и  страницам Razor, автоматически обнаруживаются
фреймворком при запуске приложения. Что касается общих атрибутов,
можно пойти еще дальше и применить фильтры глобально, без необхо-
димости декорировать отдельные классы.
Глобальные фильтры добавляются иначе, нежели фильтры, применяе-
мые к контроллерам или действиям, – они добавляются непосредственно
к сервисам MVC при конфигурировании контроллеров и страниц Razor
в классе Startup. В этом листинге показаны три эквивалентных способа
глобального применения фильтра:
Листинг 13.6 Глобальное применение фильтров к приложению
public class Startup
{
public void ConfigureServices(IServiceCollection services)
{
services.AddControllers(options =>
{
options.Filters.Add(new LogResourceFilter());
options.Filters.Add(typeof(LogResourceFilter));
options.Filters.Add<LogResourceFilter>();
});
}
}
Можно настроить MvcOptions с  по мощью перегруженного варианта
метода AddControllers(). Когда вы настраиваете фильтры глобально,
они применяются как к  контроллерам, так и  ко всем страницам Razor
в  приложении. Если вы используете в  приложении страницы Razor, то
перегруженного варианта для настройки MvcOptions нет. Вместо этого
нужно использовать метод расширения AddMvcOptions() для настройки
фильтров, как показано в следующем листинге.
Листинг 13.7  Глобальное применение фильтров к приложению
Razor Pages
public class Startup
{
public void ConfigureServices(IServiceCollection services)
{Фильтр применяется к каждому
обработчику страницы на странице.
Добавляет фильтры с помощью
объекта MvcOptions.
Вы можете передать
экземпляр фильтра
напрямую… …или передать тип
фильтра и позволить
фреймворку создать его.Кроме того, фреймворк может создать
глобальный фильтр, используя параметр
обобщенного типа.

485 Что такое фильтры, и когда их использовать
services.AddRazorPages()
.AddMvcOptions(options =>
{
options.Filters.Add(new LogResourceFilter());
options.Filters.Add(typeof(LogResourceFilter));
options.Filters.Add<LogResourceFilter>();
});
}
}
Имея в наличии три потенциально разные области действия, вам час -
то будут встречаться методы действий, к которым применено несколько
фильтров: некоторые применяются непосредственно к методу действия,
а другие унаследованы от контроллера или глобально. Тогда возникает
вопрос: какой фильтр запускается первым?
13.1.6 Порядок выполнения фильтров
Вы видели, что конвейер фильтров содержит пять различных этапов, по
одному для каждого типа фильтра. Эти этапы всегда выполняются в фик -
сированном порядке, описанном в разделах 13.1.1 и 13.1.2. Но на каждом
этапе у вас также может быть несколько фильтров одного типа (напри-
мер, несколько фильтров ресурсов), которые являются частью конвейе ра
одного метода действия. Все они могут иметь несколько областей	 дей-
ствия, в  зависимости от того, как вы их добавили, как было показано
в последнем разделе.
В этом разделе мы рассмотрим порядок	 фильтров	 в рамках	 определен-
ного	этапа и то, как на него влияет область действия. Мы начнем с рас -
смотрения порядка по умолчанию, а  затем перейдем к  способам на-
стройки порядка в соответствии с вашими требованиями.
порядок  выполнения  фильтров  по уМолчанию
Размышляя о порядке выполнения фильтров, важно помнить, что фильт -
ры ресурсов, действий и результатов реализуют два метода: *Executing
перед методом и  *Executed после метода. Кроме того, фильтры страниц
реализуют три метода!
Порядок, в котором выполняется каждый метод, зависит от области
действия фильтра, как показано на рис. 13.4 для этапа обработки запро-
са, на котором вызывается фильтр ресурсов.
По умолчанию фильтры выполняются от самой широкой области (гло-
бальные) до самого узкой (действие) при выполнении метода *Executing
для каждого этапа. Методы *Executed для фильтров выполняются в об-
ратном порядке.
Порядок выполнения для страниц Razor несколько проще, учитывая,
что у вас всего две области действия – глобальные фильтры и фильтры,
которые применяются к страницам Razor. Для страниц Razor глобальные
фильтры сначала выполняют методы *Executing и  PageHandlerSelected, Данный метод
не позволяет передавать
лямбда-функцию для
настройки MvcOptions.Вы должны использовать метод расширения,
чтобы добавить фильтры к объекту MvcOptions.
Вы можете настроить фильтры любым
из способов, показанных ранее.

486 Глава 13 Конвейер фильтров MVC и Razor Pages
а  затем фильтры страниц. Для методов *Executed фильтры работают
в обратном порядке.
Глобальные фильтры
запускаются первыми
на каждом этапе
Фильтры уровня
контроллера, запускаются
после глобальных фильтров
и перед фильтрами действий
Фильтры уровня действия
выполняются последнимиОбласть действия фильтров
определяет порядок, в котором
они запускаются на одном этапе
Фильтры также могут
применяться к базовым классам
контроллеров. Фильтры базового
класса запускаются позже,
чем фильтры на производных
контроллерахГлобальный фильтр
Фильтр контроллера
Фильтр базового
контроллера
Фильтр действия
Рис. 13.4 Порядок выполнения фильтров по умолчанию на определенном этапе
в зависимости от области действия фильтров. Для метода *Executing сначала
запускаются глобальные фильтры, затем фильтры, применяемые к контроллерам,
и, наконец, фильтры, применяемые к действиям. Что касается метода *Executed,
то здесь фильтры запускаются в обратном порядке
Иногда вы будете сталкиваться с тем, что вам нужно более тщательно
контролировать этот порядок, особенно если у вас, например, есть не-
сколько фильтров действий, применяемых в одной и той же области дей-
ствия. Конвейер фильтров удовлетворяет это требование посредством
интерфейса IOrderedFilter.
переопределение  порядка  выполнения  фильтров  по уМолчанию
с поМощью  интерфейса  ioRdeRed FiL TeR
Фильтры отлично подходят для выделения кода решения сквозных задач
из действий вашего контроллера и страницы Razor, но если к действию
применено несколько фильтров, вам часто придется контролировать
точный порядок, в котором они выполняются.
Область действия может помочь вам в  этом, но для других случаев
можно реализовать интерфейс IOrderedFilter. Он состоит из одного-
единственного свойства Order:
public interface IOrderedFilter
{
int Order { get; }
}
Вы можете реализовать это свойство в  фильтрах, чтобы задать по-
рядок их выполнения. Конвейер фильтров упорядочивает фильтры на
определенном этапе сначала на основе этого значения, от наименьшего
до наивысшего, и использует порядок выполнения фильтров по умолча-

487 Создание фильтров для приложения
нию для упорядочивания фильтров с одинаковыми значениями порядка
выполнения, как показано на рис. 13.5.
Фильтры с наименьшим
порядковым номером
запускаются первыми. Область
действия используется для
определения порядка для
случаев равенства порядковых
номеров
По умолчанию порядок
равен 0
Фильтры с наибольшим
значением Order запускаются
последними на этапеПорядок и область действия
фильтров определяют порядок,
в котором они работают
на одном этапе Фильтр контроллера
Order = –1
Фильтр контроллера
Order = 0Фильтр действия
Order = –1
Фильтр действия
Order = 0Глобальный фильтр
Order = 0
Глобальный фильтр
Order = 1
Рис. 13.5 Управление порядком выполнения фильтров для определенного этапа
с по мощью интерфейса IOrderedFilter. Фильтры сначала упорядочиваются по
свойству Order, а затем по области действия
Фильтры для Order = -1 выполняются первыми, поскольку имеют наи-
меньшее значение Order. Фильтр контроллеров выполняется первым, по-
тому что имеет более широкую область действия, чем фильтр действий.
Далее выполняются фильтры с  Order = 0 в порядке по умолчанию, как
показано на рис. 13.5. В конце выполняется фильтр с Order = 1.
По умолчанию, если фильтр не реализует интерфейс IOrderedFilter,
предполагается, что у  него Order = 0. Все фильтры, поставляемые как
часть ASP .NET Core, имеют Order = 0, поэтому вы можете добавлять соб-
ственные фильтры как перед, так и после встроенных.
В этом разделе описана бóльшая часть технических деталей, необхо-
димых для использования и создания собственных реализаций фильт -
ров. В следующем разделе вы ознакомитесь с некоторыми встроенными
фильтрами, предоставляемыми ASP .NET Core, а  также практическими
примерами фильтров, которые вы можете использовать в приложениях.
13.2 Создание фильтров для приложения
ASP .NET Core включает в себя ряд фильтров, которые вы можете исполь-
зовать, но зачастую самые полезные фильтры – это собственные фильт -
ры, созданные конкретно для приложения. В этом разделе мы прорабо-

488 Глава 13 Конвейер фильтров MVC и Razor Pages
таем каждый из шести типов фильтров. Я объясню подробнее, для чего
они нужны и когда нужно их использовать. Я выделю примеры фильтров,
которые являются частью самого фреймворка ASP .NET Core, и вы увиди-
те, как создавать собственные фильтры для приложения, используемого
в качестве примера.
Чтобы вы могли работать с чем-то реалистичным, начнем с контрол-
лера веб-API для доступа к  приложению рецептов из главы 12. Этот
контроллер содержит два действия: одно для получения RecipeDetail-
ViewModel и  другое, чтобы обновить сущность Recipe, добавляя новые
значения. В этом листинге показана ваша отправная точка для этой гла-
вы, включая оба метода действия.
Листинг 13.8  Контроллер веб-API Recipe перед рефакторингом для
использования фильтров
[Route("api/recipe")]
public class RecipeApiController : ControllerBase
{
private const bool IsEnabled = true;
public RecipeService _service;
public RecipeApiController(RecipeService service)
{
_service = service;
}
[HttpGet("{id}")]
public IActionResult Get(int id)
{
if (!IsEnabled) { return BadRequest(); }
try
{
if (!_service.DoesRecipeExist(id))
{
return NotFound();
}
var detail = _service.GetRecipeDetail(id);
Response.GetTypedHeaders().LastModified =
detail.LastModified;
return Ok(detail);
}
catch (Exception ex)
{
return GetErrorResponse(ex);
}
}
[HttpPost("{id}")]
public IActionResult Edit(
int id, [FromBody] UpdateRecipeCommand command)
{
if (!IsEnabled) { return BadRequest(); }
tryЭто поле будет передано как
конфигурация и используется для
управления доступом к действиям.
Если API не активирован,
блокируем дальнейшее
выполнение.
Если запрашиваемый рецепт
не существует, возвращаем ответ 404.Получаем модель
представления
RecipeDetail.
Задаем для заголовка ответа
LastModified значение в модели.
Возвращаем
модель
представления
с ответом 200.Если возникает исключение, перехватываем
его и возвращаем ошибку в ожидаемом
формате, например ошибка 500.
Если API не включен,
заблокируйте дальнейшее
выполнение.

489 Создание фильтров для приложения
{
if (!ModelState.IsValid)
{
return BadRequest(ModelState);
}
if (!_service.DoesRecipeExist(id))
{
return NotFound();
}
_service.UpdateRecipe(command);
return Ok();
}
catch (Exception ex)
{
return GetErrorResponse(ex);
}
}
private static IActionResult GetErrorResponse(Exception ex)
{
var error = new ProblemDetails
{
Title = "An error occurred",
Detail = context.Exception.Message,
Status = 500,
Type = "https://httpstatuses.com/500"
};
return new ObjectResult(error)
{
StatusCode = 500
};
}
}
Эти методы действий содержат большое количество кода, который
скрывает намерение каждого действия. Между методами также доволь-
но много дублирования кода, например когда проверяется, существует
ли сущность Recipe, и при форматировании исключений.
В этом разделе мы проведем рефакторинг этого контроллера, что-
бы использовать фильтры для всего кода в методах, который не связан
с целью  каждого действия. К концу главы у вас будет гораздо более про-
стой контроллер, который будет намного легче понять.
Листинг 13.9 Контроллер веб-API Recipe после рефакторинга
[Route("api/recipe")]
[ValidateModel, HandleException, FeatureEnabled(IsEnabled = true)]
public class RecipeApiController : ControllerBase
{
public RecipeService _service;
public RecipeApiController(RecipeService service)Проверяем модель привязки
и возвращаем ответ 400,
если есть ошибки.
Если запрашиваемый рецепт
не существует, возвращаем ответ 404.Обновляем рецепт
из команды
и возвращаем
ответ 200.
Если возникает исключение, перехватываем
его и возвращаем ошибку в ожидаемом
формате, например ошибка 500.
Фильтры инкапсулируют
бóльшую часть логики, общей
для нескольких методов
действий.

490 Глава 13 Конвейер фильтров MVC и Razor Pages
{
_service = service;
}
[HttpGet("{id}"), EnsureRecipeExists, AddLastModifiedHeader]
public IActionResult Get(int id)
{
var detail = _service.GetRecipeDetail(id);
return Ok(detail);
}
[HttpPost("{id}"), EnsureRecipeExists]
public IActionResult Edit(
int id, [FromBody] UpdateRecipeCommand command)
{
_service.UpdateRecipe(command);
return Ok();
}
}
Я думаю, вы должны согласиться, что контроллер из листинга 13.9 на-
много легче читать!
В этом разделе вы будете проводить постепенный рефакторинг конт -
роллера, удаляя сквозной код, чтобы получить нечто, более управляе-
мое. Все фильтры, которые мы создадим в этом разделе, будут исполь-
зовать интерфейсы синхронных фильтров – что касается создания их
асинхронных аналогов, то я оставлю это вам в качестве упражнения. Мы
начнем с рассмотрения фильтров авторизации и того, как они связаны
с безопасностью в ASP .NET Core.
13.2.1 Фильтры авторизации: защита API
Аутентификация и  авторизация – это взаимосвязанные фундаменталь-
ные концепции безопасности, которые мы подробнее рассмотрим в гла-
вах 14 и 15.
ОПРЕДЕЛЕНИЕ  Аутентификация касается определения того,
кто сделал запрос. Авторизация связана с тем, к  чему	 пользовате-
лю разрешен доступ.
Фильтры авторизации запускаются в конвейере фильтров MVC пер-
выми перед всеми остальными фильтрами. Они контролируют доступ
к методу действия, тотчас же прерывая выполнение конвейера, если за-
прос не соответствует необходимым требованиям.
В ASP .NET Core имеется встроенный фреймворк для авторизации,
который следует использовать, когда вам необходимо защитить прило-
жение MVC или веб-API. Его можно сконфигурировать с по мощью спе-
циальных политик, которые позволяют точно контролировать доступ
к действиям. Размещение фильтров на уровне действия
ограничивает их одним действием.
Намерение действия – вернуть
модель представления Recipe –
намного яснее.
Размещая фильтры на
уровне действий, вы можете
контролировать порядок,
в котором они выполняются.
Намерение действия –
обновить Recipe – гораздо яснее.

491 Создание фильтров для приложения
СОВЕТ  Можно написать собственные фильтры авторизации, реа-
лизовав интерфейсы IAuthorizationFilter или IAsyncAuthoriza-
tionFilter, но я настоятельно рекомендую не делать этого. Фрейм-
ворк для авторизации ASP .NET Core легко настраивается и должен
отвечать всем вашим потребностям.
В основе фреймворка авторизации ASP .NET Core лежит фильтр авто-
ризации, AuthorizeFilter, который можно добавить в конвейер фильт -
ров, декорировав действия или контроллеры атрибутом [Authorize].
В самом простом виде добавление атрибута [Authorize] к действию, как
показано в следующем листинге, означает, что запрос должен быть вы-
полнен проверенным пользователем, чтобы ему было позволено дви-
гаться дальше. Если вы не выполнили вход, выполнение конвейера пре-
рывается, а в браузер возвращается ответ 401 Unauthorized.
Листинг 13.10 Добавление атрибута [Authorize] к методу действия
public class RecipeApiController : ControllerBase
{
public IActionResult Get(int id)
{
// Тело метода;
}
[Authorize]
public IActionResult Edit(
int id, [FromBody] UpdateRecipeCommand command)
{
// Тело метода;
}
}
Как и в случае со всеми фильтрами, можно применить атрибут [Autho-
rize] на уровне контроллера, чтобы защитить все действия в контрол-
лере, к странице Razor, все методы обработчиков страниц или даже гло-
бально для защиты всех конечных точек приложения.
ПРИМЕЧАНИЕ  Мы подробно рассмотрим авторизацию в  гла-
ве 15, в том числе и то, как добавить более подробные требования,
чтобы только определенные группы пользователей могли выпол-
нять действие.
Следующие фильтры в  конвейере – это фильтры ресурсов. В  разде-
ле ниже мы извлечем часть общего кода из контроллера RecipeApiCon-
troller и посмотрим, как создать фильтр прерывания выполнения.Метод Get не имеет атрибута [Authorize],
поэтому его может выполнить кто угодно.
Добавляет AuthorizeFilter в конвейер
фильтров с по мощью атрибута [Authorize].
Метод Edit может быть выполнен только
в том случае, если вы выполнили вход.

492 Глава 13 Конвейер фильтров MVC и Razor Pages
13.2.2 Фильтры ресурсов: прерывание выполнения методов
действий
Фильтры ресурсов – это первые фильтры общего назначения в конвейе-
ре фильтров MVC. В разделе 13.1.4 были показаны небольшие примеры
синхронных и  асинхронных фильтров ресурсов, которые осуществля-
ли журналирование в консоль. В приложениях вы можете использовать
фильтры ресурсов для широкого диапазона целей, благодаря тому что
они выполняются так рано (и поздно) в конвейере.
ASP .NET Core включает в себя несколько реализаций фильтров ресур-
сов, которые вы можете использовать в приложениях:
ConsumesAttribute – может использоваться для ограничения разре-
шенных форматов, которые может принимать метод действия. Если
ваше действие декорировано атрибутом [Consumes("application/
json")], но клиент отправляет запрос в формате XML, фильтр ресур-
сов прервет выполнение конвейера и вернет ответ 415 Unsupported
Media Type;
DisableFormValueModelBindingAttribute  – этот фильтр предотвра-
щает привязку модели к данным формы в теле запроса. Это может
быть полезно, если вы знаете, что метод действия будет обраба-
тывать загрузку крупных файлов, которой вам нужно управлять
вручную. Фильтры ресурсов запускаются перед привязкой модели,
по этому таким образом можно отключить привязку модели для од-
ного действия1.
Фильтры ресурсов полезны, когда вы хотите убедиться, что фильтр за-
пускается на ранней стадии конвейера, перед привязкой модели. Они
обеспечивают вашей логике подключение к конвейеру на раннем этапе,
поэтому вы можете быстро прервать выполнение запроса, если нужно.
Вернемся к листингу 13.8 и посмотрим, можно ли переделать какой-
либо код в  фильтре ресурсов. В  начале методов Get и Edit есть одна
строка:
if (!IsEnabled) { return BadRequest(); }
Она представляет собой переключатель	 функций, который можно ис -
пользовать, чтобы отключить доступность всего API на основе поля Is-
Enabled. На практике вы, вероятно, загрузите это поле из базы данных
или файла конфигурации, чтобы иметь возможность контролировать
доступность динамически во время выполнения, но в  этом примере
я использую жестко зашитое значение2.
Этот фрагмент кода представляет собой автономную сквозную логи-
ку, которая не совсем соответствует основной цели каждого метода дей-
ствия, и это идеальный кандидат на роль фильтра. Вам нужно выполнить
1 Подробнее о загрузке файлов см. на странице http://mng.bz/4Z2D .
2 Чтобы узнать больше об использовании переключателей функций в приложе-
ниях, см. мою серию статей: http://mng.bz/2e40.

493 Создание фильтров для приложения
переключение функции на ранней стадии конвейера, до любой другой
логики, поэтому фильтр ресурсов имеет смысл.
СОВЕТ  Технически для этого примера также можно было бы ис -
пользовать фильтр авторизации, но я следую своему совету: «Не
пишите собственные фильтры авторизации!»
В следующем листинге показана реализация FeatureEnabledAttribute,
которая извлекает логику из методов действия и перемещает ее в фильтр.
Я также предоставил поле IsEnabled в качестве свойства фильтра.
Листинг 13.11 Фильтр ресурсов FeatureEnabledAttribute
public class FeatureEnabledAttribute : Attribute, IResourceFilter
{
public bool IsEnabled { get; set; }
public void OnResourceExecuting(
ResourceExecutingContext context)
{
if (!IsEnabled)
{
context.Result = new BadRequestResult();
}
}
public void OnResourceExecuted(
ResourceExecutedContext context) { }
}
Этот простой фильтр ресурсов демонстрирует ряд важных концепций,
которые применимы к большинству типов фильтров:
фильтр также может быть атрибутом. Им можно декорировать конт -
роллер, методы действий и  страницы Razor с  по мощью [Feature-
Enabled(IsEnabled =true)];
интерфейс фильтра состоит из двух методов: *Executing, который
вызывается перед привязкой модели, и  *Executed, который вызы-
вается после выполнения результата. Вы должны реализовать оба
этих метода, даже если для вашего варианта использования вам ну -
жен только один;
методы выполнения фильтра предоставляют объект контекста. Он
обеспечивает доступ, среди прочего, к объекту HttpContext для за-
проса и метаданные о методе действия, который будет выполнять
промежуточное ПО;
чтобы прервать выполнение конвейера, задайте для свойства con-
text.Result значение экземпляра IActionResult. Фреймворк выпол-
нит этот результат, чтобы сгенерировать ответ, игнорируя все остав-
шиеся фильтры в конвейере и пропуская целиком метод действия
(или обработчик страницы). В этом примере, если данная функция
не активирована, вы прервете выполнение оставшегося конвейера,
вернув BadRequestResult, который вернет клиенту ошибку 400.Определяет,
активирована
ли функция.Выполняется перед привязкой модели,
на ранней стадии конвейера фильтров.
Если функция не активирована,
прерывает выполнение конвейера,
задав свойство context.Result.
Должен быть реализован
для удовлетворения IResourceFilter,
но в данном случае он не требуется.

494 Глава 13 Конвейер фильтров MVC и Razor Pages
Переместив эту логику в фильтр ресурсов, вы можете удалить ее из ме-
тодов действий и вместо этого декорировать весь контроллер API прос -
тым атрибутом:
[Route("api/recipe"), FeatureEnabled(IsEnabled = true)]
public class RecipeApiController : ControllerBase
Пока что вы извлекли только две строчки кода из методов действий,
но вы на правильном пути. В следующем разделе мы перейдем к фильт -
рам действий и извлечем еще два фильтра.
13.2.3 Фильтры действий: настройка привязки модели
и результатов действий
Фильтры действий запускаются сразу после привязки модели, до вы-
полнения метода действия. Благодаря такому расположению фильтры
действий могут получить доступ ко всем аргументам, которые будут ис -
пользоваться для выполнения метода действий, что делает их мощным
способом извлечения общей логики действий.
Кроме того, они также запускаются сразу после выполнения метода
действия и при желании могут полностью изменить или заменить IAc-
tionResult, возвращаемый действием. Они даже могут обрабатывать ис -
ключения, возбуждаемые в действии.
ПРИМЕЧАНИЕ  Фильтры действий не выполняются для Razor
Pages. Точно так же фильтры страниц не выполняются для мето-
дов действия.
ASP .NET Core включает в себя несколько стандартных фильтров дей-
ствий. Один из этих часто используемых фильтров – ResponseCacheFil-
ter, который задает HTTP-заголовки кеширования для ответов, возвра-
щаемых методами действий.
СОВЕТ  Кеширование – обширная тема, направленная на повы-
шение производительности приложения по сравнению с прими-
тивным подходом. Однако оно также может осложнить отладку
и в некоторых ситуациях даже может быть нежелательным. Вслед-
ствие этого я часто применяю фильтр ResponseCacheFilter к  ме-
тодам действий, чтобы настроить HTTP-заголовки, отключающие
кеширование! Об этом и других подходах к кешированию можно
прочитать на странице http://mng.bz/2eGd.
Истинная сила фильтров действий проявляется, когда вы создаете
фильтры, адаптированные к  собственным приложениям, извлекая об-
щий код из методов действий. Чтобы продемонстрировать это, я создам
два специальных фильтра для RecipeApiController:

495 Создание фильтров для приложения
ValidateModelAttribute  – возвращает BadRequestResult, если со-
стояние модели указывает на то, что модель привязки не является
валидной и приведет к завершению выполнения действия. Рань-
ше этот атрибут был основным в моих веб-API, но теперь атрибут
[ApiController] выполняет всю эту работу (и многое другое) за
вас. Тем не менее, думаю, полезно понимать, что происходит за
кулисами;
EnsureRecipeExistsAttribute  – будет использовать аргумент каж -
дого метода действия, id, чтобы убедиться, что запрашиваемая
сущность Recipe существует до выполнения метода действия.
В противном случае фильтр вернет NotFoundResult, и вы прервете
выполнение конвейера.
Как уже было показано в  главе 6, фреймворк MVC автоматически
проверяет модели привязки, прежде чем выполнять действия, но вам
решать, что с  этим делать. В  случае с  контроллерами веб-API обычно
возвращается ответ 400 Bad Request, содержащий список ошибок, как по-
казано на рис. 13.6.
Запрос отправляется
в RecipeApiController
Т ело запроса привязано
к модели привязки метода
действия
Отправляется ответ 400 Bad
Request, указывающий на то, что
валидация запроса окончилась
неудачей
Т ело ответа отправляется в виде
объекта JSON с указанием
имени каждого поля и ошибки
Рис. 13.6 Отправка данных в веб-API с по мощью приложения Postman. Данные
привязаны к модели привязки метода действия и провалидированы. Если валидация
завершилась неудачно, обычно возвращается ответ 400 Bad Request со списком
ошибок
Обычно следует использовать атрибут [ApiController] в  контролле-
рах веб-API, что автоматически дает вам такое поведение. Но если вы не
можете или не хотите использовать его, вместо этого можно создать соб-
ственный фильтр действий. В листинге 13.12 показана базовая реализа-
ция, аналогичная поведению, которое вы получаете при использовании
атрибута [ApiController].

496 Глава 13 Конвейер фильтров MVC и Razor Pages
Листинг 13.12 Фильтр действий для валидации ModelState
public class ValidateModelAttribute : ActionFilterAttribute
{
public override void OnActionExecuting(
ActionExecutingContext context)
{
if (!context.ModelState.IsValid)
{
context.Result =
new BadRequestObjectResult(context.ModelState);
}
}
}
Этот атрибут не требует пояснений и следует шаблону, аналогичному
фильтру ресурсов из раздела 13.2.2, но здесь есть несколько интересных
моментов:
я наследую от абстрактного класса ActionFilterAttribute. Он реа-
лизует интерфейсы IActionFilter и  IResultFilter, а также их асин-
хронные аналоги, поэтому вы можете переопределить нужные вам
методы по мере необходимости. Это позволяет избежать необхо-
димости добавлять неиспользуемый метод OnActionExecuted(), но
использование базового класса совершенно необязательно. Это во-
прос предпочтения;
фильтры действий запускаются после привязки модели, поэтому
context.ModelState содержит ошибки, если проверка не удалась;
если задать для context свойство Result, это приведет к прерыва-
нию выполнения конвейера. Но из-за расположения этапа, на ко-
тором применяется фильтр действий, только выполнение метода
действий и более поздние фильтры действий будут игнорировать-
ся; все остальные этапы конвейера работают так, словно действие
выполняется как обычно.
Если вы примените этот фильтр действий к  RecipeApiController, то
можете удалить данный код из начальной части обоих методов действия,
поскольку он будет выполняться автоматически в конвейере фильтров:
if (!ModelState.IsValid)
{
return BadRequest(ModelState);
}
Вы будете использовать аналогичный подход для удаления повто-
ряющегося кода, который проверяет, соответствует ли идентификатор,
предоставленный в качестве аргумента для методов действия, сущест -
вующей сущности Recipe.Для удобства вы наследуете
от базового класса ActionFilterAttribute.
Переопределяет метод Executing для
запуска фильтра до выполнения действия.
Привязка модели и валидация на этом этапе
уже выполнены, поэтому вы можете проверить состояние.Если модель невалидна, задаем свойство Result;
это приводит к прерыванию выполнения действия.

497 Создание фильтров для приложения
В следующем листинге показан фильтр действия EnsureRecipeExists-
Attribute. Он использует экземпляр RecipeService, чтобы проверить, су -
ществует ли сущность Recipe, и возвращает ошибку 404 Not Found, если
это не так.
Листинг 13.13 Фильтр действий для проверки существования Recipe
public class EnsureRecipeExistsAtribute : ActionFilterAttribute
{
public override void OnActionExecuting(
ActionExecutingContext context)
{
var service = (RecipeService) context.HttpContext
.RequestServices.GetService(typeof(RecipeService));
var recipeId = (int) context.ActionArguments["id"];
if (!service.DoesRecipeExist(recipeId))
{
context.Result = new NotFoundResult();
}
}
}
Как и  раньше, чтобы было проще, вы наследуете от класса Action-
FilterAttribute и переопределяете метод OnActionExecuting. Основная
функциональность фильтра использует метод DoesRecipeExist() серви-
са RecipeService, поэтому первым шагом будет получение экземпляра
RecipeService. Параметр context обеспечивает доступ к объекту HttpCon-
text для запроса, который, в свою очередь, позволяет получить доступ
к контейнеру внедрения зависимостей и использовать RequestServices.
GetService(), чтобы вернуть экземпляр RecipeService.
ВНИМАНИЕ!  Данная техника получения зависимостей извест -
на как обнаружение	 сервисов	 и обычно считается антипаттерном1.
В разделе 13.4 я покажу более приемлемый способ использования
контейнера внедрения зависимостей для внедрения зависимостей
в фильтры.
Помимо RecipeService, вам понадобится дополнительная информа-
ция – это аргумент id методов действия Get и Edit. В фильтрах действий
привязка модели уже произошла, поэтому аргументы, которые фрейм-
ворк будет использовать для выполнения метода действия, уже известны
и предоставлены в context.ActionArguments.
Аргументы действия предоставлены как Dictionary<string, object>,
поэтому вы можете получить параметр id с по мощью строкового ключа
"id". Не забудьте привести объект к правильному типу.
1 Подробное обсуждение паттернов и антипаттернов внедрения зависимостей
см. в пятой главе книги «Принципы, 	практики	 и паттерны	 внедрения	 зависи-
мостей» Стивена ван Дёрсена и Марка Симанна (Manning, 2019), http://mng.bz/
RXOK.Получает экземпляр RecipeService
из контейнера внедрения зависимостей.
Извлекает параметр id,
который будет передан
методу действия
при его выполнении.Проверяет,
существует ли
сущность Recipe
с заданным
RecipeId.
Если сущности нет, возвращает результат
404 Not Found и прерывает выполнение конвейера.

498 Глава 13 Конвейер фильтров MVC и Razor Pages
СОВЕТ  Всякий раз, когда я  вижу подобные волшебные строки,
то всегда стараюсь заменить их, используя оператор nameof. К со -
жалению, он не подходит для таких аргументов метода, поэтому
будьте осторожны при рефакторинге кода. Я предлагаю явно при-
менить фильтр действий к  методу действия (а не глобально или
к контроллеру), чтобы вы помнили об этой неявной связи.
Теперь, когда у  нас есть RecipeService и  id, нужно проверить, соот -
ветствует ли идентификатор существующей сущности Recipe и, если нет,
задать для context.Result значение NotFoundResult. Так вы прерываете
выполнение конвейера и обходите метод действия.
ПРИМЕЧАНИЕ  Помните, что у вас может быть несколько фильт -
ров действий, которые вызываются на одном этапе. Описанное
выше прерывание выполнения конвейера предотвратит выполне-
ние фильтров, которые вызываются на более поздних этапах обра-
ботки запроса, а также позволит игнорировать выполнение метода
действия.
Прежде чем мы продолжим, стоит упомянуть особый случай для фильт -
ров действий. Базовый класс ControllerBase сам реализует интерфейсы
IAc tionFilter и  IAsyncActionFilter. Если вы создаете фильтр действий
для одного контроллера и  хотите применять его к  каждому действию
в этом контроллере, то можно переопределить соответствующие методы.
Листинг 13.14  Переопределение методов непосредственно для класса
ControllerBase
public class HomeController : ControllerBase
{
public override void OnActionExecuting(
ActionExecutingContext context)
{ }
public override void OnActionExecuted(
ActionExecutedContext context)
{ }
}
Если вы переопределите эти методы на контроллере, они будут запус -
каться на этапе фильтра действий для каждого действия контроллера.
Метод OnActionExecuting выполняется перед всеми другими фильтрами
действий, независимо от порядка или области действия, а метод OnAc-
tionExecuted – после всех других фильтров действий.
СОВЕТ  Реализация контроллера может быть полезна в  некото-
рых случаях, но нельзя контролировать порядок, связанный с дру -
гими фильтрами. Лично я  предпочитаю разбивать логику на яв-
ные декларативные атрибуты фильтров, но, как и всегда, выбор за
вами.Наследует от класса ControllerBase.
Выполняется перед всеми другими
фильтрами действий для каждого
действия в контроллере.
Выполняется после всех
остальных фильтров действий для
каждого действия в контроллере.

499 Создание фильтров для приложения
Теперь, когда мы закончили с  фильтрами ресурсов и действий, наш
контроллер выглядит намного аккуратнее, но есть один аспект, который
хотелось бы устранить: обработка исключений. В  следующем разделе
мы рассмотрим, как создать собственный фильтр исключений для кон-
троллера и почему у вас может возникнуть желание сделать именно это,
вмес  то того чтобы использовать компонент обработки исключений.
13.2.4 Фильтры исключений: собственная обработка
исключений для методов действий
В третьей главе я подробно рассказывал о типах компонентов для обра-
ботки ошибок, которые вы можете добавлять в приложения. Это позво-
ляет перехватывать исключения из любого компонента, находящегося
на более позднем этапе, и обрабатывать их соответствующим образом.
Если вы используете компонент обработки исключений, вам может быть
интересно, для чего вообще нужны фильтры исключений.
Ответ на этот вопрос почти такой же, как я описал в разделе 13.1.3:
фильтры отлично подходят для сквозных задач, когда вам нужно конк -
ретное поведение для MVC или речь идет о применении только к опре-
деленным маршрутам.
При обработке исключений можно применять и то, и другое. Фильтры
исключений являются частью фреймворка MVC, поэтому у них есть до-
ступ к контексту, в котором произошла ошибка, как, например, действие
или выполняемая страница Razor Page. Это может быть полезно при жур-
налировании дополнительных деталей при возникновении ошибок, на-
пример параметров действия, вызвавших ошибку.
ПРЕДУПРЕЖДЕНИЕ  Если вы используете фильтры исключений
для записи аргументов метода действия, убедитесь, что вы не хра-
ните в журналах конфиденциальные данные, такие как пароли или
данные кредитной карты.
Вы также можете использовать фильтры исключений для обработки
ошибок из разных маршрутов разными способами. Представьте, что
в  вашем приложении есть и  Razor Pages, и  контроллеры веб-API, как
в приложении рецептов. Что происходит, когда страница Razor Page воз-
буждает исключение?
Как вы видели в главе 3, исключение возвращается по конвейеру про-
межуточного ПО и перехватывается компонентом обработки исключе-
ний. Этот компонент повторно выполнит конвейер и сгенерирует стра-
ницу ошибки.
Это отлично подходит для страниц Razor Pages, а что насчет исклю-
чений в  контроллерах веб-API? Если ваш API возбуждает исключение
и,  следовательно, возвращает HTML, сгенерированный компонентом
обработки исключений, то это нарушит работу клиента, который вызвал
API, ожидая ответа в формате JSON!

500 Глава 13 Конвейер фильтров MVC и Razor Pages
Вместо этого фильтры исключений позволяют обрабатывать исключе-
ние в конвейере фильтров и генерировать соответствующее тело ответа.
Компонент обработчика исключений только перехватывает ошибки без
тела, поэтому измененный ответ веб-API не затрагивается.
ПРИМЕЧАНИЕ  Атрибут [ApiController] преобразует StatusCo-
deResult в объект ProblemDetails, но он не перехватывает исклю-
чения.
Фильтры исключений могут перехватывать исключения не только из
методов действий и обработчиков страниц. Они будут запускаться, если
исключение произойдет:
во время привязки или валидации модели;
когда выполняется метод действия или обработчик страницы;
когда выполняется фильтр действий или фильтр страниц.
Обратите внимание, что фильтры исключений не перехватывают ис -
ключения, которые возбуждаются в каких-либо фильтрах, кроме фильт -
ров действий и страниц, поэтому важно, чтобы ваши фильтры ресурсов
и результатов не возбуждали исключений. Также они не перехватывают
исключения, возникающие при выполнении IActionResult, например
при отрисовке представления Razor в HTML.
Теперь, когда вы знаете, почему вам может понадобиться фильтр ис -
ключений, пойдем дальше и реализуем один такой фильтр для Recipe-
ApiController, как показано ниже. Это позволяет безопасно удалить блок
try-catch из методов действий, зная, что ваш фильтр будет перехваты-
вать любые ошибки.
Листинг 13.15 Фильтр исключений HandleExceptionAttribute
public class HandleExceptionAttribute : ExceptionFilterAttribute
{
public override void OnException(ExceptionContext context)
{
var error = new ProblemDetails
{
Title = "An error occurred",
Detail = context.Exception.Message,
Status = 500,
Type = "https://httpstatuses.com/500"
};
context.Result = new ObjectResult(error)
{
StatusCode = 500
};
context.ExceptionHandled = true;
}
}ExceptionFilterAttribute – это абстрактный базовый класс,
реализующий интерфейс IExceptionFilter.
Для IExceptionFilter можно
переопределить только
один метод.
Создание объекта
с подробностями о проблеме,
чтобы вернуть его в ответе.
Создает ObjectResult
для сериализации ProblemDetails
и установки кода состояния ответа.
Помечает исключение как обработанное, чтобы предотвратить
его распространение в конвейер промежуточного ПО.

501 Создание фильтров для приложения
Наличие фильтра исключений в приложении – довольно распростра-
ненное явление, особенно если вы сочетаете контроллеры API и страни-
цы Razor Pages в приложении, но это не всегда нужно. Если вы можете
обрабатывать все исключения в  приложении с  по мощью одного ком-
понента промежуточного ПО, то откажитесь от фильтров исключений
и воспользуйтесь этим компонентом.
Мы почти закончили рефакторинг RecipeApiController. Осталось до-
бавить только еще один тип фильтра: фильтр результатов. Специальные
фильтры результатов, как правило, относительно редко встречаются
в приложениях, которые писал я, но они, и вы это увидите, находят свое
применение.
13.2.5 Фильтры результатов: настройка результатов
действий перед их выполнением
Если в конвейере все работает успешно и вы не прерывали его выпол-
нение, следующий этап, который идет после фильтров действий, – это
фильтры результатов. Они запускаются непосредственно перед и  пос -
ле выполнения IActionResult, возвращаемого методом действия (или
фильтрами действий).
ПРЕДУПРЕЖДЕНИЕ  Если вы прервали выполнение конвейера
из-за настройки context.Result, то этап, на котором вызывается
фильтр результатов, не будет запущен, но IActionResult все равно
будет выполняться для генерирования ответа. Исключениями из
этого правила являются фильтры действий и страниц: они только
завершают выполнение действия, как было показано на рис. 13.2
и  13.3, поэтому фильтры результатов работают как обычно, как
если бы действие или обработчик страницы сами генерировали
ответ.
Фильтры результатов запускаются сразу же после фильтров действий,
поэтому многие из этих случаев использования похожи, но обычно
фильтры результатов используются, чтобы настроить способ выполне-
ния IActionResult. Например, в ASP .NET Core есть несколько фильтров
результатов:
ProducesAttribute – приводит к тому, что результат веб-API будет
сериализован в определенный выходной формат. Например, деко-
рируя метод действия [Produces("application/xml")] этим фильт -
ром, вы заставляете форматеры попытаться отформатировать от -
вет в виде XML, даже если в заголовке клиента Accept этого формата
нет;
FormatFilterAttribute  – декорируя метод действия этим фильт -
ром, вы даете форматеру указание искать значение маршрута или
параметр строки запроса, format, и  использовать его для опре-
деления выходного формата. Например, можно вызвать /api/
recipe/11?format=json, а  FormatFilter отформатирует ответ в виде

502 Глава 13 Конвейер фильтров MVC и Razor Pages
JSON, или вызовите api/recipe/11?Format=xml  – и  получите ответ
в формате XML1.
Помимо управления форматерами вывода, можно использовать
фильтры результатов, чтобы внести корректировки в последнюю минуту
перед выполнением IActionResult и генерацией ответа.
В качестве примера доступной гибкости в следующем листинге я де-
монстрирую настройку заголовка LastModified на основе объекта, воз-
вращаемого из действия. Это несколько надуманный пример – он доста-
точно специфичен для отдельного действия и не требует перемещения
в фильтр результатов – но, надеюсь, идею вы уловили.
Листинг 13.16 Настройка заголовка ответа в фильтре результатов
public class AddLastModifedHeaderAttribute : ResultFilterAttribute
{
public override void OnResultExecuting(
ResultExecutingContext context)
{
if (context.Result is OkObjectResult result
&& result.Value is RecipeDetailViewModel detail)
{
var viewModelDate = detail.LastModified;
context.HttpContext.Response
.GetTypedHeaders().LastModified = viewModelDate;
}
}
}
Я использовал здесь еще один вспомогательный базовый класс, Re-
sultFilterAttribute, поэтому вам только нужно переопределить один
метод для реализации фильтра. Извлеките IActionResult, предостав-
ленный в  context.Result, и убедитесь, что это экземпляр OkObjectResult
со значением RecipeDetailViewModel. Если это так, извлеките поле Last-
Modified из модели представления и добавьте в  ответ заголовок Last-
Modified.
СОВЕТ  GetTypedHeaders() – это метод расширения, обеспечиваю-
щий строго типизированный доступ к заголовкам запросов и от -
ветов. Он заботится о  разборе и  форматировании значений. Его
можно найти в пространстве имен Microsoft.AspNetCore.Http.
Как и фильтры ресурсов и действий, фильтры результатов могут реа-
лизовать метод, который выполняется	 после	 выполнения результата:
1 Помните, что вам нужно явно настроить форматеры XML, если вам нужна се-
риализация в  XML. Подробные сведения о  результатах форматирования на
основе URL-адреса см. в моей статье в блоге: http://mng.bz/1rYV .ResultFilterAttribute предоставляет полезный
базовый класс, который можно переопределить.
Вы также можете переопределить
метод Executed, но к тому времени
ответ уже будет отправлен.Проверяет, вернул ли результат действия
результат 200 Ok с моделью представления.
Проверяет,
является ли
RecipeDetailViewMode
типом модели
представления……если это так, извлекает свойство LastModified
и задает заголовок Last-Modified в ответе.

503 Создание фильтров для приложения
OnResultExecuted. Вы можете использовать его, например, для проверки
исключений, произошедших во время выполнения IActionResult.
ВНИМАНИЕ!  Как правило, в методе OnResultExecuted ответ изме-
нить нельзя, поскольку вы, возможно, уже начали потоковую пере-
дачу ответа клиенту.
Запуск фильтров результатов после прерывания выполнения
с по мощью интерфейса IAlwaysRunResultFilter
Фильтры результатов предназначены для «обертывания» выполнения IAc-
tionResult, возвращаемого методом действия или фильтром действия,
чтобы вы могли настроить выполнение результата действия. Однако эта на-
стройка не применяется к  IActionResult, установленному, когда вы преры-
ваете выполнение конвейера фильтров, задав context.Result в фильтрах
авторизации, ресурсов или исключений.
Часто это не проблема, поскольку многие фильтры результатов предназна-
чены для обработки успешных трансформаций. Но иногда нужно убедиться,
что трансформация всегда применяется к  IActionResult, независимо от того,
был ли он возвращен методом действия или фильтром завершения.
В этих случаях можно реализовать интерфейсы IAlwaysRunResultFilter или
IAsyncAlwaysunResultFilter. Эти интерфейсы расширяются (и идентичны)
до стандартных интерфейсов фильтров результатов, поэтому работают так
же, как обычные фильтры результатов в конвейере фильтров. Но они поме-
чают фильтр, чтобы он также запускался после того, как фильтр авторизации,
ресурсов или исключений прервет выполнение конвейера, если стандарт -
ные фильтры результатов не сработают.
Вы можете использовать интерфейс IAlwaysRunResultFilter, чтобы гаранти-
ровать, что определенные результаты действия всегда обновляются. Напри-
мер, в документации показано, как использовать его для преобразования 415
StatusCodeResult в 422 StatusCodeResult, независимо от источника результата
действия. См. раздел «IAlwaysRunResultFilter и IAsyncAlwaysRunResultFilter»
из документации Microsoft «Фильтры в ASP.NET Core»: http://mng.b z/JDo0.
Мы закончили работу с контроллером RecipeApiController. Путем из-
влечения различных фрагментов функциональности в фильтры исход-
ный контроллер в  листинге 13.8 был упрощен до версии, которую мы
видим в листинге 13.9. Очевидно, что это немного утрированная и на-
думанная демонстрация, и я не утверждаю, что фильтры всегда должны
быть для вас предпочтительным вариантом.
СОВЕТ  В  большинстве случаев фильтры должны использовать-
ся в  крайнем случае. Где это возможно, часто предпочтительнее
применять простой закрытый метод в контроллере или поместить
функциональность в  предметную область. Обычно следует ис -
пользовать фильтры для извлечения повторяющегося, связанного
с протоколом HTTP или общего сквозного кода из контроллеров.

504 Глава 13 Конвейер фильтров MVC и Razor Pages
Есть еще один фильтр, который мы пока не рассматривали, потому
что он применяется только к Razor Pages: фильтр страниц.
13.2.6 Фильтры страниц: настройка привязки модели
для Razor Pages
Как уже говорилось, фильтры действий применяются только к контрол-
лерам и действиям; они не оказывают никакого эффекта на Razor Pages,
равно как на контроллеры и действия. Тем не менее фильтры страниц
и фильтры действий выполняют схожие роли.
Как и в случае с фильтрами действий, ASP .NET Core включает в себя
несколько уже готовых фильтров страниц. Один из них  – эквивалент
фильтра кеширования ResponseCacheFilter в Razor Page: PageResponse-
CacheFilter. Он работает так же, как и аналогичный фильтр, описанный
в разделе 13.2.3, задавая заголовки кеширования HTTP для ответов на
странице Razor.
Фильтры страниц несколько необычны, поскольку они реализуют
три метода, как мы уже обсуждали в разделе 13.1.2. На практике я ред-
ко встречал фильтр страницы, в котором реализованы все три метода.
Непривычно выполнять код сразу после выбора обработчика страницы
и перед валидацией модели. Гораздо чаще фильтр страницы исполняет
роль, прямо аналогичную фильтрам действий.
Например, в следующем листинге показан фильтр страницы, эквива-
лентный фильтру действия EnsureRecipeExistsAttribute.
Листинг 13.17  Фильтр страниц для проверки существования сущности
Recipe
public class PageEnsureRecipeExistsAtribute : Attribute, IPageFilter
{
public void OnPageHandlerSelected(
PageHandlerSelectedContext context)
{}
public void OnPageHandlerExecuting(
PageHandlerExecutingContext context)
{
var service = (RecipeService) context.HttpContext
.RequestServices.GetService(typeof(RecipeService));
var recipeId = (int) context.HandlerArguments["id"];
if (!service.DoesRecipeExist(recipeId))
{
context.Result = new NotFoundResult();
}
}Реализуем IPageFilter и как атрибут, чтобы можно
было декорировать PageModel страницы Razor.
Выполняется после выбора обработчика
перед привязкой модели – в данном
примере не используется.
Выполняется после привязки
и проверки модели перед
выполнением обработчика страницы.Получает экземпляр RecipeService
из контейнера внедрения зависимостей.
Извлекает параметр id, который будет передан методу
обработчика страницы при его выполнении.Проверяет,
существует ли
сущность Recipe
с заданным RecipeId.
Если ее не существует, возвращает результат
404 Not Found и прерывает выполнение конвейера.

505 Создание фильтров для приложения
public void OnPageHandlerExecuted(
PageHandlerExecutedContext context)
{ }
}
Фильтр страниц очень похож на фильтр действий. Самая очевидная
разница состоит в необходимости реализовать три метода, чтобы соот -
ветствовать интерфейсу IPageFilter. Обычно нужно реализовать метод
OnPageHandlerExecuting, который выполняется сразу после привязки
и валидации модели и до выполнения обработчика страницы.
Тонкое различие между кодом фильтра действий и  кодом фильтра
страниц заключается в том, что фильтр действий обращается к аргумен-
там действия, привязанным к модели, с по мощью context.ActionArgu-
ments. В этом примере фильтр страниц использует context.HandlerArgu-
ments, но есть и другой вариант.
Вы помните из главы 6, что страницы Razor Pages часто привязы-
ваются к  открытым свойствам  PageModel с  использованием атрибута
[BindProperty]. Можно получить доступ к  этим свойствам напрямую,
вместо того чтобы использовать магические строки, путем приведения
свойства HandlerInstance к правильному типу PageModel и обратившись
к свойству напрямую. Например:
var recipeId = ((ViewRecipePageModel)context.HandlerInstance).Id
Так же, как класс ControllerBase реализует IActionFilter, PageModel
реализует IPageFilter и IAsyncPageFilter. Если вы хотите создать фильтр
действий для одной-единственной страницы Razor Page, то можете из-
бавить себя от необходимости создавать отдельный фильтр страниц
и переопределить эти методы прямо на странице.
СОВЕТ  Обычно я  считаю, что не стоит использовать фильтры
страниц, если только у вас нет	 очень распространенных требова-
ний. Дополнительный уровень косвенных фильтров страниц в со-
четании с типично индивидуализированной природой отдельных
страниц Razor Pages означает, что обычно, по моему мнению, их
не стоит использовать. Конечно же, все субъективно, но не стоит
рассматривать их как первый доступный вариант.
На этом мы подошли к концу подробного рассмотрения всех фильтров
в конвейере MVC. Оглядываясь назад и сравнивая листинги 13.8 и 13.9,
вы видите, что фильтры позволили нам реорганизовать контроллеры
и  сделать цель каждого метода действия более понятной. Написание
кода таким образом упрощает рассуждение о его поведении, поскольку
каждый фильтр и действие имеют единственную ответственность.
В следующем разделе мы немного поговорим о том, что происходит,
когда вы прерываете выполнение фильтра. Я описывал,	 как это сделать,
задав для фильтра свойство context.Result, но еще не рассказывал, что Выполняется после выполнения
обработчика страницы (или
прерывания выполнения) – в данном
примере не используется.

506 Глава 13 Конвейер фильтров MVC и Razor Pages
именно при этом происходит. Например, что, если в этапе есть несколько
фильтров, когда вы прерываете выполнение? Будут ли они по-прежнему
работать?
13.3 Прерывание выполнения конвейера
В этом коротком разделе вы узнаете подробности прерывания выполне-
ния конвейера фильтров. Вы увидите, что происходит с другими фильт -
рами на этапе, когда вы прерываете выполнение конвейера, и как пре-
рвать выполнение каждого типа фильтра.
Краткое предупреждение: тема прерывания выполнения фильтров
может немного сбивать с толку. В отличие от компонентов промежуточ-
ного ПО, где все ясно и понятно, у конвейера фильтров есть свои нюансы.
К счастью, вам нечасто придется вникать в суть всего этого, но, когда вы
это сделаете, подробности вас обрадуют.
Чтобы прервать выполнение фильтров авторизации, ресурсов, дей-
ствий, страниц и результатов, нужно задать для context.Result значение
IActionResult. Так вы сможете игнорировать часть конвейера или все,
что в нем осталось. Но конвейер фильтров не является полностью линей-
ным, как уже было показано на рис. 13.2 и 13.3, поэтому, прерывая его
выполнение, не всегда удается сделать полный разворот назад. Напри-
мер, фильтры действий, чье выполнение прервано, игнорируют только
выполнение методов действий – фильтры результатов и этапы выполне-
ния результатов по-прежнему будут работать.
Есть и другая трудность. Что произойдет, если у вас несколько типов
фильтров? Допустим, у вас есть три фильтра ресурсов, выполняющихся
в конвейере. Что будет, если второй фильтр вызывает прерывание вы-
полнения? Все остальные фильтры игнорируются, но первый фильтр ре-
сурсов уже выполнил свою команду *Executing, как показано на рис. 13.7.
Он также выполняет свою команду *Executed с  context.Cancelled = true,
а  это указывает на то, что фильтр на данном этапе (фильтр ресурсов)
прервал выполнение конвейера.
Фильтр 1
Фильтр 2
Фильтр 31.  Фильтр ресурсов 1 выполняет
свою функцию *Executing
2.  Фильтр ресурсов 2 выполняет свою функцию
*Executing и прерывает выполнение конвейера,
установив context.Result5.  Фильтр ресурсов 1 выполняет
свою функцию *Executed.
Для cancelled задано значение
true, а это указывает на то,
что конвейер был прерван
4.  Фильтр ресурсов 2 не выполняет
свою функцию *Executed,
поскольку выполнение
конвейера прервано3.  Фильтр ресурсов 3 (или остальная часть
конвейера) так и не запускается
Рис. 13.7  Влияние прерывания выполнения фильтра ресурсов на другие фильтры ресурсов
на этом этапе. Фильтры, которые идут после них, не запускаются, но более ранние фильтры
выполняют свою функцию OnResourceExecuted

507 Прерывание выполнения конвейера
Понимание того, какие другие фильтры будут работать при преры-
вании выполнения одного из них, может быть довольно утомительным
делом, но я  собрал все фильтры в табл. 13.1. Вам также будет полезно
обратиться к рис. 13.2 и 13.3, что позволит визуализировать конвейер,
когда вы будете размышлять над данной темой.
Таблица 13.1 Влияние прерывания выполнения фильтров на выполнение конвейера
Тип фильтра Как прервать выполнение? Что еще запускается?
Фильтры авторизации Задать context.Result Запускается только IAlwaysRunResultFilter
Фильтры ресурсов Задать context.Result Функции фильтров ресурсов *Executed из более
ранних фильтров запускаются с context.Cancelled
= true.
IAlwaysRunResultFilter запускается перед выполне-
нием IActionResult
Фильтры действий Задать context.Result Игнорируется только выполнение метода действия.
Фильтры действий, которые идут первыми
в конвейере, выполняют свои методы *Executed
с context.Cancelled = true, потом методы фильтров
результатов, выполнения результатов и фильтров
ресурсов *Executed  работают как обычно
Фильтры страниц Задать context.Result
в OnPageHandlerSelected Игнорируется только выполнение обработчика
страниц. Фильтры страниц, которые идут первыми
в конвейере, выполняют свои методы *Executed
с context.Cancelled = true, потом методы фильтров
результатов, выполнения результатов и фильтров
ресурсов *Executed  работают как обычно
Фильтры исключений Задать context.Result
и Exception.Handled =
trueВыполняются все функции фильтров ресурсов
*Executed. IAlwaysRunResultFilter запускается
перед выполнением IActionResult
Фильтры результатов Задать context.Cancelled
= trueФильтры результатов, находящиеся первыми
в конвейере, выполняют свои методы *Executed
с context.Cancelled = true. Все функции фильтров
ресурсов *Executed работают как обычно
Самым интересным моментом здесь является то, что прерывание вы-
полнения фильтра действий (или фильтра страниц) не приводит к преры-
ванию выполнения большей части конвейера. Фактически так вы только
игнорируете фильтры действий, которые идут после, и само выполнение
метода действия. В первую очередь, создавая фильтры действий, вы мо-
жете гарантировать, что другие фильтры, такие как фильтры результа-
тов, определяющие выходной формат, работают как обычно, даже когда
ваши фильтры действий прерывают выполнение.
Последнее, о чем я хотел бы поговорить в этой главе, – как использо-
вать внедрение зависимостей с  фильтрами. В  главе 10 вы видели, что
внедрение зависимостей является неотъемлемой частью ASP .NET Core,
а в следующем разделе вы увидите, как проектировать фильтры таким
образом, чтобы фреймворк мог внедрять в них зависимости сервисов.

508 Глава 13 Конвейер фильтров MVC и Razor Pages
13.4 Использование внедрения зависимостей
с атрибутами фильтра
В этом разделе вы узнаете, как внедрять сервисы в фильтры, чтобы восполь-
зоваться преимуществами простоты внедрения зависимостей. Для этой
цели вы научитесь использовать два вспомогательных фильтра, TypeFil-
terAttribute и ServiceFilterAttribute, и увидите, как применять их, чтобы
упростить фильтр действий, который вы определили в разделе 13.2.3.
В предыдущей версии ASP .NET использовались фильтры, но у  них
была одна проблема: пользоваться сервисами в них было сложно. Реа-
лизовать их в качестве атрибутов, которыми вы декорируете действия,
было фундаментальной проблемой. Атрибуты C# не позволяют переда-
вать зависимости в  свои конструкторы (кроме постоянных значений).
Они создаются как объекты-одиночки, поэтому существует только один
экземпляр для жизненного цикла вашего приложения.
В ASP .NET Core это ограничение по-прежнему существует, поскольку
фильтры обычно создаются как атрибуты, которые вы добавляете в клас -
сы контроллера, методы действий и страницы Razor Pages. Что произой-
дет, если вам потребуется получить доступ к сервису с жизненным цик -
лом типа transient или scoped из атрибута синглтона?
В листинге 13.13 показан один из способов сделать это, используя пат -
терн локатора служб, чтобы проникнуть в  контейнер внедрения зави-
симостей и извлечь сервис RecipeService во время выполнения. Такой
вариант сработает, но обычно это нежелательный паттерн, и предпочте-
ние отдается внедрению зависимостей. Как добавить внедрение зависи-
мостей в фильтры?
Ключевой момент состоит в том, чтобы разделить фильтр на две час -
ти. Вместо того чтобы создавать класс, который одновременно является
атрибутом и фильтром, создайте класс фильтра, содержащий функцио-
нальность и атрибут, который сообщает фреймворку, когда и где исполь-
зовать фильтр.
Применим это к фильтру действий из листинга 13.13. До этого я насле-
довал от класса ActionFilterAttribute и  получил экземпляр RecipeService
из context, переданного в метод. В следующем листинге я показываю два
класса – EnsureRecipeExistsFilter и  EnsureRecipeExistsAttribute. Класс
фильтра отвечает за функциональность и принимает сервис RecipeSer-
vice в качестве зависимости конструктора.
Листинг 13.18  Использование внедрения зависимостей в фильтре
без наследования от Attribute
public class EnsureRecipeExistsFilter : IActionFilter
{
private readonly RecipeService _service;
public EnsureRecipeExistsFilter(RecipeService service)
{
_service = service;
}Не наследует
от класса
Attribute.RecipeService внедряется
в конструктор.

509 Использование внедрения зависимостей с атрибутами фильтра
public void OnActionExecuting(ActionExecutingContext context)
{
var recipeId = (int) context.ActionArguments["id"];
if (!_service.DoesRecipeExist(recipeId))
{
context.Result = new NotFoundResult();
}
}
public void OnActionExecuted(ActionExecutedContext context) { }
}
public class EnsureRecipeExistsAttribute : TypeFilterAttribute
{
public EnsureRecipeExistsAttribute()
: base(typeof(EnsureRecipeExistsFilter)) {}
}
EnsureRecipeExistsFilter – допустимый фильтр; его можно исполь-
зовать отдельно, добавив в  качестве глобального фильтра (поскольку
глобальные фильтры не обязательно должны быть атрибутами). Но его
нельзя использовать напрямую, декорируя классы контроллеров и ме-
тоды действий, поскольку это не атрибут. Вот тут в действие вступает
EnsureRecipeExistsAttribute.
Вы можете декорировать методы атрибутом EnsureRecipeExistsAt-
tribute. Он наследует от TypeFilterAttribute и передает Type создавае-
мого фильтра в качестве аргумента базовому конструктору. Этот атрибут
действует как	 фабрика	 для фильтра EnsureRecipeExistsFilter путем реа-
лизации интерфейса IFilterFactory.
Когда ASP .NET Core изначально загружает приложение, то сканирует
ваши действия и контроллеры, выискивая фильтры и фабрики фильтров,
и  использует их для формирования конвейера фильтров для каждого
действия в вашем приложении, как показано на рис. 13.8.
Когда вызывается действие, декорированное атрибутом EnsureRecipe-
ExistsAttribute, фреймворк вызывает метод CreateInstance() для атри-
бута. Он создает новый экземпляр EnsureRecipeExistsFilter и исполь-
зует контейнер внедрения зависимостей для заполнения зависимостей
(RecipeService).
Используя интерфейс IFilterFactory, вы получаете лучшее из обоих
миров: вы можете декорировать контроллеры и  действия атрибутами
и можете использовать внедрение зависимостей в фильтрах. По умолча-
нию такую функциональность предоставляют два аналогичных класса,
у которых немного разное поведение:
TypeFilterAttribute – загружает все зависимости фильтра из кон-
тейнера внедрения зависимостей и использует их для создания но-
вого экземпляра фильтра;В остальном
метод
остается
прежним.Вы должны реализовать
действие Executed, чтобы
удовлетворить интерфейс.
Наследует от T ypeFilter, который используется для заполнения
зависимостей с по мощью контейнера внедрения зависимостей.Передает тип EnsureRecipeExistsFilter
в качестве аргумента базовому
конструктору T ypeFilter.

510 Глава 13 Конвейер фильтров MVC и Razor Pages
ServiceFilterAttribute – загружает сам фильтр из контейнера. Кон-
тейнер заботится о жизненном цикле сервиса и построении графа
зависимостей. К сожалению, вам также необходимо явно зарегист -
рировать фильтр в контейнере в ConfigureServices при запуске:
services.AddTransient<EnsureRecipeExistsFilter>();
Фреймворк сканирует ваше приложение
в поисках фильтров или атрибутов, которые
реализуют интерфейс IFilterFactory
Фреймворк вызывает метод CreateInstance() для
каждого экземпляра IFilterFactory при получении
запроса на создание экземпляра фильтра,
который добавляется в конвейерАтрибуты, реализующие интерфейсы фильтров,
добавляются непосредственно в конвейер
Рис. 13.8 Фреймворк сканирует ваше приложение при запуске, чтобы найти фильтры
и атрибуты, реализующие интерфейс IFilterFactory. Во время выполнения фреймворк
вызывает метод CreateInstance(), чтобы получить экземпляр фильтра
Независимо от того, будете ли вы использовать TypeFilterAttribute
или ServiceFilterAttribute, все это – в некоторой степени вопрос пред-
почтений, и при необходимости вы всегда можете реализовать собствен-
ный интерфейс IFilterFactory. Ключевой вывод заключается в том, что
теперь вы можете использовать внедрение зависимостей в  фильтрах.
Если вам не нужно использовать внедрение зависимостей для фильтра,
реализуйте его напрямую как атрибут, чтобы было проще.
СОВЕТ  При использовании данного паттерна мне нравится соз-
давать фильтры как вложенный класс класса атрибутов. Это позво-
ляет сохранить весь код в одном файле и указывает на отношения
между классами.
На этом мы подошли к концу главы, посвященной конвейеру фильт -
ров. Фильтры – немного сложная тема, поскольку они не являются строго
необходимыми для создания базовых приложений, но я считаю, что они
чрезвычайно полезны, если нужно гарантировать, что ваши контролле-
ры и методы действий просты и их легко понять.
В следующей главе мы рассмотрим, как защитить приложение. Мы
обсудим разницу между аутентификацией и  авторизацией, понятие
личности в ASP .NET Core и то, как использовать систему ASP .NET Core
Identity, чтобы позволить пользователям регистрироваться и  входить
в приложение.

511 Резюме
Резюме
Конвейер фильтров выполняется как часть MVC или Razor Pages. Он
состоит из фильтров авторизации, ресурсов, действий, страниц, ис -
ключений и  фильтров результатов. Каждый тип фильтра группиру -
ется в этап, и его можно использовать для достижения конкретного
эффекта для этого этапа.
Фильтры ресурсов, действий и  результатов запускаются в  конвейе-
ре дважды: метод *Executing на входе и метод *Executed на выходе.
Фильтры страниц запускаются трижды: после выбора обработчика
страницы и до и после выполнения обработчика страницы.
Фильтры авторизации и исключений запускаются только один раз как
часть конвейера; они не запускаются после генерации ответа.
У каждого типа фильтра есть синхронная и асинхронная версии. На-
пример, фильтры ресурсов могут реализовывать либо интерфейс IRe-
sourceFilter, либо интерфейс IAsyncResourceFilter. Следует исполь-
зовать синхронный интерфейс, если только вашему фильтру не нужно
использовать вызовы асинхронных методов.
Можно добавлять фильтры глобально, на уровне контроллера, на уров-
не страницы Razor Page или на уровне действия. Это называется об-
ластью	 применения фильтра. Какую область применения следует вы-
брать, зависит от того, насколько широко вы хотите применить фильтр.
На определенном этапе сначала выполняются фильтры с глобальной
областью применения, затем фильтры, применяемые к контроллерам
и, наконец, фильтры для действий. Вы также можете переопределить
порядок по умолчанию, реализовав интерфейс IOrderedFilter. Фильт -
ры будут запускаться от низшего к высшему и использовать область
применения, чтобы определить порядок при равенстве значений.
Фильтры авторизации запускаются первыми в конвейере и управляют
доступом к API. ASP .NET Core включает в себя атрибут [Authorization],
который можно применить к методам действия, чтобы только выпол-
нившие вход пользователи могли осуществить действие.
Фильтры ресурсов запускаются после фильтров авторизации и  еще
раз после выполнения IActionResult. Их можно использовать, чтобы
прервать выполнение конвейера, чтобы метод действия так и не был
выполнен, а также для настройки процесса привязки модели для ме-
тода действия.
Фильтры действий запускаются после привязки модели, непосред-
ственно перед выполнением метода действия, а также после выполне-
ния этого метода. Их можно использовать для извлечения общего кода
из метода действия, чтобы предотвратить дублирование кода. Они не
выполняются для страниц Razor Pages, только для контроллеров MVC.
Базовый класс ControllerBase также реализует интерфейсы IAction-
Filter и  IAsyncActionFilter. Они запускаются в  начале и  в  конце
конвейера фильтров, независимо от порядка или области примене-
ния других фильтров действий. Их можно использовать для создания
фильтров действий, относящихся к конкретному контроллеру.

512 Глава 13 Конвейер фильтров MVC и Razor Pages
Фильтры страниц запускаются трижды: после выбора обработчика
страницы, после привязки модели и после выполнения метода обра-
ботчика страницы. Вы можете использовать эти фильтры для похожих
целей как фильтры действий. Фильтры страниц выполняются только
для Razor Pages; они не подходят для контроллеров MVC.
PageModel реализует интерфейсы IPageFilter и  IAsyncPageFilter, по -
этому их можно использовать для реализации фильтров конкретных
страниц. Они редко используются, поскольку обычно аналогичных
результатов можно добиться с по мощью простых закрытых методов.
Фильтры исключений выполняются после фильтров действий и стра-
ниц, когда метод действия или обработчик страницы возбудил исклю-
чение. Их можно использовать для предоставления настраиваемой
обработки ошибок для конкретного выполняемого действия.
Как правило, следует обрабатывать исключения на уровне промежу -
точного ПО, но можно использовать фильтры исключений, чтобы на-
строить обработку исключений для конкретных действий, контролле-
ров или страниц Razor Pages.
Фильтры результатов запускаются непосредственно перед и  после
выполнения IActionResult. Используйте их, чтобы контролировать
выполнение результата действия или полностью изменить результат
действия, которое будет выполнено.
Фильтры результатов не выполняются, если вы прерываете выполне-
ние конвейера, используя фильтры авторизации, ресурсов или исклю-
чений. Вы можете убедиться, что фильтры результатов также запуска-
ются для таких случаев путем реализации фильтра результатов, как
IAlwaysRunResultFilter или IAsyncAlwaysRunResultFilter.
Вы можете использовать атрибуты ServiceFilterAttribute и  TypeFil-
terAttribute, чтобы допустить внедрение зависимостей в специаль-
ных фильтрах. ServiceFilterAttribute требует, чтобы вы зарегист -
рировали фильтр и  все его зависимости в  контейнере внедрения
зависимостей, тогда как TypeFilterAttribute требует, только чтобы
были зарегистрированы зависимости фильтра.

14Аутентификация:
добавляем	пользователей
в приложение		с по	 мощью
ASP.NET	Core	Identity
В этой главе:
как работает аутентификация в веб-приложениях ASP.NET Core;
создание проекта с использованием системы ASP.NET Core
Identity;
добавление функциональности работы с пользователями
в существующее веб-приложение;
настройка пользовательского интерфейса ASP.NET Core Identity.
Одним из преимуществ такого веб-фреймворка, как ASP .NET Core, явля-
ется возможность предоставить динамическое приложение, настроен-
ное для отдельных пользователей. Многие приложения имеют концеп-
цию «учетной записи», в которую вы можете «войти» и получить другой
пользовательский интерфейс.
В зависимости от приложения учетная запись дает разные возмож -
ности: в некоторых приложениях вам может потребоваться выполнить
вход, чтобы получить доступ к дополнительным функциям, а в других вы
можете увидеть предлагаемые вам статьи. В  приложении для онлайн-
торговли вы можете размещать заказы и просматривать свои прошлые
заказы; на Stack Overflow можно публиковать вопросы и ответы, тогда
как на новостном сайте вы можете получить индивидуальный пользо-
вательский интерфейс на базе статей, которые вы просматривали ранее.

514 Глава 14 Аутентификация: добавляем пользователей в приложение
Когда вы думаете над тем, как добавить пользователей в свое прило-
жение, обычно есть два аспекта, которые следует учитывать:
аутентификация – процесс создания пользователей и предоставле-
ния им возможности войти в приложение;
авторизация  – настройка пользовательского интерфейса и  конт -
роль над тем, что могут делать пользователи, основываясь на теку -
щем пользователе, выполнившем вход.
В этой главе мы будем обсуждать первый из этих моментов, аутен-
тификацию и  членство, а  в  следующей главе коснемся второго вопро-
са – авторизации. В разделе 14.1 обсуждается разница между аутентифи-
кацией и авторизацией, как работает аутентификация в традиционном
веб-приложении ASP .NET Core, и  способы разработки вашей системы,
чтобы обеспечить возможность регистрации в ней.
Также я коснусь типичных различий в аутентификации между тради-
ционным веб-приложением и  веб-API, используемыми с  клиентскими
приложениями или приложениями для мобильных устройств. В  этой
книге основное внимание уделяется традиционным веб-приложениям,
но многие из этих принципов применимы к обоим вариантам.
В разделе 14.2 я представляю систему управления пользователями под
названием ASP .NET Core Identity (или просто Identity). Identity интег -
рируется с EF Core и предоставляет сервисы для создания и управления
пользователями, хранения и проверки паролей, а также входа пользова-
телей в приложение и выхода из него.
В разделе 14.3 вы создадите приложение, используя шаблон по умол-
чанию, который уже включает в себя ASP .NET.Core Identity. Так вы уви-
дите функции, которые предоставляет Identity, а еще все то, чего она не
дает.
Создание приложения отлично подходит для того, чтобы увидеть, как
его части сочетаются друг с другом, но вам нередко будет необходимо
добавлять пользователей и аутентификацию в существующее приложе-
ние. В разделе 14.4 вы увидите, какие шаги необходимы для добавления
ASP .NET Core Identity в  существующее приложение: приложение с  ре-
цептами из глав 12 и 13.
В разделах 14.5 и  14.6 вы узнаете, как заменить страницы из поль-
зовательского интерфейса Identity по умолчанию путем скаффолдинга
отдельных страниц. В разделе 14.5 вы увидите, как настроить шаблоны
Razor для создания разной HTML-разметки на странице регистрации
пользователя, а в разделе 14.6 узнаете, как настроить логику, ассоцииро-
ванную со страницей Razor. Вы увидите, как сохранить дополнительную
информацию о  пользователе (например, его имя или дату рождения)
и как предоставить ему полномочия, которые впоследствии можно будет
использовать для настройки поведения приложения (например, если это
VIP-пользователь).
Прежде чем мы конкретно рассмотрим систему ASP .NET Core Identity,
взглянем на аутентификацию и авторизацию в ASP .NET Core – что про-
исходит, когда вы регистрируетесь на веб-сайте, и  как проектировать
приложения, чтобы обеспечить эту функциональность.

515 Знакомство с аутентификацией и авторизацией
14.1 Знакомство с аутентификацией
и авторизацией
Когда вы добавляете в приложение функцию входа и контролируете до-
ступ к определенным функциям в зависимости от текущего пользовате-
ля, выполнившего вход, то используете два различных аспекта безопас -
ности:
аутентификация – процесс определения того, кто	вы;
авторизация  – процесс определения того, что вам	разрешено	 де-
лать.
Как правило, вам нужно знать, кто этот пользователь, прежде чем вы
сможете определить, что ему разрешено делать, поэтому сначала всегда
идет аутентификация, а уже затем авторизация. В этой главе мы рассмат -
риваем только аутентификацию; об авторизации речь пойдет в главе 15.
В этом разделе я начну с обсуждения того, как ASP .NET Core представ-
ляет себе пользователей, и  приведу некоторые термины и  концепции,
имеющие ключевое значение для аутентификации. Я всегда считал, что
при первом знакомстве с аутентификацией эти вещи сложнее всего по-
нять, поэтому не буду торопиться.
Далее мы рассмотрим, что означает вход в традиционное веб-при ло-
жение. В конце концов, вы всего лишь указываете свой пароль и входите
в приложение – откуда оно знает, что запрос поступил от	 вас, чтобы об-
рабатывать последующие запросы?
Наконец, мы рассмотрим, как работает аутентификация, когда вам
нужно поддерживать клиентские приложения и  приложения для мо-
бильных устройств, вызывающие веб-API, помимо традиционных веб-
приложений. Многие из этих концепций схожи, но требование под-
держки нескольких типов пользователей, традиционные, клиентские
приложения и приложения для мобильных устройств привели к появле-
нию альтернативных решений.
14.1.1 Пользователи и утверждения в ASP.NET Core
Концепция пользователя встроена в ASP .NET Core. В главе 3 вы узнали,
что HTTP-сервер Kestrel создает объект HttpContext для каждого полу -
ченного запроса. Этот объект отвечает за хранение всех деталей, связан-
ных с данным запросом, таких как URL-адрес запроса, все отправляемые
заголовки, тело запроса и т. д.
Объект HttpContext также предоставляет текущего принципала	 запро-
са в  качестве свойства User. Это видение ASP .NET Core относительно
того, какой пользователь сделал запрос. Всякий раз, когда вашему при-
ложению необходимо знать, кто этот текущий пользователь или что ему
позволено делать, оно смотрит на свойство HttpContext.User.
ОПРЕДЕЛЕНИЕ  Можно рассматривать принципала как пользова-
теля приложения.

516 Глава 14 Аутентификация: добавляем пользователей в приложение
В ASP .NET Core принципалы реализованы в виде объектов ClaimsPrin-
cipal, у которых есть коллекция утверждений, как показано на рис. 14.1.
Принципал, ассоциированный с запросом, –
это текущий пользовательПринципал реализуется
классом ClaimsPrincipal,
у которого есть коллекция
утверждений
Утверждения описывают
свойства принципала.
Обычно они состоят из
типа и значения, но могут
быть только именемClaimsPrincipal
Email=test@test.com FirstName=Andrew
HomePhone=555 123 LastName=Lock
HasAdminAccess
Рис. 14.1 Принципал – это текущий пользователь, реализованный как объект
ClaimsPrincipal. Он содержит коллекцию утверждений, описывающих пользователя
Можно рассматривать утверждения как свойства текущего пользова-
теля. Например, у вас могут быть такие объекты для адреса электронной
почты, имени или даты рождения.
ОПРЕДЕЛЕНИЕ  Утверждение  – это отдельная информация
о принципале. Она состоит из	типа	и необязательного	значения.
Утверждения также могут быть косвенно связаны с  полномочиями
и  авторизацией, поэтому у  вас может быть объект HasAdminAccess или
IsVipCustomer. Храниться они будут точно так же – как объекты, ассоци-
ированные с принципалом.
ПРИМЕЧАНИЕ  В  более ранних версиях ASP .NET использовался
ролевой подход к  безопасности. Объект ClaimsPrincipal, приме-
няемый в ASP .NET Core, совместим с  этим подходом, когда речь
идет об унаследованном коде, но для новых приложений следует
использовать утверждения.
Kestrel назначает принципала каждому запросу, поступающему в при-
ложение. Первоначально это универсальный, анонимный принципал
без аутентификации и утверждений. Как вы выполняете вход, и как ASP .
NET Core узнает, что это были вы, когда последуют другие запросы?
В следующем разделе мы рассмотрим, как работает аутентификация
в традиционном веб-приложении с по мощью ASP .NET Core и процесса
входа в учетную запись пользователя.

517 Знакомство с аутентификацией и авторизацией
14.1.2 Аутентификация в ASP.NET Core: сервисы
и промежуточное ПО
Добавление аутентификации в любое веб-приложение включает в себя
ряд действий. Один и тот же процесс применяется независимо от того,
создаете ли вы традиционное веб-приложение или клиентское прило-
жение, хотя часто случаются различия в реализации, о чем я расскажу
в разделе 14.1.3.
1  Клиент отправляет в  приложение идентификатор и  секрет, кото-
рые определяют текущего пользователя. Например, можно отпра-
вить адрес электронной почты (идентификатор) и пароль (секрет).
2  Приложение проверяет, соответствует ли идентификатор пользо-
вателю, который известен приложению, и  что соответствующий
секрет правильный.
3  Если идентификатор и секрет являются допустимыми, приложение
может задать принципала для текущего запроса, но ему также ну -
жен способ хранения этих данных для последующих запросов. Что
касается традиционных веб-приложений, то обычно это достига-
ется за счет хранения зашифрованной версии принципала в файле
cookie.
Это типичный процесс для большинства веб-приложений, но в дан-
ном разделе мы рассмотрим, как это работает в ASP .NET Core. В целом
весь процесс точно такой же, но приятно видеть, что этот паттерн под-
ходит для сервисов, промежуточного ПО и MVC. Мы рассмотрим различ-
ные элементы типичного приложения, когда вы выполняете вход как
пользователь, что это означает и как выполнять последующие запросы
в качестве данного пользователя.
вход в приложение  asP.NeT c oRe
Когда вы впервые заходите на сайт и  входите в  традиционное веб-
приложение, приложение отправляет вас на страницу входа и  просит
ввести свое имя пользователя и пароль. После отправки формы на сервер
приложение перенаправляет вас на новую страницу, и  вы волшебным
образом авторизуетесь! На рис. 14.2 показано, что происходит за кули-
сами приложения ASP .NET Core при отправке формы.
Здесь показана последовательность шагов с момента отправки формы
входа на странице Razor до того момента, когда перенаправление возвра-
щается в браузер. Когда запрос только поступает, Kestrel создает аноним-
ного принципала и назначает его свойству HttpContext.User. Затем запрос
маршрутизируется на страницу Login.cshtml, которая считывает адрес
электронной почты и пароль из запроса, используя привязку модели.
Основная работа происходит внутри сервиса SignInManager. Она от -
вечает за загрузку сущности пользователя с указанным именем пользо-
вателя из базы данных и выполняет проверку, чтобы удостовериться, что
предоставленный пароль верен.

518 Глава 14 Аутентификация: добавляем пользователей в приложение
HttpContext.UserЗапрос
SignInManager
HttpContext.UserIdentityUser
Login.cshtml
Результат
перенаправления1.  Пользователь вводит свои данные
для входа и нажимает кнопку Submit,
чтобы передать их на сервер
2.  Первоначально для свойства User
задано значение анонимного
принципала3.  Страница входа вызывает диспетчер входа.
Он загружает пользователя из базы данных
с помощью EF Core и проверяет его пароль
4.  Если пароль правильный, пользователь
может выполнить вход. Создается
ClaimsPrincipal, который задается как
свойство User в HttpContext5.  Наконец, принципал сериализуется
и возвращается в виде зашифрованного
файла cookie в браузер
Рис. 14.2 Вход в приложение ASP.NET Core. Сервис SignInManager отвечает за настройку
свойства HttpContext.User для нового принципала и сериализацию этого принципала
в зашифрованный файл cookie
ВНИМАНИЕ!  Никогда не храните пароли непосредственно в базе
данных. Их нужно хешировать с  использованием мощной одно-
сторонней функции. ASP .NET Core Identity делает это за вас, но
всегда разумно проверить все еще раз самостоятельно!
Если пароль правильный, SignInManager создает новый объект Claim-
sPrincipal из пользовательской сущности, загружаемой из базы данных,
и добавляет соответствующие утверждения, такие как адрес электрон-
ной почты. Затем она заменяет старого анонимного принципала на но-
вого проверенного пользователя.
Наконец, SignInManager сериализует принципал, шифрует его и  со-
храняет в виде файла cookie. Данный файл – это небольшой фрагмент
текста, который пересылается между браузером и вашим приложением
вместе с каждым запросом. Он состоит из имени и значения.
Этот процесс аутентификации объясняет, как задать пользователя для
запроса, когда он впервые входит в ваше приложение, а как насчет после-
дующих запросов? Вы отправляете свой пароль только при первом входе
в приложение, так как же оно узнает, что запрос делает тот же пользо-
ватель?
аутентификация  пользователей  для последующих  запросов
Ключ к сохранению вашей личности при выполнении нескольких запро-
сов находится на последнем этапе рис. 14.2, где вы сериализуете прин-
ципал в  файле cookie. Браузеры автоматически отправят этот файл со

519 Знакомство с аутентификацией и авторизацией
всеми запросами вашему приложению, поэтому не нужно указывать па-
роль при каждом запросе.
ASP .NET Core использует cookie-файл аутентификации, отправляемый
с запросами, чтобы восстановить объект ClaimsPrincipal и задать зна-
чение свойства HttpContext.User для запроса, как показано на рис. 14.3.
Важно отметить, когда этот процесс происходит – в компоненте Authen-
ticationMiddleware.
HttpContext.User
HttpContext.UserЗапрос
Компонент
статических файлов
Компонент
аутентификацииСервисы
аутентификации
Компонент
конечной точки1.  Пользователь, прошедший авторизацию,
запрашивает адрес /recipes
2.  Браузер отправляет cookie-файл
аутентификации с запросом
3.  Любое промежуточное ПО
до компонента аутентификации
обрабатывает запрос как
неаутентифицированный
6.  Все промежуточное ПО,
которое идет после компонента
аутентификации, воспринимает
запрос как запрос от пользователя,
прошедшего аутентификацию4.  Компонент аутентификации вызывает сервисы
аутентификации, которые десериализуют
принципал из файла cookie и подтверждают его
валидность
5.  Для свойства HttpContext.User задано значение
десериализованного принципала, и теперь
запрос аутентифицирован
Рис. 14.3 Последующий запрос после входа в приложение. Файл cookie, отправляемый
с запросом, содержит принципал, который проверяется и используется для аутентификации
запроса
После получения запроса, содержащего cookie-файл аутентификации,
Kestrel создает по умолчанию не прошедшего аутентификацию аноним-
ного принципала и назначает его HttpContext.User. Любое промежуточ-
ное ПО, работающее на этом этапе, до компонента AuthenticationMid-
dleware будет считать, что запрос не прошел аутентификацию, даже при
наличии допустимого файла cookie.
СОВЕТ  Если вам кажется, что ваша система аутентификации не
работает, проверьте еще раз свой конвейер промежуточного ПО.
Только компоненты, которые выполняются после Authentication-
Middleware, будут считать запрос аутентифицированным.
Компонент AuthenticationMiddleware отвечает за настройку текущего
пользователя для запроса. Он вызывает сервисы аутентификации, кото-

520 Глава 14 Аутентификация: добавляем пользователей в приложение
рые считывают файл cookie из запроса, расшифровывает его и десериа-
лизует, чтобы получить объект ClaimsPrincipal, созданный, когда поль-
зователь выполнил вход.
AuthenticationMiddleware задает для свойства HttpContext.User но-
вого, проверенного принципала. Все последующие компоненты теперь
будут знать принципала запроса и  смогут соответствующим образом
скорректировать свое поведение (например, отображение имени поль-
зователя на главной странице или ограничение доступа к некоторым об-
ластям приложения).
ПРИМЕЧАНИЕ  AuthenticationMiddleware отвечает только за
аутен тификацию входящих запросов и установку объекта Claims-
Principal, если запрос содержит cookie-файл аутентификации. Он
не несет ответственности за перенаправление запросов, не про-
шедших аутентификацию, на страницу входа или отклонение не-
авторизованных запросов – этим занимается компонент Authori-
zationMiddleware, как будет показано в главе 15.
Описанный здесь процесс, при котором одно приложение аутенти-
фицирует пользователя, когда он выполняет вход и устанавливает файл
cookie, который будет считываться при последующих запросах, является
обычным для традиционных веб-приложений, но это не единственный
случай. В следующем разделе мы рассмотрим аутентификацию для веб-
API, используемых клиентскими приложениями или приложениями для
мобильных устройств, и как меняется система аутентификации для этих
сценариев.
14.1.3 Аутентификация для API и распределенных
приложений
Процесс, который я описывал до этого, применим к традиционным веб-
приложениям, где у  вас есть одна конечная точка, выполняющая всю
работу. Она отвечает за аутентификацию и  управление пользователя-
ми, а также обслуживание данных вашего приложения, как показано на
рис. 14.4.
Браузеры вызывают
традиционные веб-приложенияТрадиционные веб-приложения обслуживают запросы
и занимаются аутентификацией и авторизацией
пользователей
Рис. 14.4 Традиционные приложения обычно обрабатывают всю функциональность
приложения: бизнес-логику, генерацию пользовательского интерфейса,
аутентификацию и управление пользователями

521 Знакомство с аутентификацией и авторизацией
Помимо этого традиционного веб-приложения, ASP .NET Core часто
используется как веб-API для предоставления данных приложениям
для мобильных устройств и  клиентским одностраничным приложени-
ям. Кроме того, тенденция к использованию микросервисов в серверной
части означает, что даже традиционным веб-приложениям, использую-
щим Razor, нередко требуется вызывать API за кулисами, как показано
на рис. 14.5.
Браузеры вызывают
традиционные веб-приложения
Клиентские и мобильные
приложения вызывают APIКаждое приложение
или API должно быть
аутентифицировано/
авторизованоИ традиционные веб-приложения,
и API вызывают другие API
Рис. 14.5 Современные приложения обычно должны предоставлять веб-API для клиентских
приложений и приложений для мобильных устройств, а также потенциально вызывать API
для серверной части. Когда все эти сервисы нуждаются в аутентификации и управлении
пользователями, это становится сложным с логистической точки зрения
В этой ситуации у  вас есть несколько приложений и  API, и  все они
должны понимать, что один и тот же пользователь отправляет запрос во
все приложения и API. Если вы будете придерживаться того же подхода,
что и раньше, когда каждое приложение управляет своими пользовате-
лями, все может быстро выйти из-под контроля!
Вам также потребуется продублировать всю логику входа между при-
ложениями и  API, а  еще понадобится иметь некую центральную базу
данных, содержащую данные пользователей. Пользователям может
понадобиться выполнить вход несколько раз, чтобы получить доступ
к разным частям приложения. Более того, использование файлов cookie
становится проблемой, в частности для некоторых мобильных клиентов
или в тех случаях, когда вы делаете запросы к нескольким доменам (по-
скольку файлы cookie принадлежат только одному домену).
Как это улучшить? Типичный подход – извлечь код, общий для всех
приложений и API, и переместить его в  поставщика	 идентификационной
информации, как показано на рис. 14.6.
Вместо того чтобы обеспечить вход в приложение напрямую, прило-
жение перенаправляет пользователя к поставщику идентификационной
информации. Пользователь выполняет вход в учетную запись этого по-
ставщика, который передает токены носителя обратно клиенту, которые
указывают, кто является пользователем и к чему ему разрешен доступ.
Клиенты и приложения могут передавать эти токены в API, чтобы предо-

522 Глава 14 Аутентификация: добавляем пользователей в приложение
ставить информацию о выполнившем вход пользователе, без необходи-
мости повторной аутентификации или непосредственного управления
пользователями.
Вместо аутентификации напрямую
через приложение браузеры и API
аутентифицируются у поставщика
идентификационной информации,
который выдает токены
Т окены передаются
в традиционные
веб-приложения и API Т еперь аутентификация является
централизованной. Т окены могут
передаваться между API и сервисами
по мере необходимости
Рис. 14.6 Альтернативная архитектура предполагает использование центрального
поставщика идентификационной информации для аутентификации и управления
пользователями системы. Т окены передаются туда и обратно между поставщиком,
приложениями и API
Такая архитектура явно более сложная на первый взгляд, поскольку вы
запустили совершенно новый сервис – поставщика идентификационной
информации, – но в конечном итоге вы увидите, что у нее имеется ряд
преимуществ:
пользователи	 могут	совместно	 использовать	 свою	личность	 в не-
скольких	 сервисах. Когда вы входите в  центрального поставщика
удостоверений, то, по сути, входите во все приложения, использу -
ющие этот сервис. Это дает вам возможность входить только один
раз, и не нужно совершать вход в несколько сервисов;
уменьшение	 дублирования	 кода. Вся логика входа инкапсулирована
в поставщике идентификационной информации, поэтому не нужно
добавлять экраны входа во все свои приложения;
можно	легко	добавлять	 новых	поставщиков. Независимо от того, ис -
пользуете ли вы поставщика идентификационной информации или
традиционный подход, можно использовать внешние сервисы для
аутентификации пользователей. Вы будете встречать это в прило-
жениях, которые позволяют «выполнить вход с по мощью Facebook»
или «с помощью Google», например. Если вы используете центра-
лизованного поставщика идентификационной информации, до-
бавление поддержки дополнительных поставщиков может быть
выполнено в одном месте. Не нужно явно конфигурировать каждое
приложение и API.

523 Знакомство с аутентификацией и авторизацией
Изначально ASP .NET Core поддерживает такие архитектуры, а также
потребление выпущенных токенов носителя, но не включает в себя под-
держку	выпуска	 этих токенов. Это означает, что вам потребуется исполь-
зовать другую библиотеку или сервис для поставщика идентификацион-
ной информации.
Один из вариантов – делегировать все обязанности по проверке под-
линности сторонним поставщикам идентификационной информации,
например Facebook, Okta, Auth0 или Azure Active Directory B2C. Они
управляют пользователями вместо вас, поэтому информация о пользо-
вателях и пароли хранятся в их базе данных, а не в вашей. Самое большое
преимущество такого подхода состоит в том, что вам не нужно беспоко-
иться о  безопасности данных клиентов; вы можете быть уверены, что
эти поставщики защитят их, ведь это их бизнес.
СОВЕТ  По возможности я рекомендую использовать этот подход,
поскольку он делегирует обязанности по обеспечению безопасно-
сти третьей стороне. Вы не потеряете данные своего пользователя,
если у вас их никогда не было!
Еще один распространенный вариант  – создать собственного по-
ставщика идентификационной информации. Может показаться, что это
трудоемкий процесс, но благодаря таким отличным библиотекам, как
OpenIddict (https://github.com/openiddict) и  IdentityServer (https://docs.
identit yserver.io/), вполне возможно написать собственного поставщика
идентификационной информации для выпуска токенов носителя, кото-
рые будут потребляться приложением.
Те, кто начинает работать с  OpenIddict и  IdentityServer, упускают из
виду один аспект: это не готовые решения. Вам как разработчику не-
обходимо написать код, который знает, как создать нового пользователя
(обычно в базе данных), как загрузить данные пользователя и проверить
его пароль. В этом отношении процесс разработки для создания постав-
щика идентификационной информации аналогичен традиционному
веб-приложению с аутентификацией на основе файлов cookie, которую
мы обсуждали в разделе 14.1.2.
Фактически можно рассматривать поставщика идентификационной
информации как традиционное веб-приложение, у которого есть толь-
ко страницы управления учетными записями. Он также имеет возмож -
ность генерировать токены для других сервисов, но не содержит никакой
другой логики для конкретного приложения. Необходимость управлять
пользователями в базе данных, а также предоставление пользователям
интерфейса, чтобы выполнить вход, является общей для обоих подходов.
Это предмет обсуждения данной главы.
ПРИМЕЧАНИЕ  Подключение приложений и API, чтобы исполь-
зовать поставщика идентификационной информации, может по-
требовать изрядной утомительной настройки как приложения, так
и поставщика. Чтобы было проще, в этой книге основное внима-

524 Глава 14 Аутентификация: добавляем пользователей в приложение
ние уделяется традиционным веб-приложениям, использующим
процесс, описанный в разделе 14.1.2. ASP .NET Core включает в себя
вспомогательную библиотеку для работы с IdentityServer и клиент -
скими одностраничными приложениями. Подробнее о том, с чего
начать, см. http://mng.bz/w9Mq и документацию по IdentityServer:
https://docs.identityserver.io/.
ASP .NET Core Identity (далее просто Identity) – это система, упроща-
ющая создание аспекта управления пользователями вашего приложе-
ния (или поставщика идентификационной информации). Она обраба-
тывает все шаблонные задачи по сохранению и загрузке пользователей
в базу данных, а также использует ряд передовых методов обеспечения
безопас ности, таких как блокировка пользователей, хеширование паро-
лей и двухфакторная	аутентификация.
ОПРЕДЕЛЕНИЕ  Двухфакторная	 аутентификация (2FA)  – это
метод идентификации пользователя, когда вам требуется допол-
нительная часть информации для выполнения входа, помимо па-
роля. Это может включать в себя, например, отправку кода на теле-
фон пользователя с по мощью SMS или использование приложения
для мобильных устройств, чтобы сгенерировать код.
В следующем разделе я расскажу о системе ASP .NET Core Identity, о за-
дачах, которые она решает, когда у вас может возникнуть желание ис -
пользовать ее, а когда нет. В разделе 14.3 мы взглянем на код и увидим
ASP .NET Core Identity в действии.
14.2 Что такое ASP.NET Core Identity?
Пишете ли вы традиционное веб-приложение с  по мощью Razor Pages
или настраиваете нового поставщика идентификационной информа-
ции, использующего такую   библиотеку, как IdentityServer, вам понадо-
бится способ сохранения сведений о ваших пользователях, таких как их
имена и пароли.
Это может показаться относительно простым требованием, но, учиты-
вая, что это связано с безопасностью и личными данными людей, важно,
чтобы вы все сделали правильно. Так же как вы сохраняете утверждения
для каждого пользователя, важно хранить пароли, используя сильный
алгоритм хеширования, позволять пользователям применять двухфак -
торную аутентификацию там, где это возможно, и защищать их от атак
методом полного перебора. И это лишь некоторые из множества требо-
ваний. Хотя вполне возможно написать весь этот код, чтобы сделать это
вручную и  создать собственную систему аутентификации и  членства,
я настоятельно рекомендую вам не делать этого.
Я уже упоминал сторонних поставщиков идентификационной ин-
формации, таких как Auth0 или Azure Active Directory B2C. Это решения,

525 Что такое ASP.NET Core Identity?
использующие модель Software-as-a-Service) (SaaS) (программное обес -
печение как услуга). Они заботятся об аспектах управления пользовате-
лями и аутентификации в вашем приложении. Если вы переносите при-
ложения в облако, то подобные решения могут иметь большой смысл.
Если вы не можете или не хотите использовать эти сторонние решения,
рекомендую рассмотреть систему ASP .NET Core Identity для хранения
данных пользователя и управления ими в своей базе данных. ASP .NET
Core Identity берет на себя большую часть шаблонного кода, связанного
с аутентификацией, оставаясь при этом гибкой и при необходимости по-
зволяя контролировать процесс выполнения входа для пользователей.
ПРИМЕЧАНИЕ  ASP .NET Core	 Identity – это следующая версия ASP .
NET Identity с дизайнерскими улучшениями, которая преобразо-
вана для работы с ASP .NET Core.
По умолчанию ASP .NET Core Identity использует библиотеку EF Core
для хранения сведений о пользователях в базе данных. Если вы уже ис -
пользуете EF Core в своем проекте, она идеально подойдет вам. В качест -
ве альтернативы можно написать собственные хранилища для загрузки
и сохранения пользовательских данных другим способом.
Identity заботится о низкоуровневых частях управления пользовате-
лями, как показано в табл. 14.1. Как видно из этого списка, Identity дает
много разных возможностей, но это далеко не все!
Таблица 14.1 Какие сервисы предоставляет ASP.NET Core Identity, а какие нет
Управляется ASP .NET Core Identity Требуется реализация со стороны разработчика
Схема базы данных для хранения пользователей
и утвержденийПользовательский интерфейс для выполнения
входа, создания и управления пользователями
(Razor Pages или контроллеры).  Включено
в необязательный пакет, который предоставляет
пользовательский интерфейс по умолчанию
Создание пользователя в базе данных Отправка сообщений электронной почты
Проверка пароля и правила Настройка утверждений для пользователей
Блокировка учетной записи пользователя (для
предотвращения атак методом полного перебора)Настройка сторонних поставщиков
идентификационной информации
Генерация кодов двухфакторной аутентификации
и управление ими
Генерация токенов для сброса пароля
Сохранение дополнительных утверждений в базе
данных
Управление сторонними поставщиками
идентификационной информации
(например, Facebook, Google, Twitter)
Самым большим недостатком является тот факт, что вам необходимо
предоставить весь пользовательский интерфейс для приложения, а так -
же объединить воедино все сервисы Identity для создания функциониру -
ющего процесса выполнения входа. Это довольно большой недостаток,
но он делает систему Identity чрезвычайно гибкой.

526 Глава 14 Аутентификация: добавляем пользователей в приложение
К счастью, ASP .NET Core включает в себя вспомогательную библиотеку
NuGet, Microsoft.AspNetCore.Identity.UI, которая дает вам весь шаблон-
ный код пользовательского интерфейса бесплатно. Это свыше 30 страниц
Razor Pages с возможностью выполнения входа, регистрации пользова-
телей. Здесь, среди прочего, используется двухфакторная аутентифика-
ция и внешние поставщики входа в учетную запись. При необходимости
эти страницы можно настроить, но у вас уже имеется готовый процесс
выполнения входа и не нужно писать никакого кода, а это – существен-
ный выигрыш. Мы рассмотрим эту библиотеку и то, как ее использовать,
в разделах 14.3 и 14.4.
По данной причине я настоятельно рекомендую использовать пользо-
вательский интерфейс по умолчанию в качестве отправной точки, неза-
висимо от того, создаете ли вы новое приложение или добавляете управ-
ление пользователями в  уже существующее. Но остается один вопрос:
когда следует использовать Identity, а когда нет?
Я большой поклонник Identity, поэтому склонен рекомендовать ее
в большинстве ситуаций, поскольку она решает множество вопросов, свя-
занных с безопасностью, в которых легко ошибиться. Мне приходилось
слышать аргументы не в пользу Identity. Некоторые из них небезосно-
вательны, а в отношении других можно поспорить:
я	уже	использую	 аутентификацию	 пользователей	 в своем	 приложе-
нии – отлично! В этом случае вы, вероятно, правы, Identity может
и не потребоваться. Но используется ли в вашей реализации двух -
факторная аутентификация? У вас есть блокировка учетных запи-
сей? Если нет и  вам нужно их добавить, тогда, вероятно, имеет
смысл рассмотреть возможность использования Identity;
я	не	хочу	использовать	 EF	Core – это разумная позиция. Вы могли бы
использовать Dapper, какой-либо иной инструмент объектно-реля-
ционного отображения или даже документоориентированную базу
данных для доступа к вашим данным. К счастью, интеграция с ба-
зой данных в  Identity является подключаемой, поэтому вы може-
те отказаться от интеграции с EF Core и использовать собственные
биб лиотеки интеграции с базами данных;
мой	вариант	 использования	 слишком	 сложен	для	Identity  – Identity
предоставляет низкоуровневые сервисы для аутентификации, по-
этому вы можете составлять различные фрагменты, как вам нра-
вится. Кроме того, это расширяемая система, поэтому, если вам
нужно, например, преобразовать утверждения перед созданием
принципала, вы можете это сделать;
мне	не	нравится	 интерфейс 	Razor	Pages	по	умолчанию – пользова-
тельский интерфейс по умолчанию в Identity не является обязатель-
ным. Вы по-прежнему можете использовать ее сервисы и управле-
ние пользователями и  предоставить собственный интерфейс для
выполнения входа и  регистрации пользователей. Однако имейте
в виду, что хотя это и дает бóльшую гибкость, таким образом вы так -
же очень легко можете создать брешь в системе управления пользо-
вателями, а это последнее место, где вам нужны такие проблемы!

527 Создание проекта, в котором используется ASP.NET Core Identity
я	не	использую	 Bootstrap	 для	стилизации	 своего	приложения – пользо-
вательский интерфейс Identity по умолчанию использует Bootstrap
в качестве фреймворка для работы со стилями, как и стандартные
шаблоны ASP .NET Core. К сожалению, нельзя так легко это изменить,
поэтому если вы используете другой фреймворк или вам нужно на-
строить сгенерированный HTML, вы все равно можете использовать
Identity, но вам нужно будет предоставить собственный пользова-
тельский интерфейс;
я	не	хочу	создавать	 собственную	 систему	 идентификации  – рад
это слышать. Использование внешнего поставщика идентифика-
ционной информации, такого как Azure Active Directory B2C или
Auth0, – отличный способ переложить ответственность и  риски,
связанные с  хранением личной информации пользователей на
третью сторону.
Каждый раз, когда вы планируете добавить управление пользователя-
ми в свое приложение ASP .NET Core, я бы порекомендовал использовать
Identity как отличный вариант для этого. В следующем разделе я проде-
монстрирую возможности Identity, создав новое приложение Razor Pages
с использованием пользовательского интерфейса Identity по умолчанию.
В разделе 14.4 мы возьмем этот шаблон и применим его к существующе-
му приложению, а в разделах 14.5 и 14.6 вы увидите, как переопределить
страницы по умолчанию.
14.3 Создание проекта, в котором используется
ASP.NET Core Identity
Я рассказал об аутентификации и  Identity в  общих чертах, но лучший
способ прочувствовать это в действии – увидеть работающий код. В этом
разделе мы рассмотрим код по умолчанию, сгенерированный шаблона-
ми ASP .NET Core с по мощью Identity, как работает этот проект и где мож -
но использовать Identity.
14.3.1 Создание проекта из шаблона
Мы начнем с использования шаблонов Visual Studio для генерации прос -
того приложения Razor Pages, которое применяет Identity для хранения
отдельных учетных записей пользователей в базе данных.
СОВЕТ  Вы можете создать эквивалентный проект с  по мощью
интерфейса командной строки .NET, выполнив команду dotnet new
webapp -au Individual -uld.
Чтобы создать шаблон с по мощью Visual Studio, вы должны использо-
вать VS 2019 или более позднюю версию. Кроме того, у вас должен быть
установлен набор средств разработки .NET 5.0.

528 Глава 14 Аутентификация: добавляем пользователей в приложение
1  Выберите File > New > Project (Файл > Создать > Проект) или Create
a New Project (Создать новый проект) на экране заставки.
2  Из списка шаблонов выберите ASP.NET Core Web Application
(Веб-приложение ASP .NET Core), убедившись, что выбираете шаб-
лон языка C#.
3  В следующем экране введите имя проекта, местоположение и имя
решения и щелкните Create (Создать).
4  Выберите шаблон веб-приложения и нажмите Change (Изменить)
в разделе Authentication (Аутентификация) для вызова диалого-
вого окна Authentication, показанного на рис. 14.7.
Выберите вариант Individual User Accounts,
чтобы  хранить локальные учетные записи
пользователей с помощью ASP .NET
Core Identity и EF CoreВыберите вариант
No Authentication,
чтобы создать шаблон
без аутентификацииВыберите вариант Store
User Accounts In-app
Параметр Work or School Accounts
настроит приложение на
использование внешнего
провайдера идентификационной
информации – с помощью Active
Directory (или Office 365, например)
для управления пользователями
и аутентификацией
Выбирайте вариант Windows
Authentication для сайтов интрасети,
где логин пользователя для Windows
обеспечивает механизм аутентификации
Рис. 14.7  Выбор режима аутентификации для нового шаблона приложения
ASP.NET Core в VS 2019
5  Выберите Individual User Accounts (Отдельные учетные записи
пользователей), чтобы создать приложение, сконфигурированное
с по мощью EF Core и ASP .NET Core Identity. Щелкните ОК.
6  Щелкните «Создать», чтобы создать приложение. Visual Studio ав-
томатически запустит команду dotnet restore, чтобы восстановить
все необходимые пакеты NuGet для проекта.
7  Запустите приложение, чтобы увидеть приложение по умолчанию,
как показано на рис. 14.8.
Этот шаблон должен быть вам знаком, но есть одна особенность: те-
перь у вас есть кнопки Register (Регистрация) и  Login (Вход)! Не стесняй-
тесь экспериментировать с шаблоном – создайте пользователя, выпол-
ните вход и выйдите из приложения, чтобы прочувствовать его. Когда
вы увидите, что вас все устраивает, посмотрите на код, сгенерированный
шаблоном, и код, который вам не пришлось писать благодаря ему.

529 Создание проекта, в котором используется ASP.NET Core Identity
Вы можете
создавать новых
пользователей
и выполнять
вход с помощью
виджета Login
Рис. 14.8 Шаблон по умолчанию с аутентификацией отдельной учетной записи
похож на шаблон без аутентификации с добавлением виджета Login в правом
верхнем углу страницы
14.3.2 Изучение шаблона в Обозревателе решений
Проект, созданный с по мощью шаблона и показанный на рис. 14.9, очень
похож на шаблон без аутентификации по умолчанию. Во многом это свя-
зано с  библиотекой пользовательского интерфейса по умолчанию, ко-
торая обеспечивает бóльшую часть функциональности, не заставляя вас
вникать в мелочи.
Пользовательский интерфейс ASP .NET Core
Identity по умолчанию содержится в области
под названием Identity Шаблон включает в себя DbContext
от EF Core и миграции, чтобы
сконфигурировать  схему базы данных
для ASP .NET Core Identity
Папка Pages идентична шаблону
без аутентификации, с дополнительным
представлением _LoginPartial Вы можете переопределить отдельные файлы
в пользовательском интерфейсе
по умолчанию, разместив файлы в
соответствующих местах в папке Areas/Identity
Рис. 14.9 Макет проекта шаблона по умолчанию. В зависимости от версии Visual Studio файлы
могут незначительно отличаться

530 Глава 14 Аутентификация: добавляем пользователей в приложение
Самым большим дополнением является папка Areas (Области) в кор-
не вашего проекта, где содержится папка Identity. Иногда области ис -
пользуются для организации разделов функциональности. Каждая об-
ласть может содержать собственную папку Pages, аналогичную основной
папке Pages в вашем приложении.
ОПРЕДЕЛЕНИЕ  Области используются для группировки страниц
Razor Pages в  отдельные иерархии для организационных целей.
Я  редко использую области и  предпочитаю создавать подпапки
в  основной папке Pages. Единственное исключение  – пользова-
тельский интерфейс Identity, который по умолчанию использует
отдельную область Identity. Для получения дополнительных сведе-
ний об областях см.: http://mng.bz/7Vw9.
Пакет Microsoft.AspNetCore.Identity.UI создает Razor Pages в  области
Identity. Вы можете переопределить любую страницу в этом пользова-
тельском интерфейсе по умолчанию, создав соответствующую страницу
в папке Areas/Identity/Pages своего приложения. Например, как показа-
но на рис. 14.9, шаблон по умолчанию добавляет файл _ViewStart.cshtml,
переопределяющий версию, включенную как часть пользовательского
интерфейса по умолчанию. Этот файл содержит следующий код, кото-
рый устанавливает по умолчанию пользовательский интерфейс Identity
Razor Pages для использования файла _Layout.cshtml вашего проекта по
умолчанию:
@{
Layout = "/Pages/Shared/_Layout.cshtml";
}
На этом этапе могут возникнуть некоторые очевидные вопросы: «От -
куда вы знаете, что входит в  пользовательский интерфейс по умолча-
нию?» и «Какие файлы можно переопределять?». Ответ  на эти вопросы
вы увидите в разделе 14.5, но в целом следует по возможности избегать
переопределения файлов. В конце концов, цель пользовательского ин-
терфейса по умолчанию – сократить количество кода, который вам нуж -
но писать!
Папка Data в вашем шаблоне нового проекта содержит класс EF Core,
DbContext, который называется ApplicationDbContext, и  миграции для
конфигурирования схемы базы данных, чтобы использовать Identity.
Подробнее об этой схеме я расскажу в разделе 14.3.3.
Последний дополнительный файл, включенный в  этот шаблон по
сравнению с версией без аутентификации, – это частичное представле-
ние Razor Pages/Shared/_LoginPartial.cshtml. Оно предоставляет ссылки
«Регистрация» и «Вход», которые вы видели на рис. 14.8, и отображается
в макете Razor по умолчанию, _Layout.cshtml.
Если вы заглянете внутрь файла _LoginPartial.cshtml, то увидите, как
маршрутизация работает с областями, путем объединения пути к стра-
нице Razor с  параметром маршрута {area} с  по мощью тег-хелперов.

531 Создание проекта, в котором используется ASP.NET Core Identity
Например, ссылка Login указывает на то, что /Account/Login находится
в области Identity, используя атрибут asp-area:
<a asp-area="Identity" asp-page="/Account/Login">Login</a>
СОВЕТ  Вы можете ссылаться на страницы Razor Pages в области
Identity, задав для Identity значение маршрута area. Вы можете
использовать атрибут asp-area в тег-хелперах, которые генериру -
ют ссылки.
Помимо новых файлов, включенных благодаря ASP .NET Core Iden-
tity, стоит открыть файл Startup.cs и посмотреть, что там изменилось.
Наиболее очевидным изменением является дополнительная настрой-
ка в ConfigureServices, которая добавляет все сервисы, необходимые
Identity.
Листинг 14.1  Добавление сервисов ASP.NET Core Identity
в ConfigureServices
public void ConfigureServices(IServiceCollection services)
{
services.AddDbContext<ApplicationDbContext>(options =>
options.UseSqlServer(
Configuration.GetConnectionString("DefaultConnection")));
services.AddDefaultIdentity<IdentityUser>(options =>
options.SignIn.RequireConfirmedAccount = true)
.AddEntityFrameworkStores<ApplicationDbContext>();
services.AddRazorPages();
}
Метод расширения AddDefaultIdentity() выполняет несколько
функций:
добавляет основные сервисы ASP .NET Core Identity;
настраивает тип пользователя приложения как IdentityUser. Это
модель сущности, которая хранится в базе данных и представляет
«пользователя» в  вашем приложении. При необходимости можно
расширить этот тип, но это не всегда необходимо, как будет показа-
но в разделе 14.6;
добавляет страницы Razor Pages пользовательского интерфейса по
умолчанию для регистрации, входа и управления пользователями;
настраивает поставщиков токенов для создания токенов двухфак -
торной аутентификации и токенов подтверждения по элект ронной
почте.ASP.NET Core Identity использует EF
Core, поэтому включает стандартную
конфигурацию EF Core.Добавляет систему Identity, включая пользовательский
интерфейс по умолчанию, и настраивает тип
пользователя как IdentityUser.
Требует от пользователей подтверждения
своих учетных записей (обычно по электронной почте),
перед тем как они выполнят вход. Настраивает Identity для хранения
данных в EF Core.

532 Глава 14 Аутентификация: добавляем пользователей в приложение
Есть еще одно очень важное изменение в файле Startup, в методе Con-
figure:
app.UseAuthentication()
Так вы добавляете компонент AuthenticationMiddleware в  конвей-
ер, чтобы можно было проверить входящие запросы, как показано на
рис. 14.3. Расположение	 этого	компонента	 очень	важно.	Его следует раз-
мещать после метода UseRouting() и перед методами UseAuthorization()
и UseEndpoints(), как показано в следующем листинге.
Листинг 14.2  Добавление компонента AuthenticationMiddleware
в конвейер промежуточного ПО
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
app.UseStaticFiles();
app.UseRouting();
app.UseAuthentication();
app.UseAuthorization();
app.UseEndpoints(endpoints =>
{
endpoints.MapRazorPages();
});
}
Если вы не используете такой конкретный порядок расположения
компонентов, то можете столкнуться со странными ошибками, когда
пользователи не проходят аутентификацию должным образом или по-
литики авторизации применяются неправильно. Такой порядок настра-
ивается в шаблонах автоматически, но нужно быть осторожным, если вы
обновляете существующее приложение или перемещаете компоненты
промежуточного ПО.
ВАЖНО  Методы UseAuthentication() и UseAuthorization() долж -
ны быть размещены между методами UseRouting() и  UseEnd-
points(). Кроме того, метод UseAuthorization() должен быть по-
мещен после метода UseAuthentication(). Вы можете добавить
дополнительные компоненты между каждым из этих вызовов,
пока сохраняется общий порядок расположения.
Теперь, когда у вас есть обзор дополнений, внесенных Identity, мы бо-
лее подробно рассмотрим схему базы данных и то, как Identity сохраняет
пользователей в базе данных. Промежуточное ПО, размещенное до UseAuthentication,
будет рассматривать все запросы как анонимные.
Промежуточное ПО маршрутизации определяет, какая
страница запрашивается, на основе URL-адреса запроса.
Метод UseAuthentication следует
размещать после метода UseRouting.
Метод UseAuthorization следует разместить после метода
UseAuthentication, чтобы он мог получить доступ к принципалу.Метод UseEndpoints должен быть последним после
установки принципала и применения авторизации.

533 Создание проекта, в котором используется ASP.NET Core Identity
14.3.3 Модель данных ASP.NET Core Identity
В готовом варианте и в шаблонах по умолчанию Identity использует EF
Core для хранения учетных записей пользователей. Он предоставляет
базовый класс DbContext, от которого можно наследовать, IdentityDbCon-
text. Он использует IdentityUser в качестве сущности пользователя для
вашего приложения.
В шаблоне класс DbContext называется ApplicationDbContext. Если вы
откроете этот файл, то увидите, что он очень скудный; он наследует от
базового класса IdentityDbContext, который я  описал ранее, и  все. Что
дает вам этот базовый класс? Самый простой способ увидеть это – обно-
вить базу данных, используя миграции.
Применение миграций – это тот же процесс, что и в главе 12. Убеди-
тесь, что строка подключения указывает на то место, где вы хотите соз-
дать базу данных, откройте командную строку в папке проекта и запус -
тите эту команду, чтобы обновить базу данных:
dotnet ef database update
Если базы данных еще нет, интерфейс командной строки создаст ее.
На рис.  14.10 показано, как выглядит база данных шаблона по умол-
чанию1.
Утверждения, ассоциированные
с каждым пользователем,
хранятся в AspNetUserClaimsASP .NET Core использует миграции EF Core.
История примененных миграций хранится
в таблице __EFMigrationsHistory
Таблицы AspNetRoles, AspNetRoleClaims
и AspNetUserRoles предоставляют
авторизацию на основе ролей
Пользовательские сущности хранятся
в таблице AspNetUsersТаблицы AspNetUserLogins
и AspNetUserT okens
используются для управления
деталями входа с помощью
сторонних ресурсов, таких как
Facebook и Google
Рис. 14.10 Схема базы данных, используемая ASP .NET Core Identity
СОВЕТ  Если после выполнения команды dotnet ef вы видите
ошибку, убедитесь, что установили инструмент командной строки
.NET, следуя инструкциям, приведенным в  разделе 12.3.1. Также
убедитесь, что вы запускаете команду из папки project, а не из пап-
ки solution.
Как много таблиц! Вам не нужно напрямую взаимодействовать с эти-
ми таблицами – Identity сделает это за вас, но не помешает иметь базовое
представление о том, для чего они нужны:
1 Если вы работаете с MS SQL Server (или LocalDB), то можете использовать обо-
зреватель объектов SQL Server в Visual Studio для просмотра таблиц и объек -
тов в своей базе данных. Для получения подробной информации см. http://
mng.bz/mg8r .

534 Глава 14 Аутентификация: добавляем пользователей в приложение
__EFMigrationsHistory – стандартная таблица миграции EF Core, в ко-
торой записывается, какие миграции были применены;
AspNetUsers – 	сама таблица профилей пользователей. Сюда сериали-
зуется IdentityUser. Вскоре мы подробнее рассмотрим эту таблицу;
AspNetUserClaims  – утверждения, ассоциированные с  определен-
ным пользователем. У пользователя может быть много таких объ-
ектов, поэтому они моделируются как тип связи «многие к одному»;
AspNetUserLogins	 и  AspNetUserTokens  – они связаны с  выполне-
нием входа в  учетную запись, используя сторонние сервисы. При
настройке позволяют пользователям выполнить вход с  учетной
записью  Google или Facebook (например), вместо того чтобы созда-
вать пароль в вашем приложении;
AspNetUserRoles, 	AspNetRoles	 и  AspNetRoleClaims  – эти таблицы  –
свое го рода наследство, оставшееся от старой модели полномочий
на основе ролей, существовавшей до .NET версии 4,5 вместо модели
на основе утверждений. Они позволяют определить роли, к которым
могут принадлежать несколько пользователей. Каждой роли можно
присвоить некое число утверждений. Эти утверждения фактически
наследуются принципалом, когда им присваивается эта роль.
Вы сами можете изучить эти таблицы, но самая интересная из них –
это AspNetUsers, показанная на рис. 14.11.
По умолчанию ASP .NET Core Identity использует
идентификаторы GUID для идентификатора
пользователя. Они хранятся в базе данных в виде строк
Таблица содержит все необходимые поля для
аутентификации пользователя, подтверждения адреса
электронной почты и номера телефона, двухфакторной
аутентификации и блокировки учетной записи
Рис. 14.11 Таблица AspNetUsers используется для хранения всей информации,
необходимой для аутентификации пользователя
Большинство столбцов в  таблице AspNetUsers связаны с  безопас -
ностью – адрес электронной почты пользователя, хеш пароля, подтвер-
дил ли он свою электронную почту, активирована ли двухфакторная
аутен тификация и т. д. По умолчанию здесь нет столбцов для дополни-
тельной информации, например для имени пользователя.
ПРИМЕЧАНИЕ  Из рис. 14.11 видно, что идентификатор первич-
ного ключа хранится в  виде столбца типа string. По умолчанию
Identity использует для идентификатора Guid. Чтобы настроить
тип данных, см. раздел «Изменение типа первичного ключа» в до-
кументации Microsoft: http://mng.bz/5jdB.

535 Создание проекта, в котором используется ASP.NET Core Identity
Все дополнительные свойства пользователя хранятся в виде утверж -
дений в таблице AspNetUserClaims, ассоциированной с этим пользовате-
лем. Это позволяет добавлять произвольную дополнительную информа-
цию без необходимости изменять схему базы данных. Хотите сохранить
дату рождения пользователя? Можете добавить утверждение к  этому
пользователю, и  не нужно изменять схему базы данных. Вы увидите,
как это работает, в разделе 14.6, когда будете добавлять объект Name для
каждого нового пользователя.
ПРИМЕЧАНИЕ  Часто добавление утверждений является самым
простым способом расширить сущность IdentityUser по умол-
чанию, но вы также можете добавить дополнительные свойства
в IdentityUser напрямую. Это требует изменений в базе данных,
но тем не менее полезно во многих ситуациях. Вы можете прочи-
тать, как добавить пользовательские данные, используя этот под-
ход, здесь: http://mng.bz/Xd61.
Важно понимать разницу между сущностью IdentityUser (хранимой
в таблице AspNetUsers) и объектом ClaimsPrincipal, который фактически
представляет свойство HttpContext.User. Когда пользователь впервые
выполняет вход, из базы данных загружается IdentityUser. Эта сущность
сочетается с дополнительными утверждениями для пользователя из таб-
лицы AspNetUserClaims для создания объекта ClaimsPrincipal. Именно
этот объект ClaimsPrincipal используется для аутентификации и сериа-
лизуется в cookie-файл аутентификации, а не IdentityUser.
Полезно иметь мысленную модель базовой схемы базы данных, кото-
рую использует Identity, но в повседневной работе вам не нужно взаи-
модействовать с  ней напрямую  – в  конце концов, для этого и  нужна
Identity! В  следующем разделе мы рассмотрим другой конец шкалы –
пользовательский интерфейс приложения и то, что вы получаете вместе
с пользовательским интерфейсом по умолчанию.
14.3.4 Взаимодействие с ASP.NET Core Identity
Вы захотите самостоятельно изучить интерфейс по умолчанию, чтобы
понять, как сочетаются все элементы вместе, но в этом разделе я выде-
лю то, что вы получаете уже в готовом виде, а также те области, которые
обычно сразу требуют дополнительного внимания.
Точкой входа пользовательского интерфейса по умолчанию являет -
ся страница регистрации пользователя приложения, как показано на
рис.  14.12. Страница регистрации позволяет пользователям регистри-
роваться в  приложении путем создания новой сущности IdentityUser
с адресом электронной почты и паролем. После создания учетной записи
пользователи перенаправляются на страницу, где указано, что они долж -
ны подтвердить адрес своей электронной почты. По умолчанию сервис
электронной почты не активирован. Все зависит от того, настраиваете ли
вы внешний почтовый сервис. Вы можете прочитать, как активировать
отправку электронной почты в документации Microsoft «Подтверждение

536 Глава 14 Аутентификация: добавляем пользователей в приложение
учетной записи и восстановление пароля в ASP .NET Core», на странице
http://mng.bz/6gBo.
Пользователи вводят адрес электронной
почты и пароль для регистрации в приложении
и перенаправляются на страницу подтверждения
регистрации
Шаблоны пользовательского интерфейса по умолчанию
включают в себя ссылки на документацию по ASP .NET
Core для активации внешних провайдеров входа
и службы отправки электронной почты
Рис. 14.12 Процесс регистрации для пользователей, применяющих
пользовательский интерфейс Identity по умолчанию. Пользователи вводят адрес
электронной почты и пароль и перенаправляются на страницу подтверждения
адреса своей электронной почты. Это страница-заполнитель, созданная по
умолчанию, но если вы активируете подтверждение по электронной почте, эта
страница обновится соответствующим образом
Как только вы ее настроите, пользователи будут автоматически полу -
чать электронное письмо со ссылкой для подтверждения своей учетной
записи.
По умолчанию адреса электронной почты пользователей должны быть
уникальными (у вас не может быть двух пользователей с одним и тем же
адресом почты), а пароль должен соответствовать разным требованиям
к длине и сложности. Можно настроить эти и другие параметры в кон-
фигурационной лямбда-функции вызова метода AddDefaultIdentity()
в файле Startup.cs, как показано в следующем листинге.
Листинг 14.3  Настройка параметров Identity в ConfigureServices
в файле Startup.cs
services.AddDefaultIdentity<IdentityUser>(options =>
{
options.SignIn.RequireConfirmedAccount = true;
options.Lockout.AllowedForNewUsers = true;
options.Password.RequiredLength = 12;
options.Password.RequireNonAlphanumeric = false;
options.Password.RequireDigit = false;
})
.AddEntityFrameworkStores<AppDbContext>();Требуем от пользователей подтверждения своей учетной записи
по электронной почте, прежде чем они смогут выполнить вход.
Активирует блокировку пользователя, чтобы предотвратить атаки
методом перебора, направленные на пароли пользователей.Обновляем требования к паролю.
На данный момент предписано
требовать длинные пароли.

537 Создание проекта, в котором используется ASP.NET Core Identity
После того как пользователь зарегистрировался в вашем приложении,
ему необходимо выполнить вход, как показано на рис. 14.13. В правой
части страницы входа шаблоны пользовательского интерфейса по умол-
чанию описывают, как вы, будучи разработчиком, можете сконфигури-
ровать внешних поставщиков входа в учетную запись, таких как Face-
book и Google. Для вас это полезная информация, но это одна из причин,
по которой вам может потребоваться настроить шаблоны пользователь-
ского интерфейса по умолчанию, как будет показано в разделе 14.5.
Шаблоны пользовательского интерфейса
по умолчанию включают в себя ссылки
на документацию на странице входа
и на странице активации двухфакторной
аутентификацииПосле входа вы можете
получить доступ к страницам
управления, щелкнув
по ссылке электронной почты
в заголовке
Страницы управления
позволяют пользователям
обновлять свой адрес
электронной почты
и пароль, активировать
двухфакторную
аутентификацию и удалять
свою учетную запись
Рис. 14.13 Вход с существующим пользователем и управление учетной записью
пользователя. На странице входа описано, как настроить внешних поставщиков
входа, таких как Facebook и Google. Страницы управления пользователями
позволяют пользователям изменять адрес своей электронной почты и пароль
и настраивать двухфакторную аутентификацию
После того как пользователь выполнил вход, он может получить до-
ступ к страницам управления пользовательским интерфейсом Identity.
Они позволяют пользователям изменять адрес своей электронной поч-
ты, менять пароль, настраивать двухстороннюю аутентификацию с по-
мощью приложения-аутентификатора или удалять все свои личные
данные.
Большинство этих функций работают без каких-либо усилий с вашей
стороны, если вы уже настроили отправку электронной почты1.
Я рассказал обо всем, что вы получаете в шаблонах пользовательско-
го интерфейса по умолчанию. Вам может показаться, что информации
мало, но здесь изложено множество требований, которые являются об-
щими почти для всех приложений. Тем не менее есть несколько вещей,
которые вы почти всегда захотите настроить:
1 Вы можете улучшить страницу аутентификатора, активировав генерацию QR-
кода, как описано здесь: http://mng.bz/nM5a.

538 Глава 14 Аутентификация: добавляем пользователей в приложение
сконфигурируйте сервис отправки электронной почты, чтобы акти-
вировать подтверждение учетной записи и восстановление пароля,
как описано в  документации Microsoft «Подтверждение учетной
запи си и  восстановление пароля в  ASP .NET Core»: http://mng.bz/
vzy7;
добавьте генератор QR-кода для страницы активации двухфактор-
ной аутентификации, как описано в документации Microsoft «Ак -
тивация генерации QR-кода для приложений, использующих TOTP
в ASP .NET Core»: http://mng.bz/4Zmw;
настройте страницы регистрации и входа, чтобы удалить ссылку на
документацию для активации внешних сервисов. Вы увидите, как
это сделать, в разделе 14.5. В качестве альтернативы вы можете пол-
ностью отключить регистрацию пользователей, как описано здесь:
http://mng.bz/mMG;
соберите дополнительную информацию о пользователях на страни-
це регистрации. Вы увидите, как это сделать, в разделе 14.6.
Есть еще много способов расширить или обновить систему Identity
и множество доступных вариантов, поэтому я рекомендую изучить «Об-
зор аутентификации в  ASP .NET Core» на странице http://mng.bz/XdGv ,
чтобы увидеть варианты, которые вам предлагаются. В следующем раз-
деле вы увидите, как выполнить еще одно распространенное требова-
ние: добавить пользователей в существующее приложение.
14.4 Добавляем ASP.NET Core Identity
в существующий проект
В этом разделе мы добавим пользователей в  приложение рецептов из
глав 12 и 13. Это работающее приложение, в которое вы хотите добавить
пользовательскую функциональность. В главе 15 мы расширим возмож -
ности приложения, чтобы ограничить контроль над пользователями, ко-
торым разрешено редактировать рецепты.
К концу этого раздела у вас будет приложение со страницей регистра-
ции, экраном входа и экраном управления учетной записью, аналогич-
ными шаблонам по умолчанию. У вас также будет постоянный виджет
в  правом верхнем углу экрана, показывающий статус входа текущего
пользователя, как показано на рис. 14.14.
Как и в разделе 14.3, на данном этапе я не буду изменять какие-либо
значения по умолчанию, поэтому мы не будем настраивать внешних по-
ставщиков входа в учетную запись, подтверждение по электронной поч-
те или двухфакторную аутентификацию. Моя задача – только добавить
ASP .NET Core Identity в существующее приложение, которое уже исполь-
зует EF Core.

539 Добавляем ASP.NET Core Identity в существующий проект
Виджет Login показывает адрес
электронной почты пользователя,
выполнившего вход и ссылку для выхода
Рис. 14.14 Приложение рецептов после добавления аутентификации с виджетом
Login
СОВЕТ  Прежде чем приступить к добавлению Identity в сущест -
вующий проект, стоит убедиться, что вы знакомы с новыми шаб-
лонами проектов. Создайте тестовое приложение и  рассмотрите
возможность настройки внешнего поставщика входа в  учетную
запись, настройки подтверждения адреса электронной почты
и активации двухфакторной аутентификации. Это займет немного
времени, но будет бесценным опытом для расшифровки ошибок
при добавлении Identity в существующие приложения.
Чтобы добавить Identity в  приложение, необходимо сделать сле-
дующее.
1 Добавьте пакеты NuGet для ASP .NET Core Identity.
2  Настройте класс Startup для использования AuthenticationMiddle-
ware и добавьте сервисы Identity в контейнер внедрения зависимо-
стей.
3 Обновите модель данных EF Core с по мощью сущностей Identity.
4  Обновите страницы Razor Pages и  макеты, чтобы предоставить
ссылки на пользовательский интерфейс Identity.
В этом разделе мы рассмотрим каждый из этих шагов по очереди.
В конце раздела 14.4 вы успешно добавите учетные записи пользовате-
лей в приложение с рецептами.
14.4.1 Настройка сервисов ASP.NET Core Identity
и промежуточного ПО
Можно добавить ASP .NET Core Identity с пользовательским интерфейсом
по умолчанию в существующее приложение, указав два пакета NuGet:
Microsoft.AspNetCore.Identity.EntityFrameworkCore – предоставляет
все основные сервисы Identity и интеграцию с EF Core;
Microsoft.AspNetCore.Identity.UI  – предоставляет страницы Razor
Pages пользовательского интерфейса по умолчанию.

540 Глава 14 Аутентификация: добавляем пользователей в приложение
Обновите файл проекта .csproj, включив в него эти два пакета:
<PackageReference
Include="Microsoft.AspNetCore.Identity.EntityFrameworkCore"
Version="5.0.0" />
<PackageReference
Include="Microsoft.AspNetCore.Identity.UI" Version="5.0.0" />
Они содержат все дополнительные необходимые зависимости, чтобы
добавить Identity с пользовательским интерфейсом по умолчанию. Обя-
зательно запустите команду dotnet restore после добавления их в свой
проект.
После добавления пакетов можно обновить файл Startup.cs, чтобы
включить сервисы Identity, как показано ниже. Это похоже на настройку
шаблона по умолчанию, которая была показана в листинге 14.1, но обя-
зательно укажите ссылку на существующий AppDbContext.
Листинг 14.4  Добавление сервисов ASP.NET Core Identity
в приложение с рецептами
public void ConfigureServices(IServiceCollection services)
{
services.AddDbContext<AppDbContext>(options =>
options.UseSqlServer(
Configuration.GetConnectionString("DefaultConnection")));
services.AddDefaultIdentity<ApplicationUser>(options =>
options.SignIn.RequireConfirmedAccount = true)
.AddEntityFrameworkStores<AppDbContext>();
services.AddRazorPages();
services.AddScoped<RecipeService>();
}
Так вы добавляете все необходимые сервисы и настраиваете Identity
для использования EF Core. Я представил здесь новый тип Application-
User, который мы будем использовать для настройки нашей пользова-
тельской сущности позже. Вы увидите, как добавить этот тип, в разде-
ле 14.4.2.
Настроить компонент AuthenticationMiddleware несколько проще: до-
бавьте его в конвейер в методе Configure. Как видно из листинга 14.5,
я  добавил промежуточное ПО после метода UseRouting(), непосред-
ственно перед UseAuthorization(). Как я упоминал в разделе 14.3.2, важ -
но, чтобы вы использовали данный порядок следования компонентов
промежуточного ПО в своем приложении.Существующая
конфигурация
сервиса
не изменилась.
Добавляет сервисы Identity в контейнер внедрения зависимостей
и использует специальный тип пользователя, ApplicationUser.Убедитесь, что вы используете
имя существующего DbContext.

541 Добавляем ASP.NET Core Identity в существующий проект
Листинг 14.5  Добавляем компонент AuthenticationMiddleware
в приложение рецептов
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
// Другая конфигурация не показана;
app.UseStaticFiles();
app.UseRouting();
app.UseAuthentication();
app.UseAuthorization();
app.UseEndpoints(endpoints =>
{
endpoints.MapRazorPages();
});
}
Мы настроили приложение для использования Identity, поэтому сле-
дующим шагом будет обновление модели данных EF Core. Вы уже ис -
пользуете EF Core в этом приложении, поэтому вам необходимо обно-
вить свою схему базу данных для включения таблиц, которые требуются
Identity.
14.4.2 Обновление модели данных EF Core
для поддержки Identity
Код, приведенный в листинге 14.4, не компилируется, поскольку ссыла-
ется на тип ApplicationUser, которого еще не существует. Создайте его
в папке Data, используя следующую строку:
public class ApplicationUser : IdentityUser { }
В  данном случае не обязательно создавать специальный пользова-
тельский тип (например, шаблоны по умолчанию используют Identity-
User), но я  считаю, что проще добавить производный тип сейчас, а  не
пытаться модернизировать его позже, если вам нужно будет добавить
дополнительные свойства в пользовательский тип.
В разделе 14.3.3 вы видели, что Identity предоставляет класс DbContext
с  именем IdentityDbContext, от которого можно наследовать. Базовый
класс IdentityDbContext включает в себя необходимый тип DbSet<T> для
хранения пользовательских сущностей с по мощью EF Core.
Обновить существующий класс DbContext для Identity просто – обно-
вите класс DbContext своего приложения, чтобы наследовать от Identi-
tyDbContext, как показано в следующем листинге. В данном случае мы
используем обобщенную версию базового контекста Identity и  предо-
ставляем тип ApplicationUser.StaticFileMiddleware никогда не будет
воспринимать запросы как
аутентифицированные, даже после того,
как вы выполните вход.
Добавляем AuthenticationMiddleware после метода
UseRouting() и до метода UseAuthorization.Промежуточное ПО, которое идет после
компонента AuthenticationMiddleware, может
читать принципала из HttpContext.User.

542 Глава 14 Аутентификация: добавляем пользователей в приложение
Листинг 14.6  Обновляем класс AppDbContext, чтобы использовать
IdentityDbContext
public class AppDbContext : IdentityDbContext<ApplicationUser>
{
public AppDbContext(DbContextOptions<AppDbContext> options)
: base(options)
{ }
public DbSet<Recipe> Recipes { get; set; }
}
Фактически, обновив таким образом базовый класс контекста, вы
добавили всю загрузку новых сущностей в модель данных EF Core. Как
было показано в главе 12, всякий раз, когда модель данных EF Core из-
меняется, необходимо создавать новую миграцию и применять эти из-
менения к базе данных.
На этом этапе ваше приложение должно скомпилироваться, поэтому
можно добавить новую миграцию, AddIdentitySchema:
dotnet ef migrations add AddIdentitySchema
Последний шаг – обновить страницы Razor Pages и макеты приложе-
ния, чтобы они ссылались на пользовательский интерфейс Identity по
умолчанию. Обычно добавление 30 новых страниц Razor Pages в прило-
жение – довольно трудоемкий процесс, но использование пользователь-
ского интерфейса Identity по умолчанию делает его проще некуда.
14.4.3 Обновление представлений Razor для связи
с пользовательским интерфейсом Identity
Технически не нужно обновлять страницы Razor, чтобы ссылаться на
страницы, включенные в  пользовательский интерфейс по умолчанию,
но вы, как минимум, вероятно, захотите добавить виджет Login в свой
макет приложения, а также убедиться, что ваши страницы используют
тот же базовый файл Layout.cshtml, что и остальная часть приложения.
Мы начнем с исправления макета страниц Identity. Создайте файл по
«волшебному» пути Areas/Identity/Pages/_ViewStart.cshtml и  добавьте
туда следующее содержимое:
@{ Layout = "/Pages/Shared/_Layout.cshtml"; }
Таким образом, макет по умолчанию для страниц Identity становится
макетом вашего приложения по умолчанию. Затем добавьте файл _Log-
inPartial.cshtml в Pages/Shared, чтобы определить виджет Login, как по-
казано в следующем листинге. Этот код в значительной степени иденти-
чен шаблону, сгенерированному шаблоном по умолчанию, но здесь мы Обновляем для наследования из контекста
Identity, а не напрямую из DbContext.
Остальная часть
класса остается
прежней.

543 Добавляем ASP.NET Core Identity в существующий проект
используем наш пользовательский ApplicationUser вместо стандартного
IdentityUser.
Листинг 14.7  Добавляем файл _LoginPartial.cshtml в существующее
приложение
@using Microsoft.AspNetCore.Identity
@using RecipeApplication.Data;
@inject SignInManager<ApplicationUser> SignInManager
@inject UserManager<ApplicationUser> UserManager
<ul class="navbar-nav">
@if (SignInManager.IsSignedIn(User))
{
<li class="nav-item">
<a class="nav-link text-dark" asp-area="Identity"
asp-page="/Account/Manage/Index" title="Manage">Hello
@User.Identity.Name!</a>
</li>
<li class="nav-item">
<form class="form-inline" asp-page="/Account/Logout"
asp-route-returnUrl="@Url.Page("/", new { area = "" })"
asp-area="Identity" method="post" >
<button class="nav-link btn btn-link text-dark"
type="submit">Logout</button>
</form>
</li>
}
else
{
<li class="nav-item">
<a class="nav-link text-dark" asp-area="Identity"
asp-page="/Account/Register">Register</a>
</li>
<li class="nav-item">
<a class="nav-link text-dark" asp-area="Identity"
asp-page="/Account/Login">Login</a>
</li>
}
</ul>
Этот фрагмент показывает текущий статус входа пользователя
и  предо ставляет ссылки для регистрации или входа в  учетную запись.
Все, что осталось сделать, – визуализировать частичное представление,
вызвав
<partial name="_LoginPartial" />
в основном файле макета вашего приложения _Layout.cshtml.
Вот и все: вы добавили Identity в существующее приложение. Пользо-
вательский интерфейс по умолчанию делает этот процесс относитель-
но простым, и вы можете быть уверены, что не создали никаких бре-Обновляем пространство имен нашего
проекта, которое содержит ApplicationUser.
В шаблоне по умолчанию используется
IdentityUser. Выполняем обновление,
чтобы использовать ApplicationUser.

544 Глава 14 Аутентификация: добавляем пользователей в приложение
шей в системе безопасности, создавая собственный пользовательский
интерфейс!
Как я писал в разделе 14.3.4, есть некоторые функции, недоступные
в пользовательском интерфейсе по умолчанию. Их нужно реализовать
самостоятельно, например подтверждение по электронной почте и ге-
нерация QR-кода для двухфакторной аутентификации. Также часто бы-
вает, что в каких-то местах вам нужно обновить одну страницу. В сле-
дующем разделе я покажу, как заменить страницу в пользовательском
интерфейсе по умолчанию, без необходимости самостоятельно пере-
страивать весь пользовательский интерфейс.
14.5 Настройка страницы в пользовательском
интерфейсе ASP.NET Core Identity
по умолчанию
В этом разделе вы узнаете, как использовать скаффолдинг для замены
отдельных страниц в пользовательском интерфейсе Identity по умолча-
нию. Вы научитесь заменять страницу таким образом, чтобы она пере-
определяла пользовательский интерфейс по умолчанию, позволяя на-
страивать и шаблон Razor, и обработчики страниц PageModel.
Теоретически, когда Identity предоставляет весь пользовательский
интерфейс целиком для вашего приложения, это здорово, но на прак -
тике появляются шероховатости, как было показано в разделе 14.3.4. По
умолчанию пользовательский интерфейс предоставляет столько, сколь-
ко может, но есть некоторые вещи, которые вы, возможно, захотите от -
регулировать. Например, на страницах входа и  регистрации описано,
как настроить внешних поставщиков входа в учетную запись для при-
ложений ASP .NET Core, как вы видели на рис. 14.12 и 14.13. Это полезная
информация для вас как для разработчика, но это не то, что вы хотите
показывать своим пользователям. Еще одно часто упоминаемое требо-
вание – это желание изменить внешний вид и поведение одной или не-
скольких страниц.
К счастью, пользовательский интерфейс Identity по умолчанию пред-
назначен для постепенной замены, поэтому вы можете переопределить
одну страницу без необходимости самостоятельно перестраивать весь
пользовательский интерфейс. Кроме того, и в Visual Studio, и в интер-
фейсе командной строки .NET есть функции, позволяющие заменять лю-
бую (или все) страницу в пользовательском интерфейсе по умолчанию,
чтобы не приходилось начинать все сначала, когда вы хотите настроить
страницу.
ОПРЕДЕЛЕНИЕ  Скаффолдинг  – это процесс генерации файлов
в  проекте, которые служат основой для настройки. В  Identity су -
ществует для этого специальный инструмент, который добавляет

545 Настройка страницы в пользовательском интерфейсе ASP.NET Core Identity
страницы Razor Pages в нужные места, чтобы они переопределяли
эквивалентные страницы пользовательского интерфейса по умол-
чанию. Первоначально код в таких страницах совпадает с кодом
пользовательского интерфейса Identity по умолчанию, но его мож -
но настроить.
В качестве примера изменений, которые легко можно внести, мы из-
меним страницу регистрации и удалим раздел дополнительной инфор-
мации о внешних поставщиках. Следующие шаги описывают, как изме-
нить страницу Register.cshtml в Visual Studio. В качестве альтернативы
можно использовать интерфейс командной строки .NET1.
1  Добавьте пакеты Microsoft.VisualStudio.Web.CodeGeneration.Design
и Microsoft.EntityFrameworkCore.Tools в файл проекта, если они еще
не добавлены. Visual Studio использует их, чтобы правильно доба-
вить заготовки в ваше приложение, и без них вы можете получить
ошибку при запуске инструмента скаффолдинга:
<PackageReference Version="5.0.0"
Include="Microsoft.VisualStudio.Web.CodeGeneration.Design" />
<PackageReference Version="5.0.0"
Include="Microsoft.EntityFrameworkCore.Tools" />
2  Убедитесь, что ваш проект собирается, – если это не так, инстру -
мент скаффолдинга прекратит работу, прежде чем будут добавле-
ны новые страницы.
3  Щелкните по проекту правой кнопкой мыши и  выберите Add >
New Scaffolded Item.
4  В диалоговом окне выбора выберите Identity из категории и  на-
жмите Add.
5  В диалоговом окне Add Identity выберите страницу Account/Reg-
ister и выберите AppDbContext приложения в качестве класса Data-
Context, как показано на рис. 14.15. Щелкните Add, чтобы изменить
страницу.
Visual Studio собирает ваше приложение, а затем генерирует страницу
Register.cshtml за вас, поместив ее в папку Areas/Identity/Pages/Account.
Он также генерирует несколько вспомогательных файлов, как показано
на рис. 14.16. В основном они требуются для того, чтобы гарантировать,
что ваша новая страница Register.cshtml может ссылаться на остальные
страницы в пользовательском интерфейсе Identity по умолчанию.
Нас интересует страница Register.cshtml, поскольку мы хотим настро-
ить пользовательский интерфейс на странице регистрации, но если вы
заглянете внутрь страницы, где находится код программной части, Reg-
1 Установите необходимые инструменты и  пакеты интерфейса командной
строки .NET, как описано на странице http://mng.bz/yYGB. Затем выполните
команду
dotnet aspnet-codegenerator identity -dc RecipeApplication.Data.AppDbCon-
text --files "Account.Register".

546 Глава 14 Аутентификация: добавляем пользователей в приложение
ister.cshtml.cs, то увидите, сколько сложностей скрывает от вас пользо-
вательский интерфейс Identity по умолчанию. Нельзя сказать, что они
непреодолимы (мы настроим обработчик страницы в разделе 14.6), но
всегда полезно избегать самостоятельного написания кода, если у  вас
есть средства, которые могут сделать это за вас.
Оставьте поле макета пустым
Переопределите файл
Account\Register
Выберите существующий
контекст данных
Щелкните Add, чтобы создать
шаблон файла
Рис. 14.15 Использование Visual Studio, чтобы изменить страницы Identity.
Сгенерированные страницы Razor Pages будут переопределять версии,
предоставляемые пользовательским интерфейсом по умолчанию
Файлы _ViewImports добавляют
ссылки на пространства имен
для ваших специальных
страницШаблонная страница Register.cshtml
и PageModel файла Register.cshtml.cs
Дубликат частичного представления
сценариев валидации,
используемого пользовательским
интерфейсом по умолчанию
Артефакт процесса построения
шаблонов, который можно
безопасно удалить _ViewStart устанавливает макет
страниц пользовательского
интерфейса идентификации
в соответствии с макетом вашего
приложения
Рис. 14.16 Генерируем страницу Register.cshtml вместе со вспомогательными
файлами, необходимыми для интеграции с остальной частью пользовательского
интерфейса Identity по умолчанию
Теперь, когда у вас есть шаблон Razor в приложении, можно настроить
его по своему усмотрению. Обратной стороной является то, что теперь
вы сопровождаете больше кода, по сравнению с тем, что у вас было, ког -
да вы использовали пользовательский интерфейс по умолчанию. Вам не
пришлось его писать, но, возможно, вам все равно придется обновить его
при выходе новой версии ASP .NET Core.
Мне нравится использовать небольшой трюк, когда дело доходит до
подобного переопределения пользовательского интерфейса Identity по

547 Управление пользователями: добавление специальных данных для пользователей
умолчанию. Во многих случаях на самом деле не нужно менять обра-
ботчики	страниц для страниц Razor, а только представление. Этого мож -
но добиться, удалив файл PageModel Register.cshtml.cs и  указав новому
файлу с  расширением .cshtml на исходную PageModel, которая является
частью  пакета NuGet пользовательского интерфейса по умолчанию.
Другое преимущество этого подхода заключается в том, что вы мо-
жете удалить и другие файлы, которые были заменены автоматически.
В целом можно внести следующие изменения.
1  Обновите директиву @model в файле Register.cshtml, чтобы она ука-
зывала на PageModel пользовательского интерфейса по умолчанию.
@model Microsoft.AspNetCore.Identity.UI.V4.Pages.Account.Internal
.RegisterModel
2 Обновите файл Areas/Identity/Pages/_ViewImports.cshtml:
@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers
3 Удалите файл Areas/Identity/Pages/IdentityHostingStartup.cs.
4 Удалите файл Areas/Identity/Pages/_ValidationScriptsPartial.cshtml.
5 Удалите файл Areas/Identity/Pages/Account/Register.cshtml.cs.
6 Удалите файл Areas/Identity/Pages/Account/_ViewImports.cshtml.
После внесения всех этих изменений вы получите лучшее из обоих ми-
ров – вы сможете обновить HTML Razor Pages пользовательского интер-
фейса по умолчанию, не беря на себя ответственность за сопровождение
кода программной части пользовательского интерфейса по умолчанию.
СОВЕТ  В исходном коде для этой книги можно увидеть эти изме-
нения в действии, где представление страницы регистрации было
настроено таким образом, чтобы удалить ссылки на внешние по-
ставщики идентификационной информации.
К сожалению, не всегда можно использовать PageModel пользователь-
ского интерфейса по умолчанию. Иногда необходимо обновить обработ -
чики страниц, например если вы хотите изменить функциональность об-
ласти Identity, а не просто внешний вид. Существует распространенное
требование, согласно которому необходимо сохранять дополнительную
информацию о пользователе, как будет показано в следующем разделе.
14.6 Управление пользователями: добавление
специальных данных для пользователей
В этом разделе вы увидите, как настроить объект ClaimsPrincipal, на -
значенный вашим пользователям, добавляя дополнительные утвержде-
ния в таблицу AspNetUserClaims при создании пользователя. Вы также

548 Глава 14 Аутентификация: добавляем пользователей в приложение
увидите, как получить доступ к этим объектам на страницах Razor Pages
и шаблонах.
Очень часто следующим шагом после добавления Identity в приложе-
ние является его настройка.
Шаблоны по умолчанию требуют только адреса электронной почты
и пароля для регистрации. Что, если вам нужна дополнительная информа-
ция, например понятное имя для пользователя? Кроме того, я упоминал,
что мы используем утверждения для безопасности, а что, если вы хотите
добавить утверждение с именем IsAdmin, определенным пользователем?
Вы знаете, что у каждого принципала есть набор утверждений, поэто-
му концептуально для добавления любого такого утверждения требуется
лишь добавить его в коллекцию пользователя. Есть два основных случая,
когда нужно предоставить пользователю утверждение:
каждому	 пользователю	 при	первой	регистрации	 в приложении. На -
пример, вы можете добавить поле «Имя» в  форме регистрации
и добавить его в качестве утверждения для пользователя, когда он
регистрируется;
вручную, 	после	того	как	пользователь	 уже	зарегистрировался. Это
обычное дело для утверждений, используемых в качестве полномо-
чий, когда существующий пользователь может захотеть добавить
утверждение IsAdmin конкретному пользователю после регистра-
ции в приложении.
В этом разделе я покажу вам первый подход, автоматически добавляя
новые утверждения к пользователю при их создании. Последний подход
более гибкий, и в конечном итоге он потребуется многим приложениям,
особенно бизнес-приложениям. К счастью, в нем нет ничего концепту -
ально сложного; для этого требуется простой пользовательский интер-
фейс, который позволяет просматривать пользователей и добавлять ут -
верждения через тот же механизм, который я покажу здесь.
СОВЕТ  Еще один распространенный подход  – настроить сущ-
ность IdentityUser, добавив, например, свойство Name. С  таким
подходом иногда проще работать, если вы хотите предоставить
пользователям возможность редактировать это свойство. В статье
Microsoft «Добавление, загрузка и  удаление специальных поль-
зовательских данных в Identity в проекте ASP .NET Core» описаны
шаги, необходимые для этого: ht tp://mng.bz/aoe7 .
Допустим, вы хотите добавить пользователю новое утверждение Full-
Name. Типичный подход будет выглядеть так.
1  Добавьте заготовки для страницы Register.cshtml, как вы делали
в разделе 14.5.
2  Добавьте поле «Имя» в  InputModel в  PageModel файла Register.csht -
ml.cs.
3  Добавьте поле ввода «Имя» в шаблон представления Razor, Register.
cshtml.

549 Управление пользователями: добавление специальных данных для пользователей
4  Создайте новую сущность ApplicationUser, как и раньше, в обра-
ботчике страницы OnPost() путем вызова метода CreateAsync для
UserManager<ApplicationUser>.
5  Добавьте пользователю новое утверждение, вызвав метод UserMan-
ager.AddClaimAsync().
6  Продолжите метод, как и  раньше, отправив электронное письмо
с  подтверждением или выполнив вход, если подтверждение по
электронной почте не требуется.
Шаги с  1 по 3 говорят сами за себя и требуют лишь обновления су -
ществующих шаблонов с по мощью нового поля. Шаги с 4 по 6 выполня-
ются в файле Register.cshtml.cs в обработчике страниц OnPost(), который
кратко описан в следующем листинге. На практике у обработчика стра-
ниц больше проверки ошибок и шаблонного кода; мы сосредоточимся на
дополнительных строках, которые добавляют дополнительное утверж -
дение в ApplicationUser.
Листинг 14.8  Добавляем специальное утверждение к новому
пользователю на странице Register.cshtml.cs
public async Task<IActionResult> OnPostAsync(string returnUrl = null)
{
if (ModelState.IsValid)
{
var user = new ApplicationUser {
UserName = Input.Email, Email = Input.Email };
var result = await _userManager.CreateAsync(
user, Input.Password);
if (result.Succeeded)
{
var claim = new Claim("FullName", Input.Name);
await _userManager.AddClaimAsync(user, claim);
var code = await _userManager
.GenerateEmailConfirmationTokenAsync(user);
await _emailSender.SendEmailAsync(
Input.Email, "Confirm your email", code );
await _signInManager.SignInAsync(user);
return LocalRedirect(returnUrl);
}
foreach (var error in result.Errors)
{
ModelState.AddModelError(
string.Empty, error.Description);
}
}
return Page();
}Создает экземпляр сущности
ApplicationUser, как обычно.
Проверяет правильность
предоставленного пароля
и создает пользователя
в базе данных.Создает
утверждение
со строковым
именем «FullName»
и предоставленным
значением.
Добавляет новое
утверждение
в коллекцию
ApplicationUser.
Отправляет пользователю
электронное письмо
с подтверждением, если
вы настроили отправителя
электронной почты.
Регистрирует пользователя, задав HttpContext.User;
принципал будет включать специальное утверждение.При создании пользователя
возникла проблема. Добавляем
ошибки в ModelState и повторно
отображаем страницу.

550 Глава 14 Аутентификация: добавляем пользователей в приложение
СОВЕТ  В листинге 14.8 показано, как добавлять дополнительные
утверждения во время регистрации, но вам часто потребуется до-
бавить дополнительные данные позже, например утверждения,
связанные с полномочиями, или другую информацию. Вам нужно
будет создать дополнительные конечные точки и страницы для до-
бавления этих данных, при необходимости обеспечивая безопас -
ность страниц (чтобы пользователи не могли обновлять свои пол-
номочия, например).
Это все, что требуется для добавления нового утверждения, но в насто-
ящее время вы нигде его не используете. Что, если вы хотите отобра-
зить его? Итак, вы добавили утверждение в  ClaimsPrincipal, который
был назначен свойству HttpContext.User при вызове SignInAsync. Это
означает, что вы можете получить утверждения везде, где у вас есть до-
ступ к ClaimsPrincipal, в том числе в обработчиках страниц и в шабло-
нах представлений. Например, можно было бы отобразить утверждение
пользователя FullName в любом месте шаблона Razor с по мощью следую-
щей инструкции:
@User.Claims.FirstOrDefault(x=>x.Type == "FullName")?.Value
Будет найдено первое утверждение текущего принципала с  типом
"FullName" и  выведено присвоенное значение (или, если утверждение
не найдено, ничего выведено не будет). Система Identity даже включа-
ет в себя удобный метод расширения, который приводит в порядок это
выражение LINQ (он находится в  пространстве имен System.Security.
Claims):
@User.FindFirstValue("FullName")
Рассказав об этой любопытной детали, мы подошли к концу главы, по-
священной ASP .NET Core Identity. Надеюсь, вы оценили, сколько усилий
можно сэкономить с по мощью Identity, особенно когда вы используете
пакет Identity UI по умолчанию.
Добавление учетных записей пользователей и аутентификации в при-
ложение обычно является первым шагом к дальнейшей настройке при-
ложения. После аутентификации вы можете заняться авторизацией,
которая позволяет заблокировать определенные действия в вашем при-
ложении в зависимости от текущего пользователя. В следующей главе вы
узнаете о системе авторизации ASP .NET Core и о том, как использовать
ее для настройки своих приложений; в частности, приложения с рецеп-
тами, которое неплохо продвигается!
Резюме
Аутентификация – это процесс определения того, кем вы являетесь,
а авторизация – процесс определения того, что вам разрешено делать.

551 Резюме
Необходимо провести проверку пользователей, прежде чем приме-
нить авторизацию.
Каждый запрос в ASP .NET Core ассоциирован с пользователем, также
известным как принципал. По умолчанию без аутентификации это
анонимный пользователь. Вы можете использовать объект Claim-
sPrincipal, чтобы обеспечить разное поведение в  зависимости от
того, кто сделал запрос.
Текущий принципал для запроса отображается в  свойстве HttpCon-
text.User. Вы можете получить доступ к этому значению на страницах
Razor и представлениях, чтобы узнать свойства пользователя, напри-
мер его ID, имя или адрес электронной почты.
У каждого пользователя есть набор утверждений. Они представляют
собой отдельные фрагменты информации о пользователе. Эти объек -
ты могут быть свойствами физического пользователя, например Name
и Email, или могут быть связаны с вещами, которые есть у пользовате-
ля, например HasAdminAccess или IsVipCustomer.
В более ранних версиях ASP .NET вместо утверждений использовались
роли. При необходимости их по-прежнему можно использовать, но по
возможности следует работать с утверждениями.
Аутентификация в ASP .NET Core обеспечивается компонентом Authen-
ticationMiddleware и  рядом сервисов аутентификации. Эти сервисы
отвечают за настройку текущего принципала, когда пользователь вы-
полняет вход, сохраняя его в файле cookie и загружая принципала из
этого файла при последующих запросах.
AuthenticationMiddleware добавляется путем вызова метода UseAu-
thentication() в  конвейере промежуточного ПО. Он должен разме-
щаться после вызова метода UseRouting() и перед методами UseAutho-
rization() и UseEndpoints().
ASP .NET Core включает в себя поддержку потребления токенов носите-
ля для аутентификации вызовов API и имеет вспомогательные библи-
отеки для настройки IdentityServer. Для получения дополнительной
информации см. статью Microsoft «Аутентификация и  авторизация
для SPA»: http://mng.bz/go0V .
ASP .NET Core Identity предоставляет низкоуровневые сервисы, необ-
ходимые для сохранения пользователей в  базе данных, гарантируя
безопасное хранение их паролей, а  также для входа пользователей
в  учетную запись и  выхода из нее. Вы должны сами предоставить
пользовательский интерфейс для функциональности и  подключить
его к подсистеме Identity.
Пакет Microsoft.AspNetCore.Identity.UI предоставляет пользователь-
ский интерфейс по умолчанию для системы Identity и включает в себя
поддержку подтверждения по электронной почте, двухстороннюю
аутен тификацию и  внешнего поставщика входа в  учетную запись.
Необходимо выполнить дополнительную настройку, чтобы активиро-
вать эти функции.
Шаблон по умолчанию для веб-приложения с  аутентификацией от -
дельной учетной записи использует ASP .NET Core Identity для хране-

552 Глава 14 Аутентификация: добавляем пользователей в приложение
ния пользователей в  базе данных с  по мощью EF Core. Он включает
в себя весь шаблонный код, необходимый для подключения пользова-
тельского интерфейса к системе Identity.
Можно использовать класс UserManager<T> для создания новых учет -
ных записей пользователей, загрузки их из базы данных и изменения
паролей. SignInManager<T> используется для входа и  выхода пользо-
вателя из приложения, назначая принципала для запроса и устанав-
ливая cookie-файл аутентификации. Пользовательский интерфейс по
умолчанию использует эти классы за вас, чтобы облегчить регистра-
цию пользователя и вход в учетную запись.
Можно обновить класс EF Core DbContext для поддержки Identity, на-
следуя от IdentityDbContext<TUser>, где TUser – это класс, который на-
следует от IdentityUser.
Вы можете добавить пользователю дополнительные утверждения
с  по мощью метода UserManager<TUser>.Add-ClaimAsync(TUser user,
Claim claim). Они добавляются в объект HttpContext.User, когда поль-
зователь входит в приложение.
Утверждения состоят из типа и  значения. Оба значения являются
строками. Вы можете использовать стандартные значения для типов,
предоставляемых в классе ClaimTypes, например ClaimTypes.GivenName
и ClaimTypes.FirstName, или специальную строку, например "Full-
Name".

15Авторизация:
обеспечиваем
защиту приложения
В этой главе:
использование авторизации для контроля над тем, кто может
использовать ваше приложение;
использование авторизации на основе утверждений и политик;
создание специальных политик для работы со сложными
требованиями;
авторизация запроса в зависимости от ресурса, к которому
осуществляется доступ;
скрытие элементов из шаблона Razor, к которым у пользователя
нет прав доступа.
В главе 14 я показал, как добавлять пользователей в приложение ASP .NET
Core, используя аутентификацию. С помощью аутентификации пользо-
ватели могут регистрироваться и входить в ваше приложение, используя
адрес электронной почты и  пароль. Каждый раз, когда вы добавляете
аутен тификацию в приложение, вы неизбежно сталкиваетесь с желани-
ем ограничить действия некоторых пользователей. Процесс определе-
ния того, может ли пользователь выполнить данное действие в вашем
приложении, называется авторизацией.
Например, на сайте для онлайн-торговли у вас могут быть админист -
раторы, которым разрешено добавлять новые продукты и менять цены,

554 Глава 15 Авторизация: обеспечиваем защиту приложения
продавцы, которым разрешено просматривать оформленные заказы,
и  клиенты, которым разрешено только размещать заказы и  покупать
продукты.
В этой главе я  покажу вам, как использовать авторизацию в  прило-
жении, чтобы контролировать действия своих пользователей. В разде-
ле 15.1 я познакомлю вас с авторизацией в контексте сценария из реаль-
ной жизни, с  которым вы, вероятно, сталкивались: аэропорт. Я  опишу
последовательность событий, от регистрации и прохождения контроля
безопасности до входа в зал ожидания аэропорта, и вы увидите, как все
это соотносится с концепциями авторизации в этой главе.
В разделе 15.2 я покажу, как авторизация вписывается в веб-прило  же-
ние ASP .NET Core и как это связано с классом ClaimsPrincipal, который
вы видели в предыдущей главе. Вы увидите, как обеспечить простейший
уровень авторизации в приложении ASP .NET Core, гарантируя, что толь-
ко проверенные пользователи могут открывать страницу Razor Page или
выполнять действие MVC.
Мы расширим этот подход в разделе 15.3, добавив понятие политик,
которые позволяют устанавливать определенные требования для опре-
деленного проверенного пользователя, проверяя, чтобы у  него были
права для выполнения действия или страницы Razor.
Вы будете широко использовать политики в системе авторизации ASP .
NET Core, поэтому в разделе 15.4 мы рассмотрим, как работать с более
сложными сценариями. Вы узнаете о требованиях к авторизации и обра-
ботчиках, как сочетать их для создания особых политик, которые можно
применять к страницам Razor и действиям.
Иногда авторизация пользователя зависит от того, к какому ресурсу
или документу он пытается получить доступ. Ресурс – это все то, что вы
пытаетесь защитить, поэтому это может быть документ или сообщение
в  социальных сетях. Например, можно разрешить пользователям соз-
давать свои документы или читать документы, полученные от других
пользователей, но редактировать они смогут только те документы, кото-
рые создали сами. Такой тип авторизации, при котором вам необходи-
мы данные документа, чтобы определить, авторизован ли пользователь,
называется авторизацией на основе ресурсов. Этой теме посвящен раз-
дел 15.5.
В последнем разделе данной главы я покажу, как расширить подход
с  использованием авторизации на основе ресурсов в  шаблонах пред-
ставлений Razor. Это позволяет изменять пользовательский интерфейс,
чтобы скрыть элементы, с которыми пользователи не имеют права взаи-
модействовать. В частности, вы узнаете, как скрыть кнопку «Изменить»,
если у пользователя нет прав на редактирование сущности.
Мы начнем с  более внимательного изучения концепции авториза-
ции, разберем, чем она отличается от аутентификации и как это связано
с концепциями из реальной жизни, которые вы можете увидеть в аэро-
порту.

555 Знакомство с авторизацией
15.1 Знакомство с авторизацией
В этом разделе вы познакомитесь с  авторизацией, и  мы сравним ее
с аутен тификацией. Я использую пример из реальной жизни, пребыва-
ние в аэропорту, чтобы проиллюстрировать, как работает авторизация
на основе утверждений.
Для тех, кто плохо знаком с веб-приложениями и безопасностью, тер-
мины «аутентификация» и  «авторизация» иногда могут выглядеть не-
сколько пугающими. Конечно, тот факт, что эти слова так похожи, не
очень помогает! Эти два понятия часто используются вместе, но между
ними определенно есть различия:
аутентификация – процесс определения того, кто сделал запрос;
авторизация – процесс определения того, разрешено ли запрошен-
ное действие.
Как правило, сначала выполняется аутентификация, чтобы вы знали,
кто выполняет запрос к  вашему приложению. Если это традиционное
веб-приложение, то оно проверяет запрос, обращаясь к зашифрованно-
му файлу cookie, который был установлен при входе пользователя в учет -
ную запись (как было показано в  предыдущей главе). Веб-API обычно
используют заголовок вместо файла cookie для аутентификации, но про-
цесс тот же.
Как только запрос будет проверен и вы узнаете, кто его отправляет,
можно определить, разрешено ли этому лицу выполнять действия на ва-
шем сервере. Данный процесс называется авторизацией, которой и по-
священа эта глава.
Прежде чем углубиться в код и приступить к изучению авторизации
в ASP .NET Core, я продемонстрирую эти концепции в сценарии из реаль-
ной жизни, с которым вы, надеюсь, знакомы: проверка в аэропорту. Что-
бы попасть в аэропорт и сесть в самолет, необходимо пройти несколько
этапов. Сначала вы должны доказать, что вы – это вы (аутентификация).
После этого нужно пройти еще ряд этапов, в ходе которых будет уста-
новлено, можно ли вам двигаться дальше (авторизация). В упрощенном
виде это может выглядеть так:
1  Вы предъявляете паспорт на стойке регистрации и получаете по-
садочный талон.
2  Вы предъявляете свой посадочный талон, чтобы пройти службу
безопасности, и проходите ее.
3  Вы предъявляете карту часто летающего пассажира, чтобы войти
в зал ожидания. Входите туда.
4  Вы предъявляете свой посадочный талон, чтобы сесть на самолет.
Садитесь в самолет.
Очевидно, что эти шаги, также показанные на рис. 15.1, будут несколь-
ко отличаться в реальной жизни (у меня нет карты часто летающего пас -
сажира!), но пока мы будем использовать их. Давайте подробнее рас -
смот рим каждый шаг.

556 Глава 15 Авторизация: обеспечиваем защиту приложения
Аутентификация
Покупка
билета на стойке
регистрацииАвторизация
Авторизация
АвторизацияПредоставляем
утверждения: номер
посадочного
талона
Предо ставляем
утверждения: золотой
класс для часто
летающих
пассажиров
Предоставляем
утверждения: номер
посадочного
талонаОтказано
Отказано
ОтказаноПроход через службу
безопасности
Вход в зал ожидания
авиакомпании
Посадка на самолетВы должны предъявить
службе безопасности
номер посадочного
талона, чтобы пройти
дальше
Для входа в зал ожидания
необходимо предъявить
золотую карту часто
летающего пассажира
Для посадки в самолет
необходимо предъявить
посадочный талонЕсли у вас нет действующего
посадочного талона,
вы не можете пройти службу
безопасности
Если вы не авторизованы,
то не можете войти в зал
ожидания
Если у вас нет разрешения,
вы не можете сесть
в самолет
Рис. 15.1 При посадке в самолет в аэропорту вы проходите несколько
этапов авторизации. На каждом этапе необходимо предъявить утверждение
в виде посадочного талона или карты часто летающего пассажира. Если вы не
авторизованы, то доступ будет запрещен
По прибытии в аэропорт первое, что вы делаете, – идете к стойке ре-
гистрации. Здесь вы можете приобрести билет на самолет, но для этого
вам нужно дать понять, кто вы, предъявив паспорт; вы аутентифицируе-
те себя. Если вы забыли паспорт, то не можете пройти аутентификацию,
и дальнейшие действия невозможны.
После покупки билета вам выдается посадочный талон, на котором
указано, каким рейсом вы летите. Предположим, он также содержит
BoardingPassNumber. Можно воспринимать этот номер как дополнитель-
ное утверждение, ассоциированное с вашей личностью.
ОПРЕДЕЛЕНИЕ  Утверждение – 	это фрагмент информации о поль-
зователе, состоящий из типа и необязательного значения.

557 Знакомство с авторизацией
Следующий шаг – безопасность. Сотрудники службы безопасности по-
просят вас предъявить посадочный талон, чтобы пройти проверку. Они
должны удостовериться, что вы действительно куда-то летите и вам раз-
решено пройти дальше на территорию аэропорта. Это процесс авториза-
ции: у вас должно быть необходимое утверждение (BoardingPassNumber),
чтобы двигаться дальше.
Если у вас его нет, то далее может произойти одно из двух:
если	вы	еще	не	купили	билет – вас направят обратно к  стойке ре-
гистрации, где вы сможете пройти аутентификацию и приобрести
его. После этого вы можете снова попробовать пройти службу без-
опасности;
если	у вас	недействительный	 билет – вас не пропустят через служ -
бу безопасности, а  тут ничего не поделаешь. Если, например, вы
предъявили посадочный талон, а улететь должны были неделю на-
зад, то, скорее всего, вас не пропустят. (Спросите меня, откуда мне
это известно!)
После прохождения проверки вам нужно дождаться посадки на рейс,
но, к сожалению, свободных мест нет. Типичный случай! К счастью, вы
регулярно летаете и накопили достаточно миль, чтобы получить золотой
статус часто летающего пассажира, поэтому можете воспользоваться за-
лом ожидания.
Вы отправляетесь в  зал ожидания, где вас просят предъявить золо-
тую карту часто летающего пассажира дежурному, и  вас впустят. Это
еще один пример авторизации. Чтобы продолжить, у вас должно быть
утверж  дение FrequentFlyerClass со значением Gold.
ПРИМЕЧАНИЕ  До сих пор в этом сценарии вы использовали ав-
торизацию дважды и  каждый раз вы предъявляли утверждение.
В первом случае было достаточно наличия любого BoardingPass-
Number, тогда как для утверждения FrequentFlyerClass вам потре-
бовалось определенное значение Gold.
Когда вы садитесь в самолет, наступает последний этап авторизации,
на котором вы должны снова предъявить утверждение BoardingPass-
Number. Вы уже делали это ранее, но посадка в самолет и проход через
службу безопасности – разные действия, поэтому нужно предъявить его
снова.
Весь этот сценарий имеет множество параллелей с запросами к веб-
приложению:
оба процесса начинаются с аутентификации;
вы должны доказать, кто вы, чтобы получить	 утверждения, которые
вам нужны для авторизации;
вы используете авторизацию для защиты конфиденциальных дей-
ствий, таких как проход через службу безопасности и  вход в  зал
ожидания.

558 Глава 15 Авторизация: обеспечиваем защиту приложения
Я буду использовать этот сценарий на протяжении всей главы, чтобы
создать простое веб-приложение, имитирующее этапы, которые вы прохо-
дите в аэропорту. Мы рассмотрели концепцию авторизации в общих чер-
тах, поэтому в следующем разделе рассмотрим, как работает авторизация
в ASP .NET Core. Начнем с самого базового уровня авторизации, гарантируя,
что только проверенные пользователи могут выполнить действие, и  по-
смотрим, что происходит, когда вы пытаетесь выполнить такое действие.
15.2 Авторизация в ASP.NET Core
В этом разделе вы увидите, как принципы авторизации, описанные
в предыдущем разделе, применяются к приложению ASP .NET Core. Вы
узнаете о роли атрибута [Authorize] и компонента AuthorizationMiddle-
ware при авторизации запросов к  страницам Razor Pages и  действиям
MVC. Наконец, вы узнаете, как не дать пользователям, не прошедшим
аутентификацию, выполнять конечные точки, и что происходит, когда
пользователи не проходят проверку.
В ASP .NET Core есть встроенная авторизация, поэтому вы можете ис -
пользовать ее в любом месте своего приложения, но в ASP .NET Core 5.0
чаще всего применяется авторизация с компонентом AuthorizationMid-
dleware, который должен быть размещен после	 компонентов маршрути-
зации и  аутентификации, но перед	 компонентом конечной точки, как
показано на рис. 15.2.
Компонент
статических файлов
Компонент
маршрутизации[Authorize]
Recipe/Index.cshtml
Компонент
аутентификации
Компонент
авторизации
Recipe/Index.cshtml
EndpointMiddlewareСервисы
авторизацииВыполняется запрос URL-адреса
/recipe/index
Компонент маршрутизации
направляет запрос в конечную точку
Recipe/Index.cshtml, декорированную
атрибутом [Authorize]
Компонент аутентификации
десериализует ClaimsPrincipal
из зашифрованного файла cookie
Компонент авторизации выполняется
после аутентификации перед
компонентом конечной точки
Если авторизация прошла
успешно, конечная точка
выполняется и генерирует
ответ как обычноКомпонент авторизации использует ClaimsPrincipal
и требования авторизации выбранной конечной точки,
чтобы определить, авторизован ли запрос для выполнения
конечной точки
В случае сбоя авторизации компонент авторизации
возвращает пользователю ошибку, и конечная точка
не выполняется
Рис. 15.2 Авторизация происходит после выбора конечной точки и после того, как запрос
будет проверен, но до выполнения метода действия или конечной точки Razor Page

559 Авторизация в ASP.NET Core
ПРИМЕЧАНИЕ  В  ASP .NET Core конечная	 точка означает обра-
ботчик, выбранный компонентом маршрутизации, который будет
генерировать ответ при выполнении. Обычно это страница Razor
или метод действия веб-API.
Используя эту конфигурацию, RoutingMiddleware выбирает конечную
точку для выполнения на основе URL-адреса запроса, например на стра-
нице Razor, как было показано в главе 5. Метаданные о выбранной ко-
нечной точке доступны всему промежуточному ПО, которое идет после
компонента маршрутизации. Они содержат сведения обо всех требова-
ниях к авторизации для конечной точки и обычно определяются путем
декорирования действия или страницы Razor атрибутом [Authorize].
AuthenticationMiddleware десериализует зашифрованный файл cookie
(или токен носителя для API), ассоциированный с запросом, чтобы соз-
дать объект ClaimsPrincipal. Этот объект задается как свойство HttpCon-
text.User для запроса, поэтому все последующие компоненты промежу -
точного ПО могут получить доступ к этому значению. Он содержит все
утверждения, которые были добавлены в  файл cookie, когда пользова-
тель прошел аутентификацию.
Теперь переходим к компоненту AuthorizationMiddleware. Этот ком-
понент проверяет, есть ли у  выбранной конечной точки какие-либо
требования к  авторизации, на основе метаданных, предоставленных
RoutingMiddleware. Если таковые имеются, AuthorizationMiddleware ис -
пользует HttpContext.User, чтобы определить, прошел ли текущий за-
прос аутентификацию и может ли он выполнить конечную точку.
Если запрос прошел аутентификацию, следующий компонент в кон-
вейере выполняется как обычно. В противном случае AuthorizationMid-
dleware прерывает выполнение конвейера, а компонент конечной точки
не выполняется.
ПРИМЕЧАНИЕ  Порядок компонентов в конвейере очень важен.
Вызов метода UseAuthorization() должен идти после методов Use-
Routing() и UseAuthentication(), но до метода UseEndpoints().
Изменения в авторизации для ASP.NET Core 3.0
В ASP.NET Core 3.0 система авторизации существенно изменилась. До этого
компонента AuthorizationMiddleware не существовало. Вместо него логику
авторизации как часть конвейера фильтров MVC выполнял атрибут [Autho-
rize].
На практике с точки зрения использования авторизации в действиях и Razor
Pages, если смотреть со стороны разработчика, особой разницы нет. Зачем
тогда что-то менять?
Новый дизайн, использующий компонент AuthorizationMiddleware в сочета-
нии с маршрутизацией конечных точек (появившейся в то же самое время),
позволяет применять дополнительные сценарии. Эти изменения упрощают

560 Глава 15 Авторизация: обеспечиваем защиту приложения
применение авторизации к конечным точкам, не относящимся к MVC или
страницам Razor Page. Вы увидите, как создавать такие типы конечных точек,
в главе 19. Узнать подробнее об изменениях в авторизации можно в разделе
«Авторизация» документа Microsoft: http://mng.bz/1rvj.
AuthorizationMiddleware отвечает за реализацию требований авто-
ризации и гарантию того, что только проверенные пользователи могут
выполнять защищенные конечные точки. В  разделе 15.2.1 вы узнаете,
как применить простейшее требование авторизации, а в разделе 15.2.2
увидите, как реагирует фреймворк, когда пользователю не разрешается
выполнить конечную точку.
15.2.1 Предотвращение доступа анонимных пользователей
к вашему приложению
Думая об авторизации, вы обычно думаете о  том, как проверить, что
у  конкретного пользователя есть полномочия на выполнение конеч-
ной точки. В ASP .NET Core обычно это можно сделать, проверив, есть ли
у пользователя определенное утверждение.
Есть еще более простой уровень авторизации, который мы еще не рас -
сматривали, – когда вы позволяете только проверенным пользователям
выполнять конечную точку. Это даже проще, чем сценарий с утвержде-
ниями (к которому мы вернемся позже), поскольку здесь есть только две
возможности:
пользователь	 прошел	 аутентификацию  – действие выполняется
в обычном режиме;
пользователь	 не	прошел	аутентификацию – пользователь не может
выполнить конечную точку.
Такого базового уровня авторизации можно достичь с по мощью атри-
бута [Authorize], который вы видели в  главе 13, когда мы обсуждали
фильтры авторизации. Вы можете применить его к  своим действиям
и страницам Razor, как показано в следующем листинге, чтобы ограни-
чить их только проверенными (выполнившими вход) пользователями.
Если не прошедший аутентификацию пользователь пытается выполнить
действие или страницу Razor, защищенные атрибутом [Authorize], он
будет перенаправлен на страницу входа.
Листинг 15.1 Применение атрибута [Authorize] к действию
public class RecipeApiController : ControllerBase
{
public IActionResult List()
{
return Ok();
}
[Authorize]Это действие может выполнить кто угодно,
даже если он не выполнил вход.
Применяет атрибут [Authorize] к отдельным действиям,
целым контроллерам или страницам Razor.

561 Авторизация в ASP.NET Core
public IActionResult View()
{
return Ok();
}
}
Применяя атрибут [Authorize] к конечной точке, вы добавляете к ней
метаданные, указывая на то, что только проверенные пользователи мо-
гут получить к ней доступ. Как было показано на рис. 15.2, эти метадан-
ные становятся доступными для AuthorizationMiddleware, когда Routing-
Middleware выбирает конечную точку.
Можно применять атрибут [Authorize] в  области метода действия,
контроллера, страницы Razor или глобально, как вы видели в главе 13.
Любое действие или страница Razor, имеющие этот атрибут, применен-
ный таким образом, могут быть выполнены только проверенным поль-
зователем. Пользователи, не прошедшие аутентификацию, будут пере-
направлены на страницу входа.
СОВЕТ  Существует несколько различных способов глобального
применения атрибута [Authorize]. Об этих вариантах и о том, что
и когда выбирать, можно прочитать в моем блоге: http://mng.bz/
opQp.
Иногда, особенно когда вы применяете атрибут [Authorize] глобаль-
но, вам, возможно, понадобится добавить исключения для этого требо-
вания. Если применить его глобально, то любой запрос, не прошедший
проверку, будет перенаправлен на страницу входа вашего приложения.
Но если этот атрибут глобальный, то когда страница входа попытается
загрузиться, вы не пройдете аутентификацию и  снова будете перена-
правлены на страницу входа. Получается, вы застряли в  бесконечном
цикле переадресации.
Чтобы избежать этого, можно назначить определенные конечные
точки, игнорирующие этот атрибут, применяя атрибут [AllowAnonymous]
к действию или странице Razor, как показано ниже. Это позволяет поль-
зователям, не прошедшим аутентификацию, выполнить действие и мо-
жет помочь вам избежать цикла переадресации, который мог бы возник -
нуть в противном случае.
Листинг 15.2  Применение атрибута [AllowAnonymous], чтобы разрешить
доступ пользователям, не прошедшим аутентификацию
[Authorize]
public class AccountController : ControllerBase
{
public IActionResult ManageAccount()
{
return Ok();Это действие могут выполнять только
пользователи, прошедшие аутентификацию.
Применяется в области действия контроллера, поэтому пользователь
должен быть аутентифицирован для всех действий контроллера.
Т олько пользователи, прошедшие
аутентификацию, могут выполнять
ManageAccount.

562 Глава 15 Авторизация: обеспечиваем защиту приложения
}
[AllowAnonymous]
public IActionResult Login()
{
return Ok();
}
}
ВНИМАНИЕ!  Если вы применяете атрибут [Authorize] глобаль-
но, обязательно добавьте атрибут [AllowAnonymous] к  действиям
входа, ошибок и сброса пароля, а также любым другим действиям,
которые должны выполнять пользователи, не прошедшие аутен-
тификацию. Если вы используете пользовательский интерфейс
Identity по умолчанию, описанный в главе 14, то все уже настроено
до вас.
Если пользователь, не прошедший аутентификацию, пытается выпол-
нить действие, защищенное атрибутом [Authorize], традиционные веб-
приложения перенаправят его на страницу входа. А что насчет веб-API
или более сложных сценариев, когда пользователь выполнил вход, но
у него нет необходимых утверждений для выполнения действия? В раз-
деле 15.2.2 мы рассмотрим, как сервисы аутентификации ASP .NET Core
решают все эти вопросы за вас.
15.2.2 Обработка запросов, не прошедших аутентификацию
В предыдущем разделе вы видели, как применить атрибут [Authorize]
к действию, чтобы гарантировать, что его могут выполнять только про-
веренные пользователи. В разделе 15.3 мы рассмотрим более сложные
примеры, которые требуют от вас наличия конкретного утверждения.
В обоих случаях вы должны отвечать одному или нескольким требовани-
ям авторизации (например, должны быть аутентифицированы), чтобы
выполнить действие.
Если пользователь отвечает требованиям авторизации, то запрос
проходит беспрепятственно через компонент AuthorizationMiddleware,
а конечная точка выполняется в  EndpointMiddleware. Если он не отвечает
требованиям выбранной конечной точки, AuthorizationMiddleware за-
вершит запрос. В зависимости от причины, по которой запрос не про-
шел проверку, AuthorizationMiddleware генерирует один из двух типов
ответов, как показано на рис. 15.3:
вызов	 (challenge) – этот ответ указывает на то, что пользователь не
был авторизован для выполнения действия, потому что еще не вы-
полнил вход;
запрет	 (forbid) –	 этот ответ указывает на то, что пользователь вы-
полнил вход, но не отвечает требованиям для выполнения действия.
Например, у него не было требуемого утверждения.Атрибут [AllowAnonymous] переопределяет
атрибут [Authorize], чтобы допустить
пользователей, не прошедших аутентификацию.
Вход в приложение может быть выполнен
анонимными пользователями.

563 Авторизация в ASP.NET Core
ПРИМЕЧАНИЕ  Если вы примените атрибут [Authorize] в  базо-
вой форме, как делали это в разделе 15.2.1, то будете генерировать
только ответы типа «вызов». В данном случае «вызов» будет сгене-
рирован для пользователей, не прошедших аутентификацию, но
проверенные пользователи всегда будут считаться доверенными.
Запрашивается URL-адрес
/recipe/indexАвторизованный Вызов Запретить
Компонент
маршрутизацииКомпонент
маршрутизацииКомпонент
маршрутизации
Компонент
аутентификацииКомпонент
аутентификацииКомпонент
аутентификации
Компонент
авторизацииКомпонент
авторизацииКомпонент
авторизации
Компонент
конечной точкиКомпонент
конечной точкиКомпонент
конечной точкиКомпонент маршрутизации
выбирает конечную точку Recipe/
Index.cshtml, декорированную
атрибутом [Authorize]
Компонент аутентификации
десериализует ClaimsPrincipal
из зашифрованного файла cookie
Компонент авторизации
использует данные атрибута
[Authorize], ассоциированные
с конечной точкой, чтобы
определить, авторизован ли запрос
Если авторизация прошла успешно,
конечная точка выполняется
и генерирует ответ, как обычноЕсли пользователь не прошел
аутентификацию, компонент
авторизации генерирует
ответ на запрос и прерывает
выполнение конвейераЕсли пользователь прошел
аутентификацию, но не выполняет
требования авторизации,
генерируется ответ, сообщающий
о запрете, который прерывает
выполнение конвейера
Рис. 15.3 Три типа ответа на попытку авторизации. В примере слева запрос содержит
cookie-файл аутентификации, поэтому пользователь проходит аутентификацию
в AuthenticationMiddleware. AuthorizationMiddleware подтверждает, что проверенный
пользователь может получить доступ к выбранной конечной точке, поэтому конечная
точка выполняется. В центральном примере запрос не прошел проверку, поэтому
AuthorizationMiddleware генерирует «вызов». В примере справа запрос прошел проверку,
но у пользователя нет полномочий на выполнение конечной точки, поэтому генерируется
«запрет»
Точный ответ HTTP , сгенерированный «вызовом» или «запретом»,
обычно зависит от типа приложения, которое вы создаете, а  следова-
тельно, от типа аутентификации, которое оно использует: традиционное
ли это веб-приложение с Razor Pages или приложение API.
Для традиционных веб-приложений, использующих аутентификацию
с файлами cookie, например при использовании ASP .NET Core Identity,
как и в главе 14, вызовы и запреты генерируют HTTP-перенаправление
на страницу в вашем приложении.
«Вызов» указывает на то, что пользователь еще не прошел аутенти-
фикацию, поэтому он перенаправляется на страницу входа в приложе-

564 Глава 15 Авторизация: обеспечиваем защиту приложения
ние. После входа он может попытаться получить доступ к защищенному
ресурсу снова.
«Запрет» означает, что запрос исходил от пользователя, который уже
выполнил вход, но ему по-прежнему не разрешено выполнять действие.
Следовательно, пользователь перенаправляется на страницу «запреще-
но» или «доступ запрещен», как показано на рис. 15.4, которая инфор-
мирует его о том, что он не может выполнить действие или страницу
Razor Page.
Рис. 15.4 Ответ, сообщающий об отказе в доступе, в традиционных веб-приложениях,
использующих аутентификацию с файлами cookie. Если у вас нет полномочий, чтобы выполнить
страницу Razor, и вы уже выполнили вход, то вы будете перенаправлены на страницу с отказом
в доступе
Предыдущее поведение является стандартным для традиционных
веб-приложений, но веб-API обычно используют другой подход к аутен-
тификации, как уже было показано в главе 14. Вместо того чтобы выпол-
нить вход и использовать API напрямую, вы обычно входите в стороннее
приложение, предоставляющее токен клиентскому одностраничному
приложению или приложению для мобильных устройств.
Клиентское приложение отправляет его, когда делает запрос к вашему
веб-API.
Аутентификация запроса веб-API с использованием токенов, по сути,
идентична традиционному веб-приложению, использующему файлы
cookie. AuthenticationMiddleware десериализует файл cookie или токен
для создания ClaimsPrincipal. Разница в том, как веб-API обрабатывает
отказы в авторизации.
Когда веб-API генерирует «вызов», то возвращает ошибку 401 Unautho-
rized вызывающей стороне. Точно так же, когда приложение генерирует
«запрет», оно возвращает ответ 403 Forbidden. Традиционное веб-при ло-
жение, по сути, обрабатывало эти ошибки, автоматически перенаправ-
ляя пользователей, не прошедших аутентификацию, на страницу входа
или страницу с надписью «доступ запрещен», но веб-API так не делает.
Клиентское одностраничное приложение или приложение для мобиль-
ных устройств должно самостоятельно обнаруживать эти ошибки и об-
рабатывать их соответствующим образом.

565 Использование политик для авторизации на основе утверждений
СОВЕТ  Такая разница в поведении – одна из причин, по которой
я обычно рекомендую создавать отдельные приложения для ваших
API и приложений Razor Pages – можно использовать и то, и другое
в одном приложении, но конфигурация будет более сложной.
Различное поведение традиционных и  одностраничных веб-при ло-
жений поначалу может сбивать с толку, но на практике обычно не нужно
об этом слишком беспокоиться. Независимо от того, создаете ли вы веб-
API или традиционное MVC-приложение, код авторизации будет выгля-
деть одинаково в обоих случаях. Примените атрибуты [Authorize] к сво-
им конечным точкам и позвольте фреймворку самому позаботиться об
этих различиях.
ПРИМЕЧАНИЕ  В  главе 14 вы увидели, как настроить ASP .NET
Core Identity в приложении Razor Pages. В этой главе предполагает -
ся, что вы также создаете приложение Razor Pages, но она в равной
степени применима и к веб-API. Политики авторизации применя-
ются одинаково, независимо от того, какое приложение вы создае-
те. Отличается только ответ на запросы, не прошедшие проверку.
Вы узнали, как применить самое основное требование авторизации –
ограничить выполнение конечной точки только проверенными пользо-
вателями, – но большинству приложений нужно что-то более тонкое, не-
жели подход «все или ничего».
Рассмотрим сценарий с аэропортом из раздела 15.1. Пройти аутенти-
фикацию (наличие паспорта) недостаточно, чтобы пройти через службу
безопасности. Вам также понадобится конкретное утверждение: Board-
ingPassNumber. В следующем разделе мы разберем, как реализовать ана-
логичное требование в ASP .NET Core.
15.3 Использование политик для авторизации
на основе утверждений
В предыдущем разделе вы узнали, как сделать так, чтобы пользователи
выполняли вход для доступа к конечной точке. В этом разделе вы увиди-
те, как применять дополнительные требования. Вы узнаете, как исполь-
зовать политики авторизации для выполнения авторизации на основе
утверждений, чтобы у выполнившего вход пользователя были необходи-
мые утверждения для выполнения определенной конечной точки.
В главе 14 вы видели, что аутентификация в  ASP .NET Core сосредо-
точена вокруг объекта ClaimsPrincipal, представляющего пользователя.
У этого объекта имеется коллекция утверждений, содержащих информа-
цию о пользователе, такую   как его имя, адрес электронной почты и дату
рождения.

566 Глава 15 Авторизация: обеспечиваем защиту приложения
Вы можете использовать их, чтобы настроить приложение под каж -
дого пользователя, например отображая приветственное сообщение
и обращаясь к пользователю по имени, но также можете использовать
утверждения для авторизации. Например, можно авторизовать поль-
зователя, только если у  него есть конкретное утверждение (например,
BoardingPassNumber) или если у утверждения есть определенное значе-
ние (утверждение FrequentFlyerClass со значением Gold).
В ASP .NET Core правила, определяющие, авторизован ли пользователь,
инкапсулированы в политике.
ОПРЕДЕЛЕНИЕ  Политика определяет требования, которым вы
должны отвечать, чтобы запрос был авторизован.
Политики можно применять к действию с по мощью атрибута [Autho-
rize], как было показано в разделе 15.2.1. В этом листинге показана мо-
дель страницы Razor, PageModel, представляющая первый этап автори-
зации в сценарии с аэропортом. Страница Razor, AirportSecurity.cshtml,
защищена атрибутом [Authorize], но вы также предоставили имя поли-
тики: "CanEnterSecurity".
Листинг 15.3 Применение политики авторизации к странице Razor
[Authorize("CanEnterSecurity")]
public class AirportSecurityModel : PageModel
{
public void OnGet()
{
}
}
Если пользователь пытается выполнить страницу AirportSecurity.csht -
ml, компонент авторизации проверит, отвечает ли пользователь требо-
ваниям политики (мы вскоре рассмотрим саму политику). Это дает один
из трех возможных результатов:
пользователь	 отвечает	 требованиям	 политики – конвейер проме-
жуточного ПО продолжает работу, и  EndpointMiddleware выполняет
страницу Razor, как обычно;
пользователь	 не	прошел	 аутентификацию  – пользователь перена-
правляется на страницу входа;
пользователь	 прошел	аутентификацию, 	но	не	отвечает	 требованиям
политики – пользователь перенаправляется на страницу с  надпи-
сями «Запрещено» или «Отказано в доступе».
Эти три результата коррелируют с  реальными результатами, кото-
рых вы можете ожидать, когда пытаетесь пройти службу безопасности
в аэро порту:
у	вас	есть	действующий	 посадочный	 талон – вы можете пройти служ -
бу безопасности, как обычно;Применение политики CanEnterSecurity
с по мощью атрибута [Authorize].
Т олько пользователи, удовлетворяющие политике
CanEnterSecurity, могут выполнять страницу Razor.

567 Использование политик для авторизации на основе утверждений
у	вас	нет	посадочного	талона – вас отправят покупать билет;
ваш	посадочный	 талон	недействителен	 (например, 	вы	опоздали	 на
день) – вас не пропустят.
В листинге 15.3 показано, как применить политику к странице Razor
с  по мощью атрибута [Authorize], но вам все равно нужно определить
политику CanEnterSecurity.
Политики добавляются в приложение ASP .NET Core в методе Configu-
reServices файла Startup.cs, как показано в листинге 15.4. Сначала вы
добавляете сервисы авторизации с по мощью метода AddAuthorization(),
а затем можно добавить политики, вызвав метод AddPolicy() для объ-
екта AuthorizationOptions. Сама политика определяется путем вызова
методов предоставленного класса AuthorizationPolicyBuilder (который
здесь называется policyBuilder).
Листинг 15.4  Добавление политики авторизации
с по мощью AuthorizationPolicyBuilder
public void ConfigureServices(IServiceCollection services)
{
services.AddAuthorization(options =>
{
options.AddPolicy(
"CanEnterSecurity",
policyBuilder => policyBuilder
.RequireClaim("BoardingPassNumber"));
});
// Дополнительная конфигурация сервиса;
}
Когда вы вызываете метод AddPolicy, то указываете имя политики, ко-
торое должно соответствовать значению, которое вы используете в сво-
их атрибутах [Authorize], и определяете требования политики. В этом
примере у  вас есть одно простое требование: у  пользователя должно
быть утверждение типа BoardingPassNumber. Если у  пользователя оно
есть, независимо от его значения, это будет отвечать требованиям по-
литики, и пользователь будет авторизован.
ПОМНИТЕ  Утверждение – это информация о пользователе, име-
ющая вид пары «ключ-значение». Политика определяет требова-
ния для успешной авторизации. Она может потребовать, чтобы
у пользователя было утверждение, а также указать более сложные
требования, как вы вскоре увидите.
Класс AuthorizationPolicyBuilder содержит несколько методов для
создания простых политик, таких как эта, как показано в табл. 15.1. На-
пример, перегруженный вариант метода RequireClaim() позволяет ука-
зать конкретное значение, которое должно иметь утверждение. Следую-
щая строка кода позволяет создать политику, в  которой утверждение
BoardingPassNumber должно иметь значение "A1234":
policyBuilder => policyBuilder.RequireClaim("BoardingPassNumber", "A1234"); Вызывает метод AddAuthorization
для настройки AuthorizationOptions.
Добавляет новую
политику.Задает имя политики.
Определяет требования политики
с помощью AuthorizationPolicyBuilder.

568 Глава 15 Авторизация: обеспечиваем защиту приложения
Таблица 15.1 Простые методы политик в классе AuthorizationPolicyBuilder
Метод Поведение политики
RequireAuthenticatedUser() Пользователь должен быть аутентифицирован. Создает поли-
тику, аналогичную атрибуту [Authorize] по умолчанию, где вы
не устанавливаете политику
RequireClaim(утверждение, значения) У пользователя должно быть указанное утверждение. Если это
предусмотрено, то оно должно быть одним из указанных значений
RequireUsername(имя пользователя) У пользователя должно быть указанное имя пользователя
RequireAssertion(функция) Выполняет предоставленную лямбда-функцию, которая
возвращает логическое значение, указывая на то, отвечаете ли
вы требованиям политики
Авторизация на основе ролей и авторизация на основе
утверждений
Если вы посмотрите на все методы, доступные в классе AuthorizationPoli-
cyBuilder с по мощью IntelliSense, то заметите, что здесь есть метод, о ко-
тором я не упоминал в табл. 15.1, RequireRole(). Он применялся в подходе
на основе ролей, который использовался в предыдущих версиях ASP.NET,
и я не рекомендую его использовать.
До того, как Microsoft приняла за стандарт авторизацию на основе утверж -
дений, используемую ASP.NET Core и в последних версиях ASP.NET, авто-
ризация на основе ролей была нормой. Пользователи назначались одной
или нескольким ролям, таким как Administrator или Manager, и авторизация
включала в себя проверку того, находился ли текущий пользователь в тре-
буемой роли.
Такой подход к авторизации на основе ролей возможен и в ASP.NET Core, но
в первую очередь он используется по причинам совместимости с прежними
версиями. Рекомендуется применять авторизацию на основе утверждений.
Если вы не переносите устаревшее приложение, использующее роли, то ре-
комендую использовать авторизацию на основе утверждений.
Можно применять эти методы для создания простых политик, кото-
рые могут справляться с базовыми ситуациями, но часто вам нужно что-
то посложнее. Что, если вы хотите создать политику, обеспечивающую
выполнение конечной точки только пользователями старше 18 лет?
Утверждение DateOfBirth предоставляет необходимую информацию,
но у него нет единственного правильного значения, поэтому вы не смо-
жете использовать метод RequireClaim(). Вы могли	бы использовать
метод RequireAssertion() и  реализовать функцию, которая вычисляет
возраст из утверждения DateOfBirth, но это может сделать код более за-
путанным.
Для более сложных политик, которые не так просто определить с по-
мощью метода RequireClaim(), я рекомендую использовать другой под-
ход и создавать специальную политику. Об этом в следующем разделе.

569 Создание специальных политик авторизации
15.4 Создание специальных политик авторизации
Вы уже видели, как создать политику, проверяющую конкретное утверж -
дение или требующую утверждения с определенным значением, но час -
то требования будут более сложными. В  этом разделе вы узнаете, как
создавать специальные требования авторизации и обработчики, а также
как настроить требования для авторизации, где есть несколько способов,
позволяющих отвечать требованиям политики, при этом каждый из ко-
торых допустим.
Вернемся к  примеру с  аэропортом. Вы уже настроили политику для
прохождения через службу безопасности и теперь собираетесь настро-
ить политику, которая будет контролировать, имеете ли вы право вхо-
дить в зал ожидания.
Как видно на рис. 15.1, вам разрешено входить в зал ожидания, если
у вас есть утверждение FlyerClass со значением Gold. Если бы это было
единственное утверждение, то для создания такой политики можно
было бы использовать класс AuthorizationPolicyBuilder:
options.AddPolicy("CanAccessLounge", policyBuilder =>
policyBuilder.RequireClaim("FrequentFlyerClass", "Gold");
Но что, если требования гораздо сложнее? Например, предположим,
что вы можете войти в зал ожидания, если вам исполнилось 18 лет (на
основе расчетов из утверждения DateOfBirth), и вы являетесь предста-
вителем одной из следующих категорий:
вы часто летаете, и у вас есть золотая карта (у вас есть утверждение
FlyerClass со значением Gold);
вы сотрудник авиакомпании (у вас есть утверждение EmployeeNum-
ber).
Если вам когда-либо запрещали доступ в зал ожидания (у вас есть ут -
верждение IsBannedFromLounge), вас не пустят, даже если вы отвечаете
остальным требованиям.
Невозможно выполнить этот сложный набор требований с по мощью
базового использования класса AuthorizationPolicyBuilder, как уже
было показано. К счастью, эти методы представляют собой обертку для
набора строительных блоков, которые можно комбинировать, чтобы по-
лучить желаемую политику.
15.4.1 Требования и обработчики: строительные блоки
политики
Каждая политика в ASP .NET Core состоит из одного или нескольких тре-
бований, и у каждого требования может быть один или несколько обра-
ботчиков. Например, в зале ожидания аэропорта у вас есть одна политика
("CanAccessLounge"), два требования (MinimumAgeRequirement и  AllowedIn-
LoungeRequirement) и несколько обработчиков, как показано на рис. 15.5.

570 Глава 15 Авторизация: обеспечиваем защиту приложения
Политика состоит из одного
или нескольких требованийКаждое требование может иметь
одного или несколько обработчиков
CanAccessLounge policy
FrequentFlyerHandler
IsAirlineEmployeeHandler
BannedFromLoungeHandler
DateOfBirthHandlerAllowedInLoungeRequirement
MinimumAgeRequirement
Рис. 15.5 У политики может быть много требований, и у каждого требования
может быть много обработчиков. Объединив несколько требований в политике
и предоставив несколько реализаций обработчиков, можно создавать сложные
политики авторизации, которые соответствуют вашим потребностям
Чтобы соответствовать политике, пользователь должен выполнить все
требования. Если пользователь терпит неудачу с  каким-либо из этих тре-
бований, компонент авторизации не разрешит выполнить защищенную
конечную точку.
В этом примере пользователю должен быть разрешен доступ в  зал
ожидания, и он должен быть старше 18 лет.
Каждое требование может иметь один или несколько обработчиков,
которые подтверждают, что требование было выполнено. Например, как
показано на рис. 15.5, у  AllowedInLoungeRequirement есть два обработчи-
ка, которые могут удовлетворить это требование:
FrequentFlyerHandler;
IsAirlineEmployeeHandler.
Если пользователь удовлетворяет любому из этих обработчиков, это
значит, что он удовлетворяет AllowedInLoungeRequirement. Вам не нужны
все обработчики, чтобы требование было удовлетворено, нужен только
один.
ПРИМЕЧАНИЕ  На рис. 15.5 показан третий обработчик, Banned-
FromLoungeHandler, о котором я расскажу в разделе 15.4.2. Он не-
много отличается в том смысле, что может использоваться только
для проверки	несоответствия требованию.
Вы можете использовать требования и  обработчики для достижения
практически любой комбинации поведения, необходимой вам для поли-
тики. Сочетая обработчики для требования, вы можете проверять усло-
вия, используя логический оператор OR: если какой-либо из обработчиков
удовлетворен, то требование удовлетворено. Комбинируя требования, вы
создаете логический оператор AND: все требования должны быть удовлет -
воренными, чтобы отвечать политике, как показано на рис. 15.6.

571 Создание специальных политик авторизации
СОВЕТ  Вы также можете добавить несколько политик на стра-
ницу Razor Page или метод действия, многократно применяя
атрибут [Authorize], например [Authorize("Policy1"), Authori-
ze("Po licy2")]. Чтобы запрос был авторизован, должны быть удов-
летворены все политики.
# AND
# ORAND   ...   AND
OR   ...   OR=Чтобы политика была удовлетворена,
необходимо удовлетворить все требования
Если какой-либо из обработчиков удовлетворен,
то и требование удовлетвореноПолитика
удовлетворена?Требование 1 Требование 2 Требование N
Обработчик
2AОбработчик
2BОбработчик
# M
Рис. 15.6 Чтобы удовлетворять политике, необходимо отвечать всем требованиям.
Вы отвечаете требованию, если отвечаете какому-либо обработчику
Я выделил требования и  обработчики, из которых состоит ваша по-
литика "CanAccessLounge", поэтому в следующем разделе вы создадите
каждый из компонентов и примените их в приложении для аэропорта,
которое мы используем в качестве примера.
15.4.2 Создание политики со специальным требованием
и обработчиком
Вы видели все составляющие специальной политики авторизации, по-
этому в этом разделе мы рассмотрим реализацию политики "CanAccess-
Lounge".
создание  iauTHoRiza TioNRequiReMeNT  для представления  требования
Как вы видели, у специальной политики может быть несколько требований,
но что такое требование на языке кода? Требование к авторизации в ASP .
NET Core – это любой класс, реализующий интерфейс IAuthorizationRe-
quirement. Это пустой интерфейс-маркер, который можно применить к лю-
бому классу, чтобы указать, что он представляет собой требование.
Если у интерфейса нет членов, то как должен выглядеть класс требова-
ний? Обычно это простые POCO-классы. В следующем листинге показан
класс AllowedInLoungeRequirement, который примерно так же прост, как
и требование. У него нет свойств или методов; он реализует необходи-
мый интерфейс IAuthorizationRequirement.
Листинг 15.5 Класс AllowedInLoungeRequirement
public class AllowedInLoungeRequirement
: IAuthorizationRequirement { } Интерфейс идентифицирует класс
как требование авторизации.

572 Глава 15 Авторизация: обеспечиваем защиту приложения
Это простейшая форма требования, но часто у них может быть одно
или два свойства, которые делают требование более универсальным. На-
пример, вместо того чтобы создавать очень специфичное требование
MustBe18YearsOldRequirement, можно было бы создать параметризован-
ное требование MinimumAgeRequirement, как показано в следующем лис -
тинге. Указав минимальный возраст в качестве параметра требования,
вы можете повторно использовать его для других политик с иными тре-
бованиями к минимальному возрасту.
Листинг 15.6 Параметризованный класс MinimumAgeRequirement
public class MinimumAgeRequirement : IAuthorizationRequirement
{
public MinimumAgeRequirement(int minimumAge)
{
MinimumAge = minimumAge;
}
public int MinimumAge { get; }
}
Требования – самая легкая часть. Они представляют каждый из ком-
понентов политики, которым вы должны отвечать, чтобы отвечать по-
литике в целом.
создание  политики  с несколькиМи  требованияМи
Вы создали два требования, поэтому теперь можете настроить политику
"CanAccessLounge", чтобы использовать их. Делается это, как и раньше,
в методе ConfigureServices файла Startup.cs. В листинге 15.7 показано,
как это сделать, создав экземпляр каждого требования и передав их клас -
су AuthorizationPolicyBuilder. Обработчики авторизации будут исполь-
зовать эти объекты требований при попытке авторизовать политику.
Листинг 15.7  Создание политики авторизации со множеством
требований
public void ConfigureServices(IServiceCollection services)
{
services.AddAuthorization(options =>
{
options.AddPolicy(
"CanEnterSecurity",
policyBuilder => policyBuilder
.RequireClaim(Claims.BoardingPassNumber));
options.AddPolicy(
"CanAccessLounge",
policyBuilder => policyBuilder.AddRequirements(
new MinimumAgeRequirement(18),
new AllowedInLoungeRequirement()
));Интерфейс идентифицирует класс
как требование авторизации.
При создании требования
указывается минимальный возраст.
Обработчики могут использовать установленный
минимальный возраст, чтобы определить,
выполнено ли требование.
Добавляет предыдущую
простую политику
для прохождения службы
безопасности.
Добавляет новую
политику для зала
ожидания аэропорта,
CanAccessLounge.Добавляет экземпляр
каждого объекта
IAuthorizationRequirement.

573 Создание специальных политик авторизации
});
// Дополнительная конфигурация сервиса;
}
Теперь у вас есть политика CanAccessLounge с двумя требованиями, по-
этому вы можете применить ее к странице Razor или методу действия
с по мощью атрибута [Authorize] точно так же, как и для политики "Can-
EnterSecurity":
[Authorize("CanAccessLounge")]
public class AirportLoungeModel : PageModel
{
public void OnGet() { }
}
Когда запрос маршрутизируется на страницу AirportLounge.cshtml,
компонент авторизации выполняет политику авторизации и  проверя-
ет каждое из требований. Но, как вы могли заметить, требования – это
прос  то данные; они указывают, что нужно выполнить, но не описывают,
как именно. Для этого необходимо написать несколько обработчиков.
создаеМ  обработчики , чтобы  отвечать  требованияМ
Обработчики авторизации содержат логику того, как соответствовать
конкретному интерфейсу IAuthorizationRequirement. При выполнении
обработчик может делать одно из трех:
отметить обработку требований как успешную;
ничего не делать;
явно не отвечать требованию.
Обработчики должны реализовать AuthorizationHandler<T>, где T  –
тип требования, которое они обрабатывают. Например, в  следующем
листинге показан обработчик для AllowedInLoungeRequirement, который
проверяет, есть ли у  пользователя утверждение FrequentFlyerClass со
значением Gold.
Листинг 15.8  Обработчик FrequentFlyerHandler для требования
AllowedInLoungeRequirement
public class FrequentFlyerHandler :
AuthorizationHandler<AllowedInLoungeRequirement>
{
protected override Task HandleRequirementAsync(
AuthorizationHandlerContext context,
AllowedInLoungeRequirement requirement)
{
if(context.User.HasClaim("FrequentFlyerClass", "Gold"))
{Обработчик реализует
AuthorizationHandler<T>.Вы должны переопределить абстрактный
метод HandleRequirementAsync.
Контекст
содержит такие
сведения, как
пользовательский
объект
ClaimsPrincipal.Экземпляр требования
для обработки.
Проверяет, есть ли у пользователя утверждение
FrequentFlyerClass со значением Gold.

574 Глава 15 Авторизация: обеспечиваем защиту приложения
context.Succeed(requirement);
}
return Task.CompletedTask;
}
}
Этот обработчик функционально эквивалентен простому обработчику
RequireClaim(), который вы видели в начале раздела 15.4, но он исполь-
зует требования и обработчики.
Когда запрос маршрутизируется на страницу AirportLounge.cshtml,
компонент авторизации видит атрибут [Authorize] на конечной точке
с политикой "CanAccessLounge". Он перебирает все требования в поли-
тике и всех обработчиков для каждого требования, вызывая для каждого
метод HandleRequirementAsync.
Компонент авторизации передает текущий AuthorizationHandlerCon-
text и требование для проверки каждому обработчику. Текущий объ-
ект ClaimsPrincipal, который авторизуется, предоставляется в контек -
сте как свойство User. В листинге 15.8 обработчик FrequentFlyerHandler
использует контекст для проверки утверждения FrequentFlyerClass со
значением Gold и, если оно существует, указывает на то, что пользова-
телю разрешено войти в зал ожидания авиакомпании, вызывая метод
Succeed().
ПРИМЕЧАНИЕ  Обработчики помечают требование как успешно
выполненное, вызывая метод context.Succeed() и передавая тре-
бование в качестве аргумента.
Важно отметить поведение, при котором у пользователя нет утверж -
дения. Утверждение FrequentFlyerHandler ничего не делает в этом слу -
чае (он возвращает завершенную задачу, чтобы соответствовать сигна-
туре метода).
ПРИМЕЧАНИЕ  Помните, что если какой-либо из обработчиков,
ассоциированных с требованием, проходит, то требование счита-
ется удовлетворенным. Достаточно одного	 успешно выполненного
обработчика, чтобы отвечать требованию.
Такое поведение, при котором вы либо вызываете метод context.Suc-
ceed(), либо ничего не делаете, типично для обработчиков авторизации.
В следующем листинге показана реализация обработчика IsAirlineEm-
ployeeHandler, который использует аналогичную проверку утверждения,
чтобы определить, отвечаете ли вы требованию.
Листинг 15.9  Обработчик IsAirlineEmployeeHandler
public class IsAirlineEmployeeHandler :
AuthorizationHandler<AllowedInLoungeRequirement>
{Если у пользователя было необходимое
утверждение, отмечаем его как
удовлетворенное, вызвав метод Succeed.Если требование не было выполнено,
ничего не предпринимаем.
Обработчик реализует
AuthorizationHandler<T>.

575 Создание специальных политик авторизации
protected override Task HandleRequirementAsync(
AuthorizationHandlerContext context,
AllowedInLoungeRequirement requirement)
{
if(context.User.HasClaim(c => c.Type == "EmployeeNumber"))
{
context.Succeed(requirement);
}
return Task.CompletedTask;
}
}
СОВЕТ  Можно писать очень обобщенные обработчики, которые
можно использовать с  несколькими требованиями, но я  предла-
гаю придерживаться только одного требования. Если вам нужно
извлечь какую-то общую функциональность, переместите ее во
внешний сервис и выполните вызов из обоих обработчиков.
Это распространенный шаблон обработчика авторизации1, но в  не-
которых случаях, вместо того чтобы проверить, насколько все было
успешно, у вас может возникнуть желание проверить, насколько все было
неудачно. Например, если вернуться к аэропорту, вы не хотите авторизо-
вать человека, которому ранее запретили вход в зал ожидания, даже если
в противном случае ему разрешили бы войти.
Для этого можно использовать метод context.Fail(), предоставлен-
ный в  контексте, как показано в  следующем листинге. Вызов метода
Fail() в обработчике всегда будет приводить к тому, что требование –
а следовательно, и вся политика – потерпит неудачу. Вы должны исполь-
зовать его только тогда, когда хотите гарантировать сбой, даже если дру -
гие обработчики выполнятся успешно.
Листинг 15.10  Вызов метода context.Fail() в обработчике, чтобы не
выполнять требование
public class BannedFromLoungeHandler :
AuthorizationHandler<AllowedInLoungeRequirement>
{
protected override Task HandleRequirementAsync(
AuthorizationHandlerContext context,
AllowedInLoungeRequirement requirement)
{
if(context.User.HasClaim(c => c.Type == "IsBanned"))
{
context.Fail();
}
1 Я оставлю реализацию обработчика MinimumAgeHandler для требования Mini-
mumAgeRequirement вам в  качестве упражнения. Вы можете найти пример
в примерах кода для этой главы.Вы должны переопределить
абстрактный метод
HandleRequirementAsync.
Проверяет, есть ли у пользователя
утверждение EmployeeNumber.
Если у пользователя было необходимое
утверждение, помечаем его как
удовлетворенное, вызвав метод Succeed.Если требование не было выполнено,
ничего не предпринимаем.
Обработчик реализует
AuthorizationHandler<T>.
Вы должны переопределить
абстрактный метод
HandleRequirementAsync.
Проверяет, есть
ли у пользователя
утверждение
IsBanned.Если у пользователя есть утверждение,
откажитесь от выполнения требования, вызвав
метод Fail. Вся политика потерпит неудачу.

576 Глава 15 Авторизация: обеспечиваем защиту приложения
return Task.CompletedTask;
}
}
В большинстве случаев ваши обработчики либо вызывают метод Suc-
ceed(), либо ничего не делают, но метод Fail() полезен, когда вам нужен
аварийный выключатель, чтобы гарантировать, что требование не будет
удовлетворено.
ПРИМЕЧАНИЕ  Независимо от того, вызывает обработчик мето-
ды Succeed() или Fail() либо ни то, ни другое, система авториза-
ции всегда будет выполнять все обработчики для требования и все
требования к политике, поэтому можете быть уверены, что ваши
обработчики всегда будут вызываться.
Последний шаг для завершения реализации авторизации в приложе-
нии – это регистрация обработчиков авторизации в контейнере внедре-
ния зависимостей, как показано в следующем листинге.
Листинг 15.11  Регистрация обработчиков авторизации в контейнере
внедрения зависимостей
public void ConfigureServices(IServiceCollection services)
{
services.AddAuthorization(options =>
{
options.AddPolicy(
"CanEnterSecurity",
policyBuilder => policyBuilder
.RequireClaim(Claims.BoardingPassNumber));
options.AddPolicy(
"CanAccessLounge",
policyBuilder => policyBuilder.AddRequirements(
new MinimumAgeRequirement(18),
new AllowedInLoungeRequirement()
));
});
services.AddSingleton<IAuthorizationHandler, MinimumAgeHandler>();
services.AddSingleton<IAuthorizationHandler, FrequentFlyerHandler>();
services.AddSingleton<IAuthorizationHandler, BannedFromLoungeHandler>();
services.AddSingleton<IAuthorizationHandler, IsAirlineEmployeeHandler>();
// Дополнительная конфигурация сервиса;
}
Для этого приложения у обработчиков нет зависимостей, внедряемых
в конструктор, поэтому я зарегистрировал их в контейнере как объекты-
одиночки. Если у  ваших обработчиков есть  зависимости с  жизненным
циклом Scoped или Transient (например, класс EF Core, DbContext), то вы
можете зарегистрировать их как Scoped.Если утверждение не найдено,
ничего не предпринимаем.

577 Управление доступом с авторизацией на основе ресурсов
ПРИМЕЧАНИЕ  Сервисы регистрируются с  жизненным циклом
трех типов: transient, scoped или singleton, как описано в главе 10.
Вы можете комбинировать концепции политик, требований и  обра-
ботчиков разными способами для достижения своих целей по автори-
зации в приложении. Пример, приведенный в этом разделе, хотя и на-
думанный, демонстрирует каждый из необходимых вам компонентов,
чтобы декларативно применить авторизацию на уровне метода дей-
ствия или страницы Razor, создавая политики и при необходимости при-
меняя атрибут [Authorize].
Помимо явного применения атрибута [Authorize] к действиям и стра-
ницам Razor, вы также можете сконфигурировать его глобально, чтобы
политика применялась к каждой странице Razor или контроллеру в ва-
шем приложении. Кроме того, для Razor Pages можно применять разные
политики авторизации к  разным папкам. Дополнительную информа-
цию о применении политик авторизации с использованием соглашений
см. в статье Microsoft: http://mng.bz/nMm2.
Однако есть одна область, где атрибут [Authorize] не работает: авториза-
ция на основе ресурсов. Атрибут [Authorize] добавляет метаданные к конеч-
ной точке, поэтому компонент авторизации может авторизовать пользова-
теля до выполнения конечной точки, но что, если вам нужно авторизовать
действие во	время метода действия или обработчика страницы Razor?
Применение авторизации на уровне документа или ресурса – обычное
явление. Если пользователям разрешено редактировать только те доку -
менты, которые они создали, то вам необходимо загрузить документ,
прежде чем вы узнаете, разрешено ли им редактировать его! С деклара-
тивным подходом, в котором используется атрибут [Authorize], сделать
это не просто, поэтому нужно воспользоваться альтернативой – импе-
ративным подходом. В следующем разделе вы увидите, как применить
авторизацию на основе ресурсов в обработчике страниц Razor.
15.5 Управление доступом с авторизацией
на основе ресурсов
В этом разделе вы узнаете об авторизации на основе ресурсов. Она ис -
пользуется, когда вам необходимо узнать подробности о  защищаемом
ресурсе, чтобы определить, авторизован ли пользователь. Вы узнаете,
как применять политики авторизации вручную с по мощью интерфейса
IAuthorizationService и создавать обработчики AuthorizationHandler на
основе ресурсов.
Авторизация на основе ресурсов – распространенная задача для при-
ложений, особенно когда у вас есть пользователи, которые могут созда-
вать или редактировать какие-то документы. Рассмотрим приложение
с рецептами, которое мы создали в предыдущих трех главах. Оно позво-
ляет пользователям создавать, просматривать и редактировать рецепты.

578 Глава 15 Авторизация: обеспечиваем защиту приложения
До настоящего момента каждый может создавать новые рецепты и от -
редактировать любой рецепт, даже если не выполнил вход в приложение.
Теперь вы хотите добавить дополнительное поведение:
только доверенные пользователи должны иметь возможность соз-
давать новые рецепты;
вы можете редактировать лишь созданные вами рецепты.
Вы уже видели, как выполнить первое из этих требований: декориро-
вать страницу Create.cshtml атрибутом [Authorize] без указания поли-
тики, как показано в этом листинге. Это заставит пользователя пройти
аутентификацию, прежде чем он сможет создать новый рецепт.
Листинг 15.12   Добавление атрибута Authorize на страницу Create.cshtml
[Authorize]
public class CreateModel : PageModel
{
[BindProperty]
public CreateRecipeCommand Input { get; set; }
public void OnGet()
{
Input = new CreateRecipeCommand();
}
public async Task<IActionResult> OnPost()
{
// Тело метода не показано для краткости;
}
}
СОВЕТ  Как и в случае со всеми фильтрами, атрибут [Authorize]
можно применить только к странице Razor Page, а не к отдельным
обработчикам страниц. Атрибут применяется ко всем обработчи-
кам страниц на странице Razor.
Добавление атрибута [Authorize] отвечает вашему первому требова-
нию, но, к сожалению, используя техники, которые уже были показаны,
у вас нет возможности удовлетворить второе требование. Можно было
бы применить политику, которая разрешает или запрещает пользова-
телю редактировать	 все рецепты, но в настоящее время нельзя просто
сделать так, чтобы пользователь мог редактировать только собственные
рецепты.
Чтобы узнать, кто создал рецепт, сначала нужно загрузить его из базы
данных. Только после этого можно попытаться авторизовать пользова-
теля, принимая во внимание конкретный рецепт (ресурс). В следующем
листинге показан частично реализованный обработчик страницы, де-
монстрирующий, как может выглядеть авторизация, которая происхо-
дит после загрузки объекта Recipe.Пользователи должны пройти аутентификацию
для выполнения страницы Razor, Create.cshtml.
Все обработчики страниц защищены.
Вы можете применить атрибут
[Authorize] только к PageModel,
но не к обработчикам.

579 Управление доступом с авторизацией на основе ресурсов
Листинг 15.13  Страница Edit.cshtml должна загрузить объект Recipe
перед авторизацией запроса
public IActionResult OnGet(int id)
{
var recipe = _service.GetRecipe(id);
var createdById = recipe.CreatedById;
// Авторизация пользователя на основе createdById;
if(isAuthorized)
{
return View(recipe);
}
}
Вам необходим доступ к ресурсу (в данном случае сущности Recipe)
для выполнения авторизации, поэтому декларативный атрибут [Autho-
rize] вам не поможет. В разделе 15.5.1 вы увидите подход, которым нуж -
но воспользоваться, чтобы справиться с этими ситуациями и применить
авторизацию внутри метода действия или страницы Razor.
ВНИМАНИЕ!  Будьте осторожны при предоставлении целочис -
ленного идентификатора сущностей в  URL-адресе, как показано
в листинге 15.13. Пользователи смогут редактировать каждую сущ-
ность, изменяя идентификатор в URL-адресе для доступа к другой
сущности. Обязательно примените проверку авторизации, или вы
рискуете столкнуться с уязвимостью под названием небезопасные
прямые	ссылки	на	объекты	(IDOR)1.
15.5.1 Ручная авторизация запросов с по мощью интерфейса
IAuthorizationService
До сих пор все подходы к авторизации были декларативными. Вы приме-
няете атрибут [Authorize] с именем политики или без него и позволяете
фреймворку брать на себя заботу о выполнении самой авторизации.
В примере с редактированием рецепта необходимо использовать	 им-
перативную авторизацию, чтобы авторизовать пользователя после за-
грузки объекта Recipe из базы данных. Вместо того чтобы применять
маркер, гласящий «Авторизуйте этот метод», нужно самостоятельно на-
писать код авторизации.
ОПРЕДЕЛЕНИЕ  Декларативное	 и императивное	 программирова-
ние – два разных стиля программирования. Декларативное про-
1 Об этой уязвимости и способах противодействия ей можно прочитать здесь:
https://owasp.org/www-chapter -ghana/assets/slides/IDOR.pdf .Идентификатор редактируемого рецепта
предоставляется привязкой модели.
Вы должны загрузить сущность Recipe
из базы данных, прежде чем узнаете,
кто ее создал.
Вы должны авторизовать текущего
пользователя, чтобы убедиться, что
ему разрешено редактировать этот
конкретный рецепт.
Метод действия может продолжить работу только
в том случае, если пользователь авторизован.

580 Глава 15 Авторизация: обеспечиваем защиту приложения
граммирование описывает то,	чего вы пытаетесь достичь, и  по-
зволяет фреймворку выяснить, как этого добиться. Императивное
программирование описывает, как сделать это, предоставляя все
необходимые шаги.
ASP .NET Core предоставляет интерфейс IAuthorizationService, кото -
рый вы можете внедрить в Razor Pages и контроллеры для императивной
авторизации. В следующем листинге показано, как обновить страницу
Edit.cshtml (она частично показана в листинге 15.13), чтобы использо-
вать интерфейс IAuthorizationService и проверить, разрешено ли дей-
ствию продолжить выполнение.
Листинг 15.14  Использование интерфейса IAuthorizationService
для авторизации на основе ресурсов
[Authorize]
public class EditModel : PageModel
{
[BindProperty]
public Recipe Recipe { get; set; }
private readonly RecipeService _service;
private readonly IAuthorizationService _authService;
public EditModel(
RecipeService service,
IAuthorizationService authService)
{
_service = service;
_authService = authService;
}
public async Task<IActionResult> OnGet(int id)
{
Recipe = _service.GetRecipe(id);
var authResult = await _authService
.AuthorizeAsync(User, Recipe, "CanManageRecipe");
if (!authResult.Succeeded)
{
return new ForbidResult();
}
return Page();
}
}
IAuthorizationService предоставляет метод AuthorizeAsync, которому
требуются три вещи для авторизации запроса:
пользовательский объект ClaimsPrincipal, предоставленный в  Pa-
geModel как User;
авторизуемый ресурс: Recipe;
политика, которую нужно определить: "CanManageRecipe".Т олько авторизованные пользователи
должны иметь право редактировать рецепты.
IAuthorizationService
вводится в конструктор
класса, используя
внедрение
зависимостей.
Загружаем рецепт
из базы данных.Вызывает IAuthorizationService,
предоставляя ClaimsPrinicipal,
ресурс и имя политики.
Если авторизация прошла неудачно,
возвращается результат Forbidden.
Если авторизация прошла успешно,
по-прежнему отображается страница Razor.

581 Управление доступом с авторизацией на основе ресурсов
Попытка авторизации возвращает объект AuthorizationResult, кото -
рый указывает на то, была ли попытка успешной, через свойство Suc-
ceeded. Если попытка была неудачной, вы должны вернуть новый объект
ForbidResult, который будет либо преобразован в  ответ 403 Forbidden,
либо перенаправит пользователя на страницу с  надписью «Отказано
в  доступе», в  зависимости от того, создаете ли вы традиционное веб-
приложение с по мощью Razor Pages или веб-API.
ПРИМЕЧАНИЕ  Как упоминалось в  разделе 15.2.2, генерируе-
мый тип ответа зависит от того, какие сервисы аутентификации
настроены. Конфигурация Identity по умолчанию, используемая
Razor Pages, генерирует перенаправления. Аутентификация с мар-
кером носителя JWT, обычно используемая с веб-API, генерирует
ответы с кодами состояния 401 и 403.
Вы настроили императивную авторизацию на самой странице Edit.
cshtml, но вам все равно нужно определить политику "CanManageRecipe",
которую вы используете для авторизации пользователя. Этот процесс
выглядит так же, как и для декларативной авторизации, поэтому необ-
ходимо сделать следующее:
создайте политику в ConfigureServices, вызвав метод AddAuthoriza-
tion();
определите одно или несколько требований политики;
определите один или несколько обработчиков	 для каждого требо-
вания;
зарегистрируйте обработчики в  контейнере внедрения зависи-
мостей.
За исключением обработчика, все эти шаги идентичны подходу с де-
кларативной авторизацией с  атрибутом [Authorize], поэтому я только
быстро пробегусь по ним.
Во-первых, вы можете создать простое требование IAuthorization-
Requirement. Как и многие другие требования, оно не содержит данных
и просто реализует интерфейс-маркер.
public class IsRecipeOwnerRequirement : IAuthorizationRequirement { }
Определить политику в  ConfigureServices так же просто, поскольку
у вас есть только одно требование. Обратите внимание, что в этом коде
пока нет ничего конкретного для ресурсов:
public void ConfigureServices(IServiceCollection services)
{
services.AddAuthorization(options => {
options.AddPolicy("CanManageRecipe", policyBuilder =>
policyBuilder.AddRequirements(new IsRecipeOwnerRequirement()));
});
}

582 Глава 15 Авторизация: обеспечиваем защиту приложения
Вы уже прошли половину пути; все, что вам нужно сделать сейчас, –
это создать обработчик авторизации для IsRecipeOwnerRequirement и за-
регистрировать его в контейнере внедрения зависимостей.
15.5.2 Создание обработчика AuthorizationHandler
на основе ресурсов
Обработчики авторизации на основе ресурсов, по сути, такие же, как
и реализации обработчиков, которые вы видели в разделе 15.4.2. Един-
ственная разница состоит в  том, что обработчик также имеет доступ
к авторизуемому ресурсу.
Чтобы создать обработчик на основе ресурсов, вы должны унасле-
довать его от базового класса AuthorizationHandler<TRequirement, TRe-
source>, где TRequirement  – это тип требования для обработки, а  TRe-
source – это тип ресурса, который вы предоставляете, когда вызываете
IAuthorizationService. Сравните его с классом AuthorizationHandler<T>,
реализованным ранее, где вы указали только тип требования.
В этом листинге показана реализация обработчика для приложения с ре-
цептами. Вы видите, что мы указали требование как IsRecipeOwnerRequire-
ment, а ресурс как Recipe, и реализовали метод HandleRequirementAsync.
Листинг 15.15  Класс IsRecipeOwnerHandler для авторизации
на основе ресурсов
public class IsRecipeOwnerHandler :
AuthorizationHandler<IsRecipeOwnerRequirement, Recipe>
{
private readonly UserManager<ApplicationUser> _userManager;
public IsRecipeOwnerHandler(
UserManager<ApplicationUser> userManager)
{
_userManager = userManager;
}
protected override async Task HandleRequirementAsync(
AuthorizationHandlerContext context,
IsRecipeOwnerRequirement requirement,
Recipe resource)
{
var appUser = await _userManager.GetUserAsync(context.User);
if(appUser == null)
{
return;
}
if(resource.CreatedById == appUser.Id)
{
context.Succeed(requirement);
}
}
}Реализует необходимый базовый класс
с указанием требования и типа ресурса.
Внедряет
экземпляр класса
UserManager<T>
с по мощью внедрения
зависимостей.
Помимо контекста и требований,
вам также предоставляется
экземпляр ресурса.
Если вы не прошли аутентификацию,
appUser будет иметь значение null.
Проверяет, создал ли текущий
пользователь рецепт, проверив
CreatedById.Если пользователь создал рецепт,
используем метод Succeed; в противном
случае ничего не делаем.

583 Управление доступом с авторизацией на основе ресурсов
Этот обработчик немного сложнее, чем те примеры, которые вы ви-
дели ранее, прежде всего потому, что вы используете дополнительный
сервис UserManager<> для загрузки сущности ApplicationUser на основе
объекта ClaimsPrincipal из запроса.
ПРИМЕЧАНИЕ  На практике в  ClaimsPrincipal, скорее всего, уже
будет добавлен идентификатор в  качестве утверждения, что де-
лает лишним дополнительный шаг в данном случае. Этот пример
показывает общий шаблон, если вам нужно использовать сервисы
с внедрением зависимостей.
Другое существенное отличие состоит в том, что метод HandleRequire-
mentAsync предоставляет ресурс Recipe в  качестве аргумента метода.
Это тот же объект, который вы предоставляли при вызове метода Autho-
rizeAsync в  IAuthorizationService. Вы можете использовать этот ресурс,
чтобы проверить, был ли он создан текущим пользователем. Если это
так, то используется метод Succeed(); в противном случае вы ничего не
делаете.
Последняя задача – добавить обработчик IsRecipeOwnerHandler в кон-
тейнер внедрения зависимостей. Ваш обработчик использует допол-
нительную зависимость UserManager<>, которая применяет EF Core, по-
этому следует зарегистрировать обработчик как сервис с  жизненным
циклом Scoped:
services.AddScoped<IAuthorizationHandler, IsRecipeOwnerHandler>();
СОВЕТ  Если вам интересно, как узнать, с каким жизненным цик -
лом нужно зарегистрировать обработчик: Scoped или Singleton, –
вспомните главу 10. По сути, если у вас есть зависимости с жизнен-
ным циклом Scoped, то вы должны зарегистрировать обработчик
как scoped; в противном случае будет singleton.
Когда все будет подключено, можно опробовать приложение. Если
вы попытаетесь отредактировать рецепт, который не создавали, нажав
кнопку «Изменить», то либо будете перенаправлены на страницу входа
(если еще не прошли аутентификацию), либо увидите страницу «Отказа-
но в доступе», как показано на рис. 15.7.
Используя авторизацию на основе ресурсов, вы можете вводить более
детальные требования авторизации, которые можно применять на уров-
не отдельного документа или ресурса. Вместо того чтобы только раз-
решить пользователю редактировать любой рецепт, можно разрешить
пользователю редактировать определенный	рецепт.

584 Глава 15 Авторизация: обеспечиваем защиту приложения
Аутенти-
фицирован ли
текущий
пользователь?
Текущий
пользователь создал
рецепт?Просмотр рецепта
Нажимаем
кнопку Edit
Страница входа
Доступ запрещенНет
НетДа
ДаРедактировать
рецепт
Рис. 15.7  Если вы выполнили вход в приложение, но не авторизованы для
редактирования рецепта, то будете перенаправлены на страницу «Отказано
в доступе». Если вы не выполнили вход, то будете перенаправлены на страницу
входа
Авторизация на основе ресурсов и проверка бизнес-логики
Ценность использования подхода к авторизации на основе ресурсов в ASP.
NET Core не всегда очевидна по сравнению с использованием простой про-
верки бизнес-логики, осуществляемой вручную (как в листинге 15.13). Ис -
пользование интерфейса IAuthorizationService и инфраструктуры автори-
зации добавляет явную зависимость от фреймворка ASP.NET Core, которую
вы, возможно, не захотите использовать, если выполняете проверку автори-
зации в сервисах модели предметной области.
Это серьезная проблема, для которой нет простого решения. Я предпочитаю
простую проверку бизнес-логики внутри предметной области, не полагаясь
на инфраструктуру авторизации фреймворка, чтобы сделать свою предмет -
ную область более простой для тестирования и независимой от фреймворка.
Но при этом теряются некоторые преимущества такого фреймворка:
  IAuthorizationService использует декларативные политики, даже если
вы императивно вызываете фреймворк авторизации;

585 Скрытие элементов в шаблонах Razor от незарегистрированных пользователей
  вы можете отделить необходимость авторизации действия от фактических
требований;
  вы можете с легкостью полагаться на периферийные сервисы и свойства
запроса, что может быть сложнее (или нежелательно) при проверке биз-
нес-логики.
Эти преимущества можно получить с по мощью проверок бизнес-логики, но
обычно для этого требуется создание большой инфраструктуры, поэтому вы
теряете много преимуществ, которые дает вам простота. Какой подход луч-
ше всего? Это зависит от специфики дизайна вашего приложения, и вполне
могут быть случаи, когда можно будет использовать оба варианта.
Все техники авторизации, которые вы видели до сих пор, были сосре-
доточены на проверке на стороне сервера. И атрибут [Authorize], и ав-
торизация на основе ресурсов фокусируются на запрете пользователям
выполнять защищенное действие на сервере. Это важно с точки зрения
безопасности, но есть еще один аспект, который следует учитывать:
опыт взаимодействия пользователя с сайтом, когда у этого пользователя
нет полномочий.
Вы защитили код, выполняющийся на сервере, но, возможно, кнопку
«Изменить» не стоит показывать пользователям, если вы не собираетесь
разрешать им редактировать рецепт! В следующем разделе мы рассмот -
рим, как можно условно скрыть ее с по мощью авторизации на основе
ресурсов в моделях представления.
15.6 Скрытие элементов в шаблонах Razor
от незарегистрированных пользователей
Весь код авторизации, который вы видели до сих пор, был связан с за-
щитой методов действий или страниц Razor Pages на стороне сервера,
а не изменением пользовательского интерфейса для пользователей. Это
важно и должно быть отправной точкой всякий раз, когда вы добавляете
авторизацию в приложение.
ВНИМАНИЕ!  Злоумышленники могут с  легкостью обойти ваш
пользовательский интерфейс, поэтому всегда важно авторизовать
методы действия и страницы Razor Pages на сервере, а не только
на стороне клиента.
Однако с точки зрения опыта взаимодействия пользователя с сайтом
наличие кнопок или ссылок, которые выглядят так, будто они доступны,
но отображают сообщение «Отказ в доступе», когда на них нажимают, не
совсем удобно. Лучше отключать эти ссылки или сделать так, чтобы их
вообще не было видно.

586 Глава 15 Авторизация: обеспечиваем защиту приложения
Этого можно добиться несколькими способами с по мощью собствен-
ных шаблонов Razor. В данном разделе я покажу вам, как добавить допол-
нительное свойство в  PageModel: CanEditRecipe. Шаблон представления
Razor будет использовать его для изменения визуализированного HTML.
СОВЕТ  В  качестве альтернативы можно было бы внедрить ин-
терфейс IAuthorizationService непосредственно в  шаблон пред-
ставления с  по мощью директивы @inject, как было показано
в  главе  10, но предпочтительнее хранить подобную логику в  об-
работчике страницы.
Когда вы закончите, визуализированный HTML созданных вами ре-
цептов останется без изменений, но кнопка «Изменить» будет скрыта
при просмотре рецепта, созданного кем-то другим, как показано на
рис. 15.8.
Если пользователь создал
рецепт, он может увидеть
кнопку EditДля рецептов, созданных
другими пользователями,
кнопка Edit скрыта
Рис. 15.8 Несмотря на то что HTML созданных вами рецептов будет отображаться
без изменений, кнопка «Изменить» будет скрыта при просмотре рецептов, созданных другим
пользователем
В следующем листинге показана модель PageModel для страницы Ra-
zor, View.cshtml, которая используется для отрисовки страницы рецеп-
тов, показанной на рис. 15.8. Как вы уже видели в случае с авторизацией
на основе ресурсов, вы можете использовать интерфейс IAuthorization-
Service, чтобы определить, есть ли у текущего пользователя полномочия
на редактирование рецепта путем вызова метода AuthorizeAsync. Затем
вы можете задать это значение в качестве дополнительного свойства Pa-
geModel, CanEditRecipe.
Листинг 15.16 Задаем свойство CanEditRecipe на странице View.cshtml
public class ViewModel : PageModel
{
public Recipe Recipe { get; set; }
public bool CanEditRecipe { get; set; }
private readonly RecipeService _service;
private readonly IAuthorizationService _authService;
public ViewModel(
RecipeService service,
IAuthorizationService authService)
{Свойство CanEditRecipe будет
использоваться для управления
отрисовкой кнопки «Изменить».

587 Скрытие элементов в шаблонах Razor от незарегистрированных пользователей
_service = service;
_authService = authService;
}
public async Task<IActionResult> OnGetAsync(int id)
{
Recipe = _service.GetRecipe(id);
var isAuthorised = await _authService
.AuthorizeAsync(User, recipe, "CanManageRecipe");
CanEditRecipe = isAuthorised.Succeeded;
return Page();
}
}
Вместо того чтобы блокировать выполнение страницы Razor (как вы
это делали ранее в обработчике страниц Edit.cshtml), используйте резуль-
тат вызова метода AuthorizeAsync, чтобы задать значение CanEditRecipe
в PageModel. Затем можно просто изменить шаблон View.chstml: добавьте
предложение if вокруг отрисовки ссылки «Изменить».
@if(Model.CanEditRecipe)
{
<a asp-page="Edit" asp-route-id="@Model.Id"
class="btn btn-primary">Edit</a>
}
Это гарантирует, что только пользователи, которые могут выполнить
страницу Edit.cshtml, смогут увидеть ссылку на эту страницу.
ВНИМАНИЕ!  Предложение if означает, что ссылка «Изменить»
не будет отображаться, если только пользователь не создавал этот
рецепт, но злоумышленник	 по-прежнему	 может	обойти	 пользова-
тельский	 интерфейс. Важно сохранить проверку авторизации на
стороне сервера в вашем обработчике страниц Edit.cshtml, чтобы
защитить себя от попыток взлома.
Выполнив это последнее изменение, мы завершили добавление ав-
торизации в  приложение рецептов. Анонимные пользователи могут
просматривать рецепты, созданные другими лицами, но они должны
выполнить вход, чтобы создавать новые рецепты. Кроме того, проверен-
ные пользователи могут редактировать только те рецепты, которые они
создали, и они не увидят кнопку «Изменить» в рецептах других пользо-
вателей.
Авторизация – ключевой аспект большинства приложений, поэтому
важно помнить о ней с самого начала. Хотя авторизацию можно доба-
вить позже, как вы это делали в приложении с рецептами, обычно пред-
почтительнее заняться данным вопросом до разработки приложения.
В следующей главе мы рассмотрим наше приложение ASP .NET Core
с другой точки зрения. Вместо того чтобы сосредоточиться на коде и ло-
гике приложения, мы рассмотрим, как подготовить его к промышленной Загружает ресурс Recipe
для использования
с IAuthorizationService.
Проверяет, имеет ли
пользователь право
редактировать рецепт.
Задает свойство CanEditRecipe модели
PageModel соответствующим образом.

588 Глава 15 Авторизация: обеспечиваем защиту приложения
эксплуатации. Вы увидите, как указать URL-адреса, которые использует
приложение, и как опубликовать его, чтобы можно было разместить его
в IIS. Наконец, вы узнаете об упаковке и минификации кода при работе
с клиентскими ресурсами, для чего это нужно и как использовать рас -
ширение BundlerMinifier в ASP .NET Core.
Резюме
Аутентификация – это процесс определения пользователя. Он отлича-
ется от авторизации, когда вы определяете, что может делать пользо-
ватель. Обычно аутентификация происходит до авторизации.
Вы можете использовать сервисы авторизации в любой части своего
приложения, но обычно применяется компонент AuthorizationMid-
dleware путем вызова метода UseAuthorization(). Для правильной ра-
боты его следует размещать после вызова методов UseRouting() и Use-
Authentication() и перед вызовом метода UseEndpoints().
Вы можете защитить страницы Razor Pages и действия MVC, применив
атрибут [Authorize]. Компонент маршрутизации записывает присут -
ствие атрибута в качестве метаданных с выбранной конечной точкой.
Компонент авторизации использует эти метаданные, чтобы опреде-
лить, как авторизовать запрос.
Самая простая форма авторизации требует, чтобы пользователь про-
шел аутентификацию до того, как выполнит действие. Для этого мож -
но применить атрибут [Authorize] на странице Razor к  действию,
контроллеру или глобально. Вы также можете применять атрибуты
обычным образом к подмножеству страниц Razor Pages.
Авторизация на основе утверждений использует утверждения теку -
щего пользователя, чтобы определить, имеет ли он право выполнить
действие. Утверждения, необходимые для выполнения действия,
определяются в политике.
У политик есть имена. Они настраиваются в файле Startup.cs как часть
вызова метода AddAuthorization() в методе ConfigureServices. Поли-
тика определяется с  по мощью метода AddPolicy(), путем передачи
имени и лямбда-функции, определяющей необходимые утверждения.
Можно применить политику к действию или странице Razor, указав
политику в  атрибуте [Authorize], например [Authorize ("CanAccess-
Lounge")]. Эта политика будет использоваться AuthorizationMiddle-
ware, чтобы определить, позволено ли пользователю выполнить вы-
бранную конечную точку.
В приложении Razor Pages, если не прошедший аутентификацию
пользователь пытается выполнить защищенное действие, он будет
перенаправлен на страницу входа. Если он уже прошел аутентифика-
цию, но у него нет необходимых утверждений, то он увидит страницу
с надписью «Отказано в доступе».
Для сложных политик авторизации можно создать специальную по-
литику. Такая политика состоит из одного или нескольких требований,

589 Резюме
а у требования может быть один или несколько обработчиков. Можно
сочетать требования и обработчики для создания политик произволь-
ной сложности.
Чтобы политика была авторизована, необходимо отвечать всем требо-
ваниям. Для этого один или несколько ассоциированных обработчи-
ков должны указывать на успех, и ни один из них не должен указывать
на явный сбой.
AuthorizationHandler<T> содержит логику, определяющую, удовлетво-
рено ли требование. Например, если требуется, чтобы пользователи
были старше 18 лет, обработчик может найти утверждение DateOf-
Birth и вычислить возраст пользователя.
Обработчики могут пометить требование как удовлетворенное, вы-
звав метод context.Succeed(requirement). Если обработчик не может
удовлетворить требование, он не должен ничего вызывать в контек -
сте, поскольку другой обработчик может вызвать метод Succeed()
и удовлетворить требование.
Если обработчик вызывает метод context.Fail(), требование не вы-
полняется, даже если другой обработчик пометил его как успешное
с по мощью метода Succeed(). Используйте этот метод, только если хо-
тите переопределить все вызовы Succeed() от других обработчиков,
чтобы гарантировать, что политика не пройдет авторизацию.
Авторизация на основе ресурсов использует сведения о защищаемом
ресурсе, чтобы определить, авторизован ли текущий пользователь.
Например, если пользователю разрешено редактировать только соб-
ственные документы, необходимо знать автора документа, прежде
чем вы сможете определить, авторизован ли он.
Авторизация на основе ресурсов использует ту же политику, требо-
вания и  обработчиков, что и  раньше. Вместо того чтобы применять
авторизацию с  атрибутом [Authorize], вы должны вручную вызвать
IAuthorizationService и предоставить ресурс, который вы защищаете.
Вы можете изменить пользовательский интерфейс для учета прав
пользователя, добавив дополнительные свойства в  PageModel. Если
пользователь не авторизован для выполнения действия, вы можете
удалить или отключить ссылку на этот метод действия в  пользова-
тельском интерфейсе. Всегда следует проходить авторизацию на сер-
вере, даже если вы удалили ссылки из пользовательского интерфейса.

16Публикация
и развертывание
приложения
В этой главе:
публикация приложения ASP.NET Core;
размещение приложения ASP.NET Core в IIS;
настройка URL-адресов для приложения ASP.NET Core;
оптимизация ресурсов на стороне клиента с по мощью
упаковки и минификации кода.
В этой книге мы рассмотрели очень много вопросов. Мы рассмотрели
базовые механизмы создания приложения ASP .NET Core, такие как на-
стройка внедрения зависимостей, загрузка настроек приложения и соз-
дание конвейера промежуточного ПО. Мы рассмотрели пользователь-
ский интерфейс, используя шаблоны и макеты Razor для формирования
HTML-ответа и  абстракции более высокого уровня, такие как EF Core
и ASP .NET Core Identity, позволяющие взаимодействовать с базой дан-
ных и добавлять пользователей в приложение. В этой главе мы пойдем
немного другим путем. Вместо того чтобы искать способы создания
больших и лучших приложений, мы сосредоточимся на том, что значит
развертывание приложения, чтобы пользователи могли получить к нему
доступ.
Мы начнем с  рассмотрения модели хостинга ASP .NET Core в  разде-
ле 16.1 и выясним, почему лучше размещать свое приложение за обрат -

591 Публикация и развертывание приложения
ным прокси-сервером, вместо того чтобы предоставлять к нему доступ
напрямую из интернета. Я покажу вам разницу между запуском прило-
жения ASP .NET Core в окружении разработки с использованием команды
dotnet run и публикацией приложения для использования на удаленном
сервере. Наконец, я опишу некоторые варианты развертывания, которые
можно использовать, при принятии решения о том, как и где развернуть
приложение.
В разделе 16.2 я покажу вам, как развернуть приложение с использо-
ванием одного из вариантов: сервера Windows под управлением IIS (In-
ternet Information Services). Это типичный сценарий развертывания для
многих разработчиков, уже знакомых с ASP .NET, поэтому он послужит
полезным примером, но, конечно же, это не единственная возможность.
Я не буду вдаваться во все технические подробности конфигурирования
системы IIS, но предоставлю вам минимум информации, необходимой
для запуска. Если вы специализируетесь на кросс-платформенной раз-
работке, не волнуйтесь, я не буду слишком углубляться в IIS.
В разделе 16.3 я расскажу о хостинге в Linux. Вы увидите, чем он от -
личается от хостинга приложений в Windows, узнаете, какие измене-
ния необходимо внести в свои приложения, и познакомитесь с подвод-
ными камнями, на которые следует обратить внимание. Я опишу, чем
обратные прокси-серверы в Linux отличаются от IIS, и приведу ссылки
на ресурсы, которые можно использовать для настройки своего окру -
жения, вместо того чтобы давать исчерпывающие инструкции в этой
книге.
Если вы не размещаете свое приложение с по мощью IIS, вам, вероят -
но, потребуется задать URL-адрес, который использует ваше приложение
ASP .NET Core при развертывании. В разделе 16.4 я покажу два способа
сделать это: с  по мощью специальной переменной окружения ASPNET-
CORE_URLS и используя аргументы командной строки. Хотя, как правило,
это не является проблемой во время разработки, установка правильных
URL-адресов для приложения имеет решающее значение при разверты-
вании.
В последнем разделе этой главы мы рассмотрим типовой шаг оптими-
зации, используемый при развертывании приложения. Упаковка и ми-
нификация кода используются для уменьшения количества и  размера
запросов, которые браузеры должны направить вашему приложению
для полной загрузки страницы. Я покажу вам, как использовать простой
инструмент для создания пакетов при построении приложения и  как
условно загрузить их в промышленном окружении, чтобы оптимизиро-
вать размер страниц приложения.
В этой главе рассматривается относительно широкий круг тем, свя-
занных с развертыванием приложения. Но, прежде чем перейти к дета-
лям, я  рассмотрю модель хостинга для ASP .NET.Core, раз уж мы здесь.
Она существенно отличается от модели хостинга предыдущей версии
ASP .NET, поэтому, если вы ориентируетесь на эти знания, лучше попы-
таться забыть то, что вы знаете!

592 Глава 16 Публикация и развертывание приложения
16.1 Модель хостинга ASP.NET Core
Если вернуться к первой главе, то вы, наверное, помните, что мы обсуж -
дали модель хостинга ASP .NET Core. Приложения ASP .NET Core, по сути,
консольные. В них есть функция static void Main, служащая точкой входа
для приложения, как стандартное консольное приложение .NET.
Что делает приложение приложением ASP .NET Core, так это то, что
оно работает на веб-сервере, обычно Kestrel, внутри процесса консоль-
ного приложения. Kestrel предоставляет функциональность HTTP , чтобы
получать запросы и возвращать ответы клиентам. Kestrel передает все
полученные запросы в код вашего приложения, чтобы сгенерировать от -
вет, как показано на рис. 16.1.
Запрос Ответ
Обратный прокси-сервер
(IIS/NGINX/Apache)
Веб-сервер ASP Net Core
(Kestrel)
Инфраструктура ASP NET Core
и логика приложения
Приложение ASP.Net Core1.  HTTP-запрос отправляется на сервер
и принимается обратным прокси-сервером
2.  Запрос перенаправляется IIS/NGINX/Apache
в ASP .NET Core
3.  Веб-сервер ASP .NET Core получает
HTTP-запрос и передает его
промежуточному ПО
4.  Запрос обрабатывается приложением,
которое генерирует ответ5.  Ответ проходит через
промежуточное ПО обратно
на веб-сервер6.  Веб-сервер пересылает ответ
на обратный прокси-сервер7.  HTTP-ответ отправляется
в браузер
Рис. 16.1 Модель хостинга ASP.NET Core. Запросы принимаются обратным прокси-сервером
и перенаправляются на веб-сервер Kestrel. Одно и то же приложение может работать
за разными обратными прокси-серверами без изменений
Такая модель хостинга отделяет сервер и обратный прокси от само-
го приложения, чтобы одно и то же приложение могло без изменений
в коде работать в нескольких окружениях.

593 Модель хостинга ASP.NET Core
В этой книге мы сосредоточились на нижней половине рис. 16.1 – са-
мом приложении ASP .NET.Core, но на самом деле вам часто придется
размещать свое приложение за обратным прокси-сервером, например
IIS в Windows или NGINX или Apache в Linux. Обратный	 прокси-сервер –
это программа, которая слушает HTTP-запросы из интернета, а затем от -
правляет запросы в ваше приложение, как если бы запрос шел напрямую
из интернета.
ОПРЕДЕЛЕНИЕ  Обратный	 прокси-сервер  – это программное
обес печение, отвечающее за получение запросов и их пересылку
на соответствующий веб-сервер с приложением. Обратный прок -
си-сервер доступен непосредственно из сети интернет, тогда как
основной веб-сервер доступен только для прокси.
Если вы запускаете свое приложение с по мощью модели «Платформа
как услуга» (PaaS), например Azure App Service, вы также используете об-
ратный прокси-сервер, которым управляет Azure. Использование обрат -
ного прокси-сервера имеет много преимуществ:
безопасность – обратные прокси-серверы специально разработаны
для защиты от вредоносного интернет-трафика, поэтому они, как
правило, хорошо протестированы;
производительность – можно настроить обратные прокси-серверы
для повышения производительности путем агрессивного кеширо-
вания ответов на запросы;
управление	 процессами  – к  сожалению, приложения иногда дают
сбой. Некоторые обратные прокси-серверы могут работать как мо-
ниторы или планировщики, чтобы гарантировать, что в случае сбоя
приложения прокси-сервер сможет автоматически перезапустить
его;
поддержка	 нескольких	 приложений – обычно на одном сервере рабо-
тают несколько приложений. Использование обратного прокси-сер-
вера упрощает поддержку такого сценария с по мощью имени хоста
запроса, чтобы решить, какое приложение должно получить запрос.
Я не хочу, чтобы казалось, будто когда вы используете обратный прок -
си-сервер, то все солнечно и радужно. Здесь есть и свои недостатки:
сложность – одна из самых больших жалоб заключается в том, на-
сколько сложными могут быть обратные прокси-серверы. Если вы
сами управляете прокси (вместо того чтобы полагаться на реализа-
цию PaaS), то может возникнуть множество ошибок;
межпроцессное	 взаимодействие – для большинства обратных прок -
си-серверов требуются два процесса: обратный прокси и ваше веб-
приложение. Обмен данными между ними часто происходит мед-
леннее, чем если бы вы напрямую предоставили доступ к  своему
веб-приложению для запросов из интернета;
ограниченные	 функции – не все обратные прокси-серверы поддер-
живают те же функции, что и приложение ASP .NET Core. Например,

594 Глава 16 Публикация и развертывание приложения
Kestrel поддерживает протокол HTTP/2, но если ваш обратный прок -
си-сервер не поддерживает его, то преимуществ вы не увидите.
Независимо от того, решите вы использовать обратный прокси-сервер
или нет, когда приходит время разместить свое приложение, вы не мо-
жете копировать файлы кода прямо на сервер. Сначала нужно опублико-
вать приложение, чтобы оптимизировать его для промышленного окру -
жения. В разделе 16.1.1 мы сравним создание приложения ASP .NET Core
для машины разработчика с публикацией, необходимой для запуска на
сервере.
16.1.1 Запуск и публикация приложения ASP.NET Core
Одно из ключевых изменений в ASP .NET Core по сравнению с предыду -
щими версиями ASP .NET состоит в том, что теперь вам проще создавать
приложения с по мощью своих любимых редакторов кода и интегриро-
ванной среды разработки. Ранее для разработки ASP .NET требовалась
Visual Studio, но сейчас, используя интерфейс командной строки .NET
и плагин OmniSharp, можно создавать приложения с по мощью удобных
инструментов на любой платформе.
В результате, независимо от того, используете вы Visual Studio или ин-
терфейс командной строки .NET, под капотом используются одни и те
же инструменты. Visual Studio предоставляет дополнительный графи-
ческий интерфейс, функциональность и оболочки для создания вашего
приложения, но выполняет те же команды, что и интерфейс командной
строки .NET за кулисами.
Напомню, что пока вы использовали четыре основные команды .NET
CLI для создания своих приложений:
dotnet new – создает приложение ASP .NET Core из шаблона;
dotnet restore – скачивает и устанавливает все указанные пакеты
NuGet для вашего проекта;
dotnet build – компилирует и собирает проект;
dotnet run – запускает ваше приложение, чтобы вы могли отправ-
лять ему запросы.
Если вы когда-либо создавали приложение .NET, будь то приложение
ASP .NET или консольное приложение .NET Framework, то знаете, что ре-
зультат процесса сборки записывается в папку bin. То же самое проис -
ходит и в случае с приложениями ASP .NET Core.
Если ваш проект успешно компилируется при вызове команды dotnet
build, .NET CLI запишет его вывод в папку bin в каталоге вашего проек -
та. Внутри этой папки есть несколько файлов, необходимых для запуска
вашего приложения, включая файл с расширением .dll, содержащий код
приложения. На рис. 16.2 показана часть папки bin для приложения ASP .
NET. Core.

595 Модель хостинга ASP.NET Core
Папка bin содержит
скомпилированное приложение
Код вашего приложения
компилируется в один файл
с расширением .dll, в данном
случае ExampleApp.dllДля запуска приложения
с использованием команды dotnet
run требуются дополнительные
файлы
Рис. 16.2 Папка bin для приложения ASP.NET Core после запуска команды dotnet
build. Приложение скомпилировано в один файл с расширением .dll, ExampleApp.dll
ПРИМЕЧАНИЕ  В Windows у вас также будет исполняемый файл
с расширением .exe, ExampleApp.exe. Это простой файл-оболочка,
который упрощает запуск приложения, содержащегося в файле Ex -
ampleApp.dll.
Когда вы вызываете команду dotnet run в папке проекта (или запускае-
те приложение с по мощью Visual Studio), интерфейс командной строки
.NET использует файл с расширением .dll для запуска приложения. Но он
не содержит всей информации, необходимой для развертывания.
Чтобы разместить и развернуть приложение на сервере, сначала необ-
ходимо его опубликовать. Это можно сделать из командной строки с по-
мощью команды dotnet publish. Она собирает и  упаковывает все, что
нужно вашему приложению для запуска. Команда упаковывает прило-
жение из текущего каталога и собирает его во вложенную папку publish.
Я  использовал конфигурацию Release вместо конфигурации Debug по
умолчанию, поэтому вывод будет полностью оптимизирован для запус -
ка в промышленном окружении:
dotnet publish --output publish --configuration Release
СОВЕТ  Всегда используйте конфигурацию release при публика-
ции приложения для развертывания. Это гарантирует, что компи-
лятор сгенерирует оптимизированный код.
После завершения команды вы найдете опубликованное приложение
в папке publish, как показано на рис. 16.3.
Как видите, файл ExampleApp.dll все еще здесь, наряду с некоторыми
дополнительными файлами. В частности, процесс публикации скопиро-
вал папку статических файлов wwwroot. При локальном запуске ваше-
го приложения с  по мощью команды dotnet run интерфейс командной
строки .NET использует эти файлы напрямую из папки проекта вашего
приложения. При запуске команды dotnet publish файлы копируются
в выходной каталог, чтобы они были включены при развертывании при-
ложения на сервере.

596 Глава 16 Публикация и развертывание приложения
Опубликованный вывод включает
в себя дополнительные файлы
по сравнению с папкой bin
Т е же файлы из папки bin также
копируются в папку publishКод вашего приложения
по-прежнему скомпилирован
в ExampleApp.dll
Папка wwwroot копируется
в папку publish
В процессе публикации
добавляется файл web.config,
чтобы упростить хостинг в IIS
Рис. 16.3 Папка publish для приложения после запуска команды dotnet publish.
Приложение по-прежнему компилируется в один файл с расширением .dll, но все
дополнительные файлы, такие как wwwroot и appsettings.json, также копируются
в целевую папку
Если первое, о чем вы инстинктивно подумали, – попробовать запус -
тить приложение в папке publish, используя команду dotnet run, кото -
рую вы уже знаете и любите, то вас ждет разочарование. Вместо запуска
приложения вы увидите сбивающее с толку сообщение: Couldn’t find a
project to run (Не удалось найти проект для запуска).
Чтобы запустить опубликованное приложение, нужно использовать
другую команду. Вместо вызова команды dotnet run вы должны вызвать
команду dotnet с  путем к  DLL-файлу приложения. Если вы запускаете
команду из папки publish, то для примера приложения на рис. 16.3 это
будет выглядеть примерно так:
dotnet ExampleApp.dll
Это команда, которую ваш сервер будет выполнять при запуске при-
ложения в промышленном окружении.
Во время разработки команда dotnet run выполняет всю работу, что-
бы облегчить вам задачу: она проверяет, создано ли приложение, ищет
файл проекта в текущей папке, выясняет, где будут находиться соответ -
ствующие файлы с расширением .dll (в папке bin), и, наконец, запускает
приложение.
В промышленном окружении вся эта дополнительная работа вам
не нужна. Ваше приложение уже собрано, нужно только запустить его.
Коман да dotnet <dll> делает только это, поэтому приложение запускает -
ся намного быстрее.
ПРИМЕЧАНИЕ  Команда dotnet, используемая для запуска опуб-
ликованного приложения, является частью среды выполнения
.NET, тогда как команда dotnet, используемая для сборки и  за-
пуска вашего приложения во время разработки, является частью
# .NET SDK.

597 Модель хостинга ASP.NET Core
Развертывания, зависящие от платформы,
и автономные развертывания
Приложения .NET Core можно развертывать двумя способами: это развер-
тывания, зависящие от времени выполнения (RDD), и автономные развер-
тывания (SCD).
В большинстве случаев вы будете использовать RDD. Оно зависит от среды
выполнения .NET 5.0, устанавливаемой на целевой машине, на которой за-
пущено ваше опубликованное приложение, но вы можете запускать его на
любой платформе – Windows, Linux или macOS – без необходимости по-
вторной компиляции.
Напротив, SCD содержит весь код, необходимый для запуска вашего при-
ложения, поэтому на целевой машине не обязательно должна быть установ-
лена .NET 5.0. Вместо этого при публикации вашего приложения среда вы-
полнения .NET 5.0 будет упакована с кодом и библиотеками приложения.
У каждого подхода есть свои плюсы и минусы, но в большинстве случаев
я отдаю предпочтение RDD. Окончательный размер RDD намного меньше,
поскольку файлы в этом случае содержат только код приложения, а не всю
платформу .NET 5.0, как в SCD. Кроме того, вы можете развернуть свои RDD-
приложения на любой платформе, тогда как SCD-приложения должны быть
скомпилированы специально для операционной системы целевой машины,
например 64-разрядной Windows 10 или 64-разрядной Red Hat Enterprise
Linux.
Тем не менее SCD отлично подходит для изоляции вашего приложения от
зависимостей на машине, используемой для хостинга. SCD не зависит от вер-
сии .NET, установленной у провайдера хостинга, поэтому можно, например,
использовать предварительные версии .NET в Azure App Service, даже если
там эти версии не поддерживаются.
В этой книге я обсуждаю RDD только для простоты, но если вы хотите создать
SCD, просто укажите идентификатор среды выполнения при публикации,
в данном случае 64-разрядную версию Windows 10:
dotnet publish -c Release -r win10-x64 -o publish_folder
Вывод будет содержать файл с расширением .exe, который является вашим
приложением, и  огромное количество файлов платформы .NET 5.0 с расши-
рением .dll (около 65 МБ, если говорить о приложении, используемом в ка-
честве примера). Вам нужно развернуть всю эту папку на целевой машине
для запуска своего приложения. В .NET 5.0 можно уменьшить некоторые из
этих сборок в процессе публикации, но в некоторых сценариях это сопряже-
но с рисками. Дополнительные сведения см. в документе Microsoft «Обзор
публикации приложений .NET Core» по адресу https://docs.microsoft.com/
dotnet/core/deploying/.

598 Глава 16 Публикация и развертывание приложения
Мы пришли к тому, что публикация приложения важна для его под-
готовки к запуску в промышленном окружении, но как его развернуть?
Как отправить файлы со своего компьютера на сервер, чтобы пользова-
тели могли получить доступ к вашему приложению? Для этого есть очень
много вариантов, поэтому в следующем разделе я приведу краткий спи-
сок подходов, которые следует рассмотреть.
16.1.2 Выбор метода развертывания для вашего приложения
Для развертывания любого приложения в  промышленном окружении
обычно есть два основных требования:
сервер, на котором можно запускать приложение;
средство загрузки приложения на сервер.
Поначалу развертывание приложения в  промышленном окружении
представляло собой трудоемкий и  подверженный ошибкам процесс,
и для многих такая ситуация по-прежнему актуальна. Если вы работае-
те в  компании, которая не меняла практики в течение последних лет,
то вам может потребоваться запросить сервер или виртуальную машину
для своего приложения и предоставить его команде эксплуатации, кото-
рая подготовит его за вас. В этом случае у вас могут быть связаны руки
и некоторые сценарии будут для вас недоступны.
Для тех, кто выбрал непрерывную интеграцию (CI) или непрерывную
доставку/развертывание (CD), есть еще больше возможностей. CI/CD –
это процесс обнаружения изменений в вашей системе управления вер-
сиями (например, Git, SVN, Mercurial, Team Foundation Version Control)
и автоматическая сборка и потенциальное развертывание приложения
на сервере практически без вмешательства человека1.
Можно найти много разных систем непрерывной интеграции или не-
прерывного развертывания: Azure DevOps, GitHub Actions, Jenkins, Team-
City, AppVeyor, Travis и Octopus Deploy, и это лишь малая часть. Каждая из
них может управлять некоторыми или всеми процессами CI/CD и может
быть интегрирована со многими другими системами.
Вместо того чтобы рекомендовать какую-либо конкретную систему,
я предлагаю опробовать некоторые из доступных сервисов и посмотреть,
какой из них лучше всего вам подходит. Некоторые лучше подходят для
проектов с открытым исходным кодом, другие – для развертывания в об-
лачных сервисах – все зависит от конкретной ситуации.
Если вы только начинаете работать с ASP .NET Core и не хотите про-
ходить через процесс настройки непрерывной интеграции, у вас все еще
остается много вариантов. Самый простой способ – использовать встро-
енные параметры развертывания Visual Studio. Они доступны в Visual
Studio через пункт меню Build> Publish AppName, который представля-
ет собой форму, показанную на рис. 16.4.
1 Между этими терминами есть тонкие, но важные отличия. У Atlassian есть хо-
рошая сравнительная статья «Непрерывная интеграция, непрерывная достав-
ка и непрерывное развертывание»: http://mng.bz/vzp4.

599 Модель хостинга ASP.NET Core
Рис. 16.4 Экран публикации приложения в Visual Studio 2019. Здесь представлены простые
варианты публикации приложения напрямую в Azure App Service, IIS, на FTP-сайт или в папку
на локальном компьютере
Здесь вы можете публиковать свое приложение прямо из Visual Studio
в разные места1. Все это замечательно, но я рекомендую присмотреться
к  более автоматизированному и  контролируемому подходу для круп-
ных приложений, или когда над одним приложением работает целая
команда.
Учитывая количество доступных возможностей и скорость, с которой
эти варианты меняются, в этой главе я сосредоточусь на одном конкрет -
ном сценарии: вы создали приложение ASP .NET Core, и вам нужно его
развернуть. У вас есть доступ к серверу Windows, который уже обслужи-
вает (предыдущая версия) приложения ASP .NET с по мощью IIS, и вы хо-
тите запускать приложение ASP .NET Core наряду с ними.
В следующем разделе вы увидите обзор шагов, необходимых для за-
пуска приложения ASP .NET. Core в промышленном окружении, исполь-
зуя IIS в качестве обратного прокси-сервера. Это не мастер-класс по на-
стройке IIS (в этом продукте, появившемся 20 лет назад, так много всего,
что я бы просто не знал, с чего начать!), но я расскажу об основах, необ-
ходимых для того, чтобы ваше приложение обслуживало запросы.
1 Инструкции по выбору параметров публикации Visual Studio см. в документе
Microsoft: http://mng.bz/4Z8j.

600 Глава 16 Публикация и развертывание приложения
16.2 Публикация приложения в IIS
В этом разделе я вкратце покажу, как опубликовать свое первое прило-
жение на IIS. Вы добавите пул приложений и веб-сайт в IIS и убедитесь,
что ваше приложение имеет необходимую конфигурацию для работы
с  IIS в  качестве обратного прокси-сервера. Само развертывание будет
таким же простым, как и  копирование опубликованного приложения
в папку хостинга IIS.
В разделе 16.1 вы узнали о необходимости публикации приложения
перед развертыванием и  преимуществах использования обратного
прокси-сервера при запуске приложения ASP .NET Core в  промышлен-
ном окружении. Если вы разворачиваете свое приложение в Windows, IIS
будет вашим обратным прокси-сервером и будет отвечать за управление
приложением.
IIS – старая и сложная штука, и я не могу охватить в этой книге все, что
связано с его настройкой. Да вы бы и не хотели, чтобы я это сделал, – это
было бы очень скучно! Вместо этого в этом разделе я предоставлю обзор
основных требований для запуска ASP .NET Core за IIS, наряду с измене-
ниями, которые вам, возможно, потребуется внести в свое приложение
для поддержки IIS.
Если вы работаете в Windows и хотите опробовать эти шаги локально,
вам придется вручную включить IIS на машине, используемой для раз-
работки. Если вы делали это в более старых версиях Windows, то ничего
особо не изменилось. Пошаговое руководство по настройке IIS и советы
по устранению неполадок можно найти в документации по ASP .NET Core
на странице http://mng.bz/6g2R.
16.2.1 Конфигурирование IIS для ASP.NET Core
Первым шагом в подготовке IIS для размещения приложений ASP .NET
Core является установка пакета ASP .NET Core Windows Hosting Bundle1.
Он включает в себя несколько компонентов, необходимых для запуска
приложений .NET:
среда	выполнения	 .NET – запускает приложение .NET 5.0;
среда	выполнения	 ASP.NET	 Core – требуется для запуска приложений
ASP .NET Core;
модуль	IIS	AspNetCore – обеспечивает связь между IIS и вашим при-
ложением, чтобы IIS мог работать как обратный прокси-сервер.
Если вы собираетесь запускать IIS на машине для разработки, убеди-
тесь, что вы установили пакет, иначе будете получать странные ошибки
от IIS.
СОВЕТ  Пакет Windows Hosting Bundle предоставляет все необхо-
димое для работы ASP .NET Core за IIS в Windows. Если вы разме-
1 Его можно скачать на странице http://mng.bz/opED .

601 Публикация приложения в IIS
щаете свое приложение на Linux или Mac или не используете IIS
в  Windows, вам необходимо установить .NET Runtime и  ASP .NET
Core Runtime для запуска приложений ASP .NET Core.
После установки пакета вам необходимо настроить пул	приложений
в IIS для приложений ASP .NET Core. Предыдущие версии ASP .NET рабо-
тали в управляемом пуле приложений, который использовал .NET Frame-
work, но для ASP .NET Core нужно создать неуправляемый	 (No	Managed
Code) пул. Модуль ASP .NET Core запускается внутри пула, который загру -
жает саму среду выполнения .NET 5.0.
ОПРЕДЕЛЕНИЕ  Пул	приложений в IIS представляет собой процесс
приложения. Вы можете запускать каждое приложение в IIS в от -
дельном пуле приложений, чтобы изолировать их друг от друга.
Чтобы создать неуправляемый пул приложений, щелкните правой
кнопкой мыши Application Pools (Пулы приложений) в IIS и выберите
Add Application Pool (Добавить пул приложений). В появившемся диа-
логовом окне укажите имя для пула приложений, например NetCore,
и выберите в поле .NET CLR version значение No Managed Code, как
показано на рис. 16.5.
Задайте для версии среды .NET CLR
значение No Managed Code
(Без управляемого кода)Введите имя для пула приложений
Оставьте режим конвейера
как Integrated (Интегрированный)
Рис. 16.5 Создание пула приложений в IIS для вашего приложения. В поле .NET CLR
version должно быть выбрано значение No Managed Code
Теперь, когда у  вас есть пул приложений, можно добавить новый
веб-сайт в  IIS. Щелкните правой кнопкой мыши по узлу Сайты и  вы-
берите Add Website (Добавить веб-сайт). В диалоговом окне «Добавить
веб-сайт», показанном на рис. 16.6, вы указываете имя веб-сайта и путь
к папке, в которой будете публиковать свой сайт. Я создал папку, которую
буду использовать для развертывания приложения Recipe из предыду -
щих глав. Важно изменить пул приложений на новый созданный вами
пул приложений NetCore. В  промышленном окружении также нужно
указать имя хоста для приложения, но я пока оставил его пустым и из-
менил порт на 81, поэтому приложение будет привязано к URL-адресу
http:/ /localhost: 81.
ПРИМЕЧАНИЕ  При развертывании приложения в  промышлен-
ном окружении необходимо зарегистрировать имя хоста у регист -

602 Глава 16 Публикация и развертывание приложения
ратора домена, чтобы ваш сайт был доступен для пользователей
в интернете. Используйте это имя хоста при настройке приложе-
ния в IIS, как показано на рис. 16.6.
Введите путь к папке,
в которой вы публикуете
свое приложениеИзмените пул приложений
на пул No Managed Code
В промышленном окружении
вы, скорее всего, оставите
здесь порт 80 и должны будете
ввести имя хоста
Рис. 16.6 Добавление нового веб-сайта в IIS для своего приложения. Обязательно
смените значение Application Pool на No Managed Code pool, созданный на
предыдущем этапе. Также укажите имя, путь, по которому вы будете публиковать
файлы приложения, и URL-адрес, который IIS будет использовать для вашего
приложения
После того как вы нажмете ОК, IIS создаст приложение и попытается
запустить его. Но вы не опубликовали приложение в папке, поэтому пока
не можете открыть его в браузере.
Прежде чем вы сможете опубликовать и запустить приложение, необ-
ходимо выполнить еще один важный шаг настройки: вы должны предо-
ставить разрешения для пула приложений NetCore, чтобы получить до-
ступ к папке опубликованного приложения. Для этого щелкните правой
кнопкой мыши по папке, в которой будет размещено приложение в про-
воднике Windows, и выберите Properties (Свойства). В диалоговом окне
Properties выберите Security > Edit > Add (Безопасность > Изменить >
Добавить). Введите в текстовое поле IIS AppPool\NetCore, как показано
на рис. 16.7, где NetCore – это имя вашего пула приложений, и нажмите
OK. Закройте все диалоговые окна, нажав кнопку ОК. Все готово.
Введите IIS AppPool, а затем имя
пула приложений No Managed,
например IIS AppPool\NetCore
Нажмите ОК, чтобы
добавить разрешения
Рис. 16.7  Добавление разрешений для пула приложений NetCore в папку
публикации веб-сайта

603 Публикация приложения в IIS
По умолчанию шаблоны ASP .NET Core настроены для бесперебойной
работы с IIS, но если вы создавали приложение с нуля, то вам может по-
требоваться внести парочку изменений. В следующем разделе я вкрат -
це покажу изменения, которые нужно внести, и  объясню, зачем они
нужны.
16.2.2 Подготовка и публикация приложения в IIS
Как мы обсуждали в  разделе 16.1, IIS действует как обратный прок -
си-сервер для вашего приложения ASP .NET Core. Это означает, что IIS
должен иметь возможность напрямую обмениваться данными с вашим
приложением для пересылки входящих запросов и исходящих ответов
из вашего приложения.
IIS использует для этой цели модуль ASP .NET Core, но между IIS и ва-
шим приложением требуется определенная степень согласования. Чтобы
все работало правильно, необходимо настроить приложение для исполь-
зования интеграции с IIS.
Интеграция с  IIS добавляется по умолчанию при применении вспо-
могательного метода IHostBuilder.ConfigureWebHostDefaults(), исполь-
зуемого в шаблонах по умолчанию. Если вы настраиваете собственный
HostBuilder, то необходимо убедиться, что вы добавили интеграцию с IIS
с методами расширения UseIIS() или UseIISIntegration().
Листинг 16.1 Добавляем интеграцию с IIS
public class Program
{
public static void Main(string[] args)
{
CreateHostBuilder(args).Build().Run();
}
public static IHostBuilder CreateHostBuilder(string[] args) =>
Host.CreateDefaultBuilder(args)
.ConfigureWebHost(webBuilder =>
{
webBuilder.UseKestrel();
webBuilder.UseStartup<Startup>();
webBuilder.UseIIS();
webBuilder.UseIISIntegration();
});
}
ПРИМЕЧАНИЕ  Если вы не используете свое приложение с  IIS,
методы UseIIS() и  UseIISIntegration() не повлияют на него, по-
этому можно все равно включить их и ничего не опасаться. Применение специального
построителя вместо конфигурации по
умолчанию ConfigureWebHostDefaults,
используемой в шаблонах.
Настраивает
приложение для
работы в IIS с моделью
внутрипроцессного
хостинга.Настраивает приложение
для использования
с IIS с внепроцессной
моделью хостинга.

604 Глава 16 Публикация и развертывание приложения
Внутрипроцессный и внепроцессный хостинг в IIS
Описание обратного прокси-сервера, которое я дал в разделе 16.1, предпо-
лагает, что ваше приложение выполняется в отдельном процессе. Это каса-
ется ситуации, если вы работаете в Linux и вплоть до выхода ASP.NET Core
версии 3.0. для IIS это был вариант по умолчанию.
В ASP.NET Core версии 3.0 ASP.NET Core перешел на использование мо-
дели внутрипроцессного хостинга по умолчанию для приложений, раз-
вернутых в IIS. В этой модели IIS размещает ваше приложение напрямую
в процессе IIS, уменьшая межпроцессное взаимодействие и повышая про-
изводительность.
Вы можете переключиться на модель внепроцессного хостинга с IIS, если
хотите, что иногда может быть полезно для устранения неполадок. У Рика
Штраля есть отличный пост, посвященный различиям между моделями хос -
тинга. В нем рассказывается о том, как переключаться между ними, и о пре-
имуществах каждой из этих моделей: http://mng.bz/QmEv.
В целом не нужно беспокоиться о различиях между моделями хостинга, но
о них нужно знать, если вы развертываете приложение в IIS. Если вы реши-
те использовать внепроцессную модель хостинга, то следует использовать
метод расширения UseIISIntegration(). Если вы используете внутрипро-
цессную модель, используйте метод UseIIS(). В качестве альтернативы мож -
но перестраховаться и задействовать оба – правильный метод расширения
будет активирован в зависимости от модели хостинга, используемой в про-
мышленном окружении. Если вы не используете IIS, то эти методы ничего
делать не будут.
При запуске приложения за IIS эти методы расширения настраивают
ваше приложение для сопряжения с  IIS, чтобы оно могло беспрепят -
ственно принимать запросы. Помимо прочего, эти методы делают сле-
дующее:
определяют URL-адрес, который IIS будет использовать для пере-
сылки запросов в ваше приложение, и настраивают его на прослу -
шивание на этом URL-адресе;
настраивают приложение для интерпретации запросов, поступаю-
щих от IIS, как идущих от клиента, настроив пересылку заголовков;
активируют аутентификацию Windows, если требуется.
Добавление этих методов расширения – единственное изменение, ко-
торое нужно внести в  приложение, чтобы иметь возможность размес -
тить его в IIS, но есть еще один аспект, о котором нужно знать, когда вы
публикуете свое приложение.
Как и в предыдущих версиях ASP .NET, IIS использует файл web.config
для настройки приложений, которые он запускает. Важно, чтобы прило-
жение содержало этот файл, когда оно публикуется на IIS; в противном

605 Публикация приложения в IIS
случае вы можете нарушить поведение или даже предоставить доступ
к закрытым файлам1.
Если ваш проект ASP .NET Core уже включает в себя файл web.config,
.NET CLI или Visual Studio скопирует его в каталог публикации при пуб-
ликации приложения. В противном случае команда publish создаст его
за вас. Если вам не нужно настраивать этот файл, лучше не включать его
в свой проект и позволить интерфейсу командной строки создать его
за вас.
После этих изменений вы, наконец, можете опубликовать свое при-
ложение в IIS. Опубликуйте его в папку либо из Visual Studio, либо с по-
мощью интерфейса командной строки .NET:
dotnet publish --output publish_folder --configuration Release
Так вы опубликуете свое приложение в папке publish_folder. Затем вы
можете скопировать его в путь, указанный в IIS, как показано на рис. 16.6.
На данный момент, если все прошло гладко, вы можете перейти по URL-
адресу, указанному для вашего приложения (в  моем случае это http://
localhost: 81), и посмотреть, как оно работает, как показано на рис. 16.8.
Приложение обслуживается с использованием
IIS в качестве обратного прокси-сервера
и URL-адреса, указанного в диалоговом окне
Add Website (Добавить веб-сайт)
Рис. 16.8 Опубликованное приложение, использующее IIS в качестве обратного
прокси-сервера, прослушивает запросы по адресу http://localhost:81
И вот оно, ваше первое приложение, работающее за обратным прок -
си-сервером. Хотя ASP .NET Core использует другую модель хостинга по
сравнению с  предыдущими версиями ASP .NET, процесс настройки IIS
аналогичен.
Как это часто бывает при развертывании, ваш успех во многом зависит
от конкретного окружения и самого приложения. Если после этих шагов
вы обнаружите, что не можете запустить приложение, я  настоятельно
1 Дополнительные сведения об использовании файла web.config для настройки
модуля Asp.Net Core см. в статье Microsoft «Модуль ASP .NET Core»: http://mng.
bz/Xdna.

606 Глава 16 Публикация и развертывание приложения
рекомендую обратиться к документации на странице https://docs.micro-
soft.com/aspnet/core/publishing/iis. Там содержится множество шагов по
устранению неполадок, которые помогут вам вернуться в нужное русло,
если IIS решит взбрыкнуть.
Этот раздел был специально создан для описания развертывания при-
ложения в IIS, поскольку он обеспечивает отличный переход для разра-
ботчиков, которые уже привыкли к  развертыванию приложений ASP .
NET и хотят развернуть свое первое приложение ASP .NET Core. Но нельзя
сказать, что IIS – единственное или лучшее место для хостинга.
В следующем разделе я кратко расскажу о размещении вашего при-
ложения в Linux, за обратным прокси-сервером, таким как NGINX или
Apache. Я не буду вдаваться в настройку самого сервера, но предоставлю
обзор вещей, которые следует учитывать, и ресурсов, которые вы можете
использовать для запуска своих приложений в Linux.
16.3 Размещение приложения в Linux
Одной из замечательных новых функций ASP .NET Core является воз-
можность разработки и развертывания кросс-платформенных приложе-
ний, запускаемых на Windows, Linux или macOS. Способность работать
в Linux, в частности, открывает возможность для менее затратных раз-
вертываний в облачном хостинге, развертываний на небольших устрой-
ствах вроде Raspberry Pi или в Docker-контейнерах.
Одной из отличительных черт Linux является то, что ее можно настра-
ивать практически до бесконечности. Однако это может быть крайне
сложно, особенно если вы пришли из мира инструментов под названием
«мастер» (wizard) и графических интерфейсов Windows. В этом разделе
содержится обзор того, что нужно для запуска приложения в Linux. Здесь
описаны общие шаги, а не утомительные детали самой конфигурации.
Я  приведу список ресурсов, к  которым вы можете обратиться при не-
обходимости.
16.3.1 Запуск приложения ASP.NET Core за обратным
прокси-сервером в Linux
Вы будете рады услышать, что запуск приложения в Linux во многом ана-
логичен запуску приложения в Windows с по мощью IIS.
1		Опубликуйте	 свое	приложение	 с по	мощью	команды dotnet publish.
Если вы создаете RDD, результат будет тот же, что и с IIS. В случае
с SCD вы должны предоставить идентификатор целевой платфор-
мы, как описано в разделе 16.1.1.
2		Установите	 необходимые	 компоненты	 на	сервер. Для развертыва-
ния RDD нужно установить среду выполнения .NET 5.0 и необхо-
димые компоненты. Подробности см. в  документации Microsoft:
https://docs.microsoft.com/en-gb/dotnet/core/install/linux.

607 Размещение приложения в Linux
3		Скопируйте	 свое	приложение	 на	сервер. Вы можете использовать лю-
бой механизм, который вам нравится: FTP , USB-накопитель и все,
что можно использовать для загрузки файлов на сервер!
4		Настройте	 обратный	 прокси-сервер	 и укажите	 ему	на	свое	приложе-
ние. Как вы уже знаете, у вас может возникнуть желание запустить
приложение за обратным прокси-сервером по причинам, описан-
ным в разделе 16.1. В Windows вы бы использовали IIS, но в Linux
у вас есть больше возможностей: NGINX, Apache или HAProxy.
5		Настройте	 инструмент	 управления	 процессами	 для	своего	приложе-
ния. В  Windows IIS действует как обратный прокси-сервер и дис -
петчер процессов, перезапуская приложение в случае сбоя или если
оно перестает отвечать. В  Linux обычно требуется настроить от -
дельный диспетчер процессов для выполнения этих обязанностей;
обратные прокси-серверы не сделают этого за вас.
Первые три пункта обычно одинаковы, независимо от того, работаете
вы в Windows с IIS или Linux, но вот последние два пункта более интересны.
В отличие от монолитного IIS, Linux придерживается философии неболь-
ших приложений, у каждого из которых единственная ответственность.
IIS работает на том же сервере, что и ваше приложение, и выполняет
несколько задач – проксирует трафик из интернета в ваше приложение,
а также отслеживает работу самого приложения. Если ваше приложение
дает сбой или перестает отвечать, IIS перезапустит процесс, чтобы про-
должить обрабатывать запросы.
В Linux обратный прокси-сервер может работать на том же сервере,
что и ваше приложение, но также часто бывает, что он работает полно-
стью на другом сервере, как показано на рис. 16.9. То же самое относит -
ся и к ситуации, если вы решите развернуть свое приложение в Docker;
обычно приложение развертывается в контейнере без обратного прок -
си-сервера, а обратный прокси на сервере будет указывать на ваш кон-
тейнер Docker.
Клиент отправляет запрос
вашему приложению
по URL-адресу вашего
приложения, например
http: /localhost: 8080Ваше приложение
обрабатывает запрос
и возвращает ответ
через обратный
прокси-серверДиспетчер процессов следит
за вашим приложением на
предмет проблем, запускает
и останавливает его по мере
необходимостиОбратный прокси-сервер
обрабатывает запрос
и перенаправляет его
на сервер, на котором
работает ваше приложение
Обратный прокси-сервер может
пересылать запросы нескольким
приложениям на нескольких серверах
Рис. 16.9 В Linux обратный прокси-сервер обычно находится на сервере, отличном
от вашего приложения. Обратный прокси-сервер перенаправляет входящие
запросы в ваше приложение, в то время как диспетчер процессов, например
systemd, отслеживает работу приложения на предмет сбоев и при необходимости
перезапускает процесс

608 Глава 16 Публикация и развертывание приложения
Поскольку обратные прокси-серверы не обязательно находятся на том
же сервере, что и ваше приложение, их нельзя использовать для пере-
запуска приложения в случае сбоя. Вместо этого для мониторинга при-
ложений нужно использовать диспетчер процессов, например systemd.
Если вы работаете с Docker, то обычно используете программное обес -
печение для оркестрации контейнеров, такое как Kubernetes (https://ku-
bernetes.io), для мониторинга работоспособности контейнеров.
Запуск приложений ASP.NET Core в Docker
Docker  – это наиболее часто используемый инструмент для контейнеризации
приложений. Контейнер – это своего рода небольшая легковесная виртуаль-
ная машина для вашего приложения. Он содержит операционную систему,
приложение и все его зависимости. Этот контейнер может быть запущен на
любом компьютере с Docker, и ваше приложение будет работать точно так
же, независимо от операционной системы хоста и того, что на ней установ-
лено. Это обеспечивает высокую повторяемость развертываний: вы можете
быть уверены, что если контейнер будет работать на вашей машине, он также
будет работать и на сервере.
ASP.NET Core хорошо подходит для развертывания контейнеров, но переход
к Docker требует большого сдвига в методологии развертывания и может
подойти или не подойти для вас и ваших приложений. Если вас интересуют
возможности, предоставляемые Docker, и вы хотите узнать больше, предла-
гаю ознакомиться со следующими ресурсами:
  «Docker in Practice», 2-е изд., Иэна Миелла и  Эйдана Хобсона Сэйерса
(Manning, 2019) предлагает широкий спектр практических приемов, ко-
торые помогут вам получить максимальную отдачу от Docker (http://mng.
bz/nM8d);
  даже если вы не выполняете развертывание в Linux, то можете использо-
вать Docker с Docker для Windows. Ознакомьтесь с бесплатной электрон-
ной книгой «Введение в контейнеры Windows» Джона Маккейба и Майк -
ла Фрииса (Microsoft Press, 2017): https://aka.ms/containersebook;
  вы можете найти большое количество подробностей о создании и запус -
ке приложений ASP.NET Core на Docker в документации .NET на странице
http://mng.bz/vz5a;
  у Стива Гордона есть отличная серия постов в блоге о Docker для раз-
работчиков ASP.NET Core: https://www.stevejgordon.c o.uk/docker-dotnet-
developers.
Конфигурирование этих систем – трудоемкая задача, требующая чте-
ния скучных текстов, поэтому я не буду подробно описывать это здесь.
Вместо этого я рекомендую ознакомиться с документацией по ASP .NET
Core. Там есть руководство по NGINX и systemd (htt p://mng.bz/yYGd) и ру -
ководство по настройке Apache с по мощью systemd (http://mng.bz/MXVB).
Оба руководства охватывают базовую конфигурацию соответствую-
щих обратных прокси-серверов и  супервизоров systemd, но, что более
важно, они также показывают, как безопасно	настроить их.

609 Размещение приложения в Linux
Обратный прокси-сервер находится между вашим приложением и ин-
тернетом, поэтому важно все сделать правильно!
Настройка обратного прокси-сервера и диспетчера процессов – обыч-
но самая сложная часть развертывания в Linux и не относится к разра-
ботке на платформе .NET: то же самое касается развертывания веб-при-
ло жения Node.js. Но нужно учесть несколько моментов внутри своего
приложения, если вы собираетесь развертывать его в  Linux. Об этом
в следующем разделе.
16.3.2 Подготовка приложения к развертыванию в Linux
В целом приложению все равно, за каким обратным прокси-сервером
оно находится, будь то NGINX, Apache или IIS, – оно получает запросы
и отвечает на них без какого-либо влияния на эти действия со стороны
данного сервера. Когда вы используете IIS, нужно добавить метод UseI-
ISIntegration(); аналогично, когда вы используете Linux, нужно доба-
вить метод расширения в настройки своего приложения.
Когда запрос поступает на обратный прокси-сервер, он содержит не-
кую информацию, которая теряется после того, как запрос перенаправ-
ляется в ваше приложение. Например, исходный запрос идет с IP-адреса
клиента/браузера, подключающегося к вашему приложению: после пе-
ресылки запроса от обратного прокси-сервера IP-адрес – это уже адрес
обратного	 прокси, а не браузера. Кроме того, если обратный прокси-сер-
вер используется для SSL-терминирования (см. главу 18), то запрос, ко-
торый изначально был сделан с использованием протокола HTTPS, мо-
жет поступать в ваше приложение в виде HTTP-запроса.
Стандартным решением этих проблем является добавление обратным
прокси-сервером дополнительных заголовков перед пересылкой запро-
сов в приложение. Например, заголовок X-Forwarded-For идентифициру -
ет IP-адрес исходного клиента, а заголовок X-Forwarded-Proto указывает
на исходную схему запроса (http или https).
Чтобы ваше приложение работало правильно, оно должно искать эти
заголовки во входящих запросах и при необходимости изменять запрос.
Запрос адреса http://localhost с заголовком X-Forwarded-Proto со схемой
https должен обрабатываться так же, как если бы это был запрос адреса
https://localhost.
Чтобы добиться этого, можно использовать компонент Forwarded-
HeadersMiddleware в конвейере промежуточного ПО. Он переопределя-
ет Request.Scheme и другие свойства HttpContext, чтобы соответствовать
перенаправленным заголовкам. Если вы используете метод по умолча-
нию Host.CreateDefaultBuilder() в файле Program.cs, считайте, что часть
работы уже сделана  – промежуточное ПО автоматически добавляется
в конвейер в отключенном состоянии. Чтобы активировать его, устано-
вите для переменной окружения ASPNETCORE_FORWARDEDHEADERS_ENABLED
значение true.
Если вы используете собственный экземпляр HostBuilder вместо по-
строителя по умолчанию, то можете добавить промежуточное ПО в на-

610 Глава 16 Публикация и развертывание приложения
чало конвейера вручную, как показано в листинге 16.2, и сконфигуриро-
вать его, используя заголовки, которые нужно искать.
ПРЕДУПРЕЖДЕНИЕ  Важно, чтобы компонент ForwardedHeader-
sMiddleware был размещен в  начале конвейера для исправления
Request.Scheme перед выполнением любого компонента, завися-
щего от схемы.
Листинг 16.2  Настройка приложения для использования
перенаправленных заголовков в файле Startup.cs
public class Startup
{
public class Configure(IApplicationBuilder app)
{
app.UseForwardedHeaders(new ForwardedHeadersOptions
{
ForwardedHeaders = ForwardedHeaders.XForwardedFor |
ForwardedHeaders.XForwardedProto
});
app.UseHttpsRedirection();
app.UseRouting();
app.UseAuthentication();
app.UseMvc();
}
}
ПРИМЕЧАНИЕ  Такое поведение требуется для обратных прокси-
серверов не только в Linux. Метод расширения UseIis() добавляет
компонент ForwardedHeadersMiddleware под капотом как часть сво-
ей конфигурации, когда ваше приложение работает за IIS.
Помимо перенаправленных заголовков, необходимо учесть несколь-
ко незначительных моментов при развертывании приложения в Linux,
которые могут сбить вас с  толку, если вы привыкли к  развертыванию
в Windows:
окончание	 строк	(LF	в Linux	и CRLF	в Windows) – Windows и Linux ис -
пользуют разные символы в тексте для обозначения конца строки.
Часто это не является проблемой для приложений ASP .NET Core, но
если вы пишете текстовые файлы на одной платформе, а читаете их
на другой, то об этом нужно помнить;
разделитель	 каталогов	 пути	(«\»	в Windows, 	«/»	в Linux) – это одна из
самых распространенных ошибок, которую я вижу, когда разработ -
чики на Windows переходят на Linux. Каждая платформа использу -
ет свой разделитель в путях к файлам, поэтому если вы загружаете
файл с использованием пути "subdir\myfile.json", в Windows это Добавляет компонент
ForwardedHeadersMiddleware
на раннем этапе конвейера.
Настраивает заголовки,
которые промежуточное ПО
должно искать и использовать.ForwardedHeadersMiddleware
должен быть размещен перед всеми
остальными компонентами.

611 Настройка URL-адресов приложения
работает, но не в  Linux. Вместо этого следует использовать метод
Path.Combine, чтобы применить соответствующий разделитель для
текущей платформы; например, Path.Combine("subdir", "myfile.
json");
переменные	 окружения	 не	могут	содержать	 символ	«:» – в  некото-
рых дистрибутивах Linux символ двоеточия (:) нельзя использо-
вать в переменных окружения. Как было показано в главе 11, этот
символ обычно используется для обозначения различных разделов
в ASP .NET Core, поэтому вам часто нужно использовать его в пере-
менных окружения. Вместо этого можно применять двойное под-
черкивание (__), и ASP .NET Core будет воспринимать его так же, как
если бы это было двоеточие;
данные	о часовом	 поясе	и данные	 локализации	 могут	отсутствовать –
дистрибутивы Linux не всегда поставляются с данными о часовом
поясе или данными локализации, что может приводить к пробле-
мам с локализацией и вызывать исключения во время выполнения.
Можно установить данные часового пояса с по мощью диспетчера
пакетов своего дистрибутива1;
разная	структура	 каталогов – в дистрибутивах Linux используется
совершенно иная структура папок, чем в  Windows, поэтому нуж -
но иметь это в виду, если ваше приложение жестко зашивает пути
в код. В частности, рассмотрите различия в папках temporary или
cache.
Этот список ни в  коем случае не является исчерпывающим, однако
если вы настроили ForwardedHeadersMiddleware и  позаботились об ис -
пользовании кросс-платформенных конструкций, таких как Path.Com-
bine, у вас не должно возникнуть много проблем с запуском приложений
в Linux. Но настройка обратного прокси-сервера – не самое простое за-
нятие, поэтому, где бы вы ни планировали разместить свое приложение,
я предлагаю ознакомиться с документацией на странице https://docs.mi-
crosoft.com/aspnet/core/publishing.
16.4 Настройка URL-адресов приложения
На данный момент вы развернули приложение, но не сделали еще кое-
что: не настроили URL-адреса для своего приложения. Когда вы ис -
пользуете IIS в качестве обратного прокси-сервера, вам не нужно бес -
покоиться об этом. Интеграция IIS с  модулем ASP .NET Core работает,
динамически создавая URL-адрес, который используется для пересылки
запросов между IIS и вашим приложением. Имя хоста, которое вы на-
страиваете в IIS (на рис. 16.6), является тем URL-адресом, который видят
внешние пользователи; внутренний URL-адрес, который IIS использует
при пересылке запросов, не виден.
1 Я сам столкнулся с этой проблемой. Подробнее о ней и о том, как я ее решил,
можно прочитать в моем блоге: http://mng.bz/aoem.

612 Глава 16 Публикация и развертывание приложения
Если вы не используете IIS в качестве обратного прокси-сервера, – ве-
роятно, вы используете NGINX или предоставляете доступ к своему при-
ложению напрямую из сети интернет – возможно, вам понадобится на-
строить URL-адреса, по которым будет вестись прослушивание, вручную.
По умолчанию ASP .NET Core будет прослушивать запросы по URL-
ад ресу http://localhost: 5000. Есть много способов задать этот адрес, но
в этом разделе я опишу два: с по мощью переменных окружения или ар-
гументов командной строки. Это два самых распространенных подхода
(за пределами IIS) для управления URL-адресами, которые использует
ваше приложение.
СОВЕТ  Чтобы узнать о  других способах установки URL-адреса,
см. мой пост «5 способов задать URL-адрес для приложения ASP .
NET Core»: http://mng.bz/go0v .
В главе 10 вы узнали о конфигурации в ASP .NET Core и, в частности,
о концепции окружения размещения, чтобы вы могли использовать раз-
ные настройки в зависимости от того, о чем идет речь: о запуске в окру -
жении разработки или промышленном окружении. Окружение разме-
щения можно задать, установив на компьютере переменную окружения
ASPNETCORE _ENVIRONMENT. ASP .NET Core волшебным образом подхватыва-
ет эту переменную, когда ваше приложение запускается, и использует ее,
чтобы определить окружение размещения.
Вы можете использовать аналогичную специальную переменную
окружения, чтобы указать URL-адрес, который использует ваше прило-
жение; это переменная ASPNETCORE_URLS. Когда ваше приложение запус -
кается, оно ищет это значение и использует его в качестве URL-адреса
приложения. Изменив его, можно изменить URL-адрес по умолчанию,
используемый всеми приложениями ASP .NET Core на компьютере.
Например, можно задать временную переменную окружения в Win-
dows из командной оболочки:
set ASPNETCORE_URLS=http://localhost:8000
Запуск опубликованного приложения с использованием dotnet <app.
dll> в том же командном окне, как видно на рис. 16.10, показывает, что
приложение теперь ведет прослушивание по URL-адресу, предоставлен-
ному в переменной ASPNETCORE_URLS.
Вы можете указать приложению вести прослушивание по нескольким
URL-адресам, разделив их точкой с запятой, или можете слушать опреде-
ленный порт без указания имени хоста localhost. Если вы задаете пере-
менную окружения ASPNETCORE_URLS:
http://localhost:5001;http://*:5002
то ваши приложения ASP .NET Core будут слушать запросы, отправлен-
ные на следующие адреса:

613 Настройка URL-адресов приложения
http://localhost:5001 – этот адрес доступен только на вашем локаль-
ном компьютере, поэтому он не будет принимать запросы из ин-
тернета;
http://*:5002 – любой URL-адрес на порту 5002. Внешние запросы из
интернета могут получить доступ к приложению на порту 5002, ис -
пользуя любой URL-адрес, соответствующий вашему компьютеру.
Задайте переменную
окружения
# ASPNETCORE_URLS.
Она применяется для
жизненного цикла окна
консоли
Ваше приложение
выполняет
прослушивание,
используя URL-адрес
из переменной
# ASPNETCORE_URLS
Рис. 16.10 Измените переменную окружения ASPNETCORE_URLS, чтобы изменить
URL-адрес, используемый приложениями ASP.NET Core
Обратите внимание, что вы не	можете указать другое имя хоста, на-
пример iciousrecipes.com. ASP .NET Core будет слушать все запросы на
определенном порту. Исключение составляет localhost, которое разре-
шает только запросы, поступающие с вашего компьютера.
ПРИМЕЧАНИЕ  Если вы обнаружите, что переменная ASPNET-
CORE_URLS не работает должным образом, убедитесь, что у вас нет
файла launchSettings.json в каталоге. Если он там присутствует, то
приоритет получают значения из этого файла. По умолчанию файл
launchSettings.json не включен в вывод publish, поэтому обычно
в промышленном окружении это не будет проблемой.
Установка URL-адреса приложения с использованием одной перемен-
ной окружения отлично подходит для некоторых случаев, особенно ког -
да вы запускаете одно приложение на виртуальной машине или в кон-
тейнере Docker1.
Если вы не используете контейнеры Docker, то, скорее всего, раз-
мещаете несколько приложений рядом на одном компьютере. В  этом
случае одна переменная окружения не годится для того, чтобы задать
URL-ад рес, поскольку это приведет к изменению URL-адресов всех при-
ложений.
В главе 11 было показано, что можно задать окружение размещения
с  по мощью переменной ASPNETCORE_ENVIRONMENT, но это также можно
1 ASP .NET Core хорошо подходит для работы c контейнерами, но работа с кон-
тейнерами – это уже отдельная книга. Дополнительные сведения о размеще-
нии и публикации приложений с по мощью Docker см. на странице http://mng.
bz/e5GV .

614 Глава 16 Публикация и развертывание приложения
сделать, используя параметр --environment при вызове команды dot-
net run:
dotnet run --no-launch-profile --environment Staging
Можно задать URL-адреса для своего приложения аналогичным обра-
зом, применяя параметр --urls. Использование аргументов командной
строки позволяет иметь несколько приложений ASP .NET Core, работаю-
щих на одной машине и слушающих разные порты. Например, следую-
щая команда запустит приложение с  рецептами, настроит его на про-
слушивание на порту 8081 и задаст в качестве окружения окружение для
обкатки, как показано на рис. 16.11:
dotnet RecipeApplication.dll --urls "http://*:8081" --environment Staging
Аргументы командной строки
используются, чтобы задать
окружение размещения
и URL-адреса
Рис. 16.11 Настройка окружения размещения и URL-адресов для приложения
с по мощью аргументов командной строки. Значения, переданные в командной
строке, переопределяют значения, предоставленные из файла appSettings.json или
переменными окружения
Помните, что не нужно задавать URL-адреса таким образом, если вы
используете IIS в качестве обратного прокси-сервера. Интеграция с IIS
сделает это за вас. Задавать URL-адреса необходимо только в том случае,
если вы вручную настраиваете URL-адрес, по которому ведет прослу -
шивание ваше приложение; например, если вы используете NGINX или
предоставляете доступ к Kestrel напрямую клиентам.
ВНИМАНИЕ!  Если вы запускаете приложение ASP .NET Core без
обратного прокси-сервера, то должны использовать фильтрацию
хостов по соображениям безопасности, чтобы приложение отвеча-
ло только на запросы от ожидаемых вами имен хостов. Для получе-
ния более подробной информации см.	мою запись в блоге: http://
mng.bz/pVXK.
Продолжая тему задач, связанных с  развертыванием, в  следующем
разделе мы рассмотрим оптимизацию некоторых ваших клиентских ре-
сурсов для промышленного окружения. Если вы создаете веб-API, то вам
не о чем беспокоиться, но в случае с традиционными веб-приложениями
об этом стоит подумать.

615 Оптимизация клиентских ресурсов с помощью BundlerMinifier
16.5 Оптимизация клиентских ресурсов
с помощью BundlerMinifier
В этом разделе мы исследуем производительность приложения ASP .NET
Core с точки зрения количества и размера запросов. Вы увидите, как по-
высить производительность приложения, используя упаковку и  мини-
фикацию кода, но убедитесь, что ваше приложение по-прежнему легко
можно отлаживать, пока вы его создаете. Наконец, мы рассмотрим рас -
пространенную технику улучшения производительности приложения
в  промышленном окружении: используя сети доставки содержимого
# (CDN).
Вы когда-нибудь использовали веб-приложение или открывали стра-
ницу, для загрузки которых, казалось, требуется вечность? Если вы сби-
лись с  проторенного пути Amazon, Google или Microsoft, то рано или
поздно столкнетесь с ситуацией, когда веб-страница загружается непо-
зволительно долго.
В следующий раз, когда такое произойдет с  вами, откройте инстру -
менты разработчика браузера (например, нажмите клавишу F12 в Edge
или Chrome) и посмотрите количество и размер запросов, которые де-
лает веб-приложение. Во многих случаях большое количество запросов,
порождающее большие ответы, и будет причиной.
Мы начнем с  изучения проблемы производительности, рассмотрев
страницу из вашего приложения с рецептами: страницу входа. Это прос -
тая страница, и она не является медленной по своей сути, но и этого бу -
дет достаточно, чтобы исследовать влияние размера запроса.
Когда вы, будучи пользователем, щелкаете мышью по кнопке входа,
браузер отправляет запрос в /Identity/Account/Login. Ваше приложение
выполняет страницу Razor, Login.cshtml, в пользовательском интерфейсе
по умолчанию, который выполняет шаблон Razor и возвращает в ответ
сгенерированный HTML, как показано на рис. 16.12. Это один запрос-от -
вет – одна поездка в оба конца.
Но это не относится к  веб-странице. HTML, возвращаемый страни-
цей, включает в себя ссылки на файлы CSS (для стилизации страницы),
файлы Java Script (для обеспечения функциональности на стороне клиен-
та – в данном случае для валидации формы) и, возможно, изображения
и другие ресурсы (хотя у вас нет ничего другого в этом приложении).
Браузер должен запросить каждый из этих дополнительных файлов
и дождаться, пока сервер вернет их до загрузки всей страницы. Если вы
занимаетесь локальной разработкой, то все это происходит быстро, так
как запросу вряд ли предстоит долгий путь. Но как только вы развора-
чиваете свое приложение в промышленном окружении – ситуация ме-
няется.

616 Глава 16 Публикация и развертывание приложения
<html>
<head>
<title>Recipes</title>
<link href="/site.css" />
<script src="/site.js"></script>
</head>
<body>...</body>
</htmlGET /Account/Login
GET site.css
GET site.jsCSS
JavaScript1.  Пользователь нажимает
кнопку Login, и запрос
отправляется
в приложение2.  Приложение ASP .NET Core выполняет
страницу Razor, Login.cshtml и создает
HTML-ответ из представления Razor
3.  Браузер разбирает
ответ и запрашивает
дополнительные ресурсы,
на которые есть ссылки,
такие как изображения,
файлы CSS и JavaScript
4.  Браузер запрашивает
ресурсы параллельно, чтобы
уменьшить общее время
загрузки
6.  После того как все ресурсы, на
которые есть ссылки, загружены,
браузер может отобразить
страницу полностью 5.  Приложение отвечает
дополнительными
ресурсамиLogin
Рис. 16.12 Загрузка всей страницы вашего приложения. Первоначальный запрос возвращает
HTML страницы, но он может включать в себя ссылки на другие ресурсы, такие как файлы CSS
и Java Script. Браузер должен сделать дополнительные запросы к вашему приложению, чтобы
получить все оставшиеся ресурсы, прежде чем страница будет полностью загружена
Пользователи будут запрашивать страницы из вашего приложения на
разном расстоянии от сервера через широкий спектр сетевых скоростей.
Количество и размер запросов и ответов для вашего приложения будут
оказывать огромное влияние на общую субъективную скорость прило-
жения. Это, в свою очередь, может существенно повлиять на то, как поль-
зователи воспринимают ваш сайт, а для сайтов онлайн-торговли даже на
то, сколько денег они тратят1.
Отличный способ выяснить, как ваше приложение будет вести себя
в  неоптимальных сетях, – использовать функцию занижения скорости
интернета (network throttling) в  инструментах разработчика Chrome
и Edge. Так вы можете имитировать задержки и скорости сети, связан-
ные с различными типами сетей, чтобы получить представление о том,
как ваше приложение ведет себя в реальных условиях.
На рис. 16.13 я загрузил страницу входа в приложение с рецептами, но
на этот раз со скромной скоростью Fast 3G.
ПРИМЕЧАНИЕ  Я  добавил в  шаблон дополнительные файлы  –
navigation.css и global.js, чтобы страница больше напоминала стра-
ницу из реального приложения.
1 По этому поводу было проведено много исследований, включая такие статис -
тические данные, как «задержка загрузки страницы на 0,1 секунды равняется
7%-ной потере в конверсии»: http://mng.bz/4Z2Q .

617 Оптимизация клиентских ресурсов с помощью BundlerMinifier
Щелкните правой кнопкой мыши кнопку
перезагрузки и выберите Empty Cache (Очистить
кеш) и Hard Refresh (Жесткое обновление)Ограничение увеличивает задержку
для каждого запроса и снижает
максимальную скорость передачи данных
Одновременно к домену
можно отправить не более
6 запросов
Полная загрузка страницы
занимает 10 запросов,
835 КБ и 5,47 с
Рис. 16.13 Изучение влияния скорости сети на время загрузки приложения.
Chrome и Edge позволяют имитировать более медленную сеть, чтобы вы имели
представление о том, что получат пользователи при загрузке вашего приложения,
когда оно окажется в промышленном окружении
Ограничение скорости ничего не меняет в отношении страницы или
запрашиваемых данных  – для одной этой страницы было загружено
10 отдельных запросов и почти 1 МБ данных, – но оно резко влияет на
время загрузки страницы. Без ограничения страница входа загружает -
ся локально за 200 мс; при использовании ограничения на это уходит
5,47 секунды.
ПРИМЕЧАНИЕ  Не пугайтесь этих цифр. Я  стараюсь перезагру -
жать все файлы при каждом запросе, чтобы подчеркнуть суть, тог -
да как на практике браузеры делают все возможное, чтобы кеши-
ровать файлы, дабы избежать отправки такого количества данных.
Время, необходимое для полной загрузки страницы приложения, в ос -
новном зависит от двух факторов:
общий	размер	ответов – это чистая математика; вы можете вернуть
данные только на определенной скорости, поэтому чем больше дан-
ных нужно вернуть, тем больше времени для этого потребуется;
количество	 запросов  – как правило, чем больше запросов должен
сделать браузер, тем больше времени требуется для полной загруз-
ки страницы. В  HTTP/1.0 и  HTTP/1.1 можно сделать только шесть
одновременных запросов к серверу, поэтому все запросы, которые
идут после шестого, должны дождаться завершения более раннего
запроса. Протокол HTTP/2.0, который поддерживается Kestrel, не
имеет такого ограничения, но нельзя всегда полагаться на то, что
клиенты его используют.
Как повысить скорость работы приложения, если нужны все файлы,
которые вы предоставляете? В целом это большая тема со множеством
возможностей, таких как использование сети доставки содержимого для
обслуживания статических файлов. Два самых простых способа повы-
сить производительность сайта: использовать упаковку и минификацию

618 Глава 16 Публикация и развертывание приложения
кода, чтобы уменьшить количество и размер запросов, которые необхо-
димо сделать браузеру, дабы загрузить приложение.
16.5.1 Ускорение работы приложения с по мощью упаковки
и минификации кода
На рис. 16.13 для приложения с рецептами вы сделали в общей сложно-
сти 10 запросов к серверу:
один первоначальный запрос HTML;
три запроса файлов CSS;
шесть запросов файлов Java Script.
Некоторые файлы CSS и Java Script являются стандартными библиотека-
ми поставщика, например Bootstrap и jQuery, которые включены как часть
шаблонов Razor по умолчанию, а некоторые (navigation.css, site.css, global.
js и site.js) – это файлы вашего конкретного приложения. В этом разделе
мы рассмотрим оптимизацию специальных файлов CSS и Java Script.
Если вы пытаетесь уменьшить количество запросов к своему прило-
жению, очевидно, что первая мысль, которая приходит на ум, – избегать
создания нескольких файлов. Например, вместо того чтобы создавать
файлы navigation.css и site.css, можно использовать один файл, содержа-
щий все стили CSS, и не нужно ничего разделять.
Это действенное решение, но размещение всего кода в одном файле
может усложнить задачу по управлению и отладке. Будучи разработчи-
ками, мы обычно стараемся избегать подобных файлов-монстров. Более
подходящее решение – разбить код на нужное вам количество файлов,
а затем упаковать	их, когда вы приступите к развертыванию.
ОПРЕДЕЛЕНИЕ  Упаковка – это процесс объединения нескольких
файлов в один файл с целью уменьшить количество запросов.
Точно так же, когда вы пишете код Java Script, вы должны использовать
описательные имена переменных, комментарии, где это необходимо,
и пробелы для создания легко читаемого и отлаживаемого кода. Когда
вы приступаете к  развертыванию скриптов, то можете обрабатывать
и  оптимизировать их размер, а  не удобочитаемость. Этот процесс на-
зывается минификацией.
ОПРЕДЕЛЕНИЕ  Минификация включает в  себя обработку кода
для уменьшения его размера без изменения его поведения. Такая
обработка имеет много разных уровней, которые обычно включа-
ют в себя удаление комментариев и пробелов, а также переимено-
вание переменных, чтобы давать им более короткие имена, или
полное удаление целых разделов кода, если они не используются.
В качестве примера рассмотрим код Java Script из следующего листин-
га. Эта (очень надуманная) функция складывает некоторые числа и воз-

619 Оптимизация клиентских ресурсов с помощью BundlerMinifier
вращает результат сложения. Она включает в  себя (чрезмерно) описа-
тельные имена переменных, комментарии и множество пробелов, но это
образец кода Java Script, который вы можете найти в собственном при-
ложении.
Листинг 16.3 Пример функции Java Script до минификации
function myFunc() {
// На самом деле эта функция ничего не делает,
// она здесь просто для того, чтобы продемонстрировать минификацию!
function innerFunctionToAddTwoNumbers(
thefirstnumber, theSecondNumber) {
// Я внутри функции myFunc
return thefirstnumber + theSecondNumber;
}
var shouldAddNumbers = true;
var totalOfAllTheNumbers = 0;
if (shouldAddNumbers == true) {
for (var index = 0; i < 10; i++) {
totalOfAllTheNumbers =
innerFunctionToAddTwoNumbers(totalOfAllTheNumbers, index);
}
}
return totalOfAllTheNumbers;
}
Эта функция занимает в общей сложности 588 байт в том виде, в ко-
тором она написана сейчас, но после минификации ее размер умень-
шился до 95 байт – до 16 % от исходного размера. Поведение кода иден-
тично, но вывод, показанный в  следующем листинге, оптимизирован
для уменьшения размера. Это явно не то, что вы хотели бы отлаживать:
в промышленном окружении нужно использовать только сжатые вер-
сии файла; при разработке вы будете использовать оригинальные ис -
ходные файлы.
Листинг 16.4 Пример функции Java Script после минификации
function myFunc(){function r(n,t){return n+t}var
n=0,t;if(1)for(t=0;i<10;i++)n=r(n,t);return n}
Оптимизация статических файлов с  по мощью упаковки и  минифи-
кации может обеспечить бесплатный рост производительности ваше-
го приложения при развертывании его в  промышленном окружении,
при этом позволяя осуществлять разработку, используя легко читаемые
и разделенные файлы.
На рис. 16.14 показано влияние упаковки и минимизации файлов на
страницу входа в приложение с рецептами. Каждый из файлов был ми-
нифицирован, чтобы уменьшить его размер, а пользовательские ресур-
сы были упакованы и  минифицированы, чтобы уменьшить их размер

620 Глава 16 Публикация и развертывание приложения
и количество запросов. Так вы сократили количество запросов с 10 до 8,
общий объем данных уменьшился с 580 КБ до 270, а время загрузки со-
ставило 3,15 с вместо 6,45 с.
Ресурсы поставщика, такие как Bootstrap
и JQuery, минифицированы отдельно
Пользовательские ресурсы JavaScript
и CSS для приложения упакованы
в один файл
Полная загрузка страницы занимает
8 запросов, 378 КБ и 3,67 с —
это на 50 % быстрее, и объем данных
стал на 50 % меньше, чем раньше
Рис. 16.14 Используя упаковку и минификацию, можно уменьшить количество требуемых
запросов и общий объем данных для передачи, что может значительно повысить
производительность. В этом примере упаковка и минификация сокращают время полной
загрузки страницы вдвое
ПРИМЕЧАНИЕ  Такие ресурсы поставщика, как jQuery и  Boot -
strap, не упакованы, как показано на рис.  16.14. Это позволяет
загружать данные файлы из сети доставки содержимого. Данной
темы я коснусь в разделе 16.5.4.
Такого улучшения производительности можно достичь с минималь-
ными усилиями с  вашей стороны, и  это никак не влияет на процесс
разработки. В следующем разделе я покажу, как сделать упаковку и ми-
нификацию частью процесса сборки ASP .NET Core и как настроить про-
цессы упаковки и минификации для своего приложения.
16.5.2 Добавляем BundlerMinifier в приложение
Упаковка и минификация – не новая идея, поэтому есть много способов
добиться аналогичного результата. Предыдущая версия ASP .NET выпол-
няла упаковку и минификацию в управляемом коде, тогда как обычно
для такого рода задач используются средства запуска задач Java Script,
такие как gulp, Grunt и webpack. Фактически, если вы пишете одностра-
ничное приложение, вы почти наверняка уже выполняете упаковку
и минификацию как нечто само собой разумеющееся.
ASP .NET Core включает в себя поддержку упаковки и минификации
с по мощью пакета NuGet, BuildBundlerMinifier, или расширения Visual
Studio, Bundler & Minifier. Вам не обязательно их использовать, а если
вы уже работаете с другими подобными инструментами, такими как
gulp или webpack, предлагаю использовать их и  дальше. Но если вы
начинаете работу с  новым проектом, то предлагаю присмотреться
к  BundlerMinifier; позже вы всегда можете переключиться на другой
инструмент.

621 Оптимизация клиентских ресурсов с помощью BundlerMinifier
Добавить BundlerMinifier в свой проект можно двумя способами:
установить расширение Visual Studio, Bundler & Minifier, из Tools >
Extensions and Updates (Инструменты > Расширения и обнов ления);
добавить в свой проект пакет NuGet, BuildBundlerMinifier.
Какой бы подход вы ни использовали, в обоих случаях используется
одна и  та же базовая библиотека BundlerMinifier1. Я  предпочитаю ис -
пользовать пакет NuGet, поскольку он кросс-платформенный и автома-
тически собирает ваши ресурсы в пакеты, но расширение Visual Studio
полезно для выполнения специальной упаковки. Если вы используете
это расширение, то убедитесь, что активировали Bundle для сборки, об
этом ниже.
Вы можете установить пакет BuildBundlerMinifier в свой проект с по-
мощью этой команды:
dotnet add package BuildBundlerMinifier
После его установки при каждой сборке проекта BundlerMinifier будет
проверять ваши файлы CSS и Java Script на предмет изменений. Если что-
то изменилось, создаются новые объединенные и минифицированные
файлы, как показано на рис. 16.15, где я изменил файл Java Script.
Сборка проекта запустит процесс
BundlerMinifier
Если файл был изменен, BundlerMinifier
повторно создаст бандл и выполнит его
минификацию
Рис. 16.15 Всякий раз при сборке проекта BuildBundlerMinifier ищет изменения во входных
файлах и при необходимости создает новые объединения
Как видно на рис. 16.15, мы минимизировали наш код Java Script и соз-
дали новый файл по адресу wwwroot/js/site.min.js. Но почему было вы-
брано это имя? Ну, потому, что так было указано в файле bundleconfig.
json. Вы добавляете этот файл в  корневую папку своего проекта, и  он
контролирует процесс BundlerMinifier.
В листинге 16.5 показана типичная конфигурация файла bundleconfig.
json для небольшого приложения. Он определяет, какие файлы включать
в каждый пакет, куда записывать результат и какие варианты минифи-
кации использовать. Здесь настроены два пакета: один для CSS и один
для Java Script. Вы можете добавить их в массив JSON или настроить уже
существующие предоставленные пакеты.
1 Библиотека и расширение BundlerMinifier – это ПО с открытым исходным ко-
дом, которое можно найти на GitHub: https://github.com/madskristensen/Bun-
dlerMinifier/.

622 Глава 16 Публикация и развертывание приложения
Листинг 16.5 Типичный файл bundleconfig.json
[
{
"outputFileName": "wwwroot/css/site.min.css",
"inputFiles": [
"wwwroot/css/site.css"
"wwwroot/css/navigation.css"
]
},
{
"outputFileName": "wwwroot/js/site.min.js",
"inputFiles": [
"wwwroot/js/site.js"
"wwwroot/js/*.js",
"!wwwroot/js/site.min.js"
],
"minify": {
"enabled": true,
"renameLocals": true
},
"sourceMap": false
}
]
Для каждого пакета можно указать определенный набор файлов для
включения, как указано в свойстве inputFiles. Если вы добавляете в про-
ект новый файл CSS или Java Script, не забудьте вернуться к файлу bundle-
config.json и добавить его в список.
Кроме того, можно использовать шаблоны	 подстановки для автома-
тического включения новых файлов по умолчанию. Это не всегда воз-
можно, например когда вам нужно убедиться, что файлы объединены
в определенном порядке, но во многих случаях я считаю такой подход
предпочтительным. Пример из предыдущего листинга использует под-
становку для пакета Java Script: шаблон держит все файлы с расширени-
ем .js в  папке wwwroot/js, но там нет самого минифицированного вы-
ходного файла.
ОПРЕДЕЛЕНИЕ  В шаблонах подстановки	 подстановочные знаки
используются для обозначения множества различных символов.
Например, *.css будет соответствовать всем файлам с расширени-
ем .css, независимо от имени файла.
Когда вы создаете свой проект, BundlerMinifier оптимизирует файлы
CSS в единый файл wwwroot/css/site.min., а Java Script в файл wwwroot/
js/site .min.js на основе настроек в файле bundleconfig.json. В следующем
разделе мы посмотрим, как включить эти файлы при запуске в промыш-
ленном окружении, продолжая использовать исходные файлы при ло-
кальной разработке. Упаковщик создаст
файл с этим именем.
Файлы, перечисленные в inputFiles,
минифицируются и объединяются
в outputFileName.
Вы можете указать несколько пакетов,
каждый с именем выходного файла.
Нужно создавать
отдельные
пакеты для CSS
и Java Script.Вы можете использовать шаблоны подстановки,
чтобы указать файлы для включения.
Символ ! исключает соответствующий
файл из пакета.
У упаковщика Java Script есть несколько
дополнительных опций.
При желании можно создать карту исходного
кода для упакованного файла Java Script.

623 Оптимизация клиентских ресурсов с помощью BundlerMinifier
ПРИМЕЧАНИЕ  Пакет BundlerMinifier отлично подходит для оп-
тимизации файлов CSS и Java Script. Но изображения – еще один
важный ресурс, который следует учитывать при оптимизации,
и они могут легко составлять основную часть размера вашей стра-
ницы. К  сожалению, для них нет встроенных инструментов, по-
этому нужно будет посмотреть другие варианты; TinyPNG (https://
tinypng.com) – один из них.
16.5.3 Использование минифицированных файлов
в промышленном окружении с по мощью тег-хелпера
окружения
Оптимизация файлов с по мощью объединения и минификации отлично
подходит для повышения производительности, но вам нужно использо-
вать исходные файлы во время разработки. Самый простой способ до-
биться такого разделения в ASP .NET Core заключается в использовании
тег-хелпера окружения, чтобы условно включать исходные файлы при
запуске в  окружении разработки и  использовать оптимизированные
файлы в других окружениях.
Вы познакомились с  тег-хелпером окружения в  главе 8, где мы ис -
пользовали его, чтобы показать баннер на главной странице, когда
приложение работало в тестовом окружении. В листинге 16.6 показано,
как использовать аналогичный подход на странице _Layout .cshtml для
CSS-фай лов нашего приложения с рецептами с по мощью двух таких тег-
хелперов: один используется, когда вы находитесь в окружении разра-
ботки, а второй – на тот случай, когда вы находитесь в другом окружении
(например, в промышленном или тестовом). Можно использовать ана-
логичные тег-хелперы для файлов Java Script.
Листинг 16.6  Использование тег-хелперов окружения
для условной отрисовки оптимизированных файлов
<environment include="Development">
<link rel="stylesheet"
href="~/lib/bootstrap/dist/css/bootstrap.css" />
<link rel="stylesheet" href="~/css/navigation.css" />
<link rel="stylesheet" href="~/css/site.css" />
</environment>
<environment exclude="Development">
<link rel="stylesheet"
href="~/lib/bootstrap/dist/css/bootstrap.min.css" />
<link rel="stylesheet" href="~/css/site.min.css" />
</environment>Отображайте эти ссылки только тогда, когда они не находятся в окружении
разработки, например на стадии обкатки или в промышленном окружении.
Версия Bootstrap
для разработки.
Версия ваших стилей
для разработки.
Отображайте эти ссылки только при запуске
приложения в окружении разработки.Минифицированная
версия Bootstrap.
Упакованная и минифицированная версия
ваших стилей.

624 Глава 16 Публикация и развертывание приложения
Когда приложение обнаруживает, что оно запущено не в окружении раз-
работки (как вы узнали в главе 11), оно переключается на отрисовку ссы-
лок для оптимизированных файлов, что дает вам лучшее из обоих миров:
производительность в промышленном окружении и простоту разработки.
Пример из листинга 16.6 также содержит уменьшенную версию Boot -
strap, хотя вы не настраивали ее как часть BundlerMinifier. Такие библио-
теки, как Bootstrap, часто включают предварительно уменьшенную вер-
сию файла для использования в промышленном окружении. Если такая
версия есть, то лучше исключать их из процесса объединения и исполь-
зовать файл из сети доставки содержимого.
16.5.4 Обслуживание часто используемых файлов из сети
доставки содержимого
Сеть доставки содержимого (Content	 Delivery	 Network – CDN) – это веб-
сайт, на котором размещены часто используемые файлы, такие как Boot -
strap или jQuery, на которые вы можете ссылаться из своих приложений.
У них есть несколько преимуществ:
обычно они быстрые;
они избавляют ваш сервер от необходимости предоставлять файл,
экономя пропускную способность;
поскольку файл предоставляется с другого сервера, он не учитыва-
ется в шести одновременных запросах, которые разрешено делать
к вашему серверу в протоколах HTTP/1.0 и HTTP/1.11;
множество разных приложений могут ссылаться на один и тот же
файл, поэтому пользователь, посещающий ваше приложение, воз-
можно, уже кешировал файл, посетив другой веб-сайт, и, вероятно,
ему вообще не нужно его скачивать.
В принципе, использовать сеть доставки содержимого просто: ссылай-
тесь на файл CDN, а не на файл на вашем сервере. К сожалению, нужно
учитывать тот факт, что, как и любой сервер, CDN иногда может выйти из
строя. Если у вас нет резервного механизма для загрузки файла из дру -
гого местоположения, такого как ваш сервер, это может привести к тому,
что ваше приложение будет выглядеть неисправным.
К счастью, у ASP .NET Core есть несколько тег-хелперов для облегчения
работы с CDN и резервными механизмами. В листинге 16.7 показано, как
обновить тег-хелпер окружения CSS для обслуживания Bootstrap из CDN
при работе в  промышленном окружении и  включения резервного ме-
ханизма. Тег asp-fallback-test* создает временный HTML-элемент и при-
меняет к нему стили Bootstrap. Если элемент имеет ожидаемые свойства
CSS, резервный тест прошел успешно, потому что должен быть загружен
Bootstrap. Если у него нет необходимых свойств, Bootstrap будет загру -
жен из альтернативной локальной ссылки.
1 Этот предел не фиксирован, но все современные браузеры используют один
и тот же предел. См. статью на странице http://mng.bz/OEWw .

625 Резюме
Листинг 16.7  Обслуживание стилей Bootstrap из CDN
с локальным резервным механизмом
<environment include="Development">
<link rel="stylesheet" href="~/lib/bootstrap/dist/css/bootstrap.css" />
<link rel="stylesheet" href="~/css/navigation.css" />
<link rel="stylesheet" href="~/css/site.css" />
</environment>
<environment exclude="Development">
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/
➥    bootstrap/4.3.1/css/bootstrap.min.css"
asp-fallback-test-class="sr-only"
asp-fallback-test-property="position"
asp-fallback-test-value="absolute"
asp-fallback-href="~/lib/bootstrap/dist/css/bootstrap.min.css" />
<link rel="stylesheet" href="~/css/site.min.css" />
</environment>
Оптимизация статических файлов – важный шаг, который необходи-
мо рассмотреть, прежде чем размещать приложение в  промышленном
окружении, поскольку это может существенно повлиять на производи-
тельность. К счастью, пакет BuildBundlerMinifier упрощает оптимизацию
файлов CSS и Java Script. Если сочетать его с обслуживанием часто исполь-
зуемых файлов из CDN, то ваше приложение будет таким быстрым, на-
сколько это возможно для пользователей в промышленном окружении.
На этом мы подошли к концу главы, посвященной публикации вашего
приложения. Этот последний этап в  разработке приложений, разверты-
вание приложения на сервере, где пользователи могут получить к  нему
доступ, является типичной и сложной задачей. Опубликовать приложение
ASP .NET Core достаточно просто, но множество доступных вариантов раз-
мещения затрудняет предоставление кратких шагов для каждой ситуации.
Какой бы вариант хостинга вы ни выбрали, есть одна важная тема,
о  которой часто забывают, но которая имеет решающее значение для
быст рого решения проблем: журналирование. В  следующей главе вы
узнае те об абстракциях журналирования в ASP .NET Core и о том, как их
можно использовать, чтобы отслеживать работу своего приложения, ког -
да оно окажется в промышленном окружении.
Резюме
Приложения ASP .NET Core – это консольные приложения со встроен-
ным веб-сервером. В промышленном окружении обычно использует -
ся обратный прокси-сервер, который обрабатывает исходный запрос
и передает его вашему приложению. Обратные прокси-серверы могут По умолчанию Bootstrap
загружается из CDN.
Резервный тест применяет
к элементу класс sr-only…
…и проверяет, что элемент абсолютно
позиционирован. Это указывает на то, что
Bootstrap был загружен.Если такая проверка прошла неудачно, значит,
загрузку из CDN выполнить не удалось, поэтому
Bootstrap загружается по локальной ссылке.

626 Глава 16 Публикация и развертывание приложения
обеспечить дополнительную безопасность, операции и преимущества
в производительности, но также могут усложнить развертывание.
Платформа .NET состоит из двух частей: .NET SDK (также известного
как интерфейс командной строки .NET) и среда выполнения .NET. При
разработке приложения вы используете интерфейс командной строки
.NET для восстановления, сборки и запуска приложения. Visual Studio
использует те же команды интерфейса командной строки .NET из ин-
тегрированной среды разработки.
Если вы хотите развернуть приложение в промышленном окружении,
необходимо опубликовать его, используя команду dotnet publish. Она
создает папку, содержащую ваше приложение в виде файла с расши-
рением .dll вместе со всеми его зависимостями.
Чтобы запустить опубликованное приложение, вам не нужен ин-
терфейс командной строки .NET, потому что вы не будете собирать
приложение. Вам нужна только среда выполнения .NET для запуска
опубликованного приложения. Вы можете запустить опубликованное
приложение с по мощью команды dotnet app.dll, где app.dll – это при-
ложение в виде файла с расширением .dll, созданное командой dotnet
publish.
Для размещения приложений ASP .NET Core в IIS необходимо устано-
вить модуль ASP .NET Core. Он позволяет задействовать IIS в качестве
обратного прокси-сервера для вашего приложения. Вы также должны
установить среду выполнения .NET и среду выполнения ASP .NET Core,
которые устанавливаются как часть пакета ASP .NET Core Windows
Hosting Bundle.
Приложения в ASP .NET Core IIS можно размещать в одном из двух ре-
жимов: внутрипроцессный и внепроцессный. Во внепроцессном ре-
жиме ваше приложение запускается как отдельный процесс, типич-
ный для большинства обратных прокси. Внутрипроцессный режим
запускает ваше приложение как часть процесса IIS. Это дает преиму -
щества в  производительности за счет исключения межпроцессного
взаимодействия.
Чтобы подготовить приложение к публикации в IIS, убедитесь, что вы
вызываете методы UseIISIntegration() и UseIIS() для WebHostBuilder.
Статический вспомогательный метод ConfigureWebHostDefaults дела-
ет это автоматически.
Когда вы публикуете свое приложение с  по мощью интерфейса ко-
мандной строки .NET, файл web.config будет добавлен в папку вывода.
Важно, чтобы этот файл был развернут при публикации вашего при-
ложения в IIS, поскольку он определяет, как должно запускаться ваше
приложение.
URL-адрес, по которому будет выполнять прослушивание ваше при-
ложение, указывается по умолчанию в переменной окружения ASPNET-
CORE_URLS. Установка этого значения изменит URL-адрес всех приложе-
ний на вашем компьютере. В качестве альтернативы можно передать
аргумент командной строки –urls при запуске вашего приложения,
например dotnet app.dll --urls http://localhost:80.

627 Резюме
Важно оптимизировать ресурсы на стороне клиента, чтобы умень-
шить размер и количество файлов, которые должны скачиваться кли-
ентским веб-браузером при загрузке страницы. Этого можно добить-
ся, объединив и минифицировав свои ресурсы.
Вы можете использовать пакет BuildBundlerMinifier для объединения
нескольких файлов Java Script или CSS в один. Можно уменьшить раз-
мер файлов в процессе, называемом минификацией, при котором не-
нужные пробелы удаляются, а переменные переименовываются с со-
хранением функции файла.
Можно установить расширение Visual Studio для управления объеди-
нением и минификацией, или пакет BuildBundlerMinifier для автома-
тического объединения и минификации при каждой сборке проекта.
Использование расширения позволяет выполнять минификацию на
разовой основе, а применение пакета NuGet дает возможность авто-
матизировать этот процесс.
Настройки для объединения и минификации хранятся в файле bun-
dleconfig.json, где вы можете определить различные выходные файлы
пакетов и выбрать, какие файлы включить в пакет. Вы можете явно
указать файлы или использовать шаблоны подстановки для включе-
ния нескольких файлов с применением подстановочных знаков. Под-
становка обычно проще и менее подвержена ошибкам, но вам нужно
будет явно указать файлы, если они должны быть объединены в опре-
деленном порядке.
Используйте тег-хелпер окружения для отрисовки пакетов при усло-
вии работы в  промышленном окружении. Это позволяет оптимизи-
ровать производительность в данном окружении и удобочитаемость
в окружении разработки.
Для распространенных файлов, совместно используемых нескольки-
ми приложениями, например jQuery или Bootstrap, можно использо-
вать файлы из CDN. Это веб-сайты, на которых размещены часто ис -
пользуемые файлы, поэтому вашему приложению не нужно самому
их предоставлять.
Используйте тег-хелперы ссылок и  скриптов, чтобы проверить пра-
вильность загрузки файла из CDN. Они могут проверить, что файл был
скачан клиентом, и гарантируют, что ваш сервер будет использоваться
в качестве запасного варианта в случае сбоя CDN.

Часть	III
Расширение	приложений
В  первой и второй частях мы рассмотрели огромное количество тем:
мы разобрали все основные функциональные компоненты, которые вы
будете использовать для создания традиционных приложений Razor
Pages с отрисовкой на стороне сервера, а также веб-API. В этой части мы
рассмотрим шесть разных тем, основываясь на том, что вы уже изучили:
журналирование, безопасность, специальные компоненты, взаимодей-
ствие со сторонними API для протокола HTTP , фоновые службы и тести-
рование.
Добавление журналирования в  приложение – одно из тех действий,
которые часто оставляют на потом до тех пор, пока вы не обнаружите
проблему в промышленном окружении. Разумное использование жур-
налирования с  самого начала поможет вам быстро диагностировать
и исправлять ошибки по мере их возникновения. В главе 17 вы познако-
митесь с фреймворком журналирования, встроенным в ASP .NET Core. Вы
увидите, как использовать его для записи сообщений журналов в самые
разные места, будь то консоль, файл или сторонняя служба удаленного
журналирования.
В наши дни правильная защита приложения – важная часть веб-разра-
ботки. Даже если у  вас нет ощущения, что в  вашем приложении есть
конфиденциальные данные, необходимо убедиться, что вы защищаете
своих пользователей от атак, следуя лучшим практикам безопасности.
В главе 18 я опишу некоторые распространенные уязвимости, как зло-
умышленники могут использовать их, а также что можно сделать для за-
щиты своих приложений.
В части I вы узнали о конвейере промежуточного ПО и увидели, на-
сколько он важен для всех приложений ASP .NET Core. В  главе 19 вы

629 Расширение приложений
узнае те, как создавать собственное промежуточное ПО, а также простые
конечные точки, когда вам не нужны все возможности Razor Pages или
контроллера веб-API. Вы также изучите, как справиться со сложными
проблемами конфигурации, относящимися к типу «курица или яйцо»,
которые часто возникают в реальных приложениях. Наконец, вы узнае-
те, как заменить встроенный контейнер внедрения зависимостей сто-
ронней альтернативой.
В главе 20 вы получите сведения о создании специальных компонентов
для работы со страницами Razor Pages и контроллерами API. Вы узнае те,
как создавать специальные тег-хелперы и атрибуты валидации, и я пред-
ставлю вам новый компонент – компонент представления – для инкап-
суляции логики с отрисовкой представления Razor. Вы также узнае те, как
заменить платформу валидации на основе атрибутов, исполь зуемую по
умолчанию в ASP .NET Core альтернативным вариантом.
Большинство создаваемых вами приложений не предназначены для
автономной работы. Очень часто вашему приложению нужно взаимо-
действовать со сторонними API, будь то API для отправки электронных
писем, получения курсов валют или приема платежей. В главе 21 вы уз-
наете, как взаимодействовать со сторонними API с по мощью абстракции
IHttpClientFactory для упрощения конфигурации, чтобы добавить обра-
ботку временных сбоев и избежать распространенных ошибок.
Эта книга в первую очередь посвящена обслуживанию HTTP-трафика
как веб-страниц с отрисовкой на сервере с использованием страниц Ra-
zor, так и веб-API, обычно используемых одностраничными приложения-
ми или приложениями для мобильных устройств. Однако многим при-
ложениям требуются длительные фоновые задачи, которые выполняют
задания по расписанию или обрабатывают элементы из очереди. В гла-
ве 22 я покажу, как создавать такие длительные фоновые задачи в своих
приложениях ASP .NET Core и автономные службы, у которых есть только
фоновые задачи, без какой-либо обработки HTTP , и  как установить их
в качестве службы Windows или демона systemd в Linux.
Глава 23, последняя по счету, посвящена тестированию приложения.
Сама роль тестирования при разработке приложений иногда может при-
водить к философским спорам, но в главе 23 я остановлюсь на практиче-
ских аспектах тестирования приложения с по мощью фреймворка xUnit.
Вы увидите, как создавать модульные тесты для своих приложений, как
тестировать код, который зависит от EF Core, использующего поставщи-
ка базы данных в памяти, и как писать интеграционные тесты, которые
могут одновременно протестировать несколько аспектов приложения.

17Мониторинг	и устранение
ошибок	с помощью
журналирования
В этой главе:
компоненты сообщения журнала;
запись журналов в нескольких местах вывода;
контроль над избыточностью сообщений журналов
в разных окружениях с по мощью фильтрации;
использование структурированного журналирования
для обеспечения возможности поиска в журналах.
Журналирование – одна из тем, которые кажутся ненужными вплоть до
тех пор, пока вы не начнете отчаянно нуждаться в ней! Нет ничего более
неприятного, чем столкнуться с проблемой, которую можно воспроизве-
сти только в промышленном окружении, а затем обнаружить, что у вас
нет журналов, которые могли бы помочь вам отладить ее.
Журналирование – это процесс записи событий или действий в при-
ложении, который часто включает в себя ведение записи в консоль, файл,
журнал событий Windows или другие системы. В  сообщение журнала
можно записывать что угодно, хотя обычно существуют два разных типа
сообщений:
информационные	 сообщения  – произошло стандартное событие:
пользователь выполнил вход, продукт был помещен в корзину, или
в приложении для ведения блога было создано новое сообщение;

631 Мониторинг и устранение ошибок с помощью журналирования
предупреждения	 и ошибки – произошла ошибка или непредвиденное
событие: у пользователя отрицательная сумма в корзине покупок,
либо произошло исключение.
Раньше существовала распространенная проблема с журналировани-
ем в крупных приложениях, которая заключалась в том, что каждая биб-
лиотека и фреймворк генерировали журналы в несколько разном фор-
мате, если вообще это делали. Когда в вашем приложении происходила
ошибка, и вы пытались ее диагностировать, из-за такого несоответствия
было трудно связать все факты в единое целое, чтобы получить полную
картину и понять проблему.
К счастью, в ASP .NET Core есть новый обобщенный интерфейс журна-
лирования, который вы можете подключить. Он используется во всем
коде ASP .NET Core, а также сторонними библиотеками, и вы можете с лег -
костью применять его для создания журналов в своем коде. С помощью
фреймворка журналирования ASP .NET Core вы можете контролировать
избыточность сообщений журналов, поступающих из всех частей кода,
включая фреймворк и библиотеки, и писать сообщение журнала в любое
место назначения, которое подключается к фреймворку.
В этой главе я подробно расскажу о фреймворке журналирования ASP .
NET Core и объясню, как использовать его для записи событий и диагнос -
тики ошибок в собственных приложениях.
В разделе 17.1 я опишу архитектуру фреймворка журналирования. Вы
узнаете, как внедрение зависимостей позволяет библиотекам и прило-
жениям создавать сообщения журнала, а также записывать эти сообще-
ния в несколько мест назначения.
В разделе 17.2 вы узнаете, как писать собственные сообщения журнала
в приложениях с по мощью интерфейса ILogger. Мы разберем анатомию
типичной записи журнала и рассмотрим ее свойства, такие как уровень
сообщения журнала, категория и сообщение.
Запись сообщений в  журналы полезна только в том случае, если вы
умеете их читать, поэтому в разделе 17.3 вы узнаете, как добавить по-
ставщиков журналирования в свое приложение. Поставщики журнали-
рования контролируют, куда ваше приложение пишет сообщения. Это
может быть консоль, файл или даже внешняя служба. Я покажу вам, как
добавить поставщика журналирования, который пишет журналы в файл,
и как сконфигурировать популярного стороннего поставщика журнали-
рования Serilog в своем приложении.
Журналирование – важная часть любого приложения, но определение
его объема может быть непростым вопросом. С одной стороны, вам нуж -
но предоставить достаточно информации, чтобы иметь возможность
диагностировать любые проблемы. С другой стороны, вы не хотите за-
полнять свои журналы данными, которые затрудняют поиск важной ин-
формации, когда вам она нужна. Хуже того. То, что достаточно для раз-
работки, может оказаться чересчур для промышленного окружения.
В разделе 17.4 я объясню, как фильтровать сообщения журнала из раз-
личных разделов приложения, например библиотек инфраструктуры
ASP .NET Core, чтобы поставщики журналирования писали только важ -

632 Глава 17 Мониторинг и устранение ошибок с помощью журналирования
ные сообщения. Это позволяет поддерживать баланс между обширным
журналированием в окружении разработки и записывать только важные
сообщения в промышленном окружении.
В последнем разделе данной главы я коснусь преимуществ структур-
ного	журналирования, подхода, который можно использовать с некото-
рыми поставщиками для фреймворка журналирования ASP .NET Core.
Структурное журналирование включает в  себя прикрепление данных
к  сообщениям журнала в  виде пар «ключ-значение», чтобы упростить
поиск по журналам и выполнение запросов к ним. Вы можете прикре-
пить, например, уникальный идентификатор клиента к каждому сооб-
щению журнала, созданному вашим приложением. Найти все сообщения
журнала, связанные с пользователем, намного проще, используя данный
подход, по сравнению с записью идентификатора клиента непоследова-
тельным образом как часть сообщения журнала.
Мы начнем эту главу с того, что разберемся, что включает в себя жур-
налирование и почему в будущем вы скажете себе спасибо за его эффек -
тивное использование в своем приложении. Затем мы рассмотрим части
фреймворка журналирования ASP .NET Core, которые вы будете исполь-
зовать непосредственно в своих приложениях, и как они сочетаются друг
с другом.
17.1 Эффективное использование журналирования
в промышленном приложении
Представьте, что вы только что развернули новое приложение в  про-
мышленном окружении, когда клиент звонит и говорит, что получает со-
общение об ошибке при работе в вашем приложении. Как бы вы опреде-
лили, что вызвало проблему? Вы могли бы спросить клиента, какие шаги
он предпринимает, и потенциально попробовать воспроизвести ошибку
самостоятельно, но если это не сработает, то вам придется рыться в коде,
пытаясь выявить ошибки. Это все, что остается сделать.
Журналирование может предоставить дополнительный контекст, не-
обходимый для быстрой диагностики проблемы. Возможно, наиболее
важные события в журнале фиксируют подробную информацию о самой
ошибке, но события, которые привели к ошибке, могут быть столь же по-
лезны при диагностике ее причины.
Есть много причин, чтобы добавить журналирование в приложение,
но, как правило, они относятся к одной из трех категорий:
журналирование с  целью аудита или аналитики, чтобы отслежи-
вать, когда произошли события;
журналирование ошибок;
журналирование событий, не связанных с ошибками, чтобы обес -
печить запись цепочки событий к моменту, когда ошибка действи-
тельно происходит.

633 Эффективное использование журналирования в промышленном приложении
Первая из этих причин проста. Вам может потребоваться вести учет,
например каждый раз, когда пользователь выполняет вход, или вы мо-
жете отслеживать, сколько раз вызывается конкретный метод API. Жур-
налирование – простой способ записать поведение своего приложения,
записывая сообщение в журнал каждый раз, когда происходит интерес -
ное событие.
Я считаю, что вторая причина является наиболее распространенной.
Когда приложение работает отлично, журналы часто остаются совер-
шенно нетронутыми. А вот когда возникает проблема и звонит клиент,
журналы становятся просто незаменимыми. Хороший набор журналов
поможет понять условия, которые вызвали ошибку, включая контекст
самой ошибки, а также контекст в предыдущих запросах.
СОВЕТ  Даже при обширном журналировании вы можете не осоз-
навать, что у вас в приложении есть проблема, если вы не просмат -
риваете журналы регулярно. Для любого среднего и крупного при-
ложения это становится непрактичным, поэтому такие службы
мониторинга, как Raygun (https://raygun.io) или Sentry (https://
sentry.io), могут стать бесценными инструментами для быстрого
уведомления о проблемах.
Если это смахивает на то, что вам предстоит серьезно поработать, зна-
чит, вам повезло. ASP .NET Core выполнит за вас массу работы по журна-
лированию навигационных цепочек, чтобы вы могли сосредоточиться
на создании качественных сообщений журнала, имеющих наибольшую
ценность при диагностике проблем.
17.1.1 Выявление проблем с по мощью специальных сообщений
журнала
ASP .NET Core использует журналирование во всех своих библиотеках.
В зависимости от того, как вы настраиваете приложение, у вас будет до-
ступ к деталям каждого запроса и запроса EF Core, даже без добавления
дополнительных сообщений журнала в  собственный код. На рис.  17.1
видны сообщения журнала, созданные при просмотре одного рецепта
в приложении рецептов.
Это дает вам много полезной информации. Вы можете увидеть, какой
URL-адрес был запрошен, страницу Razor Page и обработчик страниц, ко-
торые были вызваны, команду базы данных EF Core, вызванный резуль-
тат действия и ответ. Эта информация может оказаться бесценной, когда
вы пытаетесь изолировать проблему, будь то ошибка в рабочем прило-
жении или какая-то функция в окружении разработки, если вы работаете
локально.
Такое журналирование может быть полезно, но сообщения журнала,
которые вы создаете сами, могут иметь еще большую ценность. Напри-
мер, вы можете определить причину ошибки из сообщений журнала на

634 Глава 17 Мониторинг и устранение ошибок с помощью журналирования
рис. 17.1 – мы пытаемся просмотреть рецепт с неизвестным RecipeId 5,
но это далеко не очевидно. Если явно добавить сообщение журнала
в свое приложение, когда это происходит, как показано на рис. 17.2, то
проблема становится более очевидной.
К URL-адресу /Recipe/View/2 делается один
запрос. Внутренние библиотеки фреймворка
ASP .NET Core создают журналы для конечной
точки Razor Pages
Выполняется обработчик OnGetAsync на странице
Razor, Recipes/View.cshtml
EF Core регистрирует SQL-запросы к базе данных
Тип ActionResult и код HTTP- ответа
регистрируются
Рис. 17.1 Библиотеки ASP.NET Core используют журналирование повсюду. Один запрос
генерирует несколько сообщений журнала, описывающих прохождение запроса через ваше
приложение
Вы можете писать собственные
сообщения в журналы из классов
своего приложения, как, например,
в этом журнале из модели
представления страницы Razor.
Они часто более полезны
для диагностики проблем
и отслеживания поведения вашего
приложения
Рис. 17.2 Вы можете писать собственные сообщения. Часто они более полезны для
выявления проблем и интересных событий в ваших приложениях
Это специальное сообщение журнала легко выделяется и четко ука-
зывает на проблему (рецепта с запрошенным идентификатором не су -
ществует) и параметры или переменные, которые привели к проблеме
(значение идентификатора 5). Добавление похожих сообщений журнала
в приложения облегчит диагностику проблем, отслеживание важных со-
бытий и в целом даст знать, что делает приложение.
Надеюсь, теперь у  вас есть мотивация добавить журналирование
в свои приложения, поэтому мы рассмотрим подробности того, что сюда
входит. В  разделе 17.1.2 вы увидите, как создать сообщение журнала
и определить, куда пишутся эти сообщения. Мы подробно рассмотрим
два этих аспекта в разделах 17.2 и 17.3; однако сначала выясним, где они
сочетаются с точки зрения фреймворка журналирования ASP .NET Core
в целом.

635 Эффективное использование журналирования в промышленном приложении
17.1.2 Абстракции журналирования ASP.NET Core
Фреймворк журналирования ASP .NET Core состоит из ряда абстракций
(интерфейсы, реализации и вспомогательные классы), наиболее важные
из которых показаны на рис. 17.3:
ILogger – это интерфейс, с которым вы будете взаимодействовать
в  своем коде. У  него есть метод Log(), который используется для
запи си сообщения журнала;
ILoggerProvider – используется для создания специального экземп-
ляра ILogger, в зависимости от поставщика. «Консольный» ILogger-
Provider создает ILogger, который пишет в консоль, тогда как «фай-
ловый» ILoggerProvider создает ILogger, который пишет в файл;
ILoggerFactory – это связующее звено между экземплярами ILog-
gerProvider и ILogger, которые вы используете в своем коде. Вы ре-
гистрируете экземпляры ILoggerProvider с по мощью ILoggerFactory
и вызываете метод CreateLogger() для ILoggerFactory, когда вам ну -
жен ILogger. Фабрика создает ILogger, который обертывает каждого
из поставщиков, а поэтому, когда вы вызываете метод Log(), журнал
записывается в каждого поставщика.
Схема на рис. 17.3 позволяет легко добавлять или изменять место, куда
ваше приложение пишет сообщения журнала, не изменяя при этом код
приложения. В следующем листинге показан весь код, необходимый для
добавления ILoggerProvider, который осуществляет журналирование
в консоль.
Листинг 17.1  Добавление поставщика журналов консоли к IHost
в файле Program.cs
public class Program
{
public static void Main(string[] args)
{
CreateHostBuilder(args).Build().Run();
}
public static IHostBuilder CreateHostBuilder(string[] args) =>
new HostBuilder()
.ConfigureLogging(builder =>builder.AddConsole())
.ConfigureWebHostDefaults(webBuilder =>
{
webBuilder.UseStartup<Startup>();
});
}
ПРИМЕЧАНИЕ  Средство ведения журнала в консоли по умолча-
нию добавляется в метод CreateDefaultBuilder, как будет показано
в разделе 17.3.Добавляем новых поставщиков
с по мощью метода расширения
ConfigureLogging.

636 Глава 17 Мониторинг и устранение ошибок с помощью журналирования
Помимо этой конфигурации для IHostBuilder, вы не взаимодействуе-
те с экземплярами ILoggerProvider напрямую. Вместо этого вы пишете
сообщения в журналы, используя экземпляр ILogger. Об этом в следую-
щем разделе.
Настройка ILogger
Использование ILoggerAddConsole()
AddEventLog()ConsoleLoggerProvider
EventLogLoggerProvider
ILoggerFactory
ILogger
ILoggerCreateLogger()
ConsoleLogger
ConsoleLoggerEventLogLogger
EventLogLoggerLog()Log()
Log()Console.Write()
EventLog.Log()ILoggerProvider
регистрируется
в ILoggerFactory
с использованием
методов расширенияILoggerProvider используются
для создания средств ведения
журналов, которые ведут запись
в определенное место назначения Поставщик средства ведения
журнала для консоли создает
средство ведения журнала,
которое пишет данные в консоль
При вызове метода CreateLogger
интерфейса ILoggerFactory вы
вызываете CreateLogger для каждого
поставщика и создаете экземпляр
ILogger, который обертывает каждую
реализацию средства ведения журнала
Вызов метода Log() интерфейса
ILogger записывает сообщение
в каждое место назначения обернутого
средства ведения журналаПоставщик средства ведения
журналов EventLog создает
средство ведения журнала,
которое пишет сообщения
в журнал событий Windows
Рис. 17.3 Компоненты фреймворка журналирования ASP.NET Core. Вы регистрируете
поставщиков журналирования с по мощью ILoggerFactory, который используется для
создания реализаций ILogger, и пишете сообщения в журналы в ILogger, который использует
реализации ILogger для вывода журналов в консоль или файл. Такая схема позволяет
отправлять журналы в несколько местоположений без необходимости настраивать их при
создании сообщения журнала
17.2 Добавление сообщений журнала в приложение
В этом разделе мы подробно рассмотрим, как создавать сообщения жур-
нала в собственном приложении. Вы узнаете, как создать экземпляр ILog-

637 Добавление сообщений журнала в приложение
ger и использовать его для добавления журналов в существующее при-
ложение. Наконец, мы рассмотрим свойства, из которых состоит запись
журналирования, что они означают и для чего их можно использовать.
Журналирование, как и почти все в ASP .NET Core, доступно через внед-
рение зависимостей. Чтобы добавить его в свои сервисы, нужно только
внедрить экземпляр ILogger<T>, где T – тип вашего сервиса.
ПРИМЕЧАНИЕ  При внедрении ILogger<T> контейнер внедре-
ния зависимостей косвенно вызывает метод ILoggerFactory.
Crea te Logger<T>() для создания обернутого ILogger, показанного
на рис. 17.3. В разделе 17.2.2 вы увидите, как работать напрямую
с ILog gerFactory, если предпочитаете. Интерфейс ILogger<T> также
реализует необобщенный интерфейс ILogger, но добавляет допол-
нительные удобные методы.
Можно использовать внедренный экземпляр ILogger для создания
сообщений журнала, которые он записывает в  каждый сконфигуриро-
ванный ILoggerProvider. В следующем листинге показано, как внедрить
экземпляр ILogger<> в PageModel страницы Index.cshtml для приложения
с рецептами из предыдущих глав и написать сообщение журнала с ука-
занием количества найденных рецептов.
Листинг 17.2 Внедрение ILogger в класс и запись сообщения журнала
public class IndexModel : PageModel
{
private readonly RecipeService _service;
private readonly ILogger<IndexModel> _log;
public ICollection<RecipeSummaryViewModel> Recipes { get; set; }
public IndexModel(
RecipeService service,
ILogger<IndexModel> log)
{
_service = service;
_log = log;
}
public void OnGet()
{
Recipes = _service.GetRecipes();
_log.LogInformation(
"Loaded {RecipeCount} recipes", Recipes.Count);
}
}
В этом примере используется один из множества методов расшире-
ния ILogger для создания сообщения журнала, LogInformation(). В  ILog-
ger есть много методов расширения, позволяющих с легкостью указать
LogLevel для сообщения.Внедряет
обобщенный
интерфейс
ILogger<T>
с по мощью
внедрения
зависимостей,
который
реализует
ILogger.
Ведет запись в журнал уровня Information.
В сообщении подставляется переменная RecipeCount.

638 Глава 17 Мониторинг и устранение ошибок с помощью журналирования
ОПРЕДЕЛЕНИЕ  Уровень	 сообщения	 журнала – то, насколько важ -
но сообщение. Он определяется перечислением LogLevel. У каждо-
го сообщения есть уровень.
Также видно, что у сообщения, которое вы передаете методу LogInfor-
mation, есть заполнитель (placeholder), обозначенный фигурными скоб-
ками, {RecipeCount}, и вы передаете дополнительный параметр, Recipes.
Count, средству ведения журнала. Тот заменяет заполнитель параметром
во время выполнения. Заполнители совпадают с  параметрами по рас -
положению, поэтому если включить сюда два заполнителя, например, то
второй заполнитель совпадет со вторым параметром.
СОВЕТ  Для создания сообщения журнала можно было бы ис -
пользовать обычную интерполяцию строк, например $"Loaded
{Recipes.Count} recipes". Но я  рекомендую всегда использовать
заполнители, поскольку они предоставляют дополнительную
информацию для средства ведения журнала, которую можно ис -
пользовать для структурного журналирования, как будет показано
в разделе 17.5.
ILogger пишет сообщение во все настроенные поставщики журна-
лирования при выполнении обработчика страницы OnGet в IndexModel.
Точный формат сообщения журнала будет отличаться в  зависимости
от поставщика, но на рис. 17.4 показано, как поставщик консоли будет
отобра жать сообщение журнала из листинга 17.2.
Уровень сообщения
журнала Категория события
Сообщение журналаID события
Рис. 17.4 Пример сообщения журнала, записанного в поставщик консоли по
умолчанию. Уровень сообщения журнала предоставляет информацию о том,
насколько важно сообщение и где оно было сгенерировано. EventId позволяет
идентифицировать похожие сообщения журнала
Точный вид сообщения будет зависеть от того, куда оно пишется, но
каждая запись включает в себя до шести общих элементов:
уровень	сообщения	 журнала – уровень сообщения журнала зависит от
того, насколько он важен, и определяется перечислением LogLevel;
категория	 события – категория может быть любым строковым зна-
чением, но обычно задается как полное имя класса, создающего со-
общение. Для ILogger<T> полное имя типа T – это категория;
сообщение – это содержание сообщения журнала. Это может быть
статическая строка, или оно может содержать заполнители для пе-
ременных, как показано в листинге 17.2. Заполнители обозначены

639 Добавление сообщений журнала в приложение
фигурными скобками, {}, и заменяются предоставленными значе-
ниями параметров;
параметры – если сообщение содержит заполнители, они ассоции-
руются с указанными параметрами. Для примера из листинга 17.2
значение Recipes.Count назначается заполнителю RecipeCount. Не -
которые средства ведения журналов могут извлекать эти значения
и предоставлять их в журналах, как будет показано в разделе 17.5;
исключение – если возникает исключение, вы можете передать объ-
ект исключения функции журналирования наряду с  сообщением
и другими параметрами. Регистратор зарегистрирует исключение
в дополнение к самому сообщению;
EventId  – это необязательный целочисленный идентификатор
ошибки, который можно использовать, чтобы быстро найти все по-
хожие журналы в серии сообщений. Можно использовать EventId,
равный 1000, когда пользователь пытается загрузить несуществу -
ющий рецепт, и  EventId, равный 1001, когда пользователь пытается
получить доступ к рецепту, когда у него нет соответствующих пол-
номочий на это. Если вы не укажете EventId, будет использоваться
значение 0.
Не каждое сообщение журнала будет содержать все эти элементы –
у вас не всегда будет исключение или параметры, например. Существуют
различные перегруженные варианты методов журналирования, кото-
рые принимают эти элементы как дополнительные параметры метода.
Помимо этих необязательных элементов, у каждого сообщения будет как
минимум уровень, категория и сообщение. Это ключевые характеристи-
ки журнала, поэтому мы рассмотрим каждую из них по очереди.
17.2.1 Уровень сообщения журнала: насколько важно
сообщение журнала?
Всякий раз, когда вы создаете журнал с  по мощью ILogger, вы должны
указать уровень	сообщения	 журнала. Он указывает, насколько серьезным
или важным является сообщение журнала, а это важный фактор, когда
дело доходит до фильтрации сообщений журналов, которые пишет по-
ставщик, а также для поиска важных сообщений постфактум.
Вы можете создать сообщение журнала уровня Information, когда
пользователь начинает редактировать рецепт. Это полезно для отслежи-
вания потока и поведения приложения, но это не является чем-то важ -
ным, потому что все идет нормально. Однако при возбуждении исключе-
ния, когда пользователь пытается сохранить рецепт, вы можете создать
сообщение журнала уровня Warning или Error.
Уровень сообщения журнала обычно задается с по мощью одного из
нескольких методов расширения интерфейса ILogger, как показано
в лис  тинге 17.3. В  этом примере создается сообщение журнала уровня
Information, когда выполняется метод View, и  ошибка уровня Warning,
если запрашиваемый рецепт не найден.

640 Глава 17 Мониторинг и устранение ошибок с помощью журналирования
Листинг 17.3  Определение уровня сообщения журнала
с использованием методов расширения ILogger
private readonly ILogger _log;
public async IActionResult OnGet(int id)
{
_log.LogInformation(
"Loading recipe with id {RecipeId}", id);
Recipe = _service.GetRecipeDetail(id);
if (Recipe is null)
{
_log.LogWarning(
"Could not find recipe with id {RecipeId}", id);
return NotFound();
}
return Page();
}
Методы расширения LogInformation и  LogWarning создают сообщения
журнала с  уровнем Information и  Warning соответственно. Существует
шесть уровней. Здесь они отсортированы в порядке убывания, от наи-
более серьезного до наименее серьезного:
Critical – для катастрофических сбоев, которые могут сделать не-
возможной правильную работу приложения, например исключения
из-за нехватки памяти или если на жестком диске нет места или
горит сервер;
Error – для ошибок и исключений, которые вы не можете обрабо-
тать корректно. Например, исключения, возникающие при сохра-
нении отредактированной сущности в  EF Core. Операция не уда-
лась, но приложение может продолжить работу для других запросов
и пользователей;
Warning – если возникает непредвиденная ситуация или ошибка, ко-
торую вы можете обработать. Вы можете использовать этот уровень
для обработанных исключений или если сущность не найдена, как
в листинге 17.3;
Information  – для отслеживания обычного потока приложений,
например когда пользователь выполняет вход или просматрива-
ет определенную страницу в  вашем приложении. Обычно эти со-
общения журнала предоставляют контекст, когда вам нужно понять
шаги, ведущие к появлению сообщения об ошибке;
Debug – для отслеживания подробной информации, которая особен-
но полезна во время разработки. Обычно это приносит лишь крат -
косрочную пользу;
Trace – для отслеживания очень подробной информации, которая
может содержать конфиденциальные данные, такие как пароли или
ключи. Редко используется и вообще не используется библиотеками
фреймворков.Экземпляр ILogger внедряется в контроллер
с по мощью внедрения в конструктор.
Записывает в журнал сообщение
уровня Information.
Записывает в журнал
сообщение уровня
Warning.

641 Добавление сообщений журнала в приложение
Можно представить эти уровни в  виде пирамиды, как показано на
рис. 17.5. По мере продвижения вниз по уровням важность сообщений
снижается, а  частота повышается. Как правило, вы будете встречать
в своем приложении много сообщений журнала уровня Debug, но (наде-
юсь) всего лишь несколько сообщений уровня Critical или Error.
Катастрофические ошибки, из-за которых
приложение может перестать работать
Необработанные ошибки и исключения,
не влияющие на другие запросы
Неожиданные состояния, которые можно обойти,
например обработанные исключения
Для отслеживания нормального потока
приложений
Для отслеживания подробной информации,
особенно во время разработки
Для очень подробной
конфиденциальной информации;
используется редко
Рис. 17.5 Пирамида уровней сообщения журнала. Сообщения с уровнем около
основания пирамиды используются чаще, но менее важны. Сообщения с уровнем
ближе к верхнему должны быть редкими, но важными
Эта пирамида становится более значимой, если посмотреть на фильт -
рацию в  разделе 17.4. Когда приложение находится в  промышленном
окружении, обычно не нужно записывать все сообщения уровня Debug,
генерируемые вашим приложением. Было бы утомительно разбираться
в таком огромном объеме сообщений, и в конечном итоге ваш диск за-
полнился бы сообщениями, гласящими: «Все в порядке!» Кроме того, со-
общения уровня Trace не должны быть активированы в промышленном
окружении, поскольку это может привести к утечке конфиденциальных
данных. Отфильтровывая нижние уровни журнала, вы гарантируете,
что создаете нормальное количество журналов в промышленном окру -
жении, но имеете доступ ко всем уровням журнала в  окружении раз-
работки.
В целом сообщения журнала более высокого уровня более важны, чем
сообщения более низкого уровня, поэтому сообщения уровня Warning
важнее сообщений уровня Information, но нужно учитывать еще один
аспект. Откуда пришло сообщение или кто его создал – это ключевая ин-
формация, которая записывается с каждым сообщением журнала и на-
зывается категорией.

642 Глава 17 Мониторинг и устранение ошибок с помощью журналирования
17.2.2 Категория сообщения журнала: какой компонент
создал журнал
Помимо уровня сообщения журнала, у  каждого сообщения также есть
категория. Вы задаете уровень самостоятельно для каждого сообщения
журнала, но категория задается при создании экземпляра ILogger. Как
и уровни, категория особенно полезна для фильтрации, как будет пока-
зано в разделе 17.4. Она записывается в каждое сообщение журнала, как
показано на рис. 17.6.
Каждое сообщение
журнала имеет связанную
категорию
Для категории обычно
задается имя класса,
создающего сообщение
журнала
Рис. 17.6 У каждого сообщения журнала есть ассоциированная категория. Обычно
это имя класса компонента, создающего журнал. Поставщик журналирования
консоли по умолчанию выводит категорию сообщения для каждого журнала
Категория представляет собой объект типа string, поэтому вы можете
задать для нее любое значение, но по соглашению это должно быть пол-
ное имя типа, использующего ILogger. В разделе 17.2 я сделал это путем
внедрения ILogger<T> в  RecipeController; чтобы задать категорию ILog-
ger, используется обобщенный параметр T.
В качестве альтернативы можно внедрить в свои методы ILoggerFac-
tory и передать явную категорию при создании экземпляра ILogger. Это
позволяет изменить категорию на произвольную строку.
Листинг 17.4  Внедрение ILoggerFactory для использования
специальной категории
public class RecipeService
{
private readonly ILogger _log;
public RecipeService(ILoggerFactory factory)
{
_log = factory.CreateLogger("RecipeApp.RecipeService");
}
}
Также существует перегруженный вариант метода CreateLogger()
с  обобщенным параметром, который использует предоставленный
класс, чтобы задать категорию. Если RecipeService в листинге 17.4 на-Внедряет экземпляр ILoggerFactory
вместо экземпляра ILogger напрямую.
Передает категорию в качестве объекта
типа string при вызове метода CreateLogger.

643 Добавление сообщений журнала в приложение
ходился бы в пространстве имен RecipeApp, вызов CreateLogger можно
было бы записать как
_log = factory.CreateLogger<RecipeService>();
Точно так же последний экземпляр ILogger, созданный этим вызовом,
будет таким же, как если бы вы напрямую внедрили ILogger<RecipeSer-
vice> вместо ILoggerFactory.
СОВЕТ  Если вы по какой-то причине не используете свои кате-
гории в большом количестве, отдавайте предпочтение внедрению
ILogger<T> в свои методы через ILoggerFactory.
Последняя обязательная часть каждой записи журнала довольно оче-
видна: сообщение	 журнала. На самом простом уровне это может быть лю-
бая строка, но стоит хорошенько подумать, какую информацию было бы
полезно записать. Это может быть любая информация, которая поможет
вам позже диагностировать проблемы.
17.2.3 Форматирование сообщений и сбор значений
параметров
Каждый раз, когда вы создаете запись в журнале, то должны предоста-
вить сообщение. Это может быть любая строка, которая вам нравится, но,
как вы видели в листинге 17.2, вы также можете включить сюда заполни-
тели, обозначенные фигурными скобками, {}, в строке сообщения:
_log.LogInformation("Loaded {RecipeCount} recipes", Recipes.Count);
Включение заполнителя и значения параметра в сообщение журнала
по сути создает пару «ключ-значение», которую некоторые поставщи-
ки журналирования могут хранить в качестве дополнительной инфор-
мации, ассоциированной с журналом. Предыдущее сообщение журнала
присваивает значение Recipes.Count ключу, RecipeCount, а само сообще-
ние журнала создается путем замены заполнителя значением парамет -
ра, чтобы получить следующее (где Recipes.Count=3):
"Loaded 3 recipes"
Вы можете включить несколько заполнителей в сообщение журнала,
и они будут ассоциированы с дополнительными параметрами, передан-
ными методу журнала. Порядок заполнителей в строке форматирования
должен соответствовать порядку предоставленных вами параметров.
ПРЕДУПРЕЖДЕНИЕ  Вы должны передать в  метод журнала как
минимум столько же параметров, сколько есть заполнителей в со-
общении. Если вы не передали достаточно параметров, то полу -
чите исключение во время выполнения.

644 Глава 17 Мониторинг и устранение ошибок с помощью журналирования
Например, сообщение журнала
_log.LogInformation("User {UserId} loaded recipe {RecipeId}", 123, 456)
создаст параметры UserId=123 и RecipeId=456. Поставщики структурного
журналирования могут хранить эти значения в дополнение к отформати-
рованному сообщению журнала "User 123 loaded recipe 456". Это упро-
щает поиск в журнальных записях определенного UserId или RecipeId.
ОПРЕДЕЛЕНИЕ  Структурное, 	или	семантическое, 	журналирова-
ние добавляет к сообщениям журнала дополнительную структуру,
чтобы сделать их более доступными для поиска и  фильтрации.
Вместо того чтобы хранить только текст, он хранит дополни-
тельную контекстную информацию, обычно в  виде пар «ключ-
значение». JSON – распространенный формат, используемый для
сообщений структурного журнала, поскольку обладает всеми эти-
ми свойствами.
Не все поставщики используют семантическое журналирование. Про-
вайдер консоли по умолчанию, например, нет  – сообщение формати-
руется так, чтобы заменить заполнители, но поиск в консоли по парам
«ключ-значение» невозможен.
Но даже если изначально вы не используете структурное журналиро-
вание, я рекомендую писать сообщения журнала, как если бы вы их ис -
пользовали, с явными заполнителями и параметрами. Таким образом,
если вы решите добавить поставщика структурного журналирования
позже, то сразу увидите преимущества. Кроме того, я считаю, что, раз-
мышляя о параметрах, которые вы можете записывать таким образом,
вы придете к выводу записать больше значений параметров, а не только
сообщение журнала.
Нет ничего более неприятного, чем увидеть сообщение типа "Cannot
insert record due to duplicate key" (Не удается вставить запись из-за дуб-
лирования ключа), но значение ключа не указано!
СОВЕТ  В целом я поклонник интерполированных строк C#6, но
не используйте их для сообщений журнала, если заполнитель и па-
раметр тоже имеют смысл. Использование заполнителей вместо
интерполированных строк даст вам то же самое выходное сообще-
ние, а также создаст пары «ключ-значение», в которых можно вес -
ти поиск позже.
Мы уже достаточно изучили, как создавать сообщения журнала в при-
ложении, но не рассматривали, куда пишутся эти сообщения. В следую-
щем разделе мы рассмотрим встроенные поставщики журналирования
ASP .NET Core, как они настраиваются и как заменить их на стороннего
поставщика.

645 Контроль места записи журналов с помощью поставщиков журналирования
17.3 Контроль места записи журналов с помощью
поставщиков журналирования
В этом разделе вы узнаете, как контролировать, куда записываются со-
общения журнала, добавляя дополнительные ILoggerProvider в  свое
приложение. В качестве примера вы увидите, как добавить простого по-
ставщика файлового средства ведения журнала, который пишет ваши
сообщения журнала в файл, в дополнение к существующему поставщику
средства ведения журнала в консоли. В разделе 17.3.2 вы узнаете, как по-
менять местами инфраструктуру журналирования по умолчанию полно-
стью на альтернативную реализацию, используя библиотеку Serilog с от -
крытым исходным кодом.
До этого момента мы записывали все сообщения журнала в консоль.
Если вы запускали все примеры приложений ASP .NET Core локально, то,
вероятно, уже видели сообщения журнала, записанные в окно консоли.
ПРИМЕЧАНИЕ  Если вы используете Visual Studio и выполняете
отладку с по мощью IIS Express (по умолчанию), то не увидите окно
консоли (хотя сообщения журнала записываются в  окно Debug
Output). По этой причине я обычно проверяю, что выбираю имя
приложения из раскрывающегося списка в панели инструментов
отладки вместо IIS Express.
Запись сообщений журнала в консоль – это замечательно, когда вы вы-
полняете отладку, но это не так уж и полезно для промышленного окру -
жения. Никто не будет контролировать окно консоли на сервере, и жур-
налы не будут нигде сохраняться и будут недоступны для поиска. Ясно,
что вам нужно будет писать сообщения для промышленного окружения
в другое место.
Как вы видели в разделе 17.1, поставщики	 журналирования контроли-
руют место назначения ваших сообщений в ASP .NET Core. Они прини-
мают сообщения, которые вы создаете с по мощью интерфейса ILogger,
и записывают их в место вывода, которое зависит от поставщика.
ПРИМЕЧАНИЕ  Это название всегда меня удивляет – поставщик
журналирования по сути потребляет создаваемые вами сообще-
ния и выводит их в место назначения. Вероятно, вы можете уви-
деть происхождение этого названия из рис. 17.3, но я все же считаю
его несколько нелогичным.
Microsoft написала несколько собственных поставщиков журналиро-
вания для ASP .NET Core, доступных прямо из коробки. Сюда входят:
поставщик	 консоли – записывает сообщения в консоль, как вы уже
видели;

646 Глава 17 Мониторинг и устранение ошибок с помощью журналирования
поставщик отладки – 	записывает сообщения в окно отладки при от -
ладке приложения в Visual Studio или Visual Studio Code, например;
поставщик	 журнала	 событий – записывает сообщения в журнал со-
бытий Windows. Сообщения журнала записываются только при рабо-
те в Windows, поскольку для этого требуются API лишь для Windows;
поставщик EventSource – пишет сообщения с по мощью Event Tracing
for Windows (ETW) или LTTng в Linux.
Существует также множество сторонних реализаций поставщиков
журналирования, таких как Azure App Service, elmah.io и  Elasticsearch.
Помимо этого, существуют интеграции с другими уже существующими
фреймворками для журналирования, такими как NLog и Serilog. Всегда
стоит проверить, есть ли у вашей любимой библиотеки или службы жур-
налирования .NET поставщик для ASP .NET Core.
Поставщиков журналирования для своего приложения можно настро-
ить в файле Program.cs с по мощью класса HostBuilder. Вспомогательный
метод CreateDefaultBuilder настраивает консоль и поставщиков отладки
для вашего приложения автоматически, но, вероятно, вы захотите что-
то изменить или добавить своих поставщиков.
Есть два варианта настройки журналирования для приложения:
использовать собственный экземпляр HostBuilder вместо Host.Cre-
ateDefaultBuilder и настроить его явно;
добавить дополнительный вызов метода ConfigureLogging после
метода CreateDefaultBuilder.
Если вам нужно только настроить журналирование, последний под-
ход проще. Но если обнаружится, что вам также нужно настроить другие
аспекты HostBuilder, созданные CreateDefaultBuilder (например, на-
стройки конфигурации вашего приложения), возможно, стоит отказать-
ся от метода CreateDefaultBuilder и создать собственный экземпляр.
В разделе 17.3.1 я покажу, как добавить простой сторонний поставщик
журналирования в свое приложение, который пишет сообщения журнала
в файл, чтобы ваши журналы сохранялись. В разделе 17.3.2 я покажу, как
сделать еще один шаг и заменить ILoggerFactory по умолчанию в ASP .
NET Core альтернативной реализацией с  использованием популярной
библиотеки с открытым исходным кодом Serilog.
17.3.1 Добавление нового поставщика журналирования
в приложение
В этом разделе мы добавим поставщика журналирования, который ве-
дет запись в изменяемый (rolling) файл. Таким образом, наше прило-
жение ежедневно записывает сообщения журнала в  новый файл. Мы
продолжим вести журналы, используя поставщиков консоли и отладки,
потому что они более полезны, чем поставщик файлов при локальной
разработке.
Чтобы добавить стороннего поставщика журналирования в ASP .NET
Core, выполните следующие действия.

647 Контроль места записи журналов с помощью поставщиков журналирования
1  Добавьте в решение пакет провайдера журналирования NuGet. Я буду
использовать поставщика NetEscapades.Extensions.Logging.Rolling-
File, доступного на NuGet и GitHub. Вы можете добавить его в свое
решение с по мощью Диспетчера пакетов NuGet в Visual Studio или
с по мощью интерфейса командной строки .NET, выполнив команду
dotnet add package NetEscapades.Extensions.Logging.RollingFile
из папки проекта своего приложения.
ПРИМЕЧАНИЕ  Этот пакет представляет собой простого по-
ставщика журналирования файлов, доступного по адресу https://
github.com/andrewlock/NetEscapades.Extensions.Logging. Он осно-
ван на поставщике журналирования Azure App Service. Если вам
нужно больше контроля над журналами, например вы хотите
указать формат файла, рассмотрите возможность использования
Serilog, как описано в разделе 17.3.2.
2  Добавьте поставщика с по мощью расширения метода IHostBuild-
er.ConfigureLogging(). Вы можете добавить поставщика фай-
лов, вызвав метод AddFile(), как показано в  следующем списке.
AddFile() – это метод расширения, предоставляемый пакетом по-
ставщика журналирования, чтобы упростить добавление постав-
щика в приложение.
Листинг 17.5  Добавление стороннего поставщика журналирования
в IHostBuilder
public class Program
{
public static void Main(string[] args)
{
CreateHostBuilder(args).Build().Run();
}
public static IHostBuilder CreateHostBuilder(string[] args) =>
Host.CreateDefaultBuilder(args)
.ConfigureLogging(builder => builder.AddFile())
.ConfigureWebHostDefaults(webBuilder =>
{
webBuilder.UseStartup<Startup>();
});
}
ПРИМЕЧАНИЕ  Добавление нового поставщика не заменяет уже
существующих. В  листинге 17.5 используется вспомогательный
метод CreateDefaultBuilder, поэтому поставщики консоли и  от -
ладки уже добавлены. Чтобы удалить их, вызовите метод builder.
ClearProviders() в  начале метода ConfigureLogging или исполь-
зуйте специальный HostBuilder.Метод CreateDefaultBuilder
настраивает поставщиков консоли
и отладки, как обычно.
Добавляет нового поставщика
журналирования файлов
в фабрику регистратора.

648 Глава 17 Мониторинг и устранение ошибок с помощью журналирования
После настройки поставщика файлов вы можете запустить приложе-
ние и сгенерировать журналы. Каждый раз, когда ваше приложение за-
писывает сообщение в  журнал с  использованием экземпляра ILogger,
ILogger пишет сообщение всем настроенным поставщикам, как показа-
но на рис. 17.7. Cообщения в консоли остались доступны, но у вас также
есть постоянная запись журналов, хранящаяся в файле.
СОВЕТ  По умолчанию поставщик файлов пишет сообщения жур-
нала в подкаталог вашего приложения. Вы можете указать допол-
нительные параметры, такие как имена файлов и ограничения на
размер файла с использованием перегруженных вариантов мето-
да AddFile(). Для промышленного окружения я  рекомендую ис -
пользовать более авторитетного поставщика, такого как Serilog.
Log() Log()Log()
Log()Console.Write()
Debug.Write()
File.AppendText()ILoggerConsoleLogger
DebugLogger
FileLoggerПри вызове метода Log() интерфейса
ILogger записывается сообщение
в каждый из сконфигурированных
поставщиков журналирования
Рис. 17.7  Записывая сообщение в журнал, ILogger ведет запись с использованием
всех настроенных поставщиков. Это позволяет, например, записывать удобное
сообщение в консоль, сохраняя при этом журналы в файл
Ключевой вывод, который можно сделать из листинга 17.5, заключает -
ся в том, что система поставщиков упрощает интеграцию существующих
фреймворков и поставщиков журналирования с абстракциями журнали-
рования ASP .NET Core. Какого бы поставщика вы ни выбрали для исполь-
зования в своем приложении, принципы остаются прежними: вызовите
метод ConfigureLogging для IHostBuilder и добавьте нового поставщика
журналирования, используя в  этом случае методы расширения, такие
как AddConsole() или AddFile().
Запись сообщений вашего приложения в  файл может быть полезна
в  некоторых сценариях, и,  конечно, это лучше, чем использовать для

649 Контроль места записи журналов с помощью поставщиков журналирования
данной цели несуществующее окно консоли в промышленном окруже-
нии, но это по-прежнему, возможно, не лучший вариант.
Если вы обнаружили ошибку в промышленном окружении и вам нуж -
но быстро просмотреть журналы, чтобы выяснить, что произошло, на-
пример нужно войти на удаленный сервер, найти файлы журналов на
диске и пролистать их, чтобы найти проблему. Если у вас несколько веб-
серверов, вам предстоит гигантская работа по получению всех журна-
лов, прежде чем вы сможете приступить к устранению ошибки. Звучит
невесело. Добавьте к  этому возможность проблем с  правами доступа
к файлам или дискового пространства, и журналирование файлов будет
казаться не таким уж и привлекательным.
Вместо этого часто лучше отправлять журналы в  централизованное
место, отдельно от приложения. Точное расположение этого места зави-
сит от вас; суть в том, что каждый экземпляр вашего приложения отправ-
ляет свои журналы в одно и то же место, отдельно от самого приложения.
Если вы запускаете приложение в Azure, то получаете централизован-
ное журналирование бесплатно, потому что можете собирать журналы
с по мощью поставщика Azure App Service. В качестве альтернативы мож -
но отправить свои журналы стороннему агрегатору журналов, например
Loggr (http://loggr.net), elmah.io (https://elmah.io/) или Seq (https://getseq.
net/). Вы можете найти поставщиков журналирования для каждого из
этих сервисов в NuGet, поэтому их добавление ничем не отличается от
добавления поставщика файлов, которое вы уже видели.
Еще один популярный вариант  – использовать библиотеку Serilog
с открытым исходным кодом для одновременной записи в разные места.
В  следующем разделе я  покажу, как заменить реализацию ILoggerFac-
tory по умолчанию на Serilog в  своем приложении, открывая для себя
широкий спектр возможных вариантов того, куда писать сообщения.
17.3.2 Замена ILoggerFactory по умолчанию на Serilog
В этом разделе мы заменим интерфейс ILoggerFactory, использующийся
по умолчанию в приложении рецептов, на реализацию, использующую
Serilog. Serilog (https://serilog.net) – проект с открытым исходным кодом,
который может записывать сообщения в разные места, такие как файлы,
консоль, кластер Elasticsearch1, или базу данных. Это похоже на функцио-
нальность, которую вы получаете с  ILoggerFactory по умолчанию, но
благодаря возможностям Serilog вы можете обнаружить, что у вас есть
больше мест, куда можно вести запись.
Serilog появился раньше ASP .NET Core, но благодаря абстракциям жур-
налирования вокруг интерфейсов ILoggerFactory и  ILoggerProvider вы
можете легко интегрироваться с Serilog, используя абстракции ILogger
в коде своего приложения.
1 Elasticsearch – это поисковая система на основе REST, которая часто исполь-
зуется для агрегирования журналов. Более подробную информацию можно
узнать на странице www.elastic.co/elasticsearch/.

650 Глава 17 Мониторинг и устранение ошибок с помощью журналирования
Serilog использует ту же философию проектирования, что и абстрак -
ции журналирования ASP .NET Core, – вы записываете журналы в цент -
ральный объект журналирования, и сообщения журнала записываются
в несколько мест, такие как консоль или файл. В Serilog каждое из таких
мест называется получателем	данных1.
Когда вы используете Serilog с  ASP .NET Core, то обычно заменяете
ILog gerFactory по умолчанию на специальную фабрику, содержащую
одного поставщика, SerilogLoggerProvider. Этот поставщик может вести
запись в несколько мест, как показано на рис. 17.8. Такая конфигурация
несколько отличается от стандартной настройки журналирования ASP .
NET. Core, но предотвращает конфликт функций Serilog с эквивалентны-
ми функциями LoggerFactory по умолчанию, такими как фильтрация.
ConsoleLoggerProvider
FileLoggerProvider
EventLogLoggerProvider
ILoggerFactory
SerilogLoggerFactory:
ILoggerFactorySerilogLoggerProviderSerilog.Sinks.Console
Serilog.Sinks.RollingFile
Serilog.Sinks.EventLogASP .NET Core по умолчанию
ASP .NET Core с Serilog
Получатели данных добавляются
в Serilog для каждого желаемого
вывода
SerilogLoggerFactory заменяет
ILoggerFactory по умолчанию. Он использует
одного зарегистрированного поставщика
журналирования – SerilogLoggerProvider
Сообщения журнала
записываются
в SerilogLoggerProvider,
который пишет их в каждый
получатель данныхILoggerProvider регистрируются
в ILoggerFactory, и каждый поставщик
пишет в единственный вывод
Рис. 17.8 Конфигурация при использовании Serilog с ASP.NET Core по сравнению
с конфигурацией по умолчанию. Вы можете достичь той же функциональности с помощью
обоих подходов, но можете обнаружить, что Serilog предоставляет дополнительные
библиотеки для добавления дополнительных функций
1 Полный список доступных получателей данных см. на странице https://github.
com/serilog/serilog/wiki/Provided-Sinks. На момент написания этой главы их
насчитывалось 93.

651 Контроль места записи журналов с помощью поставщиков журналирования
СОВЕТ  Если вы знакомы с Serilog, то можете использовать при-
меры из этого раздела, чтобы интегрировать рабочую конфигура-
цию Serilog с инфраструктурой журналирования ASP .NET Core.
В этом разделе мы добавим одного получателя данных для записи со-
общений журнала в консоль, но с использованием поставщика журна-
лирования Serilog вместо встроенного поставщика консоли. Как только
вы все настроите, будет просто добавить дополнительных получателей
данных для записи в другие места. Добавление поставщика журналиро-
вания Serilog в приложения включает в себя три шага:
1 добавьте в решение необходимые пакеты NuGet Serilog;
2  создайте средство ведения журнала Serilog и  настройте его, ис -
пользуя необходимых получателей данных;
3  вызовите метод UseSerilog() в  IHostBuilder, чтобы заменить реа-
лизацию ILoggerFactory по умолчанию на SerilogLoggerFactory.
Так вы автоматически настраиваете поставщика Serilog и подклю-
чаете уже настроенное средство ведения журнала Serilog.
Чтобы установить Serilog в приложение ASP .NET Core, необходимо до-
бавить базовый пакет NuGet и пакеты NuGet для всех нужных вам полу -
чателей данных. Это можно сделать через графический интерфейс поль-
зователя NuGet Visual Studio, используя PMC или интерфейс командной
строки .NET. Чтобы добавить пакет Serilog ASP .NET Core и  получатель
данных для записи в консоль, выполните эти команды:
dotnet add package Serilog.AspNetCore
dotnet add package Serilog.Sinks.Console
Так вы добавляете необходимые пакеты NuGet в файл проекта и вос -
станавливаете их. После этого создайте средство ведения журнала Serilog
и настройте его для записи в консоль, добавив получателя данных консо-
ли, как показано в листинге 17.6. Это самая простая конфигурация Seril-
og, но здесь также можно добавить дополнительных получателей данных
и конфигурацию1. Я также добавил блок try-catch-finally вокруг нашего
вызова метода CreateHostBuilder, чтобы гарантировать, что сообщения
по-прежнему записываются, если произошла ошибка при запуске веб-
хостинга или фатальное исключение. Наконец, вы настраиваете фабрику
регистратора Serilog путем вызова метода UseSerilog() в IHostBuilder.
Листинг 17.6  Настройка поставщика журналирования Serilog
для использования консоли
public class Program
{
public static void Main(string[] args)
1 Вы можете очень долго настраивать Serilog, поэтому стоит ознакомиться с до-
кументацией, чтобы увидеть возможные варианты. Wiki особенно полезна
в этом случае: htt ps://github.com/serilog/serilog/wiki/Configuration-Basics.

652 Глава 17 Мониторинг и устранение ошибок с помощью журналирования
{
Log.Logger = new LoggerConfiguration()
.WriteTo.Console()
.CreateLogger();
try
{
CreateHostBuilder(args).Build().Run();
}
catch (Exception ex)
{
Log.Fatal(ex, "Host terminated unexpectedly");
}
finally
{
Log.CloseAndFlush();
}
}
public static IHostBuilder CreateHostBuilder(string[] args) =>
Host.CreateDefaultBuilder(args)
.UseSerilog()
.ConfigureWebHostDefaults(webBuilder =>
{
webBuilder.UseStartup<Startup>();
});
}
Настроив поставщика журналирования Serilog, можно запустить при-
ложение и генерировать журналы. Каждый раз, когда приложение созда-
ет сообщение для журнала, ILogger записывает сообщение в поставщика
Serilog, который пишет его во все получатели данных. В листинге 17.6 вы
настроили только получателя данных консоли, поэтому результат будет
выглядеть примерно так, как показано на рис. 17.9. Получатель данных
консоли Serilog подкрашивает журналы больше, по сравнению со встро-
енным поставщиком консоли, поэтому я считаю, что так немного легче
разбираться с журналами визуально.
СОВЕТ  Помимо этого, у Serilog есть много замечательных функ -
ций. Одна из моих любимых – возможность добавлять обогати-
тели. Они автоматически добавляют информацию во все ваши
сообщения журналов, такие как идентификатор процесса или
переменные окружения, что может быть полезно при диагностике
проблем. Для более подробного ознакомления с рекомендуемым
способом настройки Serilog для приложений ASP .NET Core	см . пост
Николаса Блюмхардта, создателя Serilog, «Настройка Serilog в ASP .
NET Core 3»: http://mng.bz/Yqvz.
Serilog позволяет легко подключать дополнительных получателей
данных к приложению, почти так же, как и в случае с абстракциями ASP .Создает LoggerConfiguration для настройки
средства ведения журнала Serilog.
Serilog будет писать
сообщения журнала
в консоль.Это создает экземпляр средства
ведения журнала Serilog
статического свойства Log.Logger.
Регистрирует SerilogLoggerFactory
и подключает Log.Logger в качестве
единственного поставщика
журналирования.

653 Изменение избыточности сообщений журналов с по мощью фильтрации
NET Core по умолчанию. Независимо от того, решите ли вы использовать
Serilog или будете придерживаться других поставщиков, наборы функ -
ций очень похожи, хотя Serilog – более зрелое решение. Что бы вы ни
выбрали, как только вы начнете работать в промышленном окружении,
то быстро столкнетесь с другой проблемой: огромным количеством со-
общений журналов, которые генерирует ваше приложение!
Serilog подкрашивает
различные параметры,
передаваемые средству
ведения журнала
В отличие от поставщика
консоли по умолчанию,
он не отображает
категорию сообщения
журнала
Рис. 17.9 Пример вывода с использованием получателя данных Serilog
и получателя данных консоли. Здесь больше подсветки, чем у встроенного
поставщика, хотя по умолчанию он не отображает категорию для каждого
журнала
17.4 Изменение избыточности сообщений
журналов с по мощью фильтрации
В этом разделе вы увидите, как уменьшить количество сообщений жур-
нала, записываемых в  поставщики журналирования. Вы узнаете, как
применить фильтр базового уровня, отфильтровывать сообщения из
определенных пространств имен и использовать фильтры для конкрет -
ного поставщика журналирования.
Если вы уже экспериментировали с журналированием, то, вероятно,
заметили, что получаете большое количество сообщений, даже для од-
ного запроса, такого как на рис. 17.2: это сообщения от сервера Kestrel
и от EF Core, не говоря уже о собственных. Когда вы выполняете отлад-
ку локально, доступ ко всей этой информации чрезвычайно полезен, но
в промышленном окружении вы будете так поглощены шумом, что вам
будет непросто выбрать важные сообщения.
ASP .NET Core включает возможность фильтрации сообщений журнала
до того, как они будут написаны, основываясь на сочетании трех вещей:
уровень сообщения журнала;
категория средства ведения журнала (создавшего журнал);
поставщик журналирования.
Вы можете создать несколько правил, используя эти свойства, и для
каждого созданного журнала будет применяться наиболее конкретное
правило, чтобы определить, следует ли записывать сообщение журнала
в вывод. Можно создать три следующих правила:

654 Глава 17 Мониторинг и устранение ошибок с помощью журналирования
минимальный	 уровень	 сообщения	 журнала	 по	умолчанию  – Informa-
tion  – если другие правила не применяются, только сообщения
с уровнем Information или выше будут записываться в поставщики;
для	категорий, 	начинающихся	 со	слова	 Microsoft, 	минимальный	 уро-
вень – это Warning – любое средство ведения журнала, создаваемое
в пространстве имен, которое начинается со слова Microsoft, будет
записывать только те сообщения, которые имеют уровень Warning
или выше. Так вы отфильтровываете шумные сообщения фрейм-
ворка, которые видели на рис. 17.6;
для	поставщика	 консоли	 минимальный	 уровень – это Error – сообще-
ния журнала, записываемые в консоль поставщика, должны иметь
минимальный уровень Error. Сообщения с более низким уровнем
не будут писаться в  консоль, хотя они могут быть записаны с  ис -
пользованием других поставщиков.
Обычно цель фильтрации сообщений журналов  – уменьшить коли-
чество сообщений, записываемых в определенные поставщики или из
определенных пространств имен (в зависимости от категории журнала).
На рис.  17.10 показан возможный набор правил фильтрации, которые
применяются к поставщикам консоли и файлового журналирования.
[Information] Microsoft.AspNetCore.Hosting
Request Starting
Log()
Log() Log()ILogger
FileLogger ConsoleLogger
Фильтр ФильтрПриложение записывает сообщение
журнала в ILogger с категорией,
уровнем и сообщением
ILogger пишет сообщение
в каждый из поставщиков
Сообщение журнала сравнивается с правилами
фильтрации на основе поставщика, категории
и уровня
Поставщик соответствует
правилу 1, и уровень
сообщения журнала превышает
минимальный уровень, поэтому
сообщение записываетсяПоставщик и категория
соответствуют правилу 3,
но уровень сообщения журнала
меньше минимального уровня,
поэтому сообщение отбрасывается
Рис. 17.10 Применение правил фильтрации к сообщению журнала для определения
необходимости записи его в журнал. Для каждого поставщика выбирается самое конкретное
правило. Если журнал превышает требуемый минимальный уровень правил, поставщик ведет
запись в журнал; в противном случае он отбрасывает его

655 Изменение избыточности сообщений журналов с по мощью фильтрации
В этом примере средство ведения журнала для консоли явно ограни-
чивает сообщения, пишущиеся в пространстве имен  Microsoft уровнем
Warning или выше, поэтому журнал игнорирует показанное сообщение.
И наоборот, у средства ведения журнала для файлов нет правила, ко-
торое явно ограничивает пространство имен  Microsoft, поэтому он ис -
пользует настроенный минимальный уровень Information и записывает
сообщение журнала.
СОВЕТ  При решении, следует ли записывать сообщение в  жур-
нал, выбирается только одно правило; они не сочетаются. На
рис. 17.10 правило 1 считается более конкретным, чем правило 5,
поэтому сообщение записывается в поставщика файлов, хотя оба
они могут быть технически применимы.
Обычно набор правил журналирования для приложения определяется
с использованием многоуровневой конфигурации, описанной в главе 11,
потому что он позволяет легко использовать разные правила при рабо-
те в окружении разработки или промышленном окружении. Для этого
нужно вызвать метод AddConfiguration при настройке журналирования
в файле Program.cs, но метод CreateDefaultBuilder() также делает это за
вас автоматически.
В этом листинге показано, как добавить правила конфигурации в при-
ложение при настройке собственного HostBuilder, вместо того чтобы ис -
пользовать вспомогательный метод CreateDefaultBuilder.
Листинг 17.7  Загрузка конфигурации журналирования
в ConfigureLogging
public class Program
{
public static void Main(string[] args)
{
CreateHostBuilder(args).Build().Run();
}
public static IHostBuilder CreateHostBuilder(string[] args) =>
new HostBuilder()
.UseContentRoot(Directory.GetCurrentDirectory())
.ConfigureAppConfiguration(config =>
config.AddJsonFile("appsettings.json"))
.ConfigureLogging((ctx, builder) =>
{
builder.AddConfiguration(
ctx.Configuration.GetSection("Logging"));
builder.AddConsole();
})
.ConfigureWebHostDefaults(webBuilder =>
{
webBuilder.UseStartup<Startup>();
});
}Загружает значения
конфигурации из файла
appsettings.json.
Загружает конфигурацию
фильтрации журналов
из раздела Logging и добавляет
в ILoggingBuilder.Добавляет в приложение
поставщика консоли.

656 Глава 17 Мониторинг и устранение ошибок с помощью журналирования
В этом примере я  загрузил конфигурацию из одного файла appset -
tings.json, который содержит всю конфигурацию нашего приложения.
Конфигурация журналирования содержится именно в секции "Logging"
объекта IConfiguration, который доступен при вызове метода Configure-
logging().
СОВЕТ  Как было показано в главе 11, вы можете загружать пара-
метры конфигурации из нескольких источников, таких как файлы
JSON и переменные окружения. Это можно делать условно на ос -
нове IHostingEnvironment. Распространенной практикой является
включение параметров журналирования промышленного окру -
жения в файл appsettings.json, а переопределений для локального
окружения разработки – в файл appsettings.Development.json.
Раздел журналирования вашей конфигурации должен выглядеть при-
мерно так, как показано в следующем листинге, где видно, как опреде-
лить правила, показанные на рис. 17.10.
Листинг 17.8  Раздел конфигурации фильтрации журналов файла
appsettings.json
{
"Logging": {
"LogLevel": {
"Default": "Debug",
"System": "Warning",
"Microsoft": "Warning"
},
"File": {
"LogLevel": {
"Default": "Information"
}
},
"Console": {
"LogLevel": {
"Default": "Debug",
"Microsoft": "Warning"
}
}
}
}
При создании правил журналирования важно помнить, что если у вас
есть какие-либо правила для конкретного поставщика, они будут иметь
приоритет над правилами на основе категорий, определенными в сек -
ции "LogLevel". Следовательно, для конфигурации, определенной в лис -
тинге 17.8, если ваше приложение использует только поставщиков фай-
лов или консоли, правила в секции "LogLevel" никогда не применяются.
Если вас это сбивает с толку, не волнуйтесь – меня тоже. Каждый раз,
когда я настраиваю журналирование, я обращаюсь к алгоритму, исполь-Правила, которые будут применяться,
если для поставщика нет применимых правил.
Правила, которые будут применяться
к поставщику файлов.
Правила, которые будут применяться
к поставщику консоли.

657 Изменение избыточности сообщений журналов с по мощью фильтрации
зуемому для того, чтобы определить, какое правило будет применяться
для определенного поставщика и категории. Вот он:
1  Выбрать все правила для данного поставщика. Если правила не
применяются, выбрать все правила, которые не определяют по-
ставщика (верхняя секция "LogLevel" из листинга 17.8).
2  Из выбранных правил выбрать правила с самым длинным совпа-
дающим префиксом категории. Если ни одно из выбранных правил
не соответствует префиксу категории, выбрать "Default", если есть.
3 Если выбрано несколько правил, использовать последнее.
4  Если правила не выбраны, использовать глобальный минимальный
уровень "LogLevel:Default" (это Debug в листинге 17.8).
Каждый из этих шагов (кроме последнего) сужает применимые пра-
вила для сообщения журнала, пока не останется одно. Вы видели, как
это действует для категории "Microsoft" на рис. 17.10. На рис. 17.11 этот
процесс показан более подробно.
ConsoleLogger[Information] Microsoft.AspNetCore.Hosting
Request Starting
1.  Сохраняются только правила,
специфичные для поставщика. Если
для поставщика нет правил, будут
выбраны правила без поставщика
2.  Из выбранных правил выбирается
правило, наиболее близкое
к категории сообщения журнала. Если
ни одно правило не соответствует
категории, будет выбрано правило 4
3.  Если нет совпадений ни по одному
правилу, будет использоваться уровень
сообщения журнала по умолчанию
(правило 6). При совпадении правила 3
используется минимальный уровень
Warning
Рис. 17.11 Выбор правила для применения из доступного набора для поставщика
консоли и уровня Information. Каждый шаг уменьшает количество применяемых
правил, пока у вас не останется только одно
ВНИМАНИЕ!  Правила фильтрации сообщений журналов не объ-
единяются; выбирается одно правило. Включение правил для
конкретного поставщика переопределит глобальные правила для

658 Глава 17 Мониторинг и устранение ошибок с помощью журналирования
конкретных категорий, поэтому я стараюсь придерживаться пра-
вил для конкретных категорий в своих приложениях, чтобы общий
набор правил было легче понять.
После эффективной фильтрации ваши сообщения журналов для про-
мышленного окружения должны быть намного более управляемыми,
как показано на рис. 17.12. Обычно я считаю, что лучше ограничить со-
общения журналов из инфраструктуры ASP .NET Core и библиотеки, на
которые ссылаются, уровнем Warning или выше, сохраняя журналы, ко-
торые мое приложение записывает в  Debug в окружении разработки и  In-
formation в промышленном окружении.
Т олько сообщения журнала уровня
Warning или выше записываются классами
в пространствах имен, которые начинаются
с Microsoft или System
Сообщения журнала уровня Information
и выше создаются самим приложением
Рис. 17.12 Использование фильтрации для уменьшения количества записываемых сообщений
журналов. В этом примере фильтры категорий были добавлены в пространства имен Microsoft
и System, поэтому записываются только сообщения уровня Warning и выше. Это увеличивает
долю журналов, имеющих прямое отношение к вашему приложению
Это близко к конфигурации по умолчанию, используемой в шаблонах
ASP .NET Core. Может  оказаться, что вам нужно добавить дополнитель-
ные фильтры для конкретных категорий, в зависимости от используе-
мых библиотек NuGet и категорий, в которые они пишут. Обычно лучший
способ выяснить – это запустить приложение и посмотреть, не завалило
ли вас бесполезными сообщениями журнала.
Даже когда вы контролируете количество журналов, если вы будете
придерживаться поставщиков по умолчанию, таких как файловые жур-
налы или консоли, то, вероятно, пожалеете об этом в долгосрочной пер-
спективе. Эти поставщики отлично работают, но когда дело дойдет до
поиска конкретных сообщений об ошибках или анализа журналов, у вас
появится много работы. В следующем разделе вы увидите, как структур-
ное журналирование может помочь решить эту проблему.
17.5 Структурное журналирование:
создание полезных сообщений журналов
с возможностью поиска
В этом разделе вы узнаете, как структурное журналирование помога-
ет работать с сообщениями журнала. Вы научитесь прикреплять пары
«ключ-значение» к  сообщениям журнала, а  также научитесь хранить

659 Структурное журналирование: создание полезных сообщений журналов
и  запрашивать значения ключей с  по мощью поставщика структурно-
го журналирования Seq. Наконец, вы узнаете, как использовать области
для прикрепления пар «ключ-значение» ко всем сообщениям журнала
в блоке.
Представим, что вы развернули приложение с рецептами, над кото-
рым мы работаем в промышленном окружении. Вы добавили в прило-
жение журналирование, чтобы иметь возможность отслеживать любые
ошибки в своем приложении, и сохраняете журналы в файле.
Однажды клиент звонит вам и говорит, что не может увидеть свой ре-
цепт. Конечно, когда вы просматриваете сообщения журнала, то видите
предупреждение:
warn: RecipeApplication.Controllers.RecipeController[12]
Could not find recipe with id 3245
Это вызывает у вас интерес – почему это произошло? С этим клиентом
такое случалось раньше? Случалось ли такое раньше с этим рецептом?
Было ли такое с другими	рецептами? Случается ли такое регулярно?
Как бы вы ответили на эти вопросы? Учитывая, что журналы хранят -
ся в  текстовом файле, можно было бы приступить к  базовому поиску
в выбранном вами редакторе, разыскивая фразу "Could not find recipe
with id» (Не удалось найти рецепт с идентификатором). В зависимости
от ваших навыков работы с блокнотом вы, вероятно, могли бы получить
ответы на свои вопросы, но, скорее всего, это будет трудоемкий, подвер-
женный ошибкам и болезненный процесс.
Ограничивающим фактором является то, что журналы хранятся в виде
неструктурированного текста, поэтому обработка текста  – единствен-
ный доступный для вас вариант. Лучше хранить сообщения журналов
в  структурированном формате, чтобы их можно было легко запраши-
вать, фильтровать и создавать аналитику. Сообщения журналов, содер-
жащих структурированные данные, можно хранить в  любом формате,
но в наши дни для них обычно используется формат JSON. Например,
структурированная версия того же сообщения журнала с предупрежде-
нием могла бы выглядеть примерно так:
{
"eventLevel": "Warning",
"category": "RecipeApplication.Controllers.RecipeController",
"eventId": "12",
"messageTemplate": "Could not find recipe with {recipeId}",
"message": "Could not find recipe with id 3245",
"recipeId": "3245"
}
Это сообщение содержит все те же сведения, что и неструктурирован-
ная версия, но в формате, который позволит вам легко искать определен-
ные записи журнала. Это упрощает фильтрацию журналов по EventLevel,
или показ только тех журналов, которые относятся к  идентификатору
определенного рецепта.

660 Глава 17 Мониторинг и устранение ошибок с помощью журналирования
ПРИМЕЧАНИЕ  Это лишь пример того, как может выглядеть со-
общение журнала, содержащее структурированные данные. Фор-
мат, используемый для журналов, будет варьироваться в зависи-
мости от используемого поставщика, и это может быть что угодно.
Ключевым моментом является то, что свойства журнала доступны
в виде пары «ключ-значение».
Для добавления структурного журналирования в приложение требует -
ся поставщик, который может создавать и хранить сообщения журналов,
содержащих структурированные данные. Elasticsearch – популярная по-
исковая и аналитическая система, которую можно использовать для хра-
нения и запроса журналов. В Serilog есть получатель данных для записи
журналов в Elasticsearch, который вы можете добавить в свое приложение
так же, как вы добавляли получатель данных консоли в разделе 17.3.2.
СОВЕТ  Если вы хотите узнать больше об Elasticsearch, книга «Re -
levant	Search» Дуга Тернбулла и Джона Берриман (Manning, 2016) –
отличный выбор. В  ней показано, как максимально эффективно
использовать сообщения журналов, содержащих структурирован-
ные данные.
Elasticsearch  – это мощное средство промышленного масштаба для
хранения журналов, но его настройка  – занятие не для слабонервных.
Даже после того, как вы его запустите, вы столкнетесь с крутой кривой
обучения, связанной с синтаксисом запроса. Если вас интересует что-то
более удобное, то Seq (https://getseq.net) – отличный вариант. В следую-
щем разделе я покажу вам, как добавить Seq в качестве поставщика струк -
турного журналирования, что значительно упрощает анализ журналов.
17.5.1 Добавление поставщика структурного
журналирования в приложение
Чтобы продемонстрировать преимущества структурного журналирова-
ния, в  этом разделе вы настроите приложение для записи сообщений
журналов в Seq. Вы увидите, что конфигурация практически идентична
поставщикам неструктурного журналирования, но возможности, предо-
ставляемые структурным журналированием, облегчают задачу.
Seq устанавливается на сервере или на локальном компьютере и со-
бирает сообщения журналов, содержащих структурированные данные
по протоколу HTTP , предоставляя веб-интерфейс для просмотра и ана-
лиза журналов. В настоящее время он доступен в виде приложения для
Windows или контейнера Docker для Linux. Вы можете установить бес -
платную версию для разработки, которая позволит вам поэксперимен-
тировать со структурным журналированием в целом1.
1 Вы можете скачать установщик Windows для Seq на странице https://getseq.
net/Download.

661 Структурное журналирование: создание полезных сообщений журналов
С точки зрения приложения, процесс добавления поставщика Seq дол-
жен быть вам знаком:
1  Установите поставщика Seq с  по мощью Visual Studio или интер-
фейса командной строки .NET:
dotnet add package Seq.Extensions.Logging
2  Добавьте поставщика Seq в файл Program.cs внутри метода Config-
ureLogging. Чтобы добавить его в дополнение к поставщикам кон-
соли и отладки, которые включены как часть CreateDefaultBuilder,
используйте:
Host.CreateDefaultBuilder(args)
.ConfigureLogging(builder => builder.AddSeq())
.ConfigureWebHostDefaults(webBuilder =>
{
webBuilder.UseStartup<Startup>();
});
Это все, что нужно, чтобы добавить Seq в приложение. Он будет от -
правлять журналы на локальный URL-адрес по умолчанию, когда Seq
будет установлен в  вашем локальном окружении. Метод расширения
AddSeq() включает дополнительные перегруженные варианты для на-
стройки Seq при переходе в промышленное окружение, но это все, что
вам нужно, чтобы начать проводить эксперименты локально.
Если вы еще этого не сделали, установите Seq на своей машине, ис -
пользуемой для разработки, и перейдите к приложению Seq по адресу
http://localhost: 5341. На другой вкладке откройте свое приложение и за-
пустите просмотр и создание сообщений журналов. Вернувшись в Seq,
если вы обновите страницу, увидите список сообщений журналов, при-
мерно такой, что показан на рис. 17.13. Щелкнув мышью по сообщению,
вы раскроете его и увидите структурированные данные.
ASP .NET Core поддерживает структурное журналирование, обраба-
тывая каждый перехваченный параметр из строки форматирования
сообщения в виде пары «ключ-значение». Если вы создаете сообщение
журнала, используя следующую строку форматирования:
_log.LogInformation("Loaded {RecipeCount} recipes", Recipes.Count);
поставщик создаст параметр RecipeCount со значением Recipes.Count.
Эти параметры добавляются как свойства в каждое сообщение журнала,
содержащее структурированные данные, как видно на рис. 17.13.
Такие сообщения, как правило, легче читать, чем стандартный вывод
консоли, но их истинная мощь проявляется, когда нужно ответить на
конкретный вопрос. Рассмотрим предыдущую проблему, где вы видите
эту ошибку:
Could not find recipe with id 3245

662 Глава 17 Мониторинг и устранение ошибок с помощью журналирования
Журналы перечислены в обратном хронологическом порядке
Обновляем список или
включаем автообновление
При нажатии на журнал
отображаются
структурированные данные
Каждый журнал включает
в себя различные пары
«ключ-значение», а также
стандартные свойства уровня
и сообщенияСообщения уровня Warning выделены желтым
Рис. 17.13 Журналы Seq представлены в виде списка. Вы можете просмотреть
подробные сведения об отдельных журналах, аналитику журналов в совокупности
и выполнять поиск по свойствам журналов
Вы хотите понять, насколько широко распространена данная пробле-
ма. В качестве первого шага можно было бы определить, сколько раз воз-
никала эта ошибка, и узнать, возникала ли она у других рецептов. Seq
позволяет фильтровать журналы, а  также создавать SQL-запросы для
анализа данных, поэтому поиск ответа на вопрос занимает считанные
секунды, как показано на рис. 17.14.
Вы можете выполнять
поиск и фильтровать
сообщения, используя
простые свойства или SQL
Просматривайте
результаты в виде таблицы
или графика
Результаты показывают, что для сообщений журналов
с EventId 12 было 13 вхождений, все с RecipeId = 3245
Рис. 17.14 Запрос журналов в Seq. Структурное журналирование упрощает анализ
журнала, как в этом примере
ПРИМЕЧАНИЕ  Вам не нужны такие языки запросов, как SQL, для
простых запросов, но так проще разбираться в данных. Другие по-
ставщики могут предоставлять языки запросов, отличные от SQL,
но принцип такой же, как и в этом примере с Seq.

663 Структурное журналирование: создание полезных сообщений журналов
Быстрый поиск показывает, что вы записали сообщение журнала
с EventId.Id=12 (EventId интересующего нас предупреждения) 13 раз,
и каждый раз идентификатор-нарушитель рецепта был равен 3245. Это
говорит о том, что с этим рецептом что-то не так, а это указывает вам
правильное направление для поиска проблемы.
Чаще всего для выявления ошибок в промышленном окружении тре-
буется подобная работа в качестве детектива, чтобы определить, где воз-
никла проблема. Структурное журналирование значительно упрощает
этот процесс, поэтому стоит подумать, что выбрать: Seq, Elasticsearch
или другого поставщика.
Я уже писал, как добавлять структурированные свойства в  сообще-
ния журнала, используя переменные и параметры из сообщения, но, как
видно на рис. 17.13, видимых свойств гораздо больше, чем существует
только в сообщении.
Области	 журналирования позволяют добавлять произвольные данные
в сообщения журнала. Они доступны в некоторых поставщиках неструк -
турного журналирования, но предстают во всей своей красе при исполь-
зовании с  поставщиками структурного журналирования. В  последнем
разделе этой главы я продемонстрирую, как использовать их, чтобы до-
бавить дополнительные данные в сообщения журнала.
17.5.2 Использование областей журналирования
для добавления дополнительных свойств
в сообщения журнала
В своих приложениях вы часто будете сталкиваться с тем, что у вас есть
группа операций, которые используют одни и те же данные, которые
было бы полезно прикрепить к сообщениям журнала. Например, у вас
может быть серия операций с базой данных, которые используют один
и  тот же идентификатор транзакции, или вы можете выполнять не-
сколько операций с  одним и  тем же идентификатором пользователя
либо идентификатором рецепта. Области	 журналирования позволяют
связывать одни и те же данные с каждым сообщением журнала в такой
группе.
ОПРЕДЕЛЕНИЕ  Области	 журналирования используются для
группировки нескольких операций путем добавления одних и тех
же данных в каждое сообщение журнала.
Области журналирования в  ASP .NET Core создаются путем вызо-
ва ILog ger.BeginScope<T>(T state) и  предоставления данных state для
средства ведения журнала. Эти области создаются внутри блока using;
любые сообщения журнала, записанные внутри блока, будут иметь свя-
занные данные, а те, что находятся за его пределами, – нет.

664 Глава 17 Мониторинг и устранение ошибок с помощью журналирования
Листинг 17.9  Добавление свойств области журналирования
в сообщения журнала с по мощью BeginScope
_logger.LogInformation("No, I don't have scope");
using(_logger.BeginScope("Scope value"))
using(_logger.BeginScope(new Dictionary<string, object>
{{ "CustomValue1", 12345 } }))
{
_logger.LogInformation("Yes, I have the scope!");
}
_logger.LogInformation("No, I lost it again");
Состояние этой области может быть любым объектом: например, це-
лым числом, строкой или словарем. Реализация каждого поставщика
должна решать, как обрабатывать состояние, которое вы предоставляете
в вызове BeginScope, но обычно оно будет сериализовано с по мощью ме-
тода ToString().
СОВЕТ  Наиболее частый вариант использования областей жур-
налирования, с которым сталкивался я, – это добавление допол-
нительных пар «ключ-значение» в  сообщения журнала. Чтобы
добиться такого поведения в Seq и Serilog, необходимо передать
Dictionary<string, object> в качестве объекта состояния1.
Когда записываются сообщения журнала внутри блока, состояние
области фиксируется и  записывается как часть журнала, как показано
на рис.  17.15. Dictionary<> добавляется непосредственно в  сообщение
журнала (CustomValue1), а оставшиеся значения состояния добавляются
в свойство Scope. Вы, вероятно, найдете подход с использованием сло-
варя более полезным, поскольку добавленные свойства гораздо легче
фильтруются, как видно на рис. 17.14.
На этом мы подошли к концу главы, посвященной журналированию.
Используете ли вы встроенных поставщиков журналирования или выбе-
рите стороннего поставщика, такого как Serilog или NLog, ASP .NET Core
позволяет легко получать подробные сообщения журналов не только
для кода своего приложения, но и для библиотек, составляющих инфра-
структуру приложения, например Kestrel и  EF Core. Какой бы вариант
вы не выбрали, я призываю вас добавлять больше сообщений журналов,
чем, как вы думаете, вам нужно, – в будущем вы скажете мне спасибо,
когда дело дойдет до отслеживания проблемы.
1 Николас Блюмхардт, создатель Serilog и Seq, приводит примеры и аргументы
в пользу этого в своем блоге в статье «Семантика ILogger.BeginScope ()»: http://
mng.bz/GxDD .Сообщения журнала, записанные вне блока
области, не включают состояние области.Вызов BeginScope начинает блок
области с состоянием "Scope value" .
Вы можете передать что
угодно в качестве состояния
для области.
Сообщения журнала,
записанные внутри блока
области, включают состояние
области.

665 Резюме
Состояние словаря добавляется
в виде пар «ключ-значение».
Таким образом добавляется
свойство CustomValue1
Другие значения состояния
добавляются к свойству Scope
в виде массива значений
Сообщения журнала, записанные
вне блока области, не имеют
дополнительного состояния
Рис. 17.15 Добавление свойств в журналы с использованием областей
журналирования. Состояние области, добавленное с использованием словарного
подхода, добавляется в виде свойств структурного журналирования, а другое
состояние добавляется к свойству Scope. Добавление свойств упрощает связывание
журналов друг с другом
В следующей главе мы подробно рассмотрим различные проблемы
веб-безопасности, которые вы должны учитывать при создании своих
приложений. ASP .NET Core решает некоторые из этих проблем автома-
тически, но важно понимать, где находятся уязвимости вашего прило-
жения, чтобы иметь возможность как можно эффективнее смягчить по-
следствия таких уязвимостей.
Резюме
Журналирование имеет решающее значение для быстрой диагнос -
тики ошибок в рабочих приложениях. Следует всегда настраивать
журналирование для своего приложения, чтобы журналы писались
в надежное место. Вы можете добавить журналирование в свои сер-
висы, внедрив ILogger<T>, где T – это имя сервиса. Или можно внед-
рить ILoggerFactory и вызвать метод CreateLogger().
Уровень сообщения журнала указывает, насколько оно важно,
и варьи руется от Trace к Critical. Обычно вы будете создавать мно-
го неважных сообщений журнала и только несколько сообщений,
представляющих ценность.
Уровень сообщения указывается с по мощью соответствующего ме-
тода расширения ILogger для создания журнала. Чтобы написать
сообщение уровня Information, используйте ILogger.LogIn for ma ti-
on(message).

666 Глава 17 Мониторинг и устранение ошибок с помощью журналирования
Категория сообщения журнала указывает, какой компонент создал
сообщение. Обычно задается как полное имя класса, создающего
сообщение, но вы можете использовать любое строковое значение,
если хотите. ILogger<T> будет иметь категорию сообщения журнала  T.
Можно форматировать сообщения с по мощью значений-заполни-
телей, аналогично методу string.Format, но с понятными именами
параметров. Вызывая logger.Log-Info("Loading Recipe with id {Rec-
ipeId}", 1234), вы создаете запись в журнале "Loading Recipe with id
1234", а также захватываете значение RecipeId=1234. Такое струк-
турное	журналирование значительно упрощает анализ сообщений
журнала.
ASP .NET Core включает множество готовых поставщиков журна-
лирования. Это и поставщики консоли, отладки, EventLog и Event -
Source. В качестве альтернативы можно добавить сторонних постав-
щиков.
Вы можете настроить несколько экземпляров ILoggerProvider в ASP .
NET Core, которые определяют, где выводятся журналы. Метод Cre-
ateDefaultBuilder добавляет поставщиков консоли и отладки, а вы
можете добавить дополнительных поставщиков, вызвав метод Con-
figureLogging().
Serilog – уже давно существующий фреймворк для журналирования
с поддержкой большого количества мест назначения. Вы можете до-
бавить его в свое приложение с по мощью пакета Serilog.AspNetCore.
Он заменяет ILoggerFactory по умолчанию на версию конкретно
для Serilog.
Вы можете контролировать избыточное число сообщений журналов
с по мощью конфигурации. Вспомогательный метод CreateDefault-
Builder использует секцию конфигурации "Logging", чтобы контро-
лировать избыточность вывода. Обычно в  промышленном окру -
жении фильтруется больше сообщений журналов по сравнению
с окружением разработки.
Только одно правило фильтрации выбирается для каждого постав-
щика при определении, выводить ли сообщение журнала. Выбира-
ется наиболее конкретное правило на основе поставщика и катего-
рии сообщения журнала.
Структурное журналирование включает в  себя запись сообщений
журналов, чтобы их можно было легко запрашивать и фильтровать,
вместо неструктурированного формата по умолчанию, который вы-
водится в консоль. Благодаря этому проще анализировать журналы,
искать проблемы и выявлять закономерности.
Вы можете добавить дополнительные свойства в  сообщение жур-
нала, содержащее структурированные данные, используя блоки
области журналирования. Они создаются путем вызова ILogger.
BeginScope<T>(state) в блоке using. Состояние может быть любым
объектом и добавляется ко всем сообщениям журнала внутри блока.

18Повышаем
безопасность приложения
В этой главе:
шифрование трафика по протоколу HTTPS и настройка
локальных сертификатов SSL;
защита от межсайтового скриптинга;
защита от межсайтовой подделки запросов;
разрешение вызовов API из других приложений
с использованием CORS.
Безопасность веб-приложений – популярная тема в  настоящее время.
Практически каждую неделю сообщается об очередном взломе или
утечке конфиденциальной информации. Может показаться, что ситуа-
ция безнадежна, но реальность такова, что подавляющего большинства
таких ситуаций можно было и избежать, причем с минимальными уси-
лиями.
В этой главе мы рассмотрим несколько способов защиты приложения
и  его пользователей от злоумышленников. Поскольку безопасность –
чрезвычайно обширная тема, охватывающая множество различных
направлений, эта глава ни в коем случае не является исчерпывающим
руководством. Она предназначена для того, чтобы вы знали о  неко-
торых из наиболее распространенных угроз для вашего приложения
и способах противодействия им, а также чтобы выделить области, в ко-
торые вы можете непреднамеренно ввести уязвимости, если не будете
осторожны.

668 Глава 18 Повышаем безопасность приложения
СОВЕТ  Я настоятельно рекомендую изучить дополнительные ре-
сурсы по безопасности, после того как вы прочтете эту главу. От -
крытый проект обеспечения безопасности веб-приложений Open
Web Application Security Project (OWASP) (www.owasp.org) – отлич-
ный ресурс, хотя и может показаться немного суховатым. Кроме
того, у Троя Ханта есть отличные курсы и семинары по безопасно-
сти, ориентированные на разработчиков, работающих с платфор-
мой .NET (www.troyhunt.com).
Мы начнем с того, что рассмотрим, как добавить шифрование по про-
токолу HTTPS на сайт, чтобы пользователи могли получить доступ к ва-
шему приложению без риска, что третьи лица будут шпионить за ними
или менять содержимое, пока оно путешествует по сети. Это фактиче-
ски обязательно для промышленных приложений в наши дни и актив-
но поощряется создателями современных браузеров, таких как Chrome
и Firefox. Вы увидите, как использовать сертификат разработки ASP .NET
Core, чтобы применять протокол HTTPS локально, как настроить прило-
жение для HTTPS в промышленном окружении и как сделать так, чтобы
протокол HTTPS использовался во всем приложении.
В разделах 18.2 и 18.3 вы узнаете о двух типах потенциальных атак,
которые должны быть на вашем радаре: межсайтовый скриптинг (XSS)
и  межсайтовая подделка запросов (CSRF). Мы изучим, как работают
эти атаки и как предотвратить их в своих приложениях. В ASP .NET Core
имеется встроенная защита от обоих типов атак, но вы должны не за-
бывать правильно использовать механизмы защиты и не поддаваться
искушению обойти их, если только вы не уверены, что это безопасно.
В разделе 18.4 рассматривается распространенный сценарий – у вас
есть приложение, которое хочет использовать запросы Java Script AJAX
(Асинхронный Java Script и XML) для получения данных из второго при-
ложения. По умолчанию веб-браузеры блокируют запросы к другим при-
ложениям, поэтому вам нужно активировать совместное использование
ресурсов между разными источниками (CORS) в своем API для достиже-
ния этой цели. Мы рассмотрим, как работает CORS, как создать политику
CORS для своего приложения и как применить ее к конкретным методам
действий.
Последний раздел этой главы, 18.5, охватывает набор распространен-
ных угроз. Каждая из них представляет собой потенциально критический
недостаток, который злоумышленник может использовать для взлома
вашего приложения. Решение для каждой угрозы в целом относительно
простое – важно понять, где в приложениях могут быть эти недостатки,
чтобы гарантировать, что вы не подвержены этим уязвимостям.
Мы начнем с рассмотрения протокола HTTPS и почему нужно исполь-
зовать его для шифрования трафика между браузерами пользователей
и  вашим приложением. Без него злоумышленники могут взламывать
многие механизмы безопасности, которые вы добавляете в свое прило-
жение, поэтому это первый и важный шаг, который нужно сделать.

669 Добавляем протокол HTTPS в приложение
18.1 Добавляем протокол HTTPS в приложение
В этом разделе вы узнаете о протоколе HTTPS: что это такое и почему
нужно о  нем знать, когда речь идет о  приложениях в  промышленном
окружении. Вы увидите два подхода, используемых для того, чтобы до-
бавить его в свое приложение: прямая поддержка HTTPS в приложении
и использование терминирования SSL/TLS на обратном прокси-сервере.
Затем вы узнаете, как использовать сертификат разработки для работы
с HTTPS на локальной машине и как добавить сертификат HTTPS в при-
ложение в промышленном окружении. Наконец, вы узнаете, как сделать
так, чтобы протокол HTTPS использовался в  приложении, применяя
передовые практики, такие как заголовки безопасности и перенаправ-
ление с HTTP .
До сих пор в данной книге я показывал, как браузер пользователя от -
правляет запрос по сети в ваше приложение по протоколу HTTP . Мы не
слишком вникали в  подробности этого протокола, а только выяснили,
что он использует методы для описания типа запроса (например, GET
и  POST), содержит заголовки с  метаданными о  запросе и,  возможно,
включает в себя полезную нагрузку тела	данных.
По умолчанию HTTP-запросы не шифруются; это простые текстовые
файлы, которые пересылаются по сети. Каждый, кто находится в той же
сети, что и пользователь (например, некто, использующий тот же обще-
доступный Wi-Fi в кафе), может читать запросы и ответы, которые пере-
сылаются туда и обратно. Злоумышленники могут даже	 изменять запро-
сы или ответы в процессе их передачи.
Такое использование незашифрованных веб-приложений представ-
ляет угрозу как для конфиденциальности, так и для безопасности ваших
пользователей. Злоумышленники могут читать данные, отправляемые
в формах и возвращаемые вашим приложением, внедрять вредоносный
код в ответы, чтобы совершать атаки или красть cookie-файлы аутенти-
фикации, выдавая себя за пользователей вашего приложения.
Чтобы защитить пользователей, нужно шифровать трафик между
брау зером пользователя и вашим приложением, когда он передается по
сети с использованием протокола HTTPS. Это похоже на HTTP-трафик,
но здесь используется сертификат SSL/TLS1 для шифрования запросов
и ответов, поэтому злоумышленники не могут прочитать или изменить
содержимое. Когда вы открываете браузер, то можете сказать, что сайт
использует протокол HTTPS, глядя на префикс https://, стоящий в нача-
ле URL-адреса (обратите внимание на букву «s»), или иногда там может
стоять значок в виде замка, как показано на рис. 18.1.
1 SSL – более старый стандарт, поддерживающий HTTPS, но протокол SSL был
заменен на Transport Layer Security (TLS), поэтому в этой главе я буду исполь-
зовать преимущественно TLS.

670 Глава 18 Повышаем безопасность приложения
Браузеры обычно выделяют сайты, которые
используют протокол HTTPS, символом замкаБраузеры обозначают HTTP-сайты, которые
используют протокол HTTP , как небезопасные.
В будущем такие предупреждения станут
более заметными
Рис. 18.1 Зашифрованные приложения, использующие протокол HTTPS,
и незашифрованные приложения, использующие протокол HTTP в браузере
Edge. Применяя HTTPS, вы защищаете свое приложение от просмотра или взлома
злоумышленниками
СОВЕТ  Для получения подробной информации о том, как работа-
ют протоколы SSL/TLS, см. главу 9 книги «Real-World	 Cryptography»
Дэвида Вонга (Manning, 2021), http://mng.bz/zxz1.
Реальность такова, что в  наши дни вы всегда должны использовать
протокол HTTPS, если речь идет о сайтах в промышленном окружении.
Он продвигается по умолчанию, при этом большинство браузеров пе-
реходят на то, чтобы помечать сайты, использующие протокол HTTP ,
как явно «небезопасные». Если не использовать его, то это повредит
восприя тию вашего приложения в долгосрочной перспективе, поэтому,
даже если вы не интересуетесь преимуществами, предоставляемыми
безопасностью, в ваших интересах настроить HTTPS.
Чтобы активировать HTTPS, необходимо получить и настроить серти-
фикат TLS для своего сервера. К сожалению, хотя этот процесс намного
проще, чем раньше, и сделать это теперь можно практически бесплат -
но благодаря Let’s Encrypt (https://letsencrypt.org/), во многих случаях
все еще далеко не так просто. Если вы настраиваете рабочий сервер, то
рекомендую внимательно следовать руководству на сайте Let’s Encrypt.
Ошибиться легко, поэтому не торопитесь.
СОВЕТ  Если вы размещаете свое приложение в  облаке, боль-
шинство провайдеров предоставляют сертификаты TLS по одному
клику, чтобы вам не нужно было самостоятельно управлять серти-
фикатами. Это чрезвычайно	 полезно, и я настоятельно рекомендую
всем делать так1.
1 Для этого даже не нужно размещать свое приложение в  облаке. Cloudflare
(www.cloudflare.com) предоставляет CDN-сервис, к которому можно добавить
TLS. Вы даже можете использовать его бесплатно.

671 Добавляем протокол HTTPS в приложение
Будучи разработчиками приложений ASP .NET Core, вы часто можете
обойтись без прямой	 поддержки HTTPS в приложении, используя архи-
тектуру обратного прокси-сервера, как показано на рис. 18.2, в процес -
се, называемом SSL/TLS-разгрузкой, или SSL/TLS-терминацией. Вместо
того чтобы обрабатывать запросы напрямую, используя HTTPS, ваше
приложение продолжает использовать HTTP . Обратный прокси-сервер
отвечает за шифрование и  дешифровку HTTPS-трафика от браузера.
Часто это дает вам лучшее из обоих миров – данные шифруются между
браузером пользователя и сервером, но вам не нужно беспокоиться о на-
стройке сертификатов1.
X-Forwarded-Proto: httpsПри сквозной передаче по протоколу
SSL/TLS каждый запрос остается
зашифрованным на всем пути
к вашему приложению
Обратный прокси-сервер добавляет
заголовки к запросу, чтобы приложение
могло сказать, что исходный запрос
шел по протоколу HTTPS
При SSL/TLS-терминировании обратный
прокси-сервер расшифровывает данные.
Затем он перенаправляет запрос в ваше
приложение без HTTPS-шифрования
Рис. 18.2 При использовании HTTPS с обратным прокси-сервером у вас есть два варианта:
сквозная передача по протоколу SSL/TLS и SSL/TLS-терминирование. При сквозной передаче
данные шифруются на всем пути к приложению ASP.NET Core. При SSL/TLS-терминировании
обратный прокси-сервер занимается дешифрованием данных, поэтому вашему приложению
не нужно этого делать
В зависимости от конкретной инфраструктуры, в которой вы разме-
щаете свое приложение, SSL/TLS-терминирование можно перенести
на выделенное устройство в  вашей сети, сторонний сервис, например
Cloudflare, или обратный прокси-сервер (например, IIS, NGINX или HAP -
roxy), работающие на том же или другом сервере.
Тем не менее в некоторых ситуациях вам может потребоваться рабо-
тать с SSL/TLS напрямую в своем приложении:
если	вы	предоставляете	 доступ	к Kestrel	 из	сети	интернет	 напря-
мую,	без	обратного	 прокси-сервера. Подобное стало чаще встречать-
1 Если вас беспокоит, что трафик между обратным прокси-сервером и  ва-
шим приложением не шифруется, рекомендую прочитать пост Троя Ханта
«CloudFlare, SSL и нездоровый абсолютизм безопасности»: http://mng.bz/eHCi.
В нем обсуждаются плюсы и минусы проблемы, связанной с использованием
Cloudflare для обеспечения шифрования по протоколу HTTPS.

672 Глава 18 Повышаем безопасность приложения
ся с ASP .NET Core 3.0 из-за усиления защиты сервера Kestrel. Такое
тоже нередко бывает, когда вы разрабатываете свое приложение
локально;
если	наличие	 протокола	 HTTP	между	обратным	 прокси-сервером	 и ва-
шим	приложением	 неприемлемо. Когда речь идет о защите трафика
внутри вашей сети, это менее критично по сравнению с внешним
трафиком, однако, несомненно, безопаснее использовать HTTPS
и для внутреннего трафика;
если	вы	используете	 технологию, 	требующую	 HTTPS. Некоторые но-
вые сетевые протоколы, такие как gRPC и HTTP/2, требуют соедине-
ния по протоколу HTTPS.
В каждом из этих сценариев вам потребуется настроить сертификат
TLS для своего приложения, чтобы Kestrel мог получать HTTPS-трафик.
В разделе 18.1.1 вы увидите самый простой способ приступить к исполь-
зованию протокола HTTPS при локальной разработке, а в разделе 18.1.2
узнаете, как настроить приложение для промышленного окружения.
18.1.1 Использование HTTPS-сертификатов для разработки
Работать с сертификатами HTTPS стало проще, чем раньше, но, к сожа-
лению, некоторые вещи по-прежнему могут сбивать с толку, особенно
если вы новичок в интернете. Набор средств разработки .NET, Visual Stu-
dio и IIS Express пытаются улучшить этот опыт, выполняя значительную
часть неблагодарной работы за вас.
При первом запуске команды dotnet с по мощью набора средств раз-
работки .NET этот набор устанавливает HTTPS-сертификат для разра-
ботки на ваш компьютер. Любое приложение ASP .NET Core, которое вы
создае те с использованием шаблонов по умолчанию (или для которых
вы не настраиваете сертификаты явно), будет использовать этот серти-
фикат для обработки HTTPS-трафика. Однако сертификат для разработ -
ки по умолчанию не является доверенным. Это означает, что вы получите
предупреж  дение от браузера, как показано на рис. 18.3, при обращении
к сайту после установки набора средств разработки .NET.
Сайт обслуживается по протоколу HTTPS,
но поскольку сертификат не является
надежным, браузер помечает его как
небезопасный
Чтобы получить доступ к сайту, нужно
нажать Advanced и принудительно
перейти на сайт (не рекомендуется)Код ошибки указывает на то, что центр
сертификатов недействителен
Рис. 18.3 Сертификат разработчика не является доверенным по умолчанию,
поэтому приложения, обслуживающие HTTPS-трафик и использующие его, будут
помечены браузерами как небезопасные. Хотя при необходимости вы можете
обойти эти оповещения, нужно обновить сертификат, чтобы он стал доверенным

673 Добавляем протокол HTTPS в приложение
Краткое руководство по сертификатам и подписи
HTTPS использует криптографическую систему с  открытым ключом как
часть процесса шифрования данных. Здесь используется два ключа: откры­
тый ключ, который может видеть любой, и  закрытый ключ, который видит
только ваш сервер.  Все, что зашифровано с по мощью открытого ключа, мож -
но расшифровать только с по мощью закрытого ключа. Таким образом, брау-
зер может что-то зашифровать с по мощью открытого ключа вашего сервера,
и только ваш сервер может его расшифровать. Полный сертификат TLS со-
стоит из открытых и закрытых частей.
Когда браузер подключается к вашему приложению, сервер отправляет часть
с открытым ключом сертификата TLS. Но откуда браузер знает, что имен-
но ваш сервер отправил сертификат? Для этого ваш сертификат TLS содер-
жит дополнительные сертификаты, включая сертификат от третьей стороны,
цент ра сертификации (CA). Этот доверенный сертификат называется корне­
вым сертификатом.
Центр сертификации – это сторона, чья честность неоспорима, а браузе-
ры жестко сконфигурированы, чтобы доверять определенным корневым
сертификатам. Чтобы сертификат TLS для вашего приложения был дове-
ренным, он должен содержать (или быть подписан) доверенный корневой
сертификат.
Когда вы используете сертификат разработки ASP.NET Core или создаете
собственный самоподписанный сертификат, у HTTPS вашего сайта нет этого
доверенного корневого сертификата. Это означает, что браузеры не будут
доверять вашему сертификату и не будут подключаться к вашему серверу по
умолчанию. Чтобы обойти это, нужно указать своей машине, используемой
для разработки, явно доверять сертификату.
В промышленном окружении нельзя использовать сертификат разработки
или самоподписанный сертификат, поскольку браузер пользователя ему не
доверяет. Вместо этого нужно получить подписанный сертификат HTTPS от
такого сервиса, как Let’s Encrypt, или от облачного провайдера, такого как
AWS, Azure или Cloudflare. Эти сертификаты уже будут подписаны доверен-
ным центром сертификации, поэтому браузеры будут автоматически дове-
рять им.
Чтобы устранить эти оповещения со стороны браузера, необходимо
доверять сертификату. Доверие сертификату – важная операция; она го-
ворит: «Я знаю, что этот сертификат выглядит не совсем правильно, но
просто игнорируйте это», – поэтому сложно сделать это автоматически.
Если вы работаете в Windows или macOS, то можете доверять сертифика-
ту разработки, выполнив команду
dotnet dev-certs https –trust
Эта команда доверяет сертификату, регистрируя его в  «хранилище
сертификатов» операционной системы. После того как вы выполните
данную команду, вы сможете получить доступ к своим веб-сайтам без

674 Глава 18 Повышаем безопасность приложения
каких-либо предупреждений или ярлыков «небезопасно», как показано
на рис. 18.4.
Т еперь сертификат является доверенным,
поэтому у него есть символ замка, больше
нет пометки not secure (небезопасно)
и он не отображается красным
Рис. 18.4 После того как сертификат разработки станет доверенным, вы больше
не увидите предупреждения браузера о подключении
Сертификат разработчика без проблем работает в Windows и macOS.
К несчастью, доверять сертификату в Linux немного сложнее, и все зави-
сит от конкретного варианта, который вы используете. Кроме того, про-
граммное обеспечение в Linux часто использует собственное хранилище
сертификатов, поэтому вам, вероятно, потребуется добавить сертификат
непосредственно в свой любимый браузер. Я предлагаю посмотреть до-
кументацию к вашему любимому браузеру, чтобы выбрать лучший под-
ход. Рекомендации по использованию других платформ, таких как Do-
cker, см. в разделе «Как настроить сертификат разработчика для Docker»
в документации Microsoft: http://mng.bz/0mBJ.
Если вы используете Windows, Visual Studio и  IIS Express для разра-
ботки, то, возможно, у вас и нет необходимости доверять сертификату
разработки. IIS Express действует как обратный прокси-сервер, когда
вы осуществляете разработку локально, поэтому он сам выполняет на-
стройку SSL/TLS. Кроме того, Visual Studio должна доверять сертификату
разработки IIS как части установки, поэтому вы можете так и не увидеть
предупреждений со стороны браузера.
Сертификаты разработки ASP .NET Core и  IIS упрощают использова-
ние Kestrel и HTTPS локально, но эти сертификаты не помогут, когда вы
перейде те в промышленное окружение. В следующем разделе я покажу
вам, как настроить Kestrel для использования сертификата TLS для про-
мышленного окружения.
18.1.2 Настройка Kestrel для использования сертификата
HTTPS в промышленном окружении
Создание сертификата TLS для промышленного окружения часто явля-
ется трудоемким процессом, поскольку требует подтвердить сторонне-
му центру сертификации (ЦС), что вы являетесь владельцем домена, для
которого создаете сертификат. Это важный шаг в  процессе «доверия»,
который гарантирует, что злоумышленники не смогут выдавать себя
за ваши серверы. Результатом данного процесса является один или не-
сколько файлов, представляющих собой сертификат HTTPS, который не-
обходимо настроить для своего приложения.

675 Добавляем протокол HTTPS в приложение
СОВЕТ  Особенности получения сертификата зависят от провай-
дера и вашей платформы ОС, поэтому внимательно читайте до-
кументацию от своего провайдера. Перипетии и сложности этого
процесса – одна из причин, по которой я решительно поддержи-
ваю использование SSL/TLS-терминирования, или подхода «в один
клик», описанного ранее. Это означает, что моим приложениям не
нужно иметь дело с сертификатами, а мне не нужно использовать
подходы, описанные в этом разделе; я делегирую эту ответствен-
ность другой части сети или базовой платформе.
Получив сертификат, необходимо настроить Kestrel, чтобы исполь-
зовать его для обслуживания HTTPS-трафика. В главе 16 вы узнали, как
настроить порт, на котором будет выполнять прослушивание ваше при-
ложение, с по мощью переменной окружения ASPNETCORE_URLS  или через
командную строку, и вы видели, что можно предоставить URL-адрес с пре-
фиксом HTTPS. Поскольку вы не указали конфигурацию сертификата, по
умолчанию Kestrel использует сертификат разработки. В промышленном
окружении необходимо указать Kestrel, какой сертификат использовать.
Kestrel очень легко настраивать, что позволяет настраивать сертифи-
каты несколькими способами. Вы можете использовать разные серти-
фикаты для разных портов, можете загружать из файла с расширением
.pfx или из хранилища сертификатов ОС, или у вас может быть своя кон-
фигурация для каждой конечной точки URL-адреса, которую вы предо-
ставляете. Для получения полной информации см. раздел «Конфигура-
ция конечной точки» в документации Microsoft «Реализация веб-сервера
Kestrel в ASP .NET Core»: htt p://mng.bz/KMdX.
В следующем листинге показан один из возможных способов установ-
ки специального сертификата HTTPS для приложения в промышленном
окружении, сертификат настроен по умолчанию, его Kestrel использует
для HTTPS-соединений. Вы можете добавить раздел "Kest rel:Cer ti fi-
ca tes:Default" в свой файл appsettings.json (или используя любой дру -
гой источник конфигурации, как описано в главе 11), чтобы определить
файл сертификата с  расширением .pfx, который будет использоваться.
Вы также должны указать пароль для доступа к сертификату.
Листинг 18.1  Настройка сертификата HTTPS по умолчанию для Kestrel
с использованием файла с расширением .pfx
{
"Kestrel": {
"Certificates": {
"Default": {
"Path": "localhost.pfx",
"Password": "testpassword"
}
}
}
}Создайте раздел конфигурации
в Kestrel:Certificates:Default.
Относительный или абсолютный путь
к сертификату.
Пароль для открытия сертификата.

676 Глава 18 Повышаем безопасность приложения
Предыдущий пример – самый простой способ заменить сертификат
HTTPS, поскольку он не требует изменения каких-либо значений по
умолчанию для Kestrel. Вы можете использовать аналогичный подход,
чтобы загрузить сертификат HTTPS из хранилища сертификатов ОС
(в  Windows или macOS), как показано в документации «Конфигурация
конечной точки», упомянутой ранее.
ПРЕДУПРЕЖДЕНИЕ  В  листинге 18.1 имя файла сертификата
и пароль жестко зашиты, чтобы было проще, но вы должны загру -
жать их из хранилища конфигурации, например User Secrets, как
было показано в главе 11, или загрузить сертификат из локального
хранилища. Никогда не помещайте рабочие пароли в файлы app-
settings.json.
Все шаблоны ASP .NET Core по умолчанию настраивают ваше прило-
жение на обслуживание HTTP- и  HTTPS-трафика, и,  используя конфи-
гурацию, которую вы видели до сих пор, вы можете быть уверены, что
ваше приложение может работать как с HTTP , так и HTTPS и в окружении
разработки, и в промышленном окружении.
Однако используете ли вы HTTP или HTTPS, может зависеть от URL-ад-
ре са, по которому пользователи щелкают мышью, когда впервые заходят
в ваше приложение. Например, если ваше приложение выполняет про-
слушивание, используя URL-адреса по умолчанию, http://localhost:5000
для HTTP-трафика и https://localhost:5001 для HTTPS-тра фи ка, то когда
пользователь переходит по URL-адресу с  префиксом HTTP , его трафик
шифроваться не будет. Видя, что вы приложили все усилия, чтобы на-
строить HTTPS, вероятно, лучше всего заставить пользователей его ис -
пользовать.
18.1.3 Делаем так, чтобы протокол HTTPS использовался
для всего приложения
В наши дни требуется практически принудительное использование про-
токола HTTPS для всего веб-сайта. Браузеры начинают явно помечать
HTTP-страницы как небезопасные; по соображениям безопасности вы
должны	 использовать TLS каждый раз, когда передаете конфиденциаль-
ные данные по сети, и благодаря протоколу HTTP/2 добавление TLS мо-
жет улучшить производительность вашего приложения1.
Существует несколько подходов сделать так, чтобы протокол HTTPS
использовался для всего приложения. Если вы используете обратный
прокси-сервер с  SSL/TLS-терминированием, все будет сделано за вас,
и вам не нужно беспокоиться об этом в своих приложениях. Тем не менее
1 HTTP/2 предлагает множество улучшений производительности по сравнению
с HTTP/1.x, и все современные браузеры требуют HTTPS, чтобы активировать
его. Отличное введение в  HTTP/2 можно найти в  документе Google: http://
mng.bz/9M8j.

677 Добавляем протокол HTTPS в приложение
не помешает принудительно применять SSL/TLS, независимо от того,
что может делать обратный прокси-сервер.
ПРИМЕЧАНИЕ  Если вы создаете веб-API, а не приложение Razor
Pages, обычно можно просто отклонять HTTP-запросы, не исполь-
зуя подходы, описанные в  этом разделе. Эти меры защиты при-
меняются в первую очередь при создании приложений, которые
будут использоваться в  браузере. Дополнительные сведения см.
в документе Microsoft: http://mng.bz/j46a.
Один из подходов к повышению безопасности приложения – исполь-
зовать заголовки	 безопасности	 HTTP . Это HTTP-заголовки, отправляе-
мые как часть вашего HTTP-ответа, которые сообщают браузеру, как он
должен себя вести. Доступно много разных заголовков, большинство из
которых ограничивают функции, которые ваше приложение может ис -
пользовать в обмен на повышенную безопасность1. В следующей главе
вы увидите, как добавлять собственные заголовки к HTTP-ответам, соз-
давая специальные компоненты промежуточного ПО.
Один из этих заголовков безопасности, заголовок HTTP Strict Trans-
port Security (HSTS), может помочь убедиться, что браузеры используют
протокол HTTPS там, где он доступен, вместо использования по умолча-
нию протокола HTTP .
принудительное  использование  протокола  HTTPs с по Мощью  заГоловков
HTTP s TRic T TRaNsP oRT secuRiT y
К сожалению, по умолчанию браузеры всегда загружают приложения по
протоколу HTTP , если не указано иное. Это означает, что ваши прило-
жения обычно должны поддерживать и HTTP , и HTTPS, даже если вы не
хотите обслуживать трафик через HTTP . Один из способов (и передовой
практики безопасности) смягчить это заключается в добавлении заго-
ловков HTTP Strict Transport Security в ваши ответы.
ОПРЕДЕЛЕНИЕ  HTTP	Strict	Transport	 Security	 (HSTS) – это заго-
ловок, который указывает браузеру использовать HTTPS для всех
последующих запросов к вашему приложению. Браузер больше не
будет отправлять HTTP-запросы в  ваше приложение и  будет ис -
пользовать только HTTPS. Его можно отправлять лишь с ответами
на HTTPS-запросы. Это актуально только для запросов, исходящих
из браузера, и не влияет на обмен данными между серверами.
Заголовки HSTS настоятельно рекомендуются для приложений в про-
мышленном окружении. Вы вряд ли будете активировать их для локаль-
1 У  Скотта Хельма есть отличное руководство по этому и  другим заголовкам
безопасности, которые вы можете добавить на свой сайт, например заголовок
Content Security Policy (CSP). См. статью на его веб-сайте: https://scotthelme.
co.uk/harpting-your-http-response-headers/.

678 Глава 18 Повышаем безопасность приложения
ной разработки, поскольку это будет означать, что вы никогда не сможе-
те запустить приложение, не использующее протокол HTTPS, локально.
Аналогичным образом вы должны использовать HSTS только на сайтах,
для которых вы всегда собираетесь применять HTTPS, поскольку непрос -
то (иногда невозможно) отключить его после того, как он был «включен»
с по мощью HSTS.
ASP .NET Core поставляется со встроенным промежуточным ПО для
установки заголовков HSTS, которое автоматически включается в неко-
торые шаблоны по умолчанию. В следующем листинге показано, как на-
строить заголовки HSTS для своего приложения, используя HstsMiddle-
ware в файле Startup.cs.
Листинг 18.2  Использование компонента HstsMiddleware
для добавления заголовков HSTS в приложение
public class Startup
{
public void ConfigureServices(IServiceCollection services)
{
services.AddRazorPages();
services.AddHsts(options =>
{
options.MaxAge = TimeSpan.FromHours(1);
});
}
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
if (env.IsProduction())
{
app.UseHsts();
}
app.UseStaticFiles();
app.UseRouting();
app.UseAuthorization();
app.UseEndpoints(endpoints =>
{
endpoints.MapRazorPages();
});
}
}
СОВЕТ  В предыдущем примере показано, как изменить значение
MaxAge, отправленное в заголовке HSTS. Лучше всего начать с не-
большого значения. Когда вы убедитесь, что HTTPS в вашем при-
ложении работает правильно, увеличьте значение, чтобы повы-
сить безопасность. Дополнительные сведения об HSTS см. в статье
Скотта Хельма: https://scotthelme.co.uk/hsts-themissing-link-in-tls.Настраиваем параметры
HSTS-заголовка. Так вы изменяете
значение MaxAge, которое
по умолчанию составляет 30 дней.
Вы не должны использовать HSTS
в локальном окружении.
Добавляет HstsMiddleware.
HstsMiddleware должен идти в самом
начале конвейера промежуточного ПО.

679 Добавляем протокол HTTPS в приложение
HSTS – отличный вариант, чтобы заставить пользователей использо-
вать HTTPS на вашем сайте. Но есть одна проблема с заголовком, которая
заключается в том, что его можно добавлять только в  HTTPS-запросы.
Это значит, что вы уже должны сделать HTTPS-запрос до того, как HSTS
сработает: если первоначальный запрос – это запрос по протоколу HTTP ,
заголовок HSTS не отправляется, и вы остаетесь	 с HTTP! Прискорбно,
но вы можете смягчить ситуацию, незамедлительно перенаправив не-
безопас ные запросы на HTTPS.
переадресация  с HTTP на HTTPs с поМощью  коМпонента
HTTPs RediRec TioNMiddLewaRe
HstsMiddleware обычно следует использовать вместе с промежуточным
ПО, которое перенаправляет все HTTP-запросы на HTTPS.
СОВЕТ  Перенаправление на HTTPS можно применять только
к отдельным частям приложения, например к определенным стра-
ницам Razor Pages, но я не рекомендую этого делать, поскольку так
можно очень легко создать брешь в системе безопасности своего
приложения.
ASP.NET Core поставляется с  компонентом HttpsRedirectionMiddle-
ware, который можно использовать для принудительного использования
HTTPS во всем приложении. Он добавляется в конвейер промежуточного
ПО в секцию Configure класса Startup и гарантирует, что все проходящие
через него запросы безопасны. Если HTTP -запрос доходит до HttpsRedi-
rectionMiddleware, промежуточное ПО тотчас же прерывает выполнение
конвейера, выполняя перенаправление на HTTPS-версию запроса. После
этого браузер повторит запрос, используя вместо HTTP протокол HTTPS.
ПРИМЕЧАНИЕ   Внимательные читатели заметят, что, даже ис -
пользуя заголовки HSTS и  HttpsRedirectionMiddleware, проблема
все еще присутствует. По умолчанию браузеры всегда будут делать
начальный небезопасный запрос к вашему приложению по прото-
колу HTTP . Единственный способ избежать этого – предварительно
загрузить заголовки HSTS, говоря браузерам всегда использовать
HTTPS. На сайте ForwardPMX можно найти отличное руководство
по HSTS, включая предварительную загрузку: «Полное руковод-
ство по протоколу HSTS» Криса Хербранда, http://mng.bz/Wdmg.
HttpsRedirectionMiddleware добавляется в стандартные шаблоны ASP .
NET Core. Обычно он помещается после обработки ошибок и  HstsMid-
dleware, как показано в следующем листинге. По умолчанию промежу -
точное ПО перенаправляет все HTTP-запросы на безопасную конечную
точку, используя код состояния 307 Temporary Redirect.

680 Глава 18 Повышаем безопасность приложения
Листинг 18.3  Использование HttpsRedirectionMiddleware
для принудительного применения HTTPS в приложении
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
app.UseExceptionHandler("/Error");
if (env.IsProduction())
{
app.UseHsts();
}
app.UseHttpsRedirection();
app.UseStaticFiles();
app.UseRouting();
app.UseAuthorization();
app.UseEndpoints(endpoints =>
{
endpoints.MapRazorPages();
});
}
}
HttpsRedirectionMiddleware будет автоматически перенаправлять
HTTP-за просы в  первую настроенную конечную точку HTTPS вашего
приложения. Если оно не настроено на использование HTTPS, то проме-
жуточное ПО не	будет ничего перенаправлять и вместо этого зарегист -
рирует предупреждение:
warn: Microsoft.AspNetCore.HttpsPolicy.HttpsRedirectionMiddleware[3]
Failed to determine the https port for redirect.
Если вы хотите, чтобы промежуточное ПО выполняло перенаправле-
ние на другой порт, о котором знает Kestrel, его можно настроить, задав
переменную окружения ASPNETCORE_HTTPS_PORT. Иногда это необходимо,
если вы используете обратный прокси-сервер, и  ее можно задать аль-
тернативными способами, как описано в документации Microsoft: http://
mng.bz/QmN4.
Т ерминирование SSL/TLS, пересылка заголовков
и обнаружение защищенных запросов
В начале раздела 18.1 я  рекомендовал вам рассмотреть терминирование
HTTPS-запросов на обратном прокси-сервере. Таким образом, пользователь
использует HTTPS для связи с обратным прокси-сервером, а обратный прок -
си-сервер общается с вашим приложением по протоколу HTTP. Благодаря
такой настройке ваши пользователи защищены, но ваше приложение не
должно иметь дело с сертификатами TLS.
Для правильной работы HttpsRedirectionMiddleware Kestrel требуется
какой-то способ узнать, был ли исходный запрос, полученный обратным
прокси-сервером, сделан по протоколу HTTP или HTTPS. Обратный прокси-Добавляет HttpsRedirectionMiddleware
в конвейер. Перенаправляет
все HTTP-запросы на HTTPS.

681 Защита от межсайтового скриптинга
сервер обменивается данными с вашим приложением через HTTP, поэтому
Kestrel не может выяснить это без дополнительной помощи.
Стандартный подход, используемый большинством обратных прокси (та-
ких как IIS, NGINX и HAProxy), заключается в добавлении заголовков в за-
прос перед его пересылкой в    приложение. А именно добавляется заголовок
X-For warded-Proto, указывающий на то, какой протокол использовался для
исходного запроса: HTTP или HTTPS.
ASP.NET Core включает ForwardedHeadersMiddleware для поиска этого заго-
ловка (и других) и обновляет запрос соответствующим образом, чтобы ваше
приложение воспринимало запрос, который был изначально защищен про-
токолом HTTPS как безопасный во всех отношениях.
Если вы используете IIS с  методом расширения UseIisIntegration(), то
пересылка заголовка обрабатывается автоматически. Если вы применяете
другой обратный прокси-сервер, например NGINX или HAProxy, то можете
активировать промежуточное ПО, задав для переменной окружения значе-
ние true: ASPNETCORE_FORWARDEDHEADERS_ENABLED = true, как было показано
в главе 16. В качестве альтернативы можно вручную добавить промежуточ-
ное ПО в свое приложение, как показано в разделе 16.3.2.
Когда обратный прокси-сервер пересылает запрос, ForwardedHeadersMid-
dleware будет искать заголовок X-Forwarded-Proto и при необходимости об-
новит детали запроса. Для всех последующих компонентов промежуточного
ПО запрос считается безопасным. При добавлении промежуточного ПО вруч-
ную важно разместить ForwardedHeadersMiddleware перед вызовом методов
UseHsts() или UseHttpsRedirection(), чтобы перенаправленные заголовки
были прочитаны и запрос был помечен как безопасный, если необходимо.
HTTPS – одно из основных требований для повышения безопасности
вашего приложения. Первоначально его может быть непросто настро-
ить, но как только вы начнете работать, то можете в значительной степе-
ни забыть об этом, особенно если используете терминирование SSL/TLS
на обратном прокси-сервере.
К сожалению, большинство других методов обеспечения безопасно-
сти требуют большей бдительности, чтобы убедиться, что вы случайно
не добавили уязвимости в  свое приложение по мере его роста и  раз-
вития. Многие атаки концептуально просты и известны годами, но по-
прежнему широко используются в  новых приложениях. В  следующем
разделе мы рассмотрим одну из таких атак и узнаем, как от нее защи-
титься при создании приложений с использованием Razor Pages.
18.2 Защита от межсайтового скриптинга
В этом разделе я опишу атаки, известные как межсайтовый скриптинг,
и как злоумышленники могут использовать их, чтобы скомпрометиро-
вать компьютеры ваших пользователей. Я покажу, как фреймворк Razor

682 Глава 18 Повышаем безопасность приложения
Pages защищает вас от этих атак, как отключить защиту, когда вам это
нужно, и на что обратить внимание. Я также расскажу о разнице между
кодировкой HTML и  кодировкой Java Script и  какое влияние оказывает
использование неправильного кодировщика.
Злоумышленники могут использовать уязвимость в вашем приложе-
нии для межсайтового скриптинга (XSS). Данный тип атаки позволяет
запускать код в браузере другого пользователя1. Обычно злоумышлен-
ники отправляют содержимое, используя легитимный подход, например
форму для ввода данных, которая позже отображается где-то на страни-
це. Тщательно поработав с вредоносным вводом, злоумышленник может
выполнить произвольный код Java Script в браузере пользователя и та-
ким образом может украсть файлы cookie, выдать себя за пользователя
и вообще совершать всякие плохие поступки.
На рис. 18.5 показан базовый пример такой атаки. Легитимные поль-
зователи вашего приложения могут отправить свое имя в ваше приложе-
ние, заполнив форму. Затем приложение добавляет имя во внутренний
список и отображает весь список на странице. Если имена не отобража-
ются безопасно, злоумышленник может выполнить код Java Script в брау -
зере любого другого пользователя, который просматривает список.
POST /vulnerable HTTP/1.1
Name=%3Cscript%3Ealert%28%27Oh+no
%21+XSS%21%27%29%3C%2Fscript%3E
<li>@Html.Raw(name)</li>
1.  Злоумышленник обнаруживает уязвимость
в вашем приложении. Он отправляет
тщательно созданный вредоносный ввод,
который отображается в вашем приложении 2.  Приложение отображает вредоносный ввод на
странице. Если не кодировать входные данные
перед отрисовкой, то приложение становится
открытым для межсайтового скриптинга
3.  Каждый раз, когда пользователь
посещает ваше приложение, скрипт
отображается и автоматически
запускается браузером. Этот скрипт
может делать что угодно, например
красть файлы cookie и отправлять их
злоумышленнику
Рис. 18.5 Как используется XSS-уязвимость. Злоумышленник отправляет в ваше приложение
вредоносное содержимое, которое отображается в браузерах других пользователей. Если
приложение не кодирует содержимое при записи на страницу, ввод становится частью HTML-
страницы и может запускать произвольный код Java Script
На рис. 18.5 пользователь ввел фрагмент HTML, например свое имя.
Когда пользователи просматривают список имен, шаблон Razor отобра-
1 Подробное обсуждение XSS-атак см. в статье «Межсайтовый скриптинг (XSS)»
на сайте OWASP: https://owasp.org/www-community/attacks/xss/.

683 Защита от межсайтового скриптинга
жает имена с  по мощью метода @Html.Raw(), который записывает тег
<script> прямо в документ. Ввод пользователя становится частью HTML-
разметки страницы. Как только страница загружается в браузере пользо-
вателя, тег <script> выполняется, и компьютер пользователя оказывает -
ся скомпрометирован. Как только злоумышленнику удается выполнить
произвольный код Java Script в браузере пользователя, он сможет делать
практически все, что угодно.
Уязвимость здесь связана с небезопасным отображением пользова-
тельского ввода. Если данные не были закодированы, чтобы сделать их
безопасными, прежде чем они будут визуализированы, компьютеры
ваших пользователей будут открыты для атаки. По	умолчанию	 Razor	за-
щищает	 вас	от	XSS-атак	 путем кодирования всех записанных данных
в  HTML с  по мощью тег-хелперов, HTML-хелперов или синтаксиса @.
Поэтому обычно вы должны быть в безопасности, как было показано
в главе 7.
Опасность заключается в  использовании метода @Html.Raw()  – если
HTML, который вы визуализируете, содержит пользовательский ввод
(даже косвенно), у вас может появиться XSS-уязвимость. При выполне-
нии отрисовки пользовательского ввода с  символом @ содержимое ко-
дируется до того, как будет записано в вывод, как показано на рис. 18.6.
POST /vulnerable HTTP/1.1
Name=%3Cscript%3Ealert%28%27Oh+no
%21+XSS%21%27%29%3C%2Fscript%3E
<li>@name</li>
1.  Злоумышленник пытается найти уязвимость
в вашем приложении путем создания
злонамеренного ввода2.  Приложение отображает вредоносный ввод,
но сначала кодирует его в HTML, используя
символ @. Вредоносное содержимое теперь
безопасно, и в нем нет XSS-уязвимостей
3.  Входные данные закодированы, поэтому
текст отображается как безопасная
строка, а не как HTML- элемент скрипта.
Злоумышленник потерпел неудачу
Рис. 18.6 Защита от XSS-атак с по мощью HTML-кодирования пользовательского ввода
с использованием символа @ в шаблонах Razor. Т ег <script> закодирован, поэтому он больше
не отображается как HTML и не может быть использован для компрометации приложения
В этом примере демонстрируется использование кодирования в HTML
для предотвращения непосредственного добавления элементов в HTML
DOM, но это не единственный случай, о котором нужно помнить. Если
вы передаете недоверенные данные в Java Script или используете такие

684 Глава 18 Повышаем безопасность приложения
данные в значениях URL-запросов, необходимо убедиться, что вы пра-
вильно их кодируете.
Распространенный пример – когда вы используете jQuery или Java-
Script на страницах Razor и хотите передать значение с сервера клиен-
ту. Если вы используете стандартный символ @ для отрисовки данных на
странице, вывод будет в кодировке HTML. К сожалению, если вы коди-
руете строку в HTML и вставляете ее непосредственно в код Java Script,
то, вероятно, не получите того, чего ожидаете.
Например, если в вашем файле Razor есть переменная с именем name
и вы хотите сделать ее доступной в Java Script, у вас может возникнуть
соблазн использовать что-то вроде:
<script>var name = '@name'</script>
Если имя содержит специальные символы, Razor закодирует их, ис -
пользуя кодировку HTML, а это, вероятно, не то, что вам нужно в этом
контексте Java Script. Например, если бы у переменной name было значе-
ние Arnold "Arnie" Schwarzenegger, тогда при отрисовке, как вы это дела-
ли ранее, вы бы получили следующее:
<script>var name = 'Arnold &quot;Arnie&quot; Schwarzenegger';</script>
Обратите внимание, что двойные кавычки («) были закодированы
в HTML как &quot;. Если вы используете это значение в коде Java Script
напрямую, ожидая, что оно будет «безопасным» закодированным зна-
чением, то оно будет выглядеть неправильно, как показано на рис. 18.7.
При кодировке в HTML кавычки некорректно
отображаются в JavaScriptКодировка в JavaScript дает безопасный способ
отображать вводимые пользователем данные
в ожидаемом формате
Рис. 18.7  Сравнение предупреждений при использовании кодировки Java Script
и кодировки HTML
Вместо этого нужно закодировать переменную, используя кодировку
Java Script, чтобы двойные кавычки отображались как безопасный сим-
вол Юникода, \u0022. Этого можно добиться с по мощью внедрения Java-
ScriptEncoder в представление (как было показано в главе 10) и вызова
метода Encode() для переменной name:
@inject System.Text.Encodings.Web.Java ScriptEncoder encoder;
<script>var name = '@encoder.Encode(name)'</script>
Чтобы избежать необходимости помнить об использовании кодиров-
ки Java Script, рекомендую вам не записывать значения в Java Script таким
образом. Вместо этого запишите значение в атрибуты HTML-элемента,

685 Защита от межсайтовой подделки запросов (CSRF)
а затем считайте его в переменную Java Script позже. Это полностью из-
бавляет от необходимости использовать кодировщик Java Script.
Листинг 18.4  Передача значений в Java Script путем записи их
в атрибуты HTML
<div id="data" data-name="@name"></div>
<script>
var ele = document.getElementById('data');
var name = ele.getAttribute('data-name');
</script>
XSS-атаки по-прежнему распространены, и вы легко можете подверг -
нуться им всякий раз, когда позволяете пользователям вводить данные.
Валидация входящих данных иногда может помочь, но часто не все так
просто. Например, простой валидатор имени может потребовать, чтобы
вы использовали только буквы, что предотвратит большинство атак. К со-
жалению, здесь не учитываются пользователи, у  которых в  имени есть
дефис или апостроф, не говоря уже о пользователях с незападными име-
нами. Люди (по понятным причинам) расстраиваются, когда вы говорите
им, что их имя недействительно, поэтому остерегайтесь такого подхода!
Независимо от того, используете вы строгую валидацию или нет, вы
всегда должны кодировать данные, когда визуализируете их на страни-
це. Хорошенько подумайте, когда вы пишете @Html.Raw(). Есть ли у поль-
зователя способ ввести вредоносные данные в это поле? Если да, тогда
вам нужно будет найти другой способ отображения данных.
XSS-уязвимости позволяют злоумышленникам выполнять код Java-
Script в браузере пользователя. Следующая уязвимость, которую мы рас -
смотрим, позволяет злоумышленнику делать запросы к вашему API, как
если бы это был другой пользователь, выполнивший вход, даже если он
не использует ваше приложение. Испугались? Надеюсь, что да!
18.3 Защита от межсайтовой подделки запросов
# (CSRF)
В этом разделе вы узнаете о  межсайтовой подделке запросов, а также
о том, как злоумышленники могут использовать эти атаки, чтобы вы-
дать себя за пользователя на вашем сайте, и как защититься от них с по-
мощью токенов противодействия подделке. Razor Pages защищает вас от
этих атак по умолчанию, но вы можете отключить подобные проверки,
поэтому важно понимать, к чему это приведет.
Межсайтовая подделка запросов (CSRF) может быть проблемой для
веб-сайтов или API, которые используют файлы cookie для аутентифи-Записываем желаемое значение
в Java Script в атрибут data-*.
Так вы кодируете данные в HTML.Получает ссылку на HTML-элемент.
Считывает атрибут data- * в Java Script, который
преобразует его в кодировку Java Script.

686 Глава 18 Повышаем безопасность приложения
кации. Такая атака осуществляется с вредоносного веб-сайта, создающе-
го аутентифицированный запрос к вашему API от имени пользователя,
причем пользователь его не инициировал. В  этом разделе мы узнаем,
как работают эти атаки и как смягчить их последствия с по мощью токе-
нов противодействия подделке.
Классический пример такой атаки – банковский перевод или вывод
средств. Представьте, что у  вас есть банковское приложение, которое
хранит токены аутентификации в файлах cookie, как это обычно бывает
(особенно в традиционных серверных приложениях). Браузеры автома-
тически отправляют файлы cookie, ассоциированные с доменом, с каж -
дым запросом, чтобы приложение знало, прошел ли пользователь аутен-
тификацию.
Теперь представьте, что в вашем приложении есть страница, которая
позволяет пользователю переводить средства со своего счета на другой
счет с по мощью POST-запроса на страницу Razor, Balance. Вам нужно вы-
полнить вход, чтобы получить доступ к форме (вы защитили страницу
Razor с по мощью атрибута [Authorize]), а после этого вы просто отправ-
ляете форму, используя POST-запрос, в котором указана сумма, которую
вы хотите перевести, с указанием того, куда вы хотите перевести деньги.
Предположим, пользователь заходит на ваш сайт, выполняет вход
и совершает транзакцию. Затем он посещает второй сайт, контролируе-
мый злоумышленником. Злоумышленник встроил форму в свой сайт, ко-
торый выполняет POST-запрос на сайт вашего банка, идентичный тому,
что использовался для формы на сайте банка, чтобы перевести средства.
Эта форма совершает некие вредоносные действия, например перево-
дит все деньги пользователя злоумышленнику, как показано на рис. 18.8.
Браузеры автоматически отправляют файлы cookie для приложения,
когда страница выполняет POST-запрос в полной форме, и банковское
приложение не может знать, что это злонамеренный запрос. Ничего не
подозревающий пользователь отдает все свои деньги злоумышленнику!
Уязвимость здесь вызвана тем, что браузеры автоматически отправля-
ют файлы cookie при запросе страницы (с использованием GET-запроса)
или отправляется содержимое формы. Нет разницы между легитимным
POST-запросом для отправки формы в вашем банковском приложении
и таким же запросом, исходящим со стороны злоумышленника. К сожа-
лению, подобное поведение встроено в сеть; это то, что позволяет без
проблем путешествовать по сайтам, после того как вы выполнили вход.
Распространенным решением при такой атаке является шаблон Син-
хронизирующий	 токен, который использует уникальные токены проти-
водействия подделке, чтобы обеспечить различие между легитимным
POST-запросом и поддельным запросом от злоумышленника1. Один то-
кен хранится в файле cookie, а другой добавляется в форму, которую вы
хотите защитить. Ваше приложение генерирует токены во время выпол-
1 В статье «Шпаргалка по предотвращению межсайтовой подделки запросов»
на сайте OWASP дается подробное обсуждение уязвимости CSRF, включая
шаб  лон Синхронизирующий	токен: http://mng.bz/5jRa.

687 Защита от межсайтовой подделки запросов (CSRF)
нения на основе текущего пользователя, выполнившего вход, поэтому
злоумышленник не сможет создать такой токен для своей поддельной
формы.
<form>
<input name="value"/>
<input name="account"/>
</form>1.  Пользователь просматривает ваше
приложение и выполняет вход,
задавая тем самым cookie-файл
аутентификации2.  Затем пользователь посещает
вредоносный сайт (или
скомпрометированный сайт)
3.  Вредоносный сайт подделывает форму
на вашем сайте
4.  Поскольку браузер автоматически
отправляет файлы cookie, ваше
приложение выполняет форму, как если
бы пользователь отправил ее напрямую
Рис. 18.8 CSRF-атака происходит, когда совершивший вход пользователь посещает
вредоносный сайт. На этом сайте уже есть форма, которая соответствует форме в вашем
приложении, и злоумышленник отправляет ее содержимое в ваше приложение. Браузер
отправляет cookie-файл аутентификации автоматически, поэтому ваше приложение
воспринимает запрос как действительный запрос от пользователя
Когда страница Razor Balance получает POST-запрос, она сравнивает
значение в  форме со значением в  файле cookie. Если какое-либо зна-
чение отсутствует или токены не совпадают, запрос отклоняется. Ес  ли
злоумышленник создает POST-запрос, браузер отправляет cookie-токен,
как обычно, но в самой форме токена не будет, или же он будет недей-
ствителен. Страница Razor отклонит запрос, таким образом защищаясь
от атаки, как показано на рис. 18.9.
Хорошей новостью является то, что Razor Pages автоматически защи-
щает вас от атак подобного рода. Тег-хелпер формы автоматически уста-
навливает файл cookie токена противодействия подделке и отображает
токен в скрытое поле __RequestVerificationToken для каждого элемента
<form> в вашем приложении (если вы специально не отключили их). На-
пример, возьмем этот простой шаблон Razor, который отправляется об-
ратно на ту же страницу Razor:
<form method="post">
<label>Amount</label>
<input type="number" name="amount" />
<button type="submit">Withdraw funds</button>
</form>

688 Глава 18 Повышаем безопасность приложения
<form>
<input name="value"/>
<input name="account"/>
</form>1.  Пользователь просматривает ваше
приложение и выполняет вход,
задавая тем самым cookie-файл
аутентификации
2.  Формы в вашем приложении
также создают cookie-токен
противодействия подделке 3.  Затем пользователь посещает
вредоносный сайт (или
скомпрометированный сайт)
5.  Браузер автоматически отправляет файлы
cookie, но, поскольку форма не содержит
токен противодействия подделке, ваше
приложение отклоняет запрос4.  Вредоносный веб-сайт подделывает
сообщение из формы на вашем сайте,
но у него нет токена противодействия
подделке
Рис. 18.9 Защита от CSRF-атаки с по мощью специальных токенов. Браузер автоматически
пересылает токен cookie, но вредоносный сайт не может его прочитать и поэтому не может
включить его в форму. Приложение отклоняет вредоносный запрос, потому что токены
не совпадают
При отрисовке в  HTML токен противодействия подделке хранится
в скрытом поле и отсылается обратно с подлинным запросом:
<form method="post">
<label>Amount</label>
<input type="number" name="amount" />
<button type="submit" >Withdraw funds</button>
<input name="__RequestVerificationToken" type="hidden"
value="CfDJ8Daz26qb0hBGsw7QCK"/>
</form>
ASP .NET Core автоматически добавляет эти токены в каждую форму,
а Razor Pages автоматически проверяет их. Фреймворк гарантирует, что
токены есть и в файле cookie, и в данных формы, и гарантирует их со-
впадение и отклоняет любые запросы в случае, если они не совпадают.
Если вы используете контроллеры MVC с представлениями вместо Ra-
zor Pages, ASP .NET Core по-прежнему добавляет токены противодействия
подделке в каждую форму. К сожалению, он их не проверяет. Вместо это-
го нужно декорировать свои контроллеры и действия атрибутами [Vali-
dateAntiForgeryToken]. Это гарантирует, что эти токены есть и в файле
cookie, и в данных формы, проверяет их на предмет совпадения, а если
они не совпадают, то отклоняет любые запросы.
ПРЕДУПРЕЖДЕНИЕ  ASP .NET Core не проверяет токены проти-
водействия подделке автоматически, если вы используете конт -
роллеры MVC с  представлениями. Убедитесь, что вы пометили

689 Защита от межсайтовой подделки запросов (CSRF)
все уязвимые методы атрибутами [ValidateAntiForgeryToken],
как описано в разделе «Предотвращение атак с межсайтовой под-
делкой запросов (XSRF / CSRF)» в документации по ASP .NET Core:
http://mng.bz/Xd6E. Обратите внимание, что если вы используете
контроллеры веб-API, но не используете файлы cookie для аутенти-
фикации, вы не уязвимы для атак CSRF.
Как правило, нужно использовать эти токены только для запросов
с  методами POST, DELETE и  других опасных типов запросов, которые
используются для изменения состояния. GET-запросы для этой цели не
используются, поэтому фреймворк не требует допустимых защитных
токенов для их вызова. Razor Pages проверяет эти токены, если речь об
опасных методах, таких как POST, и игнорирует безопасные методы, та-
кие как GET. Пока вы создаете свое приложение, следуя этому шаблону
(а вы должны следовать ему!), фреймворк сделает все возможное, чтобы
вы были в безопасности.
Если вам по какой-то причине необходимо явно игнорировать эти то-
кены на странице Razor, то можете отключить проверку, применив атри-
бут [IgnoreAntiforgeryToken] к PageModel страницы Razor. Это позволяет
обойти защиту фреймворка для тех случаев, когда вы уверены, что де-
лаете нечто безопасное, от чего не требуется защита, но в большинстве
случаев лучше перестраховаться и все проверить.
Защита от CSRF-атак может быть непростой задачей с  технической
точки зрения, но по большей части все должно работать без особых уси-
лий с вашей стороны. Razor добавит токены в ваши формы, а фреймворк
Razor Pages позаботится о валидации.
Все становится сложнее, если вы делаете много запросов к API с по-
мощью Java Script и отправляете объекты в формате JSON, а не данные
формы. В таких случаях вы не сможете отправить токен верификации
как часть формы (потому что вы отправляете JSON), поэтому вам нужно
будет вместо этого добавить его в качестве заголовка в запрос1.
СОВЕТ  Если вы не используете аутентификацию с файлами coo-
kie и  у  вас есть одностраничное приложение, отправляющее то-
кены аутентификации в заголовке, то это хорошая новость – вам
вообще не нужно волноваться о межсайтовой подделке запросов!
Вредоносные сайты могут отправлять вашему API только файлы
cookie, но не заголовки, поэтому они не могут выполнять запросы,
прошедшие аутентификацию.
1 Как именно вы это делаете, зависит от того, какой Java Script-фреймворк вы
используете. Документация Microsoft («Предотвращение атак с межсайтовой
подделкой запросов (XSRF/CSRF) в  ASP .NET Core») содержит примеры с  ис -
пользованием JQuery и AngularJS, но вы должны иметь возможность распро-
странить это на выбранный вами фреймворк Java Script: http://mng.b z/54Sl.

690 Глава 18 Повышаем безопасность приложения
Создание уникальных токенов с API для защиты данных
Защитные токены, используемые для предотвращения межсайтовой под-
делки запросов, зависят от возможностей фреймворка использовать силь-
ное симметричное шифрование для шифрования и расшифровки данных.
Алгоритмы шифрования обычно полагаются на один или несколько ключей,
которые используются, чтобы инициализировать шифрование и сделать этот
процесс воспроизводимым. Если у  вас есть ключ, вы можете шифровать
и расшифровывать данные; без него данные в безопасности.
В ASP.NET Core шифрование выполняют API защиты данных (data protection
API). Они создают защитные токены, шифруют cookie-файлы аутентификации
и генерируют безопасные токены. Что особенно важно – они также контро-
лируют управление файлами ключей, которые используются для шифрования.
Файл ключа – это небольшой XML-файл, который содержит случайное зна-
чение ключа, используемое для шифрования в приложениях ASP.NET Core.
Очень важно, чтобы он хранился в надежном месте – если злоумышленник
завладеет им, то сможет выдавать себя за любого пользователя вашего при-
ложения и вообще делать плохие вещи!
Система защиты данных хранит ключи в надежном месте, в зависимости от
того, как и где вы размещаете приложение. Например:
  веб­приложение Azure – в специальной синхронизированной папке, со-
вместно используемой регионами;
  IIS без профиля пользователя – зашифрованы в реестре;
  учетная запись с  профилем пользователя  – в  %LOCALAPPDATA%\ASP.
NET\DataProtection-Keys в  Windows или ~/.aspnet/DataProtection-Keys
в Linux или macOS;
  все остальные случаи – в  памяти; при перезапуске приложения ключи
будут потеряны.
Так почему вас это должно волновать? Чтобы ваше приложение могло читать
cookie-файлы аутентификации ваших пользователей, оно должно расшиф-
ровать их, используя тот же ключ, который применялся для их шифрования.
Если вы работаете с несколькими серверами, то по умолчанию у каждого
сервера будет свой ключ, и вы не сможете читать файлы cookie, зашифро-
ванные другими серверами.
Чтобы обойти это, вы должны сконфигурировать свое приложение для хра-
нения ключей защиты данных в едином месте. Это может быть совместно
используемая папка на жестком диске, экземпляр Redis или, например, эк -
земпляр хранилища BLOB-объектов Azure.
Документация Microsoft по API защиты данных чрезвычайно подробная, но
может показаться непосильной. Рекомендую прочитать раздел по настройке
защиты данных (http://mng.bz/d40i) и настройке провайдера хранилища клю-
чей для использования в том случае, если у вас несколько серверов (https://
docs.microsoft.com/en-us/aspnet/core/security/data-protection/implementa -
tion/key-storage-providers?view=aspnetcore-5.0&tabs=visual-studio).

691 Вызов веб-API из других доменов с помощью CORS
Стоит пояснить, что уязвимости, подверженные межсайтовой под-
делке запросов, обсуждаемые в этом разделе, требуют, чтобы вредонос -
ный сайт выполнял к вашему приложению POST-запрос в полной форме.
Вредоносный сайт не может запрашивать ваш API, используя только код
Java Script на	стороне	 клиента, поскольку браузеры будут блокировать
запросы к вашему API из другого источника.
Это функция безопасности, но она часто может вызывать проблемы.
Если вы создаете одностраничное клиентское приложение, или даже
если у вас есть небольшое количество кода Java Script в приложении с от -
рисовкой на стороне сервера, вы можете обнаружить, что вам нужно де-
лать подобные запросы между	разными	 источниками. В следующем раз-
деле я опишу типичный сценарий, с которым вы, вероятно, столкнетесь,
и покажу, как изменить приложение, чтобы обойти его.
18.4 Вызов веб-API из других доменов
с помощью CORS
В этом разделе вы узнаете о  совместном использовании ресурсов
между разными источниками (CORS), протоколе, позволяющем Java-
Script делать запросы из одного домена в другой. CORS часто смущает
многих разработчиков, поэтому в этом разделе описывается, почему
он необходим и как работают заголовки CORS. Затем вы узнаете, как
добавить CORS для своего приложения и для определенных действий
веб-API, а  также как настроить несколько политик CORS для своего
приложения.
Как вы уже видели, атаки с межсайтовой подделкой запросов могут
быть довольно мощными, но они были бы еще опаснее, если бы не брау -
зеры, реализующие правило	 ограничения	 домена. Данная концепция за-
прещает приложениям использовать Java Script для вызова веб-API в дру -
гом месте, если только это не разрешено явно веб-API.
ОПРЕДЕЛЕНИЕ  Источники считаются одинаковыми, если они
соответствуют протоколу (HTTP или HTTPS), домену (example.com)
и порту (80 по умолчанию для HTTP и 443 для HTTPS). Если при-
ложение пытается получить доступ к ресурсу с по мощью Java Script
и источники не идентичны, браузер блокирует запрос.
Правило ограничения домена является строгим  – источники двух
URL-адресов должны быть идентичны, чтобы запрос был разрешен. На-
пример, следующие источники одинаковы:
http://example.com/home;
http://example.com/site.css.
Пути этих двух адресов различаются (/home и /site.css), но протокол,
домен и порт (80) идентичны. Итак, если бы вы находились на главной

692 Глава 18 Повышаем безопасность приложения
странице своего приложения, то могли бы без проблем запросить файл
/site.css с по мощью Java Script.
Напротив, источники следующих сайтов различаются, поэтому вы не
можете запросить ни один из этих URL-адресов с по мощью Java Script из
источника http://example.com:
https:	//example.com – другой протокол (https);
http:	//www.example.com – другой домен (включая поддомен);
http:	//example.com:5000 – другой порт.
Что касается простых приложений, например когда вся функциональ-
ность сосредоточена в одном веб-приложении, такое ограничение может
и не быть проблемой, но очень часто приложение отправляет запросы
в иной домен.
Например, у вас может быть сайт для онлайн-торговли, расположен-
ный по адресу http://shopping.com, и  вы пытаетесь загрузить данные
с  сайта http://api.shopping.com, чтобы отобразить подробные сведения
о товарах, имеющихся в продаже. При такой конфигурации вы столкне-
тесь с правилом ограничения домена. Любая попытка выполнить запрос
с  по мощью Java Script к домену api.shopping.com завершится ошибкой,
аналогичной той, что показана на рис. 18.10.
По умолчанию браузер
не разрешает запросы
из разных источников
и блокирует доступ вашего
приложения к ответу
Рис. 18.10 Журнал консоли для неудавшегося запроса. Chrome заблокировал запрос
от приложения http://shopping.com:6333 к API по адресу http://api.shopping.com:5111
Необходимость выполнять запросы, используя разные источники, из
Java Script становится все более распространенным явлением с ростом чис -
ла клиентских одностраничных приложений и  отходом от монолитных
приложений. К счастью, есть веб-стандарт, позволяющий безопасно обой-
ти эту проблему, – это совместное использование ресурсов между разными
источниками (CORS). Вы можете использовать его, чтобы контролировать,
какие приложения могут вызывать ваш API, дабы иметь возможность раз-
решать сценарии, подобные тому, который я только что описал.
18.4.1 Разбираемся с CORS и тем, как он работает
CORS – это веб-стандарт, позволяющий вашему веб-API делать заявле-
ния о том, кто может выполнять к нему запросы из разных источников.
Например, можно:
разрешить запросы от http://shopping.com и ht tps://app.shopping.com;
разрешить запросы из разных источников, только если использует -
ся метод GET;

693 Вызов веб-API из других доменов с помощью CORS
разрешить возвращать заголовок Server в  ответах на запросы из
разных источников;
разрешить отправку учетных данных (таких как cookie-файлы
аутен тификации или заголовки авторизации) с запросами из раз-
ных источников.
Можно объединить эти правила в  политику	 и применять разные по-
литики к  разным конечным точкам своего API. Вы можете применить
политику ко всему приложению или отдельную политику к каждому дей-
ствию API.
CORS использует HTTP-заголовки. Когда ваш веб-API получает запрос,
он задает специальные заголовки для ответа, чтобы указать, разрешены
ли запросы из разных источников, что это за источники и какие HTTP-
методы и заголовки может использовать запрос, – почти все, что касает -
ся запроса.
В некоторых случаях перед отправкой реального запроса к вашему API
браузер отправляет предварительный запрос. Он отправляется с исполь-
зованием метода OPTIONS, который браузер использует, чтобы проверить,
разрешено ли сделать настоящий запрос. Если API вернет правильные за-
головки, браузер отправит настоящий запрос, как показано на рис. 18.11.
# GET
# OPTIONS
Access-Control-Allow-Origin
PUThttp://shopping.com http://api.shopping.com
1.  Браузер начинает с загрузки главной
HTML-страницы приложения с сайта
http://shopping.com
2.  Клиентский JavaScript выполняет GET -запрос
к API http://api.shopping.com
5.  Для некоторых HTTP-методов (например,
PUT) браузер отправляет «предварительный»
запрос OPTIONS
8.  В данном случае предварительный ответ
включал заголовки CORS, поэтому браузер
выполняет запрос3.  Даже если API не настроен
для CORS, он может
вернуть данные
6.  Если API настроен
для CORS, он добавит
специальные заголовки
CORS к ответу4.  Браузер проверяет
ответ на наличие
заголовков CORS.
Если их нет, то он
не дает JavaScript
прочитать ответ
7.  Если ответ OPTIONS
не включает заголовки
CORS, браузер не будет
выполнять «настоящий»
запрос
9.  Браузер делает
ответ доступным
для JavaScript, который
инициировал запрос
Рис. 18.11 Два запроса из разных источников. Ответ на первый запрос не содержит
заголовки CORS, поэтому браузер блокирует их чтение приложением. Второй запрос требует
предварительного запроса с по мощью метода OPTIONS, чтобы проверить, активирован ли CORS.
Поскольку ответ содержит заголовки CORS, можно сделать настоящий запрос и предоставить
ответ приложению Java Script

694 Глава 18 Повышаем безопасность приложения
Для более подробного обсуждения см. книгу «CORS	 в действии» Мон-
сура Хуссейна (Manning, 2014): http://mng.bz/aD41.
Спецификация CORS, как и многие технические документы, довольно
сложна и содержит множество заголовков и процессов, с которыми при-
дется столкнуться1. К счастью, ASP .NET Core занимается деталями специ-
фикации за вас, поэтому ваша основная задача – точно определить, кому
и при каких обстоятельствах нужен доступ к вашему API.
18.4.2 Добавление глобальной политики CORS
ко всему приложению
Как правило, не следует настраивать CORS для своих API, пока он вам не
понадобится. Браузеры не просто так блокируют обмен данными между
источниками – так они закрывают путь для атаки. Подождите, пока у вас
не появится API в домене, отличном от приложения, которому необходи-
мо получить к нему доступ.
Чтобы добавить поддержку CORS в приложение, необходимы четыре
вещи:
добавить сервисы CORS в свое приложение;
настроить хотя бы одну политику CORS;
добавить промежуточное ПО CORS в конвейер;
задать политику CORS по умолчанию для всего приложения либо
декорировать действия веб-API атрибутом [EnableCors], чтобы вы-
борочно активировать CORS для определенных конечных точек.
Добавление сервисов CORS в приложение включает в себя вызов мето-
да AddCors() в методе Startup.ConfigureServices:
services.AddCors()
Бóльшая часть ваших усилий по настройке CORS уйдет на конфигу -
рирование политики. Политика CORS контролирует, как ваше приложе-
ние будет отвечать на запросы из разных источников. Она определяет,
какие источники разрешены, какие заголовки возвращать, какие HTTP-
методы разрешить и т. д. Обычно политики определяются одновременно
с добавлением сервисов CORS в свое приложение.
Например, рассмотрим предыдущий пример с сайтом для онлайн-тор-
говли. Вы хотите, чтобы ваш API, размещенный на http://api.shopping.
com , был доступен из основного приложения через клиентский Java Script,
размещенный на http://shopping.com . Поэтому необходимо настроить
API, чтобы разрешить запросы из разных источников.
ПРИМЕЧАНИЕ  Помните, что именно основное приложение бу -
дет получать ошибки при попытке делать запросы из разных ис -
точников, но вам нужно добавить CORS к  API, к которому вы полу -
чаете доступ, а не в приложение, выполняющее запросы.
1 Если вам так будет проще, то можете прочитать спецификацию здесь: https://
fetch.spec.whatwg.org/#http-cors-protocol.

695 Вызов веб-API из других доменов с помощью CORS
В следующем листинге показано, как настроить политику "AllowShop-
pingApp", чтобы разрешить запросы из разных источников от http://
shopping.com к API. Кроме того, мы явно разрешаем любой тип HTTP-
метода; без этого вызова разрешены только простые методы (GET, HEAD
и POST). Политики создаются с использованием знакомого беглого стиля
построителя (fluent builder), который вы встречали на протяжении всей
этой книги.
Листинг 18.5  Настройка политики CORS, чтобы разрешить запросы
из определенного источника
public void ConfigureServices(IServiceCollection services)
{
services.AddCors(options => {
options.AddPolicy("AllowShoppingApp", policy =>
policy.WithOrigins("http://shopping.com")
.AllowAnyMethod());
});
// Другая конфигурация сервисов.
}
ВНИМАНИЕ!  При перечислении источников в  методе WithOri-
gins() убедитесь, что у них нет завершающего символа в виде на-
клонной черты «/»; в  противном случае источники не совпадут,
и ваши запросы не будут выполнены.
После того как вы определили политику CORS, вы можете применить
ее к своему приложению. В следующем листинге вы применяете полити-
ку "AllowShoppingApp" ко всему приложению с по мощью CorsMiddleware,
вызвав метод UseCors() в методе Configure файла Startup.cs.
Листинг 18.6  Добавление промежуточного ПО CORS и настройка
политики CORS по умолчанию
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
app.UseRouting();
app.UseCors("AllowShoppingApp");
app.UseAuthentication();
app.UseAuthorization();
app.UseEndpoints(endpoints =>
{
endpoints.MapControllers();
});
}Метод AddCors предоставляет перегруженный вариант Action<CorsOptions>.
У каждой политики
есть уникальное имя.
Метод WithOrigins указывает, какие
источники разрешены. Обратите внимание,
что URL-адрес не имеет завершающего
символа в виде наклонной черты /.Позволяет всем HTTP-методам
вызывать API.
Промежуточное ПО CORS должно идти
после вызова метода UseRouting().
Добавляет промежуточное ПО CORS
и использует AllowShoppingApp в качестве
политики по умолчанию.
Помещаем промежуточное ПО CORS перед
промежуточным ПО конечной точки.

696 Глава 18 Повышаем безопасность приложения
ПРИМЕЧАНИЕ  Как и в случае со всеми компонентами промежу -
точного ПО, важен порядок промежуточного ПО CORS. Вы должны
разместить вызов UseCors() после метода UseRouting() и до метода
UseEndpoints(). Промежуточное ПО CORS должно перехватывать
запросы из разных источников к вашим действиям веб-API, чтобы
иметь возможность генерировать правильные ответы на предва-
рительные запросы и добавлять необходимые заголовки. Обычно
промежуточное ПО CORS размещается перед вызовом UseAuthen-
tication().
Имея такое промежуточное ПО для API, приложение для онлайн-
тор говли теперь может выполнять запросы из разных источников. Вы
можете вызвать API с  сайта http://shopping.com, и  браузер пропускает
CORS-запрос, как показано на рис. 18.12. Если вы сделаете тот же запрос
из домена, отличного от http://shopping.com, запрос останется заблоки-
рованным.
Без CORS
C CORSПо умолчанию браузер
не разрешает запросы
из разных источников
и блокирует доступ вашего
приложения к ответу
При активировании CORS API
отправляет заголовки CORS
с ответом. Браузер видит эти
заголовки и передает ответ
JavaScript
Рис. 18.12 При активации CORS, как показано на изображении ниже, могут
выполняться запросы из разных источников, и браузер сделает ответ доступным
для Java Script. Сравните это с верхним изображением, на котором запрос был
заблокирован
Глобальное применение политики CORS к своему приложению может
оказаться излишним. Если в вашем API есть только подмножество дей-
ствий, к которым нужно обращаться из других источников, будет разум-
но активировать CORS лишь для этих конкретных действий. Это можно
сделать с по мощью атрибута [EnableCors].

697 Вызов веб-API из других доменов с помощью CORS
18.4.3 Добавляем CORS к определенным действиям веб-API
с помощью атрибута EnableCors
Браузеры по умолчанию блокируют запросы из разных источников по
уважительной причине – они могут быть использованы вредоносными
или взломанными сайтами. Активация CORS для всего приложения мо-
жет не стоить риска, если вы знаете, что вам когда-либо потребуется до-
ступ только к подмножеству действий из разных источников.
В таком случае лучше всего активировать политику CORS только для
этих конкретных действий. ASP .NET Core предоставляет атрибут [Ena-
bleCors], позволяющий выбрать политику, которая будет применяться
к определенному контроллеру или методу действия. Данный подход по-
зволяет применять разные политики CORS к разным методам действий.
Например, можно разрешить GET-запросам доступ ко всему API из до-
мена http://shopping.com и только другие HTTP-методы для конкретно-
го контроллера, позволяя всем получить доступ к методу, получающему
список продуктов.
Эти политики определяются в  методе ConfigureServices с  по мощью
метода AddPolicy(), и политике дается имя, как вы уже видели в листин-
ге 18.5. Однако вместо вызова UseCors("AllowShoppingApp"), как вы ви-
дели в листинге 18.6, вы добавляете промежуточное ПО без политики по
умолчанию, вызывая только метод UseCors().
Чтобы применить политику к контроллеру или методу действия, ис -
пользуйте атрибут [EnableCors], как показано в  следующем листинге.
Атрибут [EnableCors] для действия имеет приоритет над этим же атрибу -
том для контроллера, или же можно использовать атрибут [DisableCors],
чтобы полностью отключить доступ к методу из разных источников.
Листинг 18.7  Применение атрибута EnableCors к контроллеру
и действию
[EnableCors("AllowShoppingApp")]
public class ProductController: Controller
{
[EnableCors("AllowAnyOrigin")
public IActionResult GeteProducts() { /* Method */ }
public IActionResult GeteProductPrice(int id) { /* Method */ }
[DisableCors]
public IActionResult DeleteProduct(int id) { /* Method */ }
}Применяет политику CORS,
AllowShoppingApp, к каждому
методу действия.Политика AllowAnyOrigin «ближе» к действию, поэтому имеет приоритет.
Будет применена политика AllowShoppingApp (из контроллера).Атрибут DisableCors полностью отключает
CORS для метода действия.

698 Глава 18 Повышаем безопасность приложения
Если вы хотите применить политику CORS к  большинству своих
действий, но хотите использовать другую политику или полностью от -
ключить CORS для некоторых из них, то можете передать политику по
умолчанию при настройке промежуточного ПО, например с  по мощью
Use Cors("Allow ShoppingApp"). Действия, декорированные [Enable-
Cors("Other Policy")], будут преимущественно применять OtherPolicy,
а для действий, декорированных атрибутом [DisableCors], CORS вообще
не будет активирован.
Независимо от того, хотите ли вы использовать одну политику CORS
по умолчанию или несколько, необходимо настроить политики CORS для
своего приложения в методе ConfigureServices. При настройке CORS до-
ступно множество различных параметров. В следующем разделе я пре-
доставлю их обзор.
18.4.4 Настройка политик CORS
Браузеры реализуют политику CORS из соображений безопасности, по-
этому следует внимательно подумать о последствиях ослабления любых
налагаемых ими ограничений. Даже если вы активируете возможность
отправки запросов из разных источников, то все равно сможете контро-
лировать, какие данные эти запросы могут отправить и что вернет ваш
API. Например, можно настроить:
источники, которые могут делать запросы к вашему API из разных
источников;
HTTP-методы (такие как GET, POST и DELETE), которые можно ис -
пользовать;
заголовки, которые может отправлять браузер;
заголовки, которые браузер может прочитать из ответа вашего при-
ложения;
будет ли браузер отправлять с запросом учетные данные для аутен-
тификации.
Все эти параметры определяются при создании политики CORS в вы-
зове метода AddCors(), используя метод CorsPolicyBuilder, как вы видели
в листинге 18.5. Политика может задать все эти параметры или ни один
из них, чтобы вы могли настроить результаты по своему усмотрению.
В табл. 18.1 показаны некоторые доступные параметры и что они делают.
Один из первых моментов, возникающих при настройке CORS, – осо-
знание того, что у вас проблема с разными источниками. Несколько раз
я был в тупике, пытаясь понять, почему запрос не работает, пока не по-
нял, что это кросс-доменный запрос или он идет с HTTP на HTTPS, на-
пример.
По возможности я рекомендую полностью избегать запросов из раз-
ных источников. Вы можете столкнуться с  небольшими различиями
в том, как браузеры обрабатывают их, что может причинить еще больше
головной боли. В частности, избегайте кросс-доменных проблем при пе-
реходе с HTTP на HTTPS, запуская все свои приложения с использовани-
ем протокола HTTPS. Как уже обсуждалось в разделе 18.1, в любом случае

699 Изучение других векторов атак
это более подходящая практика, и она поможет избежать головной боли,
связанной с CORS.
Таблица 18.1 Доступные методы для настройки политики CORS,
и что они делают
Пример метода CorsPolicyBuilder Результат
WithOrigins("http://shopping.
com") Разрешает запросы из разных источников от http://
shopping.com
AllowAnyOrigin() Разрешает запросы из любого источника. Это означает,
что любой веб-сайт может делать Java Script-запросы
к вашему API
WithMethods()/AllowAnyMethod() Задает разрешенные HTTP-методы (такие как GET,
POST и DELETE), с по мощью которых можно выполнять
запросы к вашему API
WithHeaders()/AllowAnyHeader() Задает заголовки, которые браузер может отправлять
вашему API. Если вы ограничиваете заголовки,
то должны включить по меньшей мере заголовки
"Accept", "Content-Type" и "Origin", чтобы разрешить
действительные запросы
WithExposedHeaders() Позволяет вашему API отправлять в браузер
дополнительные заголовки. По умолчанию в ответе
отправляются только заголовки Cache-Control,
Content-Language, Content-Type, Expires, LastModified
и Pragma
AllowCredentials() По умолчанию браузер не отправляет детали
аутентификации с запросами из разных источников,
только если вы явно не разрешите это. Вы также
должны активировать отправку учетных данных
на стороне клиента в Java Script при создании запроса
Когда я решаю, что мне определенно нужна политика CORS, то обычно
начинаю с метода WithOrigins(). Затем при необходимости я расширяю
или ограничиваю политику, чтобы обеспечить блокировку моего API для
запросов из разных источников, сохранив при этом необходимую функ -
циональность. Обойти CORS может быть сложно, но помните, что эти
ограничения существуют для вашей же безопасности1.
Запросы из разных источников – всего лишь один из множества по-
тенциальных способов, с  по мощью которых злоумышленники могут
скомпрометировать ваше приложение. От многих из них легко защи-
титься, но нужно знать о них и знать, как смягчить последствия таких
атак. В  следующем разделе мы рассмотрим распространенные угрозы
и способы избежать их.
18.5 Изучение других векторов атак
Пока я  описал два потенциальных способа, с  по мощью которых зло-
умышленники могут скомпрометировать ваши приложения, – межсай-
1 Вы можете найти список с первой десяткой от OWASP здесь: https://owasp.org/
www-project-top-ten.

700 Глава 18 Повышаем безопасность приложения
товый скриптинг и межсайтовая подделка запросов – и как их предот -
вратить. Обе эти уязвимости регулярно входят в десятку самых важных
рисков для веб-приложений по версии OWASP1, поэтому важно знать
о  них и  избегать их появления в  своих приложениях. В  этом разделе
я дам обзор других наиболее распространенных уязвимостей и расскажу,
как избежать их появления в своих приложениях.
18.5.1 Обнаружение и предотвращение атак с открытым
перенаправлением
Одна из распространенных уязвимостей, описанная на сайте OWASP ,
связана с атаками с  открытым	 перенаправлением. Это атака, при которой
пользователь щелкает по ссылке, ведущей на другое безопасное прило-
жение, и в конечном итоге попадает на вредоносный веб-сайт, например
обслуживающий вредоносное ПО. Безопасное приложение не содержит
прямых ссылок на вредоносный сайт, так как же это происходит?
Атаки с  открытым перенаправлением происходят, когда следующая
страница передается в  качестве параметра методу действия. Самый
распространенный пример – когда вы входите в  приложение. Обычно
приложения запоминают страницу, на которой находится пользователь,
прежде чем перенаправить его на страницу входа, передавая текущую
страницу в качестве параметра строки запроса returnUrl. После того как
пользователь выполняет вход, приложение перенаправляет пользовате-
ля на returnUrl, чтобы продолжить с того места, где он остановился.
Представьте, что пользователь просматривает сайт для онлайн-тор-
говли. Он нажимает кнопку «Купить» рядом с продуктом и перенаправ-
ляется на страницу входа. Страница продукта, на которой он находился,
передается в виде returnUrl, поэтому после входа он перенаправляется
на страницу продукта вместо переброски на главную страницу.
Атака с открытым перенаправлением использует этот общепринятый
шаблон, как показано на рис. 18.13. Злоумышленник создает URL-адрес
для входа, где для returnUrl задается значение в виде веб-сайта, на кото-
рый он хочет отправить пользователя. Злоумышленник убеждает поль-
зователя щелкнуть по ссылке, ведущей на ваше веб-приложение. После
того как пользователь выполнит вход, уязвимое приложение перенапра-
вит пользователя на вредоносный сайт.
Простой способ решить такую проблему – всегда проверять, что re-
turnUrl является локальным URL-адресом, принадлежащим вашему
приложению, до	того, как перенаправить пользователей на него. Поль-
зовательский интерфейс Identity по умолчанию уже делает это, поэтому
вам не нужно беспокоиться о странице входа, если вы используете эту
систему, как описано в главе 14.
1 OWASP публикует список в интернете с описанием каждой атаки и способа-
ми предотвращения этих атак. Здесь есть шпаргалка по безопасности: https://
cheatsheetseries.owasp.org/.

701 Изучение других векторов атак
HTTP/1.1 302 Found
Location: http://evil.comhttp://shopping.com/Account/
login?returnUrl=http%3A%2F%2Fevil.com1.  Пользователь щелкает по ссылке на страницу
входа доверенного приложения, которое
выглядит безопасным
2.  Приложение, как обычно, показывает
страницу входа, обслуживаемую
доверенным приложением
5.  Браузер следует за этим
редиректом, и пользователь попадает
на вредоносный сайт 3.  Пользователь
выполняет вход
со своим адресом
электронной почты,
паролем и returnUrl4.  После входа пользователя
приложение отправляет редирект
на указанный returnUrl
Рис. 18.13 Открытое перенаправление использует распространенный шаблон
URL-адреса возврата. Обычно он используется для страниц входа, но может
использоваться и в других областях вашего приложения. Если приложение
не проверяет, что URL-адрес безопасен до перенаправления пользователя,
то может перенаправлять пользователей на вредоносные сайты
Если у  вас есть перенаправления в  других частях приложения, ASP .
NET Core предоставляет несколько вспомогательных методов для обес -
печения безопасности, наиболее полезным из которых является Url.
IsLocalUrl(). В следующем листинге показано, как убедиться, что пре-
доставленный returnUrl безопасен, а если это не так, выполнить перена-
правление на главную страницу приложения. Вы также можете исполь-
зовать вспомогательный метод LocalRedirect() в классах ControllerBase
и PageModel, который возбуждает исключение, если предоставленный
URL-адрес не является локальным.
Листинг 18.8  Обнаружение атак с открытым перенаправлением путем
проверки локальных URL-адресов возврата
[HttpPost]
public async Task<IActionResult> Login(
LoginViewModel model, string returnUrl = null)
{
// Проверяем пароль и даем пользователю выполнить вход.
if (Url.IsLocalUrl(returnUrl))
{URL-адрес возврата
предоставляется в качестве
аргумента метода действия.
Возвращает true, если URL-адрес возврата
начинается с символа / или ~ /.

702 Глава 18 Повышаем безопасность приложения
return Redirect(returnUrl);
}
else
{
return RedirectToAction("Index", "Home");
}
}
Этот простой шаблон обеспечивает защиту от атак открытого перена-
правления, которые в противном случае могли бы предоставить вашим
пользователям доступ к  вредоносному контенту. Всякий раз, когда вы
перенаправляете пользователя на адрес, который идет из строки запро-
са или другого пользовательского ввода, вы должны использовать этот
шаблон.
Атаки с открытым перенаправлением представляют риск для ваших
пользователей, но не для вашего приложения напрямую, а  следующая
уязвимость представляет собой опасность уже для самого приложения.
18.5.2 Предотвращение атак с использованием внедрения
SQL-кода с по мощью EF Core и параметризации
Атаки путем внедрения SQL-кода представляют собой одну из самых
опасных угроз для приложения. Злоумышленники создают простой
вредоносный код, который они отправляют в ваше приложение в виде
традиционного ввода на основе форм или путем настройки URL-адресов
и строк запроса для выполнения произвольного кода в вашей базе дан-
ных. Данная уязвимость может предоставить доступ злоумышленникам
ко всей вашей базе данных, поэтому очень важно находить и устранять
любые подобные уязвимости в своих приложениях.
Надеюсь, я вас немного напугал этим вступлением, а теперь перейдем
к хорошим новостям – если вы используете EF Core (или почти любой
другой ORM-инструмент) стандартным образом, то вы в безопасности.
EF Core имеет встроенную защиту от внедрения SQL-кода, поэтому если
вы не делаете ничего экстравагантного, все будет в порядке.
Подобные уязвимости возникают, когда вы сами создаете инструкции
SQL и включаете динамический ввод, предоставляемый злоумышленни-
ком, пусть даже косвенно. EF Core предоставляет возможность создавать
низкоуровневые SQL-запросы с по мощью метода FromSqlRaw(), поэтому
вы должны быть осторожными, когда используете его.
Представьте, что в  вашем приложении с  рецептами есть форма по-
иска, позволяющая искать рецепт по названию. Если вы пишете запрос
с использованием методов расширения LINQ (как описано в главе 12), то
атаки с использованием внедрения SQL-кода вам не грозят. Однако если
вы решите написать SQL-запрос вручную, то откроете путь для подобной
уязвимости.URL-адрес является локальным, поэтому
перенаправление на него безопасно.
URL-адрес не был локальным и мог представлять собой атаку
с открытым перенаправлением, поэтому в целях безопасности
выполняем перенаправление на домашнюю страницу.

703 Изучение других векторов атак
Листинг 18.9  Внедрение SQL-кода в EF Core, обусловленное
конкатенацией строк
public IList<User> FindRecipe(string search)
{
return _context.Recipes
.FromSqlRaw("SELECT * FROM Recipes" +
"WHERE Name = '" + search + "'")
.ToList();
}
В этом листинге пользовательский ввод в параметре search включен
непосредственно в SQL-запрос. Создавая вредоносный ввод, пользова-
тели потенциально могут выполнять любые операции с  вашей базой
данных. Представьте, что злоумышленник выполняет поиск по вашему
сайту, используя текст
'; DROP TABLE Recipes; --
Ваше приложение назначает его параметру search, и SQL-запрос, вы-
полняемый к вашей базе данных, принимает следующий вид:
SELECT * FROM Recipes WHERE Name = ''; DROP TABLE Recipes; --'
Просто введя текст в  форму поиска вашего приложения, злоумыш-
ленник удалил из него всю таблицу рецептов! Это катастрофа, но подоб-
ная уязвимость обеспечивает более или менее неограниченный доступ
к базе данных. Даже если вы правильно настроили полномочия для базы
данных, чтобы предотвратить такого рода деструктивные действия, зло-
умышленники, вероятно, смогут прочитать все данные из вашей базы,
включая данные пользователей.
Самый простой способ избежать этого  – не создавать SQL-запросы
вручную. Если вам действительно нужно написать собственные SQL-
запросы, не используйте конкатенацию строк, как в листинге 18.9. Ис -
пользуйте параметризованные запросы, в  которых (потенциально не-
безопасные) входные данные отделены от самого запроса, как показано
здесь.
Листинг 18.10  Как избежать внедрения SQL-кода,
используя параметризацию
public IList<User> FindRecipe(string search)
{
return _context.Recipes
.FromSqlRaw("SELECT * FROM Recipes WHERE Name = '{0}'",
search)
.ToList();
}Параметр поиска вводится
пользователем, поэтому
это небезопасно.
Т екущий DbContext хранится в поле _context.
Вы можете писать запросы
вручную, используя метод
расширения FromSqlRaw.Внедряет уязвимость, включая
небезопасный контент непосредственно в строку SQL.
В SQL-запросе для параметра
используется заполнитель {0}.
Опасный ввод передается в виде параметра
отдельно от запроса.

704 Глава 18 Повышаем безопасность приложения
Параметризованные запросы не уязвимы для атак с внедрением SQL-
кода, поэтому представленная ранее атака не сработает. Если вы исполь-
зуете EF Core (или другие ORM-инструменты) для доступа к данным с по-
мощью стандартных LINQ-запросов, то будете неуязвимы для подобных
атак. EF Core будет автоматически создавать все SQL-запросы, используя
параметризованные запросы, чтобы защитить вас.
ПРИМЕЧАНИЕ  Я говорил об атаках с использованием внедрения
SQL-кода только с точки зрения реляционной базы данных, но эта
уязвимость может проявляться и в NoSQL, и в документоориенти-
рованных базах данных. Всегда используйте параметризованные
запросы (или их аналог) и не создавайте запросы, объединяя стро-
ки с пользовательским вводом.
Атаки с использованием внедрения SQL-кода были уязвимостью но-
мер один в интернете на протяжении более десятка лет, поэтому очень
важно знать о  них и  о том, как они возникают. Всякий раз, когда вам
нужно писать низкоуровневые SQL-запросы, убедитесь, что вы всегда
используете параметризованные запросы.
Следующая уязвимость также связана с доступом злоумышленников
к данным, к которым они не должны иметь доступа. Эта атака несколько
утонченная по сравнению с  прямой атакой с  использованием внедре-
ния, но выполнить ее несложно: единственное, что нужно злоумышлен-
нику, – умение считать.
18.5.3 Предотвращение небезопасных прямых ссылок
на объекты
Небезопасная	 прямая	ссылка	на	объект – звучит несколько занудно, но это
означает, что пользователи получают доступ к вещам, к которым у них
не должно быть доступа, используя шаблоны в  URL-адресах. Вернемся
к нашему старому другу, приложению с рецептами. Напомню, что при-
ложение показывает вам список рецептов. Вы можете просмотреть лю-
бой из них, но вы можете редактировать только рецепты, которые соз-
дали сами. Когда вы просматриваете чужой рецепт, кнопка «Изменить»
не отображается.
Например, пользователь нажимает эту кнопку на одном из своих ре-
цептов и замечает URL-адрес: /Recipes/Edit/120. «120» – это неуместный
идентификатор в базе данных редактируемого объекта. Можно было бы
просто изменить этот идентификатор, чтобы получить доступ к  другой
сущности, к которой у пользователя обычно нет доступа. Пользователь
может попробовать ввести /Recipes/Edit/121. Если это позволяет им
редактировать или просматривать рецепт, к  которому они не должны
иметь доступ, значит, у вас небезопасная прямая ссылка на объект.
Решить эту проблему просто – у вас должна быть авторизация и аутен-
тификация на основе ресурсов в методах действий. Если пользователь

705 Изучение других векторов атак
пытается получить доступ к сущности, доступ к которой ему запрещен,
то должен получить ошибку Permission denied. У него не должно быть
возможности обойти вашу авторизацию, вводя URL-адрес непосред-
ственно в строку поиска браузера.
В приложениях ASP .NET Core эта уязвимость обычно возникает при
попытке ограничить действия пользователей, скрывая элементы из
пользовательского интерфейса, например кнопку «Изменить». Вместо
этого следует использовать авторизацию на основе ресурсов, как опи-
сано в главе 15.
ВНИМАНИЕ!  Вы всегда должны использовать авторизацию на
основе ресурсов, чтобы ограничить сущности, к которым пользо-
ватель может получить доступ. Скрытие элементов пользователь-
ского интерфейса улучшает опыт взаимодействия пользователя
с сайтом, но это не мера безопасности.
Можно обойти эту уязвимость, избегая целочисленных идентифика-
торов сущностей в URL-адресах, например используя псевдослучайный
GUID (допустим, C2E296BA-7EA8-4195-9CA7-C323304CCD12) вместо этого.
Это усложняет процесс угадывания других сущностей, поскольку нель-
зя просто добавить единицу к существующему числу, но это всего лишь
мас кирует проблему, а  не исправляет ее. Тем не менее использование
GUID может быть полезно, когда вы хотите, чтобы у вас были общедо-
ступные страницы (не требующие аутентификации), но вы не хотите,
чтобы их идентификаторы можно было легко обнаружить.
В последнем разделе этой главы речь не идет об одной конкретной
уязвимости. В ней мы обсудим отдельный, но связанный с этой темой
вопрос: защиту данных пользователей.
18.5.4 Защита паролей и данных пользователей
Для многих приложений самыми конфиденциальными данными, кото-
рые вы будете хранить, являются личные данные ваших пользователей.
Это может быть адрес электронной почты, пароли, адресные данные или
платежная информация. Будьте осторожны при хранении таких данных.
Помимо того что вы предоставляете привлекательную цель для зло-
умышленников, у вас могут быть юридические обязательства в отноше-
нии того, как вы с ними обращаетесь, например законы о защите данных
и требования соответствия PCI.
Самый простой способ защитить себя – не хранить ненужные данные.
Если вам не нужен адрес вашего пользователя, не спрашивайте его. Та-
ким образом, вы не сможете его потерять! Аналогично, если вы исполь-
зуете стороннюю службу идентификации для хранения сведений о поль-
зователях, как описано в главе 14, вам не придется так усердно работать,
чтобы защитить личные данные своих пользователей.
Если вы храните данные пользователя в собственном приложении или
создаете собственного поставщика идентификационной информации,

706 Глава 18 Повышаем безопасность приложения
тогда вам нужно обязательно следовать лучшим практикам при работе
с пользовательской информацией. Новые шаблоны проектов, использу -
ющие ASP .NET Core Identity, следуют большинству из этих практик по
умолчанию, поэтому я настоятельно рекомендую начать с одного из них.
Вам нужно рассмотреть много различных аспектов – их слишком много,
чтобы подробно рассматривать их здесь1, но они включают в себя сле-
дующее:
никогда не храните пароли пользователей где-либо напрямую. Вы
должны хранить только криптографические хеши, вычисленные
с использованием дорогостоящего алгоритма хеширования, такого
как BCrypt или PBKDF2;
не храните больше данных, чем нужно. Никогда не храните данные
кредитной карты;
разрешите пользователям использовать двухфакторную аутенти-
фикацию (2FA) для входа на ваш сайт;
не позволяйте пользователям использовать заведомо ненадежные
или скомпрометированные пароли;
пометьте cookie-файлы аутентификации как http (чтобы их нельзя
было прочитать с по мощью Java Script) и «безопасно», чтобы они от -
правлялись только через HTTPS-соединение, а не через HTTP;
не показывайте, зарегистрирован пользователь в вашем приложе-
нии или нет. Из-за утечки этой информации вы можете подверг -
нуться атакам перечислением2.
Это все рекомендации, но они представляют собой минимум, который
вы должны делать для защиты своих пользователей. Самое главное  –
быть в курсе потенциальных проблем безопасности, когда вы создаете
приложение. Пытаться использовать механизмы безопасности в конце
всегда труднее, чем подумать об этом с самого начала, поэтому лучше
сделать это раньше, чем позже.
Эта глава представляет собой краткий обзор вещей, на которые стоит
обратить внимание. Мы коснулись большинства известных уязвимостей
в системе безопасности, но я настоятельно рекомендую ознакомиться
с другими ресурсами, упомянутыми в  этой главе. Они предоставляют
более исчерпывающий список вещей, которые следует учитывать, до-
полняя меры защиты, упомянутые в этой главе. Кроме того, не забывай-
те о проверке ввода и оверпостинге, о которых шла речь в главе 6. ASP .
NET Core включает базовые средства защиты от некоторых наиболее
распространенных атак, но вы все равно можете навредить себе. Убеди-
тесь, что ваше приложение не попало в заголовки из-за того, что было
взломано!
1 NIST (Национальный институт стандартов и технологий) недавно выпустил
свои рекомендации по цифровой идентификации о  том, как обрабатывать
данные пользователя: http://mng.bz/6gRA.
2 Узнать подробнее о перечислении можно в этом видеоуроке от Троя Ханта:
http://mng.bz/PAAA.

707 Резюме
Резюме
Протокол HTTPS используется для шифрования данных вашего при-
ложения при их передаче от сервера браузеру и обратно. Это не по-
зволяет третьим лицам видеть или изменять их.
HTTPS практически обязателен для приложений в  промышленном
окружении, поскольку современные браузеры, такие как Chrome
и Firefox, явно помечают приложения, не поддерживающие этот про-
токол HTTPS, как «небезопасные».
В промышленном окружении вы можете избежать обработки TLS
в своем приложении с по мощью SSL- или TLS-терминирования. Здесь
обратный прокси-сервер использует протокол HTTPS для связи с брау -
зером, но трафик между вашим приложением и  обратным прокси-
сервером не зашифрован. Обратный прокси-сервер может находиться
на том же или на другом сервере, например IIS или NGINX, либо это
может быть сторонний сервис, такой как Cloudflare.
Можно использовать сертификат разработчика ASP .NET Core или сер-
тификат разработчика IIS Express для активации протокола HTTPS во
время разработки. Их нельзя использовать в промышленном окруже-
нии, но этого достаточно для локального тестирования. Необходимо
выполнить команду dotnet devcerts https --trust при первой установ-
ке .NET SDK, чтобы доверять сертификату.
Можно настроить сертификат HTTPS для Kestrel в  промышленном
окружении, используя секцию конфигурации Kestrel:Certificates:
Default. Для этого не требуется никаких изменений в приложении –
Kestrel автоматически загрузит сертификат при запуске вашего при-
ложения и будет использовать его для обслуживания HTTPS-запросов.
Можно использовать компонент HstsMiddleware для установки HSTS-
заголовков для своего приложения, чтобы браузер отправлял HTTPS-
запросы вместо HTTP-запросов. Это может быть применено только
после того, как в  ваше приложение будет отправлен HTTPS-запрос,
поэтому лучше всего использовать его вместе с  перенаправлением
с HTTP на HTTPS.
Вы можете принудительно использовать протокол HTTPS во всем при-
ложении с по мощью компонента HttpsRedirectionMiddleware. Он бу -
дет перенаправлять HTTP-запросы на конечные точки HTTPS.
Межсайтовый скриптинг используется злоумышленниками, чтобы
внедрять содержимое в ваши приложения, как правило, для запуска
вредоносного кода Java Script, когда пользователи просматривают
ваше приложение. Можно избежать подобных атак, если вы будете
всегда кодировать небезопасный ввод перед записью его на страницу.
Razor Pages делает это автоматически, если вы не применяете метод
@Html.Raw(), поэтому используйте его редко и осторожно.
Межсайтовая подделка запросов является проблемой для приложе-
ний, использующих проверку подлинности на основе файлов cookie,
например ASP .NET Core Identity. Эти атаки полагаются на тот факт,

708 Глава 18 Повышаем безопасность приложения
что браузеры автоматически отправляют файлы cookie на веб-сайт.
Вредоносный сайт может создать форму, которая отправляет запро-
сы с по мощью метода POST на ваш сайт, а браузер будет отправлять
cookie-файлы аутентификации с  запросом. Это позволяет вредонос -
ным веб-сайтам отправлять запросы, как если бы это был пользова-
тель, выполнивший вход.
Вы можете смягчить последствия таких атак, используя защитные то-
кены. Сюда входит написание скрытого поля в каждой форме, которое
содержит случайную строку на основе текущего пользователя. Анало-
гичный токен хранится в файле cookie. У допустимого запроса будут
обе части, но поддельный запрос с вредоносного веб-сайта будет со-
держать только половину – файл cookie; он не может воссоздать скры-
тое поле в форме. Выполнив валидацию этих токенов, ваш API может
отклонять поддельные запросы.
Фреймворк Razor Pages автоматически добавляет защитные токены
в любые формы, которые вы создаете с по мощью Razor, и проверяет
токены для входящих запросов. При необходимости можно отклю-
чить проверку валидации, используя атрибут [IgnoreAntiForgeryTo-
ken].
Браузеры не разрешают веб-сайтам выполнять запросы Java Script
AJAX от одного приложения к другому из разных источников. Чтобы
соответствовать источнику, у приложения должны быть такой же про-
токол, домен и порт. Если вы хотите делать подобные запросы из раз-
ных источников, то должны активировать совместное использование
ресурсов между источниками (CORS) в своем API.
CORS использует HTTP-заголовки для обмена данными с  браузера-
ми и  определяет, какие источники могут вызывать ваш API. В  ASP .
NET Core можно определить несколько политик, которые могут при-
меняться либо глобально ко всему приложению, либо к конкретным
контроллерам и действиям.
Вы можете добавить промежуточное ПО CORS, вызвав метод UseCors()
в методе Startup.Configure и, при необходимости, указав имя приме-
няемой политики CORS по умолчанию. Также можно применить CORS
к  действию или контроллеру веб-API, добавив атрибут [EnableCors]
и указав имя применяемой политики.
Атаки с открытым перенаправлением используют распространенный
механизм returnURL после выполнения входа для перенаправления
пользователей на вредоносные веб-сайты. Вы можете предотвратить
эту атаку, убедившись, что выполняете перенаправление только на ло-
кальные URL-адреса, принадлежащие вашему приложению.
Небезопасные прямые ссылки на объект – распространенная проб-
лема, когда вы предоставляете идентификатор сущностей базы дан-
ных в URL-адресе. Всегда нужно проверять, есть ли у пользователей
полномочия для доступа к  запрашиваемому ресурсу или его изме-
нения с по мощью авторизации на основе ресурсов в своих методах
действия.

709 Резюме
Атаки с  использованием внедрения SQL-кода являются распростра-
ненным вектором атак при создании SQL-запросов вручную. Всегда
используйте параметризованные запросы или  фреймворк, например
EF Core, который неуязвим для внедрения SQL-кода.
Самыми конфиденциальными данными в  вашем приложении часто
являются данные ваших пользователей. Обезопасьте себя, сохраняя
только те данные, которые вам нужны. Убедитесь, что вы храните па-
роли лишь в виде хеша, защитите себя от слабых или скомпрометиро-
ванных паролей и обеспечьте возможность двухфакторной аутенти-
фикации. ASP .NET Core Identity предоставляет все это уже в готовом
виде, поэтому если вам нужно будет создать поставщика идентифика-
ционной информации, то это отличный выбор.

19Создание	специальных
компонентов
В этой главе:
создание специального промежуточного ПО;
создание простых конечных точек, которые генерируют
ответ с использованием промежуточного ПО;
использование значений конфигурации для настройки
других поставщиков конфигурации;
замена встроенного контейнера внедрения зависимостей
сторонним контейнером.
Когда вы создаете приложения с по мощью ASP .NET Core, бóльшая часть
вашей креативности и специализации направляется на сервисы и моде-
ли, образующие вашу бизнес-логику, а также на страницы Razor и конт -
роллеры, которые предоставляют их через представления или API. Одна-
ко в конце концов вы, скорее всего, обнаружите, что не можете достичь
желаемой функциональности, используя компоненты, которые постав-
ляются из коробки. На этом этапе вам может потребоваться создать спе-
циальный компонент.
В этой главе показано, как создавать некоторые компоненты ASP .NET
Core, которые вам, вероятно, понадобятся по мере роста вашего прило-
жения. Вероятно, вам не нужно использовать их все, но каждый из них
решает конкретную проблему, с которой вы можете столкнуться.
Мы начнем с рассмотрения конвейера промежуточного ПО. Вы виде-
ли, как создавать конвейеры путем объединения существующих ком-

711 Настройка конвейера промежуточного ПО
понентов промежуточного ПО, в главе 3, но в этой главе вы создадите
собственное промежуточное ПО. Вы изучите основные конструкции
промежуточного ПО методов Map, Use и Run и узнаете, как создавать ав-
тономные классы промежуточного ПО. Вы будете использовать их для
создания компонентов промежуточного ПО, которые могут добавлять
заголовки во все ваши ответы, а также промежуточное ПО, которое воз-
вращает ответы.
В разделе 19.2 вы увидите, как использовать специальное промежу -
точное ПО для создания простых конечных точек с по мощью маршрути-
зации конечных точек. Используя маршрутизацию конечных точек, вы
можете воспользоваться мощью систем маршрутизации и авторизации,
о которых узнали в главах 5 и 15, без дополнительных сложностей, свя-
занных с использованием контроллеров веб-API.
В главе 11 описана система поставщика конфигурации, используемая
ASP .NET Core, но в разделе 19.3 мы рассмотрим более сложные сцена-
рии. В  частности, я  покажу, как справиться с  ситуацией, когда самому
поставщику конфигурации требуются значения конфигурации. Напри-
мер, поставщику конфигурации, который считывает значения из базы
данных, может потребоваться строка подключения. Вы также увидите,
как использовать внедрение зависимостей при настройке строго типи-
зированных объектов IOptions – что невозможно сделать, используя ме-
тоды, которые вы видели до этого момента.
Мы остановимся на внедрении зависимостей в разделе 19.4, где я по-
кажу, как заменить встроенный контейнер внедрения зависимостей сто-
ронней альтернативой. Встроенный контейнер подходит для самых ма-
леньких приложений, но ваша функция ConfigureServices может быст ро
раздуться по мере роста вашего приложения и  регистрации дополни-
тельных сервисов. Я покажу, как интегрировать стороннюю библиотеку
Lamar в существующее приложение, чтобы вы могли использовать до-
полнительные функции, такие как автоматическая регистрация серви-
сов по соглашению.
Компоненты и техники, показанные в этой главе, являются общими
для всех приложений ASP .NET Core. Например, я использую предмет об-
суждения первой темы – специальное промежуточное ПО – почти в каж -
дом проекте, который создаю. В главе 20 мы рассмотрим некоторые до-
полнительные компоненты, относящиеся к Razor Pages и контроллерам
веб-API.
19.1 Настройка конвейера промежуточного ПО
В этом разделе вы узнаете, как создать собственное промежуточное ПО.
Вы научитесь использовать методы расширения Map, Run и Use для соз-
дания простого промежуточного ПО с использованием лямбда-выраже-
ний. Затем вы увидите, как создать эквивалентные компоненты проме-
жуточного программного обеспечения, используя специализированные

712 Глава 19 Создание специальных компонентов
классы. Вы также узнаете, как разделить конвейер промежуточного ПО
на ветви и когда это может пригодиться.
Конвейер промежуточного ПО  – один из основных строительных
блоков приложений ASP .NET. Core, поэтому мы подробно рассмотрели
его в главе 3. Каждый запрос проходит через этот конвейер, и каждый
компонент, в свою очередь, получает возможность изменить запрос или
обработать его и вернуть ответ. ASP .NET Core включает готовое проме-
жуточное ПО для обработки распространенных сценариев. Вы найдете
промежуточное ПО для обслуживания статических файлов, обработки
ошибок, аутентификации и многого другого.
Во время разработки большую часть времени вы будете проводить,
работая с Razor Pages и контроллерами веб-API. Они используются в ка-
честве конечных точек для большей части бизнес-логики вашего прило-
жения и вызывают методы в различных бизнес-службах и моделях.
Однако иногда вам не нужна вся мощь (и связанная с ней сложность),
которую предоставляют Razor Pages и контроллеры веб-API. Возможно,
вы хотите создать очень простое приложение, которое при вызове воз-
вращает текущее время. Или, может, вы хотите добавить URL-адрес про-
верки работоспособности в существующее приложение, когда обраще-
ние по URL-адресу не приводит к какой-либо существенной обработке
запроса, а  проверяет, запущено ли приложение. Хотя вы могли бы ис -
пользовать контроллеры веб-API, вы также могли бы создать небольшие
специализированные компоненты промежуточного ПО, чтобы удовлет -
ворить этим требованиям.
В других случаях у вас могут быть требования, выходящие за рамки
компетенции Razor Pages и контроллеров веб-API. Например, у вас мо-
жет возникнуть желание убедиться, что все ответы, сгенерированные
вашим приложением, включают в себя определенный заголовок. Такого
рода сквозная задача идеально подходит для специального промежуточ-
ного ПО. Вы можете добавить собственное промежуточное ПО на ран-
нем этапе в конвейере, чтобы гарантировать, что каждый ответ от ваше-
го приложения включает в себя необходимый заголовок, независимо от
того, исходит он от компонента статических файлов, обработки ошибок
или страницы Razor.
В этом разделе я  также покажу три способа создания специальных
компонентов промежуточного ПО и как создать ветви в конвейере, когда
запрос может перетекать то в одну ветвь, то в другую. Сочетая методы,
продемонстрированные в этом разделе, вы сможете создавать индиви-
дуальные решения для удовлетворения конкретных требований.
Мы начнем с создания компонента промежуточного ПО, который воз-
вращает текущее время в виде обычного текста, когда приложение полу -
чает запрос. После этого мы рассмотрим ветвление конвейера, создание
компонентов общего назначения и, наконец, увидим, как инкапсулиро-
вать промежуточное ПО в отдельные классы. В разделе 19.2 вы увидите
альтернативный подход к предоставлению промежуточного программ-
ного обеспечения, генерирующего ответы, с использованием маршрути-
зации конечных точек.

713 Настройка конвейера промежуточного ПО
19.1.1 Создание простых конечных точек с по мощью метода
расширения Run
Как вы видели в предыдущих главах, конвейер промежуточного ПО для
приложения определяется в методе Configure класса Startup. Вы добав-
ляете промежуточное ПО к  предоставленному объекту IApplication-
Builder, обычно использующему методы расширения. Например:
public void Configure(IApplicationBuilder)
{
app.UseDeveloperExceptionPage();
app.UseStaticFiles();
}
Когда ваше приложение получает запрос, он проходит через каждый
компонент, любой из которых получает возможность изменить запрос
или обработать его, генерируя ответ. Если компонент генерирует ответ,
то, по сути, прерывает выполнение конвейера; последующие компо-
ненты конвейера не увидят запрос. Ответ проходит обратно через более
ранние компоненты на пути в браузер.
Для создания простого компонента, который всегда генерирует ответ,
можно использовать метод расширения Run. Этот метод принимает одну
лямбда-функцию, которая выполняется всякий раз, когда запрос дости-
гает компонента. Метод Run всегда генерирует ответ, поэтому промежу -
точное ПО, размещенное после него, никогда не будет выполнено. По
этой причине всегда следует размещать данный компонент в конвейере
последним.
СОВЕТ  Помните: компоненты промежуточного ПО выполняются
в том порядке, в котором вы добавляете их в конвейер. Если ком-
понент обрабатывает запрос и генерирует ответ, те компоненты,
которые идут после него, не увидят запрос.
Метод расширения Run предоставляет доступ к запросу в виде объекта
HttpContext, который вы видели в главе 3. Он содержит все детали запро-
са в свойстве Request, такие как путь URL-адреса, заголовки и тело запро-
са, а также свойство Response, которое можно использовать для возврата
ответа.
В следующем листинге показано, как создать простой компонент про-
межуточного ПО, который возвращает текущее время. Он использует
предоставленный объект HttpContext и свойство Response, чтобы задать
заголовок ответа Content-Type (в  нашем случае это не является строго
необходимым условием, поскольку если альтернативный заголовок не
задан, то используется заголовок text/plain), и записывает тело ответа
с по мощью функции WriteAsync (text).

714 Глава 19 Создание специальных компонентов
Листинг 19.1  Создание простого компонента промежуточного
программного обеспечения с использованием метода
расширения Run
public void Configure(IApplicationBuilder app)
{
app.Run(async (HttpContext context) =>
{
context.Response.ContentType = "text/plain";
await context.Response.WriteAsync(
DateTimeOffset.UtcNow.ToString());
});
app.UseStaticFiles();
}
Метод расширения Run полезен для создания простого компонента
промежуточного ПО. Его можно использовать для создания очень прос -
тых конечных точек, которые всегда генерируют ответ. Но поскольку
компонент всегда генерирует какой-то ответ, вы всегда должны поме-
щать его в конец конвейера, так как после его выполнения другие ком-
поненты не размещаются.
Более распространенный сценарий – когда вам нужно, чтобы ваш ком-
понент промежуточного ПО отвечал только на конкретный путь URL-
адреса. В  следующем разделе вы увидите, как комбинировать методы
расширения Run и Map, чтобы создавать простые ветвящиеся конвейеры
промежуточного ПО.
19.1.2 Ветвление конвейера с по мощью метода
расширения Map
До сих пор, обсуждая конвейер промежуточного ПО, мы всегда рассмат -
ривали его как единый конвейер, состоящий из последовательных ком-
понентов. Каждый запрос проходит через все компоненты, пока один из
них не сгенерирует ответ, который проходит обратно через предыдущие
компоненты.
Метод расширения Map позволяет преобразовать этот простой конвей-
ер в ветвящуюся структуру. Каждая ветвь конвейера независима; запрос
проходит то через одну ветвь, то через другую, но не через обе, как по-
казано на рис. 19.1. Метод расширения Map смотрит на путь URL-адреса
запроса. Если путь совпадает с требуемым шаблоном, то запрос переме-
щается по ветви конвейера; в противном случае он остается в основном
конвейере, что обеспечивает совершенно разное поведение в  разных
ветвях конвейера.Использует метод расширения Run для
создания простого промежуточного ПО,
которое всегда возвращает ответ.
Вы должны установить значение
заголовка Content-type
для генерируемого вами
ответа – text/plain – значение
по умолчанию.
Возвращает время в виде строки в ответе. Код состояния
200 OK используется, если не установлен явно.Любое промежуточное ПО, добавленное после
метода расширения Run, не будет выполнено.

715 Настройка конвейера промежуточного ПО
RequestRequestMap("/ping")Обычно конвейеры промежуточного ПО состоят
из последовательных компонентов
Каждый компонент
может вернуть ответ
или передать запрос
следующему компонентуПромежуточное
ПО на основном
конвейере не
выполняется, когда
исполняется ветвьПромежуточное ПО с методом расширения Map можно
использовать для создания ветвящихся конвейеров
Если запрос начинается
с /ping, Map передает запрос
промежуточному ПО ветви
Традиционный последовательный
конвейер промежуточного ПОВетвящийся конвейер промежуточного ПО
Рис. 19.1 Сравнение последовательного конвейера промежуточного ПО и конвейера
ветвления, созданного с по мощью метода расширения Map. В конвейере ветвления
запросы проходят только через одну из ветвей. Компонент другой ветки не видит запрос
и не выполняется
ПРИМЕЧАНИЕ  Сопоставление URL-адресов, используемое ме-
тодом Map, концептуально аналогично маршрутизации, как было
показано начиная с главы 6, но оно гораздо проще и имеет много
ограничений. Например, здесь используется простое сопоставле-
ние строки и префикса, и нельзя использовать параметры марш-
рута. Как правило, следует отдавать предпочтение созданию ко-
нечных	точек, а  не ветвлению с  использованием метода Map, как
будет показано в разделе 19.2.
Например, представьте, что вы хотите добавить простую конечную
точку проверки работоспособности в существующее приложение. Эта ко-
нечная точка представляет собой простой URL-адрес, который вы можете
вызвать и который указывает, правильно ли работает ваше приложение.
Вы можете легко создать компонент для проверки работоспособности,
используя метод расширения Run, как было показано в листинге 19.1, но
это все, что может сделать ваше приложение. Вы хотите, чтобы проверка
работоспособности отвечала только на определенный URL-адрес, /ping.
Razor Pages должен обрабатывать все остальные запросы в обычном ре-
жиме.
СОВЕТ  Сценарий с проверкой работоспособности – простой при-
мер демонстрации работы метода Map, но ASP .NET Core включает
в  себя встроенную поддержку конечных точек проверки работо-
способности, которые следует использовать вместо того, чтобы
создавать собственные. Подробнее о  создании проверок работо-
способности можно узнать в документе Microsoft «Проверка рабо-
тоспособности в ASP .NET.Core»: ht tp://mng.bz/nMA2.

716 Глава 19 Создание специальных компонентов
В качестве одного из решений можно было бы создать ветвь с  по-
мощью метода расширения Map и  поместить в  нее промежуточное ПО
для проверки работоспособности, как показано на рис.  19.1. Только те
запросы, которые соответствуют шаблону /ping, будут выполнять ветвь;
все остальные запросы будут обрабатываться стандартным компонен-
том маршрутизации и Razor Pages на основном конвейере.
Листинг 19.2  Использование метода расширения Map для создания
ветвящихся конвейеров
public void Configure(IApplicationBuilder app)
{
app.UseDeveloperExceptionPage();
app.Map("/ping", (IApplicationBuilder branch) =>
{
branch.UseExceptionHandler();
branch.Run(async (HttpContext context) =>
{
context.Response.ContentType = "text/plain";
await context.Response.WriteAsync("pong");
});
});
app.UseStaticFiles();
app.UseRouting();
app.UseEndpoints(endpoints =>
{
endpoints.MapRazorPages();
});
}
Мы создали абсолютно новый объект IApplicationBuilder (в листинге
он называется branch), который можно настроить так же, как и основной
конвейер app. Промежуточное ПО, добавленное в  branch, добавляется
только в ветвь, а не в основной конвейер.
В этом примере вы добавляете промежуточное ПО с  методом Run
в  ветвь, поэтому оно будет выполняться только для запросов, начина-
ющихся с  /ping, например /ping, /ping/go или /ping?id=123. Все запро-
сы, которые не начинаются с  /ping, метод Map игнорирует. Они остаются
в основном конвейере и выполняют следующие компоненты в конвейе-
ре после Map (в данном случае StaticFilesMiddleware).
При необходимости с  по мощью метода Map можно создавать раски-
дистые ветвящиеся конвейеры, где ветви будут независимы друг от дру -
га, а также можно вкладывать вызовы в  Map, чтобы у вас были ветви, ко-
торые отходят от других ветвей.
Метод расширения Map может быть полезным, но если вы переусерд-
ствуете, то быстро можете запутаться. Помните, что нужно использовать
промежуточное ПО для реализации сквозных задач или очень простых Каждый запрос будет проходить
через это промежуточное ПО.
Метод расширения Map будет ветвиться,
если запрос начинается с /ping.
Это промежуточное
ПО будет
работать только
для запросов,
соответствующих
ветке /ping.Метод расширения Run всегда
возвращает ответ, но только
в ветке /ping.
Остальная часть конвейера промежуточного ПО
будет выполняться для запросов,
не соответствующих ветке /ping.

717 Настройка конвейера промежуточного ПО
конечных точек. Механизм маршрутизации конечных точек контрол-
леров и  Razor Pages лучше подходит для более сложных требований
к маршрутизации, поэтому не бойтесь его использовать.
СОВЕТ  В разделе 19.2 вы увидите, как создавать конечные точки,
которые используют систему маршрутизации конечных точек.
Одна из ситуаций, в которой метод Map может быть полезен,  – когда вам
нужно два «независимых» более мелких приложения, но вы хотите изба-
вить себя от хлопот, связанных с несколькими развертываниями. Можно
использовать этот метод, чтобы конвейеры были разделены, с отдельной
маршрутизацией и  конечными точками внутри каждой ветви. Просто
имейте в виду, что обе эти ветви будут иметь одну и ту же конфигурацию
и  контейнер внедрения зависимостей, поэтому они независимы толь-
ко с точки зрения конвейера промежуточного ПО1. Последний момент,
о котором следует помнить при использовании метода расширения Map,
заключается в том, что он изменяет фактическое свойство Path, которое
видит промежуточное ПО в ветви. Если оно совпадает с префиксом URL-
адреса, метод Map отсекает совпадающий сегмент от пути, как показано
на рис. 19.2. Удаленные сегменты хранятся в свойстве HttpContext, Path-
Base, чтобы быть доступными, когда они вам понадобятся.
Path: /branch/recipes/index
PathBase: /
Path: /recipes/index
PathBase: /branch Path: /recipes/index
PathBase: /Map("/branch")
Routing
middlewareRouting
middleware
Endpoint
middlewareEndpoint
middlewareЕсли запрос остается на
основном конвейере, свойство
Path будет соответствовать
URL-адресу, а PathBase будет
пустымКогда запрос уходит в ветвь, промежуточное
ПО с методом расширения Map перемещает
совпадающий сегмент из Path в PathBase
RoutingMiddleware использует
свойство Path только
для маршрутизации, поэтому
на контроллере Recipe выбрано
действие Index
Рис. 19.2 Когда метод расширения Map перенаправляет запрос в ветвь, он удаляет
совпадающий сегмент из свойства Path и добавляет его в свойство PathBase
ПРИМЕЧАНИЕ  Генератор ссылок ASP .NET Core (используемый,
например, в Razor, как обсуждалось в главе 5) использует свойство
PathBase, чтобы гарантировать, что он генерирует URL-адреса, ко-
торые включают PathBase в качестве префикса.
1 Создание по-настоящему независимых ветвей в одном и том же приложении
требует гораздо больше усилий. См. пост в блоге Филипа В. «Запуск несколь-
ких независимых конвейеров ASP .NET Core бок о бок в одном приложении»:
http://mng.bz/vzA4.

718 Глава 19 Создание специальных компонентов
Вы уже видели метод расширения Run, который всегда возвращает от -
вет, и метод расширения Map, который создает ветвь в конвейере. Следу -
ющий метод расширения, который мы рассмотрим, – это универсальный
метод Use.
19.1.3 Добавление в конвейер с по мощью метода
расширения Use
Метод расширения Use можно использовать для добавления компонен-
тов общего назначения. Его можно использовать для просмотра и  из-
менения запросов по мере их поступления, для генерации ответа или
передачи запроса следующему компоненту в конвейере.
Как и в случае с методом расширения Run, когда вы добавляете метод
Use в конвейер, то указываете лямбда-функцию, которая выполняется,
когда запрос доходит до компонента. Приложение передает в эту функ -
цию два параметра:
HttpContext, представляющий	 текущий	 запрос	и ответ. Вы можете
использовать его, чтобы проверить запрос или сгенерировать ответ,
как было показано в случае с расширением Run;
указатель	 на	остальную	 часть	конвейера	 в виде Func<Task>. Выпол-
няя эту задачу, вы можете выполнить остальную часть конвейера.
Предоставляя указатель на остальную часть конвейера, вы можете
использовать метод расширения Use, чтобы точно контролировать, как
и когда будет выполняться остальная часть конвейера, как показано на
рис. 19.3.
Request
Response  // logic
}  // logic
}(context, next) =>
{
// logic
await next(); (context, next) =>
{
// logic
await next();(context, next) =>
{
// logic
}При вызове метода next()
вызывается остальная часть
промежуточного ПОЕсли промежуточное ПО
не вызывает метод next(),
выполнение конвейера
прервано, и остальные
компоненты не будут
выполняться
Middleware 1Middleware 2Middleware 3
Рис. 19.3 Три компонента промежуточного ПО, созданных с по мощью метода расширения
Use. Вызывая Func<Task> с по мощью метода next(), вы вызываете остальную часть конвейера.
Каждый компонент может выполнять код до и после вызова остальной части конвейера или
может вообще не вызывать метод next(), чтобы прервать выполнение конвейера
Если вы вообще не вызываете предоставленный Func<Task>, остальная
часть конвейера не выполняется, таким образом вы получаете полный
контроль.

719 Настройка конвейера промежуточного ПО
Предоставляя остальную часть конвейера в виде Func<Task>, вы услов-
но упрощаете прерывание выполнения конвейера, что открывает мно-
жество различных сценариев. Вместо ветвления конвейера для реализа-
ции компонента проверки работоспособности с по мощью методов Map
и Run, как вы это делали в листинге 19.2, можно использовать единствен-
ный экземпляр метода расширения Use. Это обеспечивает ту же необхо-
димую функциональность, что и раньше, но без ветвления конвейера.
Листинг 19.3  Использование метода расширения Use для создания
компонента для проверки работоспособности
public void Configure(IApplicationBuilder app)
{
app.Use(async (HttpContext context, Func<Task> next) =>
{
if (context.Request.Path.StartsWithSegments("/ping"))
{
context.Response.ContentType = "text/plain";
await context.Response.WriteAsync("pong");
}
else
{
await next();
}
});
app.UseStaticFiles();
}
Если входящий запрос начинается с  необходимого сегмента пути
(/ping), компонент отвечает и не вызывает остальную часть конвейера.
В противном случае расширение вызывает следующий компонент в кон-
вейере, и ветвление не требуется.
С помощью метода расширения Use можно контролировать, когда вы-
зывать остальную часть конвейера. Но важно отметить, что обычно не
следует изменять объект Response после вызова метода next(). Вызов ме-
тода next() запускает остальную часть конвейера, поэтому последующие
компоненты могут начать потоковую передачу ответа в браузер. Если вы
попытаетесь изменить ответ после выполнения конвейера, то в конеч-
ном итоге можете повредить ответ или отправить неверные данные.
ВНИМАНИЕ!  Не изменяйте объект Response после вызова метода
next(). Кроме того, не вызывайте его, если вели запись в  Response.
Body; запись в  этот поток может запустить Kestrel, чтобы начать
потоковую передачу ответа браузеру, а это может привести к от -
правке недействительных данных. Обычно можно безопасно счи-
тывать	 данные из объекта Response; например, чтобы проверить
окончательный код состояния StatusCode или ContentType ответа.Метод расширения Use принимает лямбда-функцию
с параметрами HttpContext(context) и Func<Task>(next).
Метод StartsWithSegments
ищет указанный сегмент
в текущем пути.
Если путь совпадает, генерируем ответ
и прерываем выполнение конвейера.
Если путь не совпадает, вызываем следующий
компонент промежуточного ПО в конвейере,
в данном случае метод UseStaticFiles().

720 Глава 19 Создание специальных компонентов
Еще один распространенный вариант использования метода расши-
рения Use – изменение каждого запроса или ответа, который проходит
через него. Например, существуют различные HTTP-заголовки, которые
вы должны отправлять со всеми своими приложениями из соображений
безопасности. Эти заголовки часто отключают небезопасные и устарев-
шие варианты поведения браузеров или ограничивают функции, акти-
вированные браузером. В главе 18 вы узнали о заголовке HSTS, но есть
и другие заголовки, которые вы можете добавить для дополнительной
безопасности1.
Представьте, что вам было поручено добавить один такой заголовок,
X-Content-Type-Options: nosniff (который обеспечивает дополнитель-
ную защиту от XSS-атак), в  каждый ответ, создаваемый вашим при-
ложением. Такой вид сквозной задачи идеально подходит для проме-
жуточного ПО. Вы можете использовать метод расширения Use, чтобы
перехватывать каждый запрос, задать заголовок ответа, а  затем вы-
полнить остальную часть конвейера. Не важно, какой ответ генерирует
конвейер, будь то статический файл, ошибка или страница Razor. Ответ
всегда будет иметь заголовок безопасности.
В листинге 19.4 показан надежный способ сделать это. Когда проме-
жуточное ПО получает запрос, оно регистрирует функцию обратного вы-
зова, которая выполняется до того, как Kestrel начнет отправлять ответ
обратно в браузер. Затем вызывается метод next() для запуска осталь-
ной части конвейера. Когда конвейер генерирует ответ, вероятно в ка-
ком-либо компоненте, который идет позже, Kestrel выполняет функцию
обратного вызова и добавляет заголовок. Такой подход гарантирует, что
заголовок не окажется случайно удален другим компонентом в конвейе-
ре, а также что вы не пытаетесь изменить заголовки после того, как ответ
начал потоковую передачу в браузер.
Листинг 19.4  Добавление заголовков к ответу с методом расширения Use
public void Configure(IApplicationBuilder app)
{
app.Use(async (HttpContext context, Func<Task> next) =>
{
context.Response.OnStarting(() =>
{
context.Response.Headers["X-Content-Type-Options"] =
"nosniff";
return Task.CompletedTask;
});
await next();
}
1 Можно проверить заголовки безопасности для своего приложения на сайте
https://securityheaders.com, который также предоставляет информацию о том,
какие заголовки нужно добавить в свое приложение и почему.Добавляет промежуточное ПО
в начало конвейера.
Задает функцию, которая должна вызываться
перед отправкой ответа в браузер.
Добавляет заголовок в ответ
для дополнительной защиты от XSS-атак.Функция,
переданная
в OnStarting,
должна
возвращать
задачу.
Вызывает остальную часть
конвейера промежуточного ПО.

721 Настройка конвейера промежуточного ПО
app.UseStaticFiles();
app.UseRouting();
app.UseEndpoints(endpoints =>
{
endpoints.MapControllers();
});
}
Такие простые компоненты, которые вы видели в  примере с  заго-
ловком безопасности, – обычное явление, но они могут быстро загро-
моздить метод Configure и затруднить понимание конвейера с первого
взгляда. Вместо этого обычно принято инкапсулировать промежуточное
ПО в класс, функционально эквивалентный методу расширения Use, но
который легко протестировать и использовать повторно.
19.1.4 Создание специального компонента
промежуточного ПО
Удобно создавать промежуточное ПО, используя метод расширения Use,
как вы это делали в листингах 19.3 и 19.4, но его нелегко протестировать,
и  вы несколько ограничены в  своих возможностях. Например, нельзя
просто использовать внедрение зависимостей для внедрения сервисов
с жизненным циклом Scoped внутри этих базовых компонентов. Обычно
вместо того, чтобы напрямую вызвать метод расширения Use, промежу -
точное ПО инкапсулируется в функционально эквивалентный класс.
Специальные компоненты промежуточного ПО не обязательно долж -
ны наследовать от определенного базового класса или реализовывать
интерфейс, но они имеют определенную форму, как показано в листин-
ге 19.5. ASP .NET Core использует отражение для вызова метода во время
исполнения приложения. У  классов промежуточного ПО должен быть
конструктор, принимающий объект RequestDelegate, который представ-
ляет остальную часть конвейера, и функция Invoke с сигнатурой, похо-
жей на эту:
public Task Invoke(HttpContext context);
Функция Invoke() эквивалентна лямбда-функции из метода расшире-
ния Use и вызывается при получении запроса. Вот как можно преобра-
зовать класс HeadersMiddleware из листинга 19.4 в отдельный класс про-
межуточного ПО1.
1 Использование такого подхода делает промежуточное ПО более гибким.
В частности, это означает, что вы можете легко использовать внедрение за-
висимостей для внедрения сервисов в метод Invoke. Если бы метод Invoke был
переопределенным методом базового класса или интерфейсом, то это было
бы невозможно. Однако при желании вы можете реализовать интерфейс
IMidd leware, который определяет базовый метод Invoke.Независимо от того, какой ответ будет
сгенерирован, в него будет добавлен
заголовок безопасности.

722 Глава 19 Создание специальных компонентов
Листинг 19.5  Добавление заголовков к объекту Response
с использованием специального компонента
промежуточного ПО
public class HeadersMiddleware
{
private readonly RequestDelegate _next;
public HeadersMiddleware(RequestDelegate next)
{
_next = next;
}
public async Task Invoke(HttpContext context)
{
context.Response.OnStarting(() =>
{
context.Response.Headers["X-Content-Type-Options"] =
"nosniff";
return Task.CompletedTask;
});
await _next(context);
}
}
Данный компонент фактически идентичен примеру из листинга 19.4,
но он инкапсулирован в классе HeadersMiddleware. Вы можете добавить
этот компонент в свое приложение в Startup.Configure путем вызова
app.UseMiddleware<HeadersMiddleware>();
Существует распространенный шаблон, который состоит в том, чтобы
создавать вспомогательные методы расширения, дабы упростить потреб-
ление вашего метода расширения из Startup.Configure (чтобы Intelli-
Sense отображал его как параметр в  экземпляре IApplicationBuilder).
Вот как можно создать простой метод расширения для HeadersMiddle-
ware.
Листинг 19.6  Создание метода расширения для предоставления
HeadersMiddleware
public static class MiddlewareExtensions
{
public static IApplicationBuilder UseSecurityHeaders(
this IApplicationBuilder app)
{
return app.UseMiddleware<HeadersMiddleware>();
}
}RequestDelegate представляет
остальную часть конвейера
промежуточного ПО.
Метод Invoke
вызывается
с HttpContext
при получении
запроса.Добавляет
заголовок в ответ,
как и раньше.
Вызывает остальную часть конвейера
промежуточного ПО. Обратите внимание, что вы
должны передать предоставленный HttpContext.
По соглашению, метод расширения должен
возвращать экземпляр IApplicationBuilder,
чтобы разрешить построение цепочки.
Добавляет промежуточное ПО в конвейер.

723 Настройка конвейера промежуточного ПО
С помощью этого метода расширения вы теперь можете добавить
компонент заголовков в свое приложение, используя
app.UseSecurityHeaders();
СОВЕТ  Существует пакет NuGet, SecurityHeaders, который упро-
щает добавление заголовков безопасности с  по мощью проме-
жуточного ПО без необходимости писать свои собственные. Он
предо ставляет удобный интерфейс для добавления рекомендуе-
мых заголовков безопасности в свое приложение. Инструкции по
его установке можно найти на GitHub: https://github.com/andrew -
lock/NetEscapades.AspNetCore.SecurityHeaders.
Листинг 19.5 представляет собой простой пример, но вы можете соз-
дать промежуточное ПО для множества различных целей. В некоторых
случаях вам может потребоваться использовать внедрение зависимо-
стей для внедрения сервисов и их использования для обработки запро-
са. Вы можете внедрять сервисы с моделью жизненного цикла Singleton
в  конструктор своего компонента или сервисы с  любым типом цикла
в метод Invoke, как показано в следующем листинге.
Листинг 19.7  Использование внедрения зависимостей в компонентах
промежуточного ПО
public class ExampleMiddleware
{
private readonly RequestDelegate _next;
private readonly ServiceA _a;
public HeadersMiddleware(RequestDelegate next, ServiceA a)
{
_next = next;
_a = a;
}
public async Task Invoke(
HttpContext context, ServiceB b, ServiceC c)
{
// Используем сервисы a, b и c
// и/или вызываем _next.Invoke(context);
}
}
ВНИМАНИЕ!  ASP .NET Core создает промежуточное ПО только
один раз за весь жизненный цикл вашего приложения, поэтому
любые зависимости, внедряемые в  конструктор, должны иметь
жизненный цикл Singleton. Если вам нужно использовать огра-
ниченные или временные зависимости с  жизненными циклами
Scoped или Transient, внедрите их в метод Invoke.
Здесь мы рассмотрели практически все, что нужно, чтобы приступить
к созданию собственных компонентов промежуточного ПО. Инкапсули-Вы можете внедрить
в конструктор
дополнительные
сервисы. Это должны
быть синглтоны.
Вы можете внедрить сервисы
в метод Invoke. У них может быть
любой жизненный цикл.

724 Глава 19 Создание специальных компонентов
руя промежуточное ПО в специальные классы, вы можете легко тести-
ровать их поведение или распространять их в пакетах NuGet, поэтому
я настоятельно рекомендую использовать данный подход. Помимо всего
прочего, это сделает ваш метод Startup.Configure() не таким нагромож -
денным, и его проще будет понять.
19.2 Создание специальных конечных точек
с помощью маршрутизации  конечных точек
В этом разделе вы узнаете, как создавать специальные конечные точ-
ки из промежуточного ПО с использованием маршрутизации конечных
точек. Мы возьмем простые ветви конвейера, использованные в разде-
ле  19.1, и  преобразуем их для применения маршрутизации конечных
точек, и я продемонстрирую дополнительные функции, такие как марш-
рутизация и авторизация.
В разделе 19.1 я описал создание простой конечной точки с по мощью
методов расширения Map и Run, которые возвращают ответ pong в виде
простого текста всякий раз, когда вы получаете запрос /ping путем ветв-
ления конвейера промежуточного ПО. Это прекрасно, потому что все так
просто, но что, если у вас более сложные требования?
Рассмотрим базовое усовершенствование примера с отправкой запро-
са и получением ответа (ping-pong): как бы вы добавили авторизацию
в запрос? Компонент AuthorizationMiddleware, добавленный в конвейер
с по мощью метода UseAuthorization(), ищет метаданные конечных то-
чек, таких как Razor Pages, чтобы узнать, есть ли там атрибут [Authorize],
но он не умеет работать с методом расширения Map.
Кроме того, что, если вы хотите использовать более сложную марш-
рутизацию? Возможно, вы хотите вызвать /ping/3 и получить ответ от
компонента промежуточного ПО в виде pong-pong-pong (нет, я тоже не
понимаю, зачем вам это!). Теперь нужно попытаться разобрать это целое
число из URL-адреса, убедиться, что оно действительно, и т. д. Похоже,
у вас еще много работы!
Когда ваши требования начнут расти таким образом, один из ва-
риантов – перейти к использованию контроллеров веб-API или Razor
Pages. Они обеспечивают максимальную гибкость вашего приложения
и имеют наибольшее количество функций, но они также сравнительно
тяжелые по сравнению с промежуточным ПО. Что, если вам нужно не-
что среднее?
В ASP .NET Core 3.0 система маршрутизации была переписана, чтобы
использовать маршрутизацию	 конечных	 точек	 для обеспечения именно
такого баланса. Маршрутизация конечных точек позволяет создавать
конечные точки, которые могут использовать тот же фреймворк марш-
рутизации и авторизации, что и контроллеры веб-API и Razor Pages, на-
слаждаясь при этом простотой промежуточного ПО.

725 Создание специальных конечных точек с помощью маршрутизации
ПРИМЕЧАНИЕ  Мы подробно рассматривали маршрутизацию
конечных точек в главе 5.
В этом разделе вы увидите, как преобразовать простое промежуточ-
ное ПО на основе ветвей из предыдущего раздела в конечную точку. Вы
увидите, как такой подход упрощает применение авторизации к конеч-
ной точке, используя декларативные подходы, с которыми вы уже зна-
комы по главе 15.
19.2.1 Создание специального компонента маршрутизации
конечных точек
Как я описал в главе 5, маршрутизация конечных точек разделяет про-
цесс выполнения конечной точки на два этапа, реализуемых двумя от -
дельными компонентами промежуточного ПО:
RoutingMiddleware – использует входящий запрос для выбора конеч-
ной точки для выполнения. Он предоставляет метаданные о  вы-
бранной конечной точке в  HttpContext, например требования к ав-
торизации, применяемые с по мощью атрибута [Authorize];
EndpointMiddleware – выполняет выбранную конечную точку для ге-
нерации ответа.
Преимущество использования этого двухэтапного процесса заключа-
ется в том, что вы можете разместить промежуточное ПО	 между	 ком -
понентом, который выбирает конечную точку, и компонентом, который
ее выполняет для генерации ответа. Например, AuthorizationMiddleware
использует выбранную конечную точку, чтобы определить, следует ли
прервать выполнение конвейера до выполнения конечной точки.
Представим, что вам нужно применить авторизацию к простой конеч-
ной точке ping-pong, которую вы создали в разделе 19.1.2. Этого намно-
го проще достичь с по мощью маршрутизации конечных точек, нежели
использовать простые ветви конвейера, такие как Map или Use. Первый
шаг – создать компонент для функциональности, используя подход, ко-
торый вы видели в разделе 19.1.4, как показано в следующем листинге.
Листинг 19.8  Класс PingPongMiddleware, реализованный
в виде компонента промежуточного ПО
public class PingPongMiddleware
{
public PingPongMiddleware(RequestDelegate next)
{
}
public async Task Invoke(HttpContext context)
{
context.Response.ContentType = "text/plain";
await context.Response.WriteAsync("pong");
}
}Даже если он не используется
в данном случае, вы должны
внедрить RequestDelegate
в конструктор.
Метод Invoke вызывается
для выполнения промежуточного ПО.Промежуточное ПО всегда
возвращает в ответ «pong».

726 Глава 19 Создание специальных компонентов
Обратите внимание, что этот компонент всегда возвращает ответ
"pong", независимо от URL-адреса запроса – мы настроим путь "/ping"
позже. Можно использовать этот класс для преобразования конвейера
промежуточного ПО, чтобы вместо версии с ветвлением, показанной на
рис. 19.1, получить версию с конечной точкой, показанной на рис. 19.4.
Поступает запрос на URL-адрес /ping
Компонент маршрутизации выбирает конечную
точку ping-pong на основе URL-адреса запроса
Компонент, размещенный после компонента
маршрутизации, знает, какая конечная точка
была выбрана
Выбранная конечная точка, конечная точка
ping-pong, выполняется компонентом
конечной точки/ping
/ping
Конечная точка
ping-pongping-pong
Конечная точка
Razor PagesRouting
middleware
# CORS
middleware
Authorization
middleware
Endpoint
middleware
Рис. 19.4 Маршрутизация конечной точки отделяет выбор конечной точки от
выполнения конечной точки. Компонент маршрутизации выбирает конечную
точку на основе входящего запроса и предоставляет метаданные о конечной
точке. Компонент, размещенный перед компонентом конечной точки, может
действовать в зависимости от выбранной конечной точки, например завершать
неавторизованные запросы. Если запрос авторизован, компонент конечной точки
выполняет выбранную точку и генерирует ответ
Преобразование компонента ping-pong в конечную точку не требует
никаких изменений в  самом промежуточном ПО. Вместо этого нужно
создать мини-конвейер, где содержится только компонент ping-pong.
СОВЕТ  По существу, преобразование промежуточного ПО, гене-
рирующего ответы, в  конечную точку требует преобразовать его
в его же собственный мини-конвейер, чтобы при желании вы мог -
ли включить в него дополнительные компоненты.
Вы должны создать конвейер конечной точки внутри аргумента лямб-
да-функции UseEndpoints(), как показано в  следующем листинге. Ис -
пользуйте метод CreateApplicationBuilder(), чтобы создать новый эк -
земпляр IApplicationBuilder, добавьте промежуточное ПО, образующее

727 Создание специальных конечных точек с помощью маршрутизации
вашу конечную точку, а  затем вызовите метод Build(), чтобы создать
конвейер.
Листинг 19.9 Отображение конечной точки ping-pong в UseEndpoints
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
app.UseRouting();
app.UseAuthentication();
app.UseAuthorization();
app.UseEndpoints(endpoints =>
{
var endpoint = endpoints
.CreateApplicationBuilder()
.UseMiddleware<PingPongMiddleware>()
.Build();
endpoints.Map("/ping", endpoint);
endpoints.MapRazorPages();
endpoints.MapHealthChecks("/healthz");
});
}}
Как только у вас появится конвейер, можете связать его с определен-
ным маршрутом, вызвав метод Map() экземпляра IEndpointRouteBuilder
и передав шаблон маршрута.
СОВЕТ  Обратите внимание, что функция Map() в IEndpointRoute-
Builder создает новую конечную точку (состоящую из вашего мини-
конвейера) с ассоциированным маршрутом. Хотя у нее то же имя, она
концептуально отличается от функции Map для IApplicationBuilder
из раздела 19.1.2, которая используется для ветвления	конвейера.
Если у вас много специальных конечных точек, метод UseEndpoints()
может быстро стать громоздким. Мне нравится извлекать эту функцио-
нальность в  метод расширения, чтобы делать метод Endpoints() чище
и удобнее для чтения. В следующем листинге мы извлекаем код для соз-
дания конечной точки из листинга 19.9 в  отдельный класс, используя
шаб  лон маршрута в качестве параметра метода.
Листинг 19.10  Метод расширения для использования
PingPongMiddleware в качестве конечной точки
public static class EndpointRouteBuilderExtensions
{
public static IEndpointConventionBuilder MapPingPong(
this IEndpointRouteBuilder endpoints,Создаем миниатюрный автономный
экземпляр IApplicationBuilder
для построения конечной точки.
Добавляем промежуточное
ПО и создаем окончательную
конечную точку. Выполнение
происходит при выполнении
конечной точки.Добавляем новую конечную точку
в коллекцию конечных точек,
ассоциированную с шаблоном маршрута "/ping" .
Создаем метод расширения для
регистрации PingPongMiddleware
в качестве конечной точки.

728 Глава 19 Создание специальных компонентов
string route)
{
var pipeline = endpoints.CreateApplicationBuilder()
.UseMiddleware<PingPongMiddleware>()
.Build();
return endpoints
.Map(route, pipeline)
.WithDisplayName("Ping-pong");
}
}
Теперь, когда у вас есть метод расширения MapPingPong(), можете об-
новить свой метод UseEndpoints() в  Startup.Configure(), чтобы он стал
проще и понятнее:
app.UseEndpoints(endpoints =>
{
endpoints.MapPingPong("/ping");
endpoints.MapRazorPages();
endpoints.MapHealthChecks("/healthz");
});
Поздравляю, вы создали свою первую конечную точку! Пока вы еще
не добавили никакой дополнительной функциональности, но с по мощью
системы маршрутизации конечных точек теперь намного проще удов-
летворить дополнительные требования по авторизации, как будет по-
казано в разделе 19.2.2.
СОВЕТ  В  этом примере использовался очень простой шаблон
маршрута "/ping", но вы также можете использовать шаблоны,
содержащие параметры маршрута, такие как "/ping/{count}", ис -
пользуя тот же фреймворк маршрутизации, который вы изучали
в главе 5. Чтобы увидеть примеры того, как получить доступ к этим
данным из своего промежуточного ПО, а также советы по наилуч-
шему использованию, см. 	мою запись в блоге: http://mng.bz/4ZRj.
Преобразование существующего промежуточного ПО, такого как
PingPongMiddleware, для работы с маршрутизацией конечных точек мо-
жет быть полезно, если вы уже реализовали это ПО, но вам придется пи-
сать большое количество шаблонного кода, если вы хотите создать но-
вую простую конечную точку. В ASP .NET Core 5.0 этот процесс намного
проще.Позволяет
вызывающей стороне
передать шаблон
маршрута для
конечной точки.Создаем конвейер
конечных точек.
Добавляем новую конечную точку
в предоставленную коллекцию конечных
точек, используя предоставленный
шаблон маршрута. Вы можете добавить сюда дополнительные метаданные
напрямую, либо вызывающая сторона может добавить
метаданные самостоятельно.

729 Создание специальных конечных точек с помощью маршрутизации
19.2.2 Создание простых конечных точек с по мощью MapGet
и WriteJsonAsync
С ASP .NET Core 5.0 теперь проще, чем когда-либо, создавать простые ко-
нечные точки, использующие маршрутизацию, и возвращать JSON. ASP .
NET Core 5.0 строится на основе примитивов маршрутизации конечных
точек, введенных в ASP .NET Core 3.0, и добавляет вспомогательные ме-
тоды для сериализации и десериализации JSON. Во многих случаях это
все, что необходимо для создания простых конечных точек, когда вам не
нужны все возможности контроллеров веб-API.
Например, вместо преобразования PingPongMiddleware в  конечную
точку и  необходимости создавать выделенный конвейер, как я  пока-
зывал в разделе 19.2.1, можно создать эквивалентную конечную точку
напрямую. В  следующем листинге показано, как использовать метод
расширения MapGet для написания встроенного лямбда-метода обра-
ботчика, что функционально идентично подходу, описанному в разде-
ле 19.2.1.
Листинг 19.11  Создание специальной конечной точки напрямую
с помощью метода MapGet
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
app.UseRouting();
app.UseAuthentication();
app.UseAuthorization();
app.UseEndpoints(endpoints =>
{
endpoints.MapGet("/ping", (HttpContext ctx)=>
ctx.Response.WriteAsync("pong"));
endpoints.MapRazorPages();
endpoints.MapHealthChecks("/healthz");
});
}}
Это эквивалентно примеру из раздела 19.2.1, но явно намного про-
ще – здесь не требуются дополнительные классы или вспомогательные
методы! Существуют альтернативные методы расширения для других
HTTP-методов, такие как MapPost и  MapPut, поэтому вы можете создать
несколько встроенных конечных точек таким образом.
СОВЕТ  Как и в разделе 19.2.1, в этом примере используется очень
простой шаблон маршрута, "/ping", но вы также можете исполь-
зовать шаблоны, содержащие параметры маршрута, например "/
ping/{count}". См. соответствующий исходный код для простого
примера.Настраиваем лямбда-функцию
для выполнения, когда GET-запрос
маршрутизируется к конечной точке /ping.

730 Глава 19 Создание специальных компонентов
Важно понимать разницу между методом расширения конечной	 точки
MapGet, показанным здесь, и методом расширения построителя	 прило-
жения Map, обсуждаемым в разделе 19.1:
используйте Map для	создания	 отдельных	 ветвей	конвейера	 промежу-
точного	 ПО и MapGet для регистрации конечной точки в компоненте
маршрутизации, который генерирует ответ;
Map использует	 простые	 сегменты	 URL-адреса, 	чтобы	решить, 	какую
ветвь	выбрать;	 он	не	использует	 параметры	 маршрута. MapGet ис -
пользует шаблоны маршрутов, такие же, как Razor Pages и парамет -
ры Web API, как описано в главе 5.
Методы расширения MapGet и MapPost также были доступны в ASP .NET
Core версии 3.0, но ASP .NET Core 5.0 представил дополнительные методы
расширения, позволяющие легко читать и писать JSON с по мощью се-
риализатора System.Text.Json. В следующем листинге показана простая
конечная точка «echo», которая считывает JSON из тела запроса, а затем
пишет его в ответ.
Листинг 19.12  Запись JSON из специальной конечной точки
с использованием WriteAsJsonAsync
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
app.UseRouting();
app.UseAuthentication();
app.UseAuthorization();
app.UseEndpoints(endpoints =>
{
endpoints.MapPost("/echo", async (HttpContext ctx =>
{
MyCustomType model = await ctx.Request
.ReadFromJsonAsync<MyCustomType>();
await context.Response.WriteAsJsonAsync(model);
});
endpoints.MapRazorPages();
endpoints.MapHealthChecks("/healthz");
});
}}
Функция ReadFromJsonAsync позволяет десериализовать тело запроса
в объект POCO – в данном примере это MyCustomType. Это похоже  на при-
вязку модели, которую вы видели в главе 6, но гораздо более примитив-
но. Здесь нет встроенной проверки или чтения из значений маршрута,
и любые ошибки в данных запроса вызовут исключение.
Точно так же WriteAsJsonAsync сериализует любой объект, переданный
ему в ответе, в виде JSON. Это очень эффективно по сравнению с подхо-
дом с ActionResult, используемым в Razor Pages и контроллерах веб-API,
но у него гораздо меньше функций. Здесь нет конвейера фильтров, нет
согласования содержимого и встроенной обработки ошибок.Настраиваем лямбда-функцию
для выполнения, когда GET-запрос
маршрутизируется к конечной точке /ping.
Используем
System.T ext.
Json для
десериализации
тела запроса
в объект
MyCustomT ype.Используем System.T ext.Json для
сериализации объекта модели
в виде JSON в теле ответа.

731 Создание специальных конечных точек с помощью маршрутизации
СОВЕТ  Если все, что вам нужно, – это быстрый и очень простой
API, методы расширения Map* и вспомогательные методы JSON –
отличный вариант. Если вам нужны дополнительные функции,
такие как валидация, привязка модели, поддержка нескольких
форматов или интеграция с  OpenAPI, используйте контроллеры
веб-API.
Одно из преимуществ маршрутизации конечных точек, независимо от
того, используете вы методы расширения Map* или подход с существую-
щим промежуточным ПО из раздела 19.2.1, заключается в том, что вы
получаете всю мощь шаблонов маршрутов. Однако использование прос -
тых ветвей Map может быть быстрее, чем использование инфраструктуры
маршрутизации, поэтому в некоторых случаях лучше избегать маршру -
тизации конечных точек.
Встроенный компонент StaticFileMiddleware – хороший пример та-
кого компромисса. Это промежуточное ПО обслуживает статические
файлы на основе URL-адреса запроса, но не использует маршрутизацию
конечных точек из-за того, какое влияние на производительность ока-
зывает добавление множества (возможно, сотен) маршрутов для каждо-
го статического файла в вашем приложении. Обратной стороной этого
выбора является тот факт, что добавления авторизации к статическим
файлам добиться непросто; если использовалась маршрутизация конеч-
ных точек, то сделать это не составит труда.
19.2.3 Применение авторизации к конечным точкам
Одним из основных преимуществ маршрутизации конечных точек явля-
ется возможность легко применять авторизацию к конечной точке. Для
Razor Pages и контроллеров веб-API это достигается за счет добавления
атрибута [Authorize], как вы видели в главе 15.
Для других конечных точек, таких как конечная точка ping-pong, соз-
данная в разделе 19.2.1, можно декларативно применить авторизацию
при добавлении конечной точки в свое приложение, вызвав метод Re-
quireAuthorization() в  IEndpointConventionBuilder, как показано в сле-
дующем листинге.
Листинг 19.13  Применение авторизации к конечной точке с по мощью
метода RequireAuthorization()
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
app.UseRouting();
app.UseAuthentication();
app.UseAuthorization();
app.UseEndpoints(endpoints =>
{
endpoints.MapPingPong("/ping")
.RequireAuthorization();Требуем авторизацию. Это эквивалентно
применению атрибута [Authorize].

732 Глава 19 Создание специальных компонентов
endpoints.MapRazorPages();
endpoints.MapHealthChecks("/healthz")
.RequireAuthorization("HealthCheckPolicy")
});
}}
В листинге 19.13 показаны два примера применения авторизации
к конечным точкам:
RequireAuthorization() – если вы не укажете аргумент метода, он
применит политику авторизации по умолчанию к конечной точке.
Это равносильно применению атрибута [Authorize] к  конечной
точке Razor Page или контроллера веб-API;
RequireAuthorization(policy)  – если вы указываете имя политики,
будет использоваться выбранная политика авторизации. Политика
должна быть настроена в  ConfigureServices, как вы видели в главе 15.
Это эквивалентно применению атрибута [Authorize ("HealthCheck-
Policy")] к конечной точке страницы Razor или контроллера веб-API.
Если вы применяете авторизацию к  своему приложению глобально
(как описано в главе 15), то можете создать брешь в глобальной политике
с по мощью дополнительного метода AllowAnonymous(). Например:
endpoints.MapPingPong("/ping").AllowAnonymous();
Это эквивалентно использованию атрибута [AllowAnonymous] на стра-
ницах Razor и методах действия контроллеров.
ПРИМЕЧАНИЕ  Метод AllowAnonymous() для конечных точек – но-
винка .NET 5.0.
Авторизация  – это классический пример добавления метаданных
к конечным точкам для добавления функциональности, но есть и другие
варианты. Вы можете использовать следующие готовые методы:
RequireAuthorization() – применяет политики авторизации к  ко-
нечной точке, как вы уже видели;
AllowAnonymous() – переопределяет глобальную политику авториза-
ции, чтобы разрешить анонимный доступ к конечной точке;
RequireCors(policy) – применяет политику CORS к конечной точке,
как описано в главе 18;
RequireHost(hosts) – разрешает маршрутизацию к конечной точке
только в том случае, если входящий запрос соответствует одному из
предоставленных имен хоста;
WithDisplayName(name) – задает понятное имя для конечной точки.
Используется в основном в журналировании для описания конеч-
ной точки;
WithMetadata(items) – добавляет произвольные значения в качестве
метаданных в конечную точку. Вы можете получить доступ к этим
значениям в промежуточном ПО после того, как компонент марш-
рутизации выберет конечную точку.Требуем авторизацию
с использованием
конкретной политики
HealthCheckPolicy.

733 Работа с требованиями к сложной конфигурации
Эти методы обеспечивают различную функциональность, например
CORS и авторизацию, для беспрепятственной работы в Razor Pages, конт -
роллерах веб-API, встроенных конечных точках, такие как конечные
точки проверки работоспособности и специальные конечные точки, на-
пример PingPongMiddlleWare. Они должны позволить вам удовлетворить
большинство требований, предъявляемых к  специальным конечным
точкам. А если вы обнаружите, что вам нужно что-то посложнее, напри-
мер привязка модели, то всегда можете выполнить откат, чтобы исполь-
зовать контроллеры веб-API. Выбор за вами!
В следующем разделе мы отойдем от конвейера промежуточного ПО
и  посмотрим, как работать с  требованиями к  сложной конфигурации.
В частности, вы увидите, как настроить поставщиков сложных конфигу -
раций, которым требуются собственные значения конфигурации, и как
использовать сервисы внедрения зависимостей для создания строго ти-
пизированных объектов IOptions.
19.3 Работа с требованиями к сложной
конфигурации
В этом разделе я опишу, как удовлетворить два требования к сложной
конфигурации: поставщики конфигурации, которым необходимо на-
строить себя, и  использование сервисов для настройки объектов IOp-
tions. В первом сценарии вы увидите, как частично создать свою кон-
фигурацию, позволяющую создать поставщика. Во втором сценарии вы
увидите, как использовать интерфейс IConfigureOptions, чтобы разре-
шить доступ к сервисам при настройке объектов параметров.
В главе 11 мы подробно обсудили систему конфигурации ASP .NET Core.
Вы видели, как объект IConfiguration создается из нескольких слоев, где
последующие слои могут добавлять или заменять значения конфигура-
ции из предыдущих слоев. Каждый слой добавляется поставщиком кон-
фигурации, который может считывать значения из файла, переменных
окружения, User Secrets или из любого количества возможных мест.
Вы также видели, как привязать значения конфигурации к строго ти-
пизированным объектам POCO с по мощью интерфейса IOptions. Мож -
но внедрять эти строго типизированные объекты в свои классы, чтобы
обес печить легкий доступ к настройкам, вместо того чтобы читать кон-
фигурацию, используя строковые ключи.
В этом разделе мы рассмотрим два более сложных сценария. В первом
сценарии вы попытаетесь использовать поставщика конфигурации, ко-
торый сам требует настройки. Например, представьте, что вы хотите со-
хранить некую конфигурацию в таблице базы данных. Чтобы загрузить
эти значения, вам нужна какая-нибудь строка подключения, которая,
скорее всего, также из объекта IConfiguration. Налицо ситуация «кури-
ца или яйцо»: вам нужно создать объект IConfiguration, чтобы добавить
поставщика, но вы не можете добавить его без создания объекта ICon-

734 Глава 19 Создание специальных компонентов
figuration!
Во втором сценарии вам нужно настроить строго типизированный
объект IOptions со значениями, возвращаемыми из сервиса. Но сервис
будет доступен только после того, как вы настроите все объекты IOptions.
В  разделе 19.3.2 вы увидите, как справиться с  этим путем реализации
интерфейса IConfigureOptions.
19.3.1 Частичное создание конфигурации для настройки
дополнительных поставщиков
ASP .NET Core включает в  себя множество поставщиков конфигурации,
таких как поставщики файлов и переменных окружения, для настройки
которых не требуется ничего, кроме основных деталей. Все, что вам нуж -
но, например, для чтения файла JSON, – это путь к этому файлу.
Но система конфигурации очень расширяема, и  поставщикам более
сложных конфигураций может самим потребоваться конфигурация. На-
пример, у вас может быть поставщик, который загружает значения кон-
фигурации из базы данных, поставщик, загружающий значения из уда-
ленного API, или поставщик, загружающий секреты из Azure Key Vault1.
Каждому из них требуется конфигурация: строка подключения для
базы данных, URL-адрес удаленной службы или ключ для расшифров-
ки данных из Key Vault. К сожалению, это приводит к замкнутому кругу:
вам нужно добавить поставщика для создания объекта конфигурации,
но, чтобы сделать это, вам нужен объект конфигурации!
Решение состоит в том, чтобы использовать двухэтапный процесс для
создания окончательного объекта конфигурации IConfiguration, как по-
казано на рис. 19.5. На первом этапе вы загружаете значения конфигура-
ции, доступные локально, например файлы JSON и переменные окруже-
ния, и создаете временную IConfiguration. Вы можете использовать этот
объект для настройки комплексных поставщиков, добавить их в  свой
конструктор конфигурации и создать окончательный объект IConfigu-
ration для своего приложения.
Вы можете использовать этот двухэтапный процесс всякий раз, когда
у вас есть поставщики, которые сами нуждаются в конфигурации. Двой-
ное создание объекта конфигурации означает, что значения загружают -
ся из каждого начального поставщика конфигурации дважды, но это не
приводит к каким-либо проблемам.
В качестве примера этого процесса в листинге 19.14 показано, как соз-
дать временный объект IConfiguration, построенный с использованием
1 Azure Key Vault – это сервис, позволяющий безопасно хранить секреты в об-
лаке. Ваше приложение извлекает секреты из Azure Key Vault во время вы-
полнения, вызывая API и  предоставляя идентификатор клиента и  секрет.
Идентификатор клиента и секрет должны поступать из значений локальной
конфигурации, чтобы вы могли получить все остальное из Azure Key Vault. До-
полнительные сведения, в том числе о том, как начать работу с этим сервисом,
см. в документации Microsoft: http://mng.bz/Qm7v .

735 Работа с требованиями к сложной конфигурации
содержимого XML-файла. Он содержит свойство конфигурации "Set-
tingsFile" с именем файла JSON.
ConfigurationBuilder
IConfiguration
IConfigurationJsonConfigurationProvider
EnvironmentVariablesProvider
AzureKeyVaultProviderAddJsonFile()
AddEnvironmentVariables()
Build()
Build()clientId: config value
secretId: secret value
AddAzureKeyVault(clientId, secretId)1.  Вы начинаете с создания экземпляра
ConfigurationBuilder
3.  Вызовите метод
Build() для создания
временного объекта
IConfiguration
5.  Вызовите метод
Build() второй раз,
чтобы создать
окончательную
конфигурацию
IConfiguration 6.  Окончательная IConfiguration включает в себя
конфигурацию от всех поставщиков4.  Извлеките значения конфигурации,
необходимые для настройки
других поставщиков
конфигурации, и добавьте
дополнительных поставщиков2.  Добавьте в конструктор поставщиков
конфигурации, доступных локально
Рис. 19.5 Добавление поставщика конфигурации, которому требуется конфигурация. Начните
с добавления поставщиков, о которых у вас есть сведения, и создайте временный объект
IConfiguration. Вы можете использовать его для загрузки параметров, которые требуются
комплексному поставщику, добавления поставщика в свой конструктор конфигурации
и создания окончательного объекта IConfiguration с использованием всех поставщиков
На втором этапе конфигурации вы добавляете поставщика файлов
JSON (используя имя файла из частичного объекта IConfiguration) и по-
ставщика переменной окружения.
Когда вы, наконец, вызываете метод Build() в IHostBuilder, будет соз-
дан новый объект IConfiguration, содержащий значения конфигурации
из файла XML, файла JSON и переменных окружения.
Листинг 19.14  Использование нескольких объектов IConfiguration
для конфигурирования поставщиков
public static IHostBuilder CreateHostBuilder(string[] args) =>
Host.CreateDefaultBuilder(args)
.ConfigureAppConfiguration((context, config) =>

736 Глава 19 Создание специальных компонентов
{
config.Sources.Clear();
config.AddXmlFile("baseconfig.xml");
IConfiguration partialConfig = config.Build();
string filename = partialConfig["SettingsFile"];
config.AddJsonFile(filename)
.AddEnvironmentVariables();
})
.ConfigureWebHostDefaults(webBuilder =>
{
webBuilder.UseStartup<Startup>();
});
Это несколько надуманный пример – маловероятно, что вам понадо-
бится загружать значения конфигурации для чтения файла JSON, – но
принцип тот же, независимо от того, каких поставщиков вы исполь-
зуете. Хороший пример – поставщик Azure Key Vault. Чтобы загрузить
значения конфигурации из Azure Key Vault, вам понадобится URL-адрес,
идентификатор клиента и секрет. Они должны быть загружены из дру -
гих поставщиков конфигурации, поэтому вы должны использовать тот
же двухэтапный процесс, как показано в предыдущем листинге.
После загрузки конфигурации приложения ее обычно привязывают
к строго типизированным объектам с по мощью шаблона IOptions. В сле-
дующем разделе мы рассмотрим другие способы настройки объектов IOp-
tions и способы их создания с по мощью сервиса внедрения зависимостей.
19.3.2 Использование сервисов для настройки IOptions
с помощью IConfigureOptions
Распространенной и рекомендуемой практикой является привязка объ-
екта конфигурации к строго типизированным объектам IOptions<T>, как
было показано в главе 11. Обычно такая привязка настраивается в  Start-
up.ConfigureServices путем вызова services.Configure<T>() и  предо-
ставления объекта IConfiguration или раздела для привязки.
Чтобы привязать строго типизированный объект, CurrencyOptions,
к разделу объекта IConfiguration, "Currencies", нужно использовать:
public void ConfigureServices(IServiceCollection services)
{
services.Configure<CurrencyOptions>(
Configuration.GetSection("Currencies"));
}
Так вы задаете свойства объекта CurrencyOptions на основе значений
в  разделе "Currencies" объекта IConfiguration. Такая простая привяз-Удаляем источники
конфигурации
по умолчанию.Добавляет XML-файл
в конфигурацию, который
содержит конфигурацию
для других поставщиков.
Создает объект
IConfiguration для
чтения XML-файла.Извлекает
конфигурацию,
которая
требуется другим
поставщикам.
Использует извлеченную
конфигурацию для настройки
других поставщиков.Помните, что значения от последующих
поставщиков будут перезаписывать
значения от предыдущих поставщиков.

737 Работа с требованиями к сложной конфигурации
ка – обычное явление, но иногда вам может потребоваться настроить
конфигурацию своих объектов IOptions<T> или вы можете вообще не за-
хотеть привязывать их к конфигурации. Шаблон IOptions требует только
настройки строго типизированного объекта перед его внедрением в за-
висимый сервис; он не требует от вас обязательной привязки его к раз-
делу IConfiguration.
СОВЕТ  Технически, даже если вы вообще не настраиваете IOp-
ti ons<T>, вы можете по-прежнему внедрять его в  свои сервисы.
В этом случае объект T всегда будет создаваться с использованием
конструктора по умолчанию.
У метода services.Configure<T>() есть перегруженный вариант, по-
зволяющий предоставить лямбда-функцию, которую фреймворк ис -
пользует для настройки объекта CurrencyOptions.
Например, в следующем фрагменте мы используем лямбда-функцию,
чтобы задать для свойства Currencies в  сконфигурированном объекте
CurrencyOptions значение в виде фиксированного массива строк:
public void ConfigureServices(IServiceCollection services)
{
services.Configure<CurrencyOptions>(
Configuration.GetSection("Currencies"));
services.Configure<CurrencyOptions>(options =>
options.Currencies = new string[] { "GBP", "USD"});
}
Каждый вызов Configure<T>(), и привязка к  IConfiguration, и лямб-
да-функция, добавляет еще один шаг конфигурации к объекту Curren-
cyOptions. Когда контейнеру внедрения зависимостей сначала требуется
экземпляр IOptions<CurrencyOptions>, каждый из шагов выполняется по
очереди, как показано на рис. 19.6.
new CurrencyOptions()
Configure(config)
IOptions<CurrencyOptions>Configure(options=>)DefaultCurrency = "GBP"
Currencies = []
DefaultCurrency = "GBP"
Currencies = ["GBP", "USD"]Когда требуется экземпляр IOptions <CurrencyOptions>, контейнер
внедрения зависимостей создает экземпляр CurrencyOptions
и настраивает его с каждым из зарегистрированных вызовов
Configure
Каждый этап с методом
Configure() обновляет экземпляр
CurrencyOptions
Вызовы Configure выполняются
последовательно, чтобы создать
окончательный объект
После полной настройки IOptions
<CurrencyOptions> внедряется
как зависимость
Рис. 19.6 Настройка объекта CurrencyOptions. Когда контейнеру внедрения зависимостей
требуется экземпляр IOptions<> строго типизированного объекта, контейнер создает объект,
а затем использует каждый из зарегистрированных методов Configure(), чтобы задать
свойства объекта

738 Глава 19 Создание специальных компонентов
В предыдущем фрагменте кода вы задали для свойства Currencies ста -
тический массив строк в лямбда-функции. Но что, если вы заранее не
знаете правильные значения? Вам может потребоваться загрузить до-
ступные валюты из базы данных или, например, из какого-либо удален-
ного сервиса.
К сожалению, такую ситуацию, когда вам нужен сконфигурированный
сервис для настройки IOptions<T>, трудно разрешить. Помните, что вы
объявляете конфигурацию объекта IOptions<T> внутри ConfigureSer-
vices как часть конфигурации внедрения зависимостей. Как получить
полностью настроенный экземпляр сервиса обмена валют, если вы еще
не зарегистрировали его в контейнере?
Решение состоит в том, чтобы отложить настройку объекта IOptions<T>
до последнего момента, непосредственно перед тем, как контейнер
внед рения зависимостей должен создать его для обработки входящего
запроса.
На этом этапе контейнер будет полностью настроен и будет знать, как
создать сервис обмена валют.
ASP .NET Core предоставляет этот механизм с интерфейсом IConfi-
gu re Options<T>, который реализуется в классе конфигурации и исполь-
зуется для настройки объекта IOptions<T> любым удобным для вас
способом. Этот класс может использовать внедрение зависимостей,
поэтому вы можете с легкостью применять любые другие необходи-
мые сервисы.
Листинг 19.15  Реализация интерфейса IConfigureOptions<T>
для настройки объекта параметров
public class ConfigureCurrencyOptions : IConfigureOptions<CurrencyOptions>
{
private readonly ICurrencyProvider _currencyProvider;
public ConfigureCurrencyOptions(ICurrencyProvider currencyProvider)
{
_currencyProvider = currencyProvider;
}
public void Configure(CurrencyOptions options)
{
options.Currencies = _currencyProvider.GetCurrencies();
}
}
Осталось только зарегистрировать эту реализацию в  контейнере
внедрения зависимостей. Как всегда, важен порядок, поэтому если вы
хотите, чтобы ConfigureCurrencyOptions выполнялся после привязки
к  конфигурации, нужно добавить его после первого вызова services.
Configure<T>(): Вы можете внедрять сервисы, которые доступны
только после полной настройки внедрения зависимостей.Configure вызывается,
когда требуется экземпляр
IOptions<CurrencyOptions>.
Вы можете использовать внедренный сервис
для загрузки значений из удаленного API.

739 Использование стороннего контейнера внедрения зависимостей
public void ConfigureServices(IServiceCollection services)
{
services.Configure<CurrencyOptions>(
Configuration.GetSection("Currencies"));
services.AddSingleton
<IConfigureOptions<CurrencyOptions>, ConfigureCurrencyOptions>();
}
ВНИМАНИЕ!  Объект CurrencyConfigureOptions регистрируется
как объект-одиночка, поэтому он будет захватывать все внедрен-
ные сервисы с типом жизненного цикла Scoped или Transient1.
В этой конфигурации, когда IOptions<CurrencyOptions> внедряется
в контроллер или сервис, объект CurrencyOptions сначала будет привя-
зан к разделу "Currencies" вашего объекта IConfiguration, а затем будет
настроен с по мощью класса ConfigureCurrencyOptions.
Одна часть конфигурации, которую мы еще не показали, – это ICur-
rencyProvider, используемый классом ConfigureCurrencyOptions. В при-
мере кода для этой главы я создал простой сервис CurrencyProvider и за -
регистрировал его в контейнере внедрения зависимостей:
services.AddSingleton<ICurrencyProvider, CurrencyProvider>();
По мере роста вашего приложения и  добавления дополнительных
функций и сервисов вы, вероятно, обнаружите, что пишете все больше
и больше таких простых регистраций, где регистрируете сервис, реали-
зующий интерфейс IService. Встроенный контейнер внедрения зависи-
мостей ASP .NET Core требует, чтобы вы явно регистрировали каждый из
этих сервисов вручную. Если это требование вас разочаровывает, воз-
можно, пришло время взглянуть на сторонние контейнеры, которые мо-
гут взять на себя задачи по написанию шаблонного кода.
19.4 Использование стороннего контейнера
внедрения зависимостей
В этом разделе я  покажу, как заменить контейнер внедрения зависи-
мостей, используемый по умолчанию сторонней альтернативой, Lamar.
Сторонние контейнеры часто предоставляют дополнительные функции
по сравнению со встроенным контейнером, такие как сканирование сбо-
рок, автоматическая регистрация сервисов и внедрение свойств. Замена
встроенного контейнера также может быть полезна при переносе су -
1 Если вы добавляете сервис с жизненным циклом Scoped в свой класс конфи-
гурации (например, DbContext), вам нужно проделать немного больше работы,
чтобы убедиться, что она правильно освобождена. Я описываю, как этого до-
биться, в статье своего блога: http://mng.bz/6m17 .

740 Глава 19 Создание специальных компонентов
ществующего приложения, использующего сторонний контейнер, в ASP .
NET Core.
Сообщество .NET использовало контейнеры внедрения зависимостей
в  течение многих лет, прежде чем ASP .NET Core решил использовать
встроенный контейнер. Команда ASP .NET Core хотела найти способ ис -
пользовать внедрение зависимостей в собственных библиотеках фрейм-
ворка, и они хотели создать общую абстракцию1, позволяющую заменить
встроенный контейнер любимой сторонней альтернативой, например:
Autofac;
StructureMap/Lamar;
Ninject;
Simple Injector;
Unity.
Встроенный контейнер намеренно ограничен в возможностях, кото-
рые он предоставляет, и вряд ли будет сильно развиваться. Сторонние
контейнеры, напротив, могут предоставлять множество дополнитель-
ных функций. Вот некоторые из функций, доступных в  Lamar (https://
jasperfx.github.io/lamar/documentation/ioc/), наследнике StructureMap:
сканирование сборок для пар «интерфейс/реализация» на основе
соглашений;
автоматическая регистрация конкретных классов;
внедрение свойств и выбор конструктора;
автоматическое разрешение Lazy<T>/Func<T>;
инструменты отладки и  тестирования, позволяющие заглянуть
внутрь контейнера.
Ни одна из этих функций не является обязательной для запуска при-
ложения, поэтому использование встроенного контейнера имеет смысл,
если вы создаете небольшое приложение или новичок в  работе с  кон-
тейнерами внедрения зависимостей. Но если в  какой-то переломный
момент простота встроенного контейнера становится слишком обреме-
нительной, возможно, его стоит заменить.
СОВЕТ  Промежуточный подход  – использовать пакет NuGet,
Scrutor, который добавляет ряд функций во встроенный контей-
нер внедрения зависимостей, не заменяя его полностью. Введение
и примеры см. в посте моего блога «Использование Scrutor для ав-
томатической регистрации своих сервисов в контейнере внедре-
ния зависимостей ASP .NET Core»: ht tp://mng.bz/MX7B.
1 Хотя продвижение внедрения зависимостей в  качестве основной практики
приветствовалось, эта абстракция вызвала ряд противоречий. В  этом посте
под заголовком «Что не так с внедрением зависимостей в ASP .NET Core?» от
одного из разработчиков библиотеки SimpleInjector описываются многие
аргументы и  проблемы: http://mng.bz/yYAd. Дополнительную информацию
также можно найти на GitHub: https://github.com/aspnet/DependencyInjection/
issues/433.

741 Использование стороннего контейнера внедрения зависимостей
В этом разделе я покажу, как настроить приложение ASP .NET Core, что-
бы использовать Lamar для разрешения зависимостей. Это не будет слож -
ный пример или подробное обсуждение самой этой библиотеки. Я при-
веду минимум информации, чтобы вы могли приступить к работе.
Какой бы сторонний контейнер вы ни выбрали для установки в  су -
ществующее приложение, общий процесс почти одинаков:
1 Установите пакет NuGet.
2  Зарегистрируйте сторонний контейнер в  IHostBuilder в файле Pro-
gram.cs.
3 Добавьте метод ConfigureContainer в классе Startup.
4  Настройте сторонний контейнер в методе ConfigureContainer, что -
бы зарегистрировать свои сервисы.
Большинство основных контейнеров .NET были перенесены для рабо-
ты на .NET Core и включают адаптер, позволяющий добавлять их в при-
ложения ASP .NET Core. Для получения более подробной информации
стоит ознакомиться с  конкретным руководством для используемого
вами контейнера. В случае с Lamar процесс выглядит так:
1  Установите пакет Lamar.Microsoft.DependencyInjection, используя
диспетчер пакетов NuGet, запустив команду dotnet add package:
dotnet add package Lamar.Microsoft.DependencyInjection
Или добавив <PackageReference> в файл с расширением .csproj:
<PackageReference
Include="Lamar.Microsoft.DependencyInjection" Version="4.4.0" />
2 Вызовите метод UseLamar() IHostBuilder в файле Program.cs:
public static IHostBuilder CreateHostBuilder(string[] args) =>
Host.CreateDefaultBuilder(args)
.UseLamar()
.ConfigureWebHostDefaults(webBuilder =>
{
webBuilder.UseStartup<Startup>();
}
3  Добавьте метод ConfigureContainer в свой класс Startup со следую-
щей сигнатурой:
public void ConfigureContainer(ServiceRegistry services) { }
Настройте класс Lamar ServiceRegistry в методе ConfigureContainer,
как показано в следующем листинге. Это базовая конфигурация, а более
сложный пример можно увидеть в исходном коде для этой главы.

742 Глава 19 Создание специальных компонентов
Листинг 19.16  Настройка Lamar в качестве стороннего контейнера
внедрения зависимостей
public void ConfigureContainer(ServiceRegistry services)
{
services.AddAuthorization();
services.AddControllers()
.AddControllersAsServices();
services.Scan(_ => {
_.AssemblyContainingType(typeof(Startup));
_.WithDefaultConventions();
});
}
В этом примере я использовал соглашения по умолчанию для регист -
рации сервисов. Вы автоматически регистрируете конкретные классы
и сервисы, имена которых соответствуют ожидаемым соглашениям (на-
пример, Service реализует IService). Вы можете изменить эти соглаше-
ния или добавить другие регистрации в методе ConfigureContainer.
Класс ServiceRegistry, переданный в метод ConfigureContainer, реализу -
ет интерфейс IServiceCollection. Это означает, что вы можете использо-
вать все встроенные методы расширения, такие как AddControllers() и Add-
Authorization(), для добавления сервисов фреймворка в свой контейнер.
ПРЕДУПРЕЖДЕНИЕ  Если вы используете внедрение зависимо-
стей в своих контроллерах MVC (почти наверняка!) и регистрируе-
те эти зависимости в Lamar, а не во встроенном контейнере, вам
может потребоваться вызвать метод AddControllersAsServices(),
как показано в листинге 19.16. Это связано с деталями реализации
того, как ваши контроллеры MVC создаются фреймворком. Для по-
лучения дополнительной информации см. запись в моем блоге под
названием «Активация контроллера и  внедрение зависимостей
в ASP .NET Core MVC»: http://mng.bz/aogm.
При такой конфигурации всякий раз, когда вашему приложению тре-
буется создать сервис, оно будет запрашивать его из контейнера Lamar,
который создаст дерево зависимостей для класса и  экземпляр. Дан-
ный пример не демонстрирует всю мощь Lamar, поэтому обязательно
ознакомьтесь с  документацией (https://jasperfx.github.io/lamar/) и  со-
ответствующим исходным кодом для этой главы, чтобы увидеть до-
полнительные примеры. Даже в  скромных приложениях Lamar может
значительно упростить код регистрации сервисов, но его дополнитель-
ное преимущест во состоит в том, чтобы показать все сервисы, которые
вы зарегистрировали, и все связанные с ними проблемы.
На этом мы подошли к концу главы, посвященной пользовательским
компонентам. В этой главе я сосредоточился на некоторых наиболее рас -Настраиваем сервисы в ConfigureContainer
вместо ConfigureServices.
Вы можете (и должны) добавлять сервисы платформы
ASP.NET Core в ServiceRegistry, как обычно.
Требуется,
чтобы Lamar
использовалась
для создания
контроллеров
веб-API.Lamar может автоматически
сканировать ваши сборки
в поисках сервисов, которые нужно
зарегистрировать.

743 Резюме
пространенных компонентах, которые вы будете создавать для конфи-
гурации, внедрения зависимостей и промежуточного ПО. В следующей
главе вы узнаете о дополнительных компонентах, особое внимание бу -
дет уделено страницам Razor и контроллерам веб-API.
Резюме
Используйте метод расширения Run для создания компонентов про-
межуточного ПО, которые всегда возвращают ответ. Вы всегда должны
размещать его в конце конвейера или ветви, поскольку компоненты,
размещенные после него, не будут выполнены.
Вы можете создавать ветви в  конвейере промежуточного ПО с  по-
мощью метода расширения Map. Если входящий запрос соответствует
указанному префиксу пути, запрос выполнит ветвь конвейера; в про-
тивном случае он выполнит основной конвейер.
Когда метод расширения Map соответствует сегменту пути запроса, он
удаляет сегмент из объекта запроса HttpContext.Path и  перемещает
его в свойство PathBase, что гарантирует правильную работу маршру -
тизации в ветвях.
Вы можете использовать метод расширения Use для создания компо-
нентов промежуточного ПО общего назначения, которые могут гене-
рировать ответ, изменять запрос или передавать запрос следующему
компоненту в конвейере. Это полезно для сквозных задач, таких как
добавление заголовка ко всем ответам.
Вы можете инкапсулировать промежуточное ПО в повторно исполь-
зуемый класс. Этот класс должен принимать объект RequestDelegate
в конструкторе и иметь открытый метод Invoke(), который принимает
объект HttpContext и возвращает Task. Для вызова следующего компо-
нента в конвейере вызовите объект RequestDelegate с предоставлен-
ным объектом HttpContext.
Чтобы создать конечные точки, которые генерируют ответ, создайте
миниатюрный конвейер, содержащий промежуточное ПО для генера-
ции ответа, и вызовите endpoints.Map(route,pipeline). Маршрутиза-
ция конечных точек будет использоваться для сопоставления входя-
щих запросов с вашими конечными точками.
В качестве альтернативы используйте MapGet и другие методы расши-
рения Map* для создания встроенных конечных точек. Маршрутизация
конечных точек сопоставляет входящие запросы с этими точками так
же, как и с другими специальными конечными точками.
Вы можете читать и записывать JSON внутри конечной точки Map*, ис -
пользуя методы расширения ReadFromJsonAsync и  WriteAsJsonAsync.
Они используют сериализатор System.Text. Json для прямой десериа-
лизации и сериализации объектов. Эти методы могут быть полезны
для создания простых API. Имейте в виду, что в этом подходе отсут -

744 Глава 19 Создание специальных компонентов
ствует большинство функций, доступных с контроллерами веб-API, та-
кими как валидация, конвейер фильтров и согласование содержания.
Вы можете прикреплять метаданные к конечным точкам, что делает
их доступными для любых компонентов промежуточного ПО, разме-
щенных между вызовами методов UseRouting() и  UseEndpoints(). Эти
метаданные обеспечивают такие функции, как авторизация и CORS.
Чтобы добавить авторизацию к конечной точке, вызовите метод Re-
quireAuthorization() после сопоставления конечной точки. Это экви-
валентно использованию атрибута [Authorize] в Razor Pages и конт -
роллерах веб-API. При желании можно предоставить имя политики
авторизации, вместо того чтобы использовать политику по умолча-
нию.
Некоторым поставщикам конфигурации самим требуются значения
конфигурации. Например, поставщику конфигурации, который за-
гружает параметры из базы данных, может понадобиться строка под-
ключения. Вы можете загрузить этих поставщиков конфигурации,
частично создав объект IConfiguration, используя других поставщи-
ков и считывая требуемую конфигурацию из него. Затем вы можете
настроить поставщика базы данных и добавить его в  Configuration-
Builder перед повторным построением, чтобы получить окончатель-
ный объект IConfiguration.
Если вам нужно использовать сервисы из контейнера внедрения зави-
симостей для настройки объекта IOptions<T>, вы должны создать от -
дельный класс, реализующий IConfigureOptions<T>. Этот класс может
использовать внедрение зависимостей в конструкторе и применяется
для ленивой инициализации запрашиваемого объекта IOptions<T> во
время выполнения.
Вы можете заменить встроенный контейнер внедрения зависимостей
на сторонний контейнер. Сторонние контейнеры часто предоставля-
ют дополнительные функции, такие как регистрация зависимостей на
основе соглашений, сканирование сборок или внедрение свойств.
Чтобы использовать сторонний контейнер, такой как Lamar, устано-
вите пакет NuGet, активируйте контейнер в  IHostBuilder и реализуй-
те метод ConfigureContainer() в классе Startup. Настройте сторонний
контейнер в  этом методе, зарегистрировав необходимые сервисы
фреймворка ASP .NET Core и сервисы для конкретного приложения.

20Создание	специальных
компонентов	MVC
и Razor Pages
В этой главе:
создание специальных тег-хелперов Razor;
использование компонентов представления для создания
сложных представлений Razor;
создание специального атрибута валидации
DataAnnotations;
замена фреймворка валидации DataAnnotations
альтернативым вариантом.
В предыдущей главе вы узнали, как настроить и расширить некоторые
основные системы в  ASP .NET Core: конфигурацию, внедрение зависи-
мостей и  конвейер промежуточного ПО. Эти компоненты составляют
основу всех приложений ASP .NET Core. В  данной главе мы сосредото-
чимся на Razor Pages и контроллерах MVC/API. Вы узнаете, как создавать
спе циальные компоненты, которые работают с представлениями Razor,
и компоненты, которые работают с фреймворком валидации, используе-
мым как Razor Pages, так и контроллерами API.
Мы начнем с рассмотрения тег-хелперов. В разделе 20.1 я покажу вам,
как создать два разных тег-хелпера: один, который генерирует HTML для
описания текущей машины, и второй, который позволяет писать инст -
рукции if в шаблонах Razor без использования C#. Все это предоставит

746 Глава 20 Создание специальных компонентов MVC и Razor Pages
вам сведения, необходимые для создания собственных тег-хелперов
в ваших приложениях, если возникнет такая необходимость.
В разделе 20.2 вы узнаете о  новой концепции Razor: компонентах
представления. Компоненты представления немного похожи на частич-
ные представления, но могут содержать бизнес-логику и доступ к базе
данных. Например, на сайте для онлайн-торговли у вас может быть кор-
зина покупок, динамически заполняемое меню и виджет входа – и все
это на одной странице. Каждый из этих разделов не зависит от содер-
жимого главной страницы и имеет свою логику и потребности в доступе
к данным. В приложении ASP .NET Core, использующем Razor Pages, каж -
дый из них реализуется в виде компонента представления.
В разделе 20.3 я покажу, как создать специальный атрибут валидации.
Как было показано в главе 6, валидация является важной обязанностью
обработчиков страниц Razor и методов действий, а атрибуты DataAnnota-
tions обеспечивают ясный декларативный способ сделать это. Ранее мы
рассматривали только встроенные атрибуты, но часто вы будете сталки-
ваться с тем, что вам нужно добавить атрибуты, адаптированные к пред-
метной области вашего приложения. В разделе 20.3 вы увидите, как соз-
дать простой атрибут валидации и  расширить его для использования
сервисов, зарегистрированных в контейнере внедрения зависимостей.
В этой книге я уже упоминал, что при желании можно легко заменить
основные части фреймворка ASP .NET Core. В  разделе 20.4 вы сделаете
это, заменив встроенный фреймворк валидации на основе атрибутов
популярной альтернативой FluentValidation. Эта библиотека с открытым
исходным кодом позволяет отделить модели привязки от правил про-
верки, что упрощает создание определенной логики валидации. Мно-
гие предпочитают данный подход разделения проблем декларативному
подходу с использованием DataAnnotations.
Когда вы создаете страницы с  по мощью Razor Pages, одной из луч-
ших функций повышения производительности являются тег-хелперы,
и в следующем разделе вы увидите, как создать собственные тег-хелперы.
20.1 Создание специального тег-хелпера Razor
В этом разделе вы узнаете, как создавать собственные тег-хелперы, по-
зволяющие настраивать вывод HTML. Вы узнаете, как создавать тег-
хелперы, которые добавляют новые элементы в разметку HTML, а также
тег-хелперы, которые можно использовать для удаления или настройки
существующей разметки. Вы также увидите, как ваши тег-хелперы ин-
тег рируются с инструментами интегрированной среды разработки, что-
бы предоставить богатые возможности IntelliSense таким же образом,
что и встроенные тег-хелперы.
На мой взгляд, тег-хелперы  – одно из лучших дополнений к  языку
шаблонов Razor в ASP .NET Core. Они позволяют писать шаблоны Razor,
которые легче читать, поскольку требуют меньше переключения между

747 Создание специального тег-хелпера Razor
C# и HTML, и они дополняют ваши HTML-теги, а не заменяют их (в отли-
чие от HTML-хелперов, широко использовавшихся в предыдущей версии
# ASP .NET).
ASP .NET Core обладает широким спектром тег-хелперов (см. главу 8),
которые удовлетворят многие из ваших повседневных требований, осо-
бенно когда речь идет о создании форм. Например, можно использовать
тег-хелпер ввода, добавив атрибут asp-for в тег <input> и передав ссылку
на свойство PageModel, в данном случае Input.Email:
<input asp-for="Input.Email" />
Тег-хелпер активируется наличием атрибута и получает возможность
дополнить тег <input> при отрисовке в HTML. Тег-хелпер использует имя
свойства, чтобы задать имя тега <input> и  свойства идентификатора,
значение модели, чтобы задать свойство value и  наличие таких атри-
бутов, как [Required] или [EmailAddress], чтобы добавить атрибуты для
валидации:
<input type="email" id="Input_Email" name="Input.Email"
value="test@example.com" data-val="true"
data-val-email="The Email Address field is not a valid e-mail address."
data-val-required="The Email Address field is required."
/>
Тег-хелперы помогают уменьшить дублирование кода или могут
упрос  тить распространенные шаблоны. В  этом разделе я  покажу, как
создать собственные тег-хелперы.
В разделе 20.1.1 вы создадите тег-хелпер системной информации, ко-
торый выводит сведения об имени и операционной системе сервера, на
котором работает ваше приложение. В разделе 20.1.2 вы создадите тег-
хелпер, который можно использовать для условного отображения или
скрытия элемента на основе логического свойства C#. В разделе 20.1.3 вы
создадите тег-хелпер, который считывает содержимое Razor, записанное
внутри тег-хелпера, и преобразовывает его.
20.1.1 Вывод информации об окружении
с помощью специального тег-хелпера
Распространенная проблема, с которой вы можете столкнуться, когда на-
чинаете запускать свои веб-приложения в промышленном окружении,
особенно если вы используете группу серверов, – это определить, на ка-
ком компьютере отображается страница, которую вы просматриваете
в данный момент. Точно так же при частом развертывании может быть
полезно знать, какая версия приложения работает. При разработке и тес -
тировании мне иногда нравится добавлять небольшой «информацион-
ный дамп» в нижней части своих макетов, чтобы можно было с легко-
стью определить, какой сервер сгенерировал текущую страницу, в каком
окружении работает приложение и т. д.

748 Глава 20 Создание специальных компонентов MVC и Razor Pages
В этом разделе я покажу вам, как создать специальный тег-хелпер для
вывода системной информации в свой макет. Вы сможете переключать
отображаемую информацию, но по умолчанию будет отображаться имя
компьютера и  операционная система, на которой запущено приложе-
ние, как показано на рис. 20.1.
SystemInfoTagHelper отображает
информацию о сервере, на котором
выполняется приложение
Рис. 20.1 SystemInfoTagHelper отображает имя компьютера и операционную
систему, на которой работает приложение. Это может быть полезно, чтобы
определить, какой экземпляр вашего приложения обработал запрос, если вы
работаете с группой серверов
Вы можете вызвать этот тег-хелпер из Razor, создав элемент <system-
info> в своем шаблоне:
<footer>
<system-info></system-info>
</footer>
СОВЕТ  Вероятно, вы не захотите раскрывать такую информацию
в  промышленном окружении, поэтому вы также можете заклю-
чить ее в тег-хелпер <environment>, как было показано в главе 8.
Самый простой способ создать специальный тег-хелпер – наследовать
от базового класса TagHelper и переопределить функцию Process() или
ProcessAsync(), которая описывает, как класс должен отображать себя.
В следующем листинге показан полный тег-хелпер, SystemInfoTagHelper,
который отображает системную информацию в тег <div>. Вы можете лег -
ко расширить этот класс, если хотите отобразить дополнительные поля
или добавить дополнительные параметры.
Листинг 20.1  SystemInfoTagHelper для отрисовки системной
информации в представление
public class SystemInfoTagHelper : TagHelper
{
private readonly HtmlEncoder _htmlEncoder;
public SystemInfoTagHelper(HtmlEncoder htmlEncoder)
{
_htmlEncoder = htmlEncoder;Наследует
от базового
класса
TagHelper.При записи HTML-содержимого
на страницу необходим
HtmlEncoder.

749 Создание специального тег-хелпера Razor
}
[HtmlAttributeName("add-machine")]
public bool IncludeMachine { get; set; } = true;
[HtmlAttributeName("add-os")]
public bool IncludeOS { get; set; } = true;
public override void Process(
TagHelperContext context, TagHelperOutput output)
{
output.TagName = "div";
output.TagMode = TagMode.StartTagAndEndTag;
var sb = new StringBuilder();
if (IncludeMachine)
{
sb.Append(" <strong>Machine</strong> ");
sb.Append(_htmlEncoder.Encode(Environment.MachineName));
}
if (IncludeOS)
{
sb.Append(" <strong>OS</strong> ");
sb.Append(
_htmlEncoder.Encode(RuntimeInformation.OSDescription));
}
output.Content.SetHtmlContent(sb.ToString());
}
}
В этом примере много нового кода, поэтому мы будем работать над
ним построчно. Вначале имя класса тег-хелпера определяет имя элемен-
та, который вы должны создать в  своем шаблоне Razor. У  него удален
суффикс и  используется дефис. Поскольку этот тег-хелпер называется
SystemInfoTagHelper, вы должны создать элемент <system-info>.
СОВЕТ  Если вы хотите изменить имя элемента, например на
<env-info>, но хотите сохранить то же имя класса, то можно при-
менить атрибут [HtmlTargetElement] с желаемым именем, напри-
мер [HtmlTargetElement("Env-Info")]. HTML-теги не чувстви-
тельны к регистру, поэтому можно использовать "Env-Info" или
"env-info".
Внедрите HtmlEncoder в свой тег-хелпер, чтобы иметь возможность ко-
дировать в HTML любые данные, которые вы пишете на страницу. Как
было показано в главе 18, вы всегда должны кодировать в HTML данные,
которые пишете на страницу, чтобы избежать XSS-уязвимостей (и обес -
печить правильное отображение данных).
Вы определили два свойства в тег-хелпере: IncludeMachine и IncludeOS,
которые вы будете использовать, чтобы управлять, какие данные будут
записываться на страницу. Они декорированы соответствующим атри-Декорирование свойств
с помощью атрибута
HtmlAttributeName позволяет
задавать их значения из разметки
Razor.
Основная функция,
вызываемая при отрисовке
элемента.
Заменяет элемент
<systeminfo> на
элемент <div>.Отображает как начальный,
так и конечный тег <div> </div>.
При необходимости
добавляет элемент
<strong> и имя
компьютера
в кодировке HTML.
При необходимости
добавляет элемент
<strong> и имя ОС
в кодировке HTML.
Задает внутреннее содержимое тега <div>, используя значение
в кодировке HTML, хранящееся в построителе строк.

750 Глава 20 Создание специальных компонентов MVC и Razor Pages
бутом [HtmlAttributeName], что позволяет задавать свойства из шаблона
Razor. В Visual Studio вы даже получаете IntelliSense и проверку типов
для этих значений, как показано на рис. 20.2.
Рис. 20.2 В Visual Studio тег-хелперы выделены фиолетовым цветом, и вы получаете
IntelliSense для свойств, декорированных атрибутом [HtmlAttributeName]
Наконец, мы подошли к  методу Process(). Движок Razor вызывает
этот метод, чтобы выполнить тег-хелпер, когда он идентифицирует це-
левой элемент в  шаблоне представления. Метод Process() определяет
тип тега для отрисовки (<div>), нужно ли визуализировать начальный
и конечный теги (или самозакрывающийся тег – это зависит от типа тега,
который вы визуализируете) и HTML-содержимое тега <div>. Вы задаете
HTML-содержимое для отрисовки внутри тега, вызывая метод Content.
SetHtmlContent() в предоставленном экземпляре класса TagHelperOutput.
ВНИМАНИЕ!  Всегда кодируйте свой вывод в HTML перед записью
в тег с по мощью метода SetHtmlContent(). В качестве альтернати-
вы можно передать незакодированный ввод в метод SetContent(),
и вывод будет автоматически закодирован в HTML.
Прежде чем вы сможете использовать новый тег-хелпер в  шаблоне
Razor, необходимо зарегистрировать его. Это можно сделать в файле _
ViewImports.cshtml, используя директиву @addTagHelper и указав полное
имя тег-хелпера и сборки. Например:
@addTagHelper CustomTagHelpers.SystemInfoTagHelper, CustomTagHelpers
Кроме того, можно добавить все тег-хелперы из определенной сборки
с по мощью синтаксиса подстановочных знаков * и указав имя сборки:
@addTagHelper *, CustomTagHelpers
Создав и зарегистрировав собственный тег-хелпер, вы можете исполь-
зовать его в любом представлении Razor, частичном представлении или
макетах.
СОВЕТ  Если вы не видите автодополнение для своего тег-хелпера
в Visual Studio, а тег-хелпер не отображается полужирным шриф-
том, используемым Visual Studio, вероятно, вы неправильно заре-
гистрировали тег-хелперы в файле __ViewImports .cshtml, исполь-
зуя директиву @addTagHelper.

751 Создание специального тег-хелпера Razor
SystemInfoTagHelper  – это пример тег-хелпера, который генерирует
содержимое, но вы также можете использовать тег-хелперы для управ-
ления отрисовкой существующих элементов. В  следующем разделе вы
создадите простой тег-хелпер, который может контролировать, визуали-
зируется элемент или нет, на основе HTML-атрибута.
20.1.2 Создание специального тег-хелпера для условного
скрытия элементов
Если вы хотите контролировать, отображается ли элемент в шаблоне Ra-
zor на основе переменной C#, то обычно заключаете этот элемент в ин-
струкцию if:
@{
var showContent = true;
}
@if(showContent)
{
<p>The content to show</p>
}
Возврат к  подобным конструкциям C# может быть полезным, по-
скольку позволяет создавать любую разметку, которая вам нравится.
К сожалению, переключение между C# и HTML может быть утомитель-
ным, а также усложняет использование редакторов HTML, которые не
понимают синтаксис Razor.
В этом разделе вы создадите простой тег-хелпер, чтобы избежать по-
добной проблемы. Вы можете применить его к существующим элемен-
там, чтобы добиться того же результата, как было показано ранее, но без
необходимости возвращаться к C#:
@{
var showContent = true;
}
<p if="showContent">
The content to show
</p>
Вместо того чтобы создавать новый элемент, как вы это делали для Sys
temInfoTagHelper(<systeminfo>), вы создадите тег-хелпер, который при-
мените в  качестве атрибута к  существующим HTML-элементам. Этот
тег-хелпер делает одно: контролирует видимость элемента, к которому
прикреплен. Если значение, переданное в атрибуте if, истинно, то эле-
мент и его содержимое отображаются как обычно. Если переданное зна-
чение ложно, тег-хелпер удаляет элемент и его содержимое из шаблона.
Вот как это сделать.

752 Глава 20 Создание специальных компонентов MVC и Razor Pages
Листинг 20.2 Создание IfTagHelper для условной отрисовки элементов
[HtmlTargetElement(Attributes = "if")]
public class IfTagHelper : TagHelper
{
[HtmlAttributeName("if")]
public bool RenderContent { get; set; } = true;
public override void Process(
TagHelperContext context, TagHelperOutput output)
{
if(RenderContent == false)
{
output.TagName = null;
output.SuppressOutput();
}
}
public override int Order => int.MinValue;
}
Вместо отдельного элемента <if> движок Razor выполняет IfTagHelper
всякий раз, когда находит элемент с атрибутом if. Это можно применить
к любому HTML-элементу: <p>, <div>, <input> и т. д. Вы должны опреде-
лить логическое свойство, указав, следует ли отображать содержимое,
привязанное к значению в атрибуте if.
Здесь функция Process() намного проще. Если RenderContent имеет
значение false, она задает для TagHelperOutput.TagName значение null,
в результате чего элемент удаляется со страницы.
Вы также вызываете метод SuppressOutput(), который запрещает от -
рисовку содержимого внутри элемента с атрибутом. Если значение Ren-
derContent равно true, вы пропускаете эти шаги, и содержимое отобра-
жается как обычно.
Еще одно замечание – переопределенное свойство Order. Оно контро-
лирует порядок, в котором запускаются тег-хелперы, когда к элементу
применено несколько тег-хелперов. Задавая для Order значение int.
MinValue, вы гарантируете, что IfTagHelper будет запущен первым, уда-
ляя элемент, если это необходимо, до выполнения других тег-хелперов.
Как правило, нет смысла запускать другие тег-хелперы, если элемент все
равно будет удален со страницы.
ПРИМЕЧАНИЕ  Не забудьте зарегистрировать свои тег-хелперы
в файле _ViewImports.cshtml с директивой @addTagHelper.
С помощью простого HTML-атрибута теперь можно условно отобра-
жать элементы в шаблонах Razor без необходимости возвращаться к C#.
Этот тег-хелпер может показывать и скрывать содержимое, и ему не нуж -
но знать, что оно из себя представляет. В следующем разделе мы созда-
дим тег-хелпер, которому необходимо знать содержимое.Задавая значение для свойства Attributes,
вы гарантируете, что тег-хелпер
запускается атрибутом if.
Привязывает
значение
атрибута if
к свойству
RenderContent.Движок Razor вызывает
метод Process() для
выполнения тег-хелпера.
Если свойство
RenderContent
имеет значение
false, удаляет
элемент.Задает для элемента, где находится тег-хелпер,
значение null, удаляя его со страницы.
Не отображает и не вычисляет внутреннее
содержимое элемента.
Гарантирует, что этот тег-хелпер запускается раньше
всех остальных, прикрепленных к элементу.

753 Создание специального тег-хелпера Razor
20.1.3 Создание тег-хелпера для преобразования Markdown
в HTML
Показанные до сих пор два тег-хелпера не зависят от содержимого, на-
писанного внутри тег-хелпера, но также может быть полезно создавать
тег-хелперы, которые проверяют, извлекают и изменяют это содержание.
В этом разделе вы увидите пример такого тег-хелпера, который преоб-
разует содержимое Markdown, записанное внутри него, в HTML1.
ОПРЕДЕЛЕНИЕ  Markdown  – широко используемый текстовый
язык разметки, который легко читается, и его также можно пре-
образовать в HTML. Этот распространенный формат используется
файлами README на GitHub, а я использую его, например, для на-
писания статей в блоге. Для получения более подробной информа-
ции о Markdown см. руководство на GitHub: https://guides.github.
com/features/mastering-markdown.
Мы будем применять популярную библиотеку Markdig ( https://github.
com/xoofx/markdig) для создания тег-хелпера Markdown. Эта библиотека
преобразует строку, содержащую Markdown, в  строку HTML. Установить
Markdig можно с по мощью Visual Studio, выполнив команду dotnet add pack-
age Markdig или добавив <PackageReference> в файл с расширением .csproj:
<PackageReference Include="Markdig" Version="0.22.0" />
Тег-хелпер Markdown, который мы вскоре создадим, можно исполь-
зовать, добавив элементы <markdown> на страницу Razor, как показано
в следующем листинге.
Листинг 20.3 Использование тег-хелпера Markdown на странице Razor
@page
@model IndexModel
<markdown>
## This is a markdown title
This is a markdown list:
* Item 1
* Item 2
<div if="showContent">
Content is shown when showContent is true
</div>
</markdown>
1 Библиотека с открытым исходным кодом WebAPIContrib.Core включает в себя
аналогичный тег-хелпер, а также другие полезные утилиты. Вы можете найти
ее в NuGet и GitHub по адресу https://github.com/WebApiContrib/W ebAPICon-
trib.Core.Т ег-хелпер Markdown добавляется
с помощью элемента <markdown>.
Заголовки можно создать в Markdown,
используя символ # для обозначения h1,
## для обозначения h2 и т. д.Markdown преобразует
простые списки
в HTML-элементы <ul>.
Содержимое Razor может быть вложено
в другие тег-хелперы.

754 Глава 20 Создание специальных компонентов MVC и Razor Pages
Тег-хелпер Markdown визуализирует содержимое с по мощью следую-
щих шагов.
1  Визуализирует любое содержимое Razor внутри тег-хелпера. Сюда
входит выполнение любых вложенных тег-хелперов и код C# внутри
тег-хелперов. В листинге 20.3, например, используется IfTagHelper.
2  Преобразовывает полученную строку в HTML с по мощью библио-
теки Markdig.
3  Заменяет содержимое визуализированным HTML и  удаляет эле-
мент <markdown>.
В следующем листинге показан простой подход к  реализации тег-
хелпера Markdown с  использованием Markdig. Markdig поддерживает
множество дополнительных расширений и функций, которые вы можете
активировать, но общий шаблон тег-хелпера будет таким же.
Листинг 20.4  Реализация класса MarkdownTagHelper
с использованием Markdig
public class MarkdownTagHelper: TagHelper
{
public override async Task ProcessAsync(
TagHelperContext context, TagHelperOutput output)
{
TagHelperContent markdownRazorContent = await
output.GetChildContentAsync(NullHtmlEncoder.Default);
string markdown =
markdownRazorContent.GetContent(NullHtmlEncoder.Default);
string html = Markdig.Markdown.ToHtml(markdown);
output.Content.SetHtmlContent(html);
output.TagName = null;
}
}
При отрисовке в HTML содержимое Markdown из листинга 20.3 (когда
значение переменной showContent равно true) становится таким:
<h2>This is a markdown title</h2>
<p>This is a markdown list:</p>
<ul>
<li>Item 1</li>
<li>Item 2</li>
</ul>
<div>
Content is shown when showContent is true
</div>
ПРИМЕЧАНИЕ  В  листинге 20.4 мы реализовали метод Proces-
sAsync() вместо метода Process(), потому что вызываем асин-
хронный метод GetChildContentAsync(). Вы должны вызывать Т ег-хелпер Markdown будет
использовать элемент <markdown>.
Получаем
содержимое
элемента
<markdown>.
Отрисовка
содержимого
Razor в строку.
Преобразовываем
строку Markdown в HTML
с помощью Markdig.
Пишем содержимое HTML в вывод.
Удаляем элемент <markdown> из содержимого.

755 Компоненты представления: добавление логики в частичные представления
асинхронные методы только из других асинхронных методов;
в противном случае вы можете получить такие проблемы, как не-
хватка потоков. Дополнительные сведения см. в  документе Mi-
crosoft «Лучшие практики по производительности ASP .NET Core»:
http://mng.bz/KM7X.
Тег-хелперы из этого раздела представляют собой небольшую выбор-
ку возможных путей, которые вы могли бы изучить, но они охватывают
две обширные категории: тег-хелперы для отрисовки нового содержи-
мого и тег-хелперы для управления отрисовкой других элементов1.
Тег-хелперы могут быть полезны для предоставления небольших час -
тей изолированной, многократно используемой функциональности,
подобной этой, но они не предназначены для предоставления крупных
разделов приложения или для выполнения вызовов сервисов бизнес-ло-
гики. Вместо этого нужно использовать компоненты представления, как
будет показано в следующем разделе.
20.2 Компоненты представления: добавление
логики в частичные представления
В этом разделе вы познакомитесь с  компонентами	 представления. Ком -
поненты представления работают независимо от основной страницы
Razor и могут использоваться для инкапсуляции сложной бизнес-логи-
ки. Вы можете использовать компоненты представления, чтобы ваша
основная страница Razor была сосредоточена на одной задаче, отрисов-
ке основного содержимого, вместо того чтобы нести ответственность за
другие разделы страницы.
Если представить себе типичный веб-сайт, то можно заметить, что
час то у  него имеется несколько независимых динамических разделов
в дополнение к  основному содержимому. Рассмотрим, например, сайт
Stack Overflow, показанный на рис. 20.3. Помимо основной части стра-
ницы, содержащей вопросы и ответы, здесь есть раздел, показывающий
пользователя, выполнившего вход, панель для статей в блогах и связан-
ных с этим материалов, а также раздел для вакансий.
Каждый из этих разделов фактически не зависит от основного содер-
жимого. Каждый раздел содержит бизнес-логику (решая, какие статьи
или рекламные сообщения нужно показывать), доступ к базе данных (за-
грузка деталей поста) и логику отрисовки для отображения данных. В раз-
деле 7 вы видели, что можно использовать макеты и частичные представ-
ления, чтобы разделить отрисовку шаблона представления на похожие
разделы, но частичные представления не подходят для этого примера.
1 Дополнительные сведения и примеры см. в документации Microsoft: https://
docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/authoring?view
=aspnetcore-5.0.

756 Глава 20 Создание специальных компонентов MVC и Razor Pages
Сведения
о текущем
пользователе
Статьи в блогах
и связанные
с ними
материалы
Предложения
о работе
Основное содержимое
Рис. 20.3 Веб-сайт Stack Overflow имеет несколько разделов, которые не зависят
от основного содержимого, но содержат бизнес-логику и сложную логику отрисовки.
Каждый из них может отображаться в виде компонента представления в ASP.NET Core
Частичные представления позволяют инкапсулировать логику отри-
совки	представления, но не бизнес-логику, независимую от содержимого
главной страницы.
Компоненты представления предоставляют эту функциональность,
инкапсулируя и  бизнес-логику, и  логику отрисовки для отображения
небольшого раздела страницы. Вы можете использовать внедрение за-
висимостей для предоставления доступа к контексту базы данных и мо-
жете тестировать компоненты представления независимо от представ-
ления, которое они генерируют, во многом подобно контроллерам MVC
и API. Рассматривайте их как своего рода мини-контроллеры MVC или
мини-страницы Razor Pages. Они вызываются непосредственно из пред-
ставления Razor, а не в ответ на HTTP-запрос.
СОВЕТ  Компоненты просмотра сопоставимы с  дочерними	 дей-
ствиями из предыдущей версии ASP .NET, поскольку они предо-
ставляют аналогичную функциональность. В ASP .NET Core дочер-
них действий нет.
Просмотр компонентов по сравнению с Razor Components и Blazor
В этой книге основное внимание уделено приложениям с отрисовкой на сто-
роне сервера с использованием страниц Razor, и приложениям API, исполь-
зующим контроллеры веб-API. .NET Core 3.0 представил совершенно новый
подход к созданию приложений ASP.NET Core: Blazor. В этой книге он не рас -
сматривается, поэтому я рекомендую прочитать книгу «Blazor в действии»
Криса Сэйнти (Manning, 2021).

757 Компоненты представления: добавление логики в частичные представления
В Blazor есть две модели программирования, на стороне клиента и на сторо-
не сервера, – и там, и там используются компоненты Blazor (которые, как ни
странно, официально называются компонентами Razor). Компоненты Blazor
имеют много параллелей с компонентами представления, но находятся они
в совершенно разных мирах. Компоненты Blazor могут легко взаимодейство-
вать друг с другом, но их нельзя использовать с тег-хелперами или компо-
нентами представления, и их сложно комбинировать с формами Razor Page.
Тем не менее если вам нужен «островок» богатой интерактивности на сто-
роне клиента на одной странице Razor, то можно встроить компонент Blazor
внутрь страницы Razor, как показано в разделе «Отрисовка компонентов на
странице или в представлении с по мощью тег-хелпера компонента»: http://
mng.bz/PPen .  Вы также можете использовать компоненты Blazor как способ
заменить вызовы AJAX на своих страницах Razor, как показано в записи мое-
го блога: http://mng.bz/9MJj.
Если вам не нужна интерактивность Blazor на стороне клиента, компоненты
представления по-прежнему являются лучшим вариантом для изолированных
разделов в Razor Pages. Они четко взаимодействуют с вашими страницами,
не имеют дополнительных операционных издержек и используют знакомые
концепции, такие как макеты, частичные представления и тег-хелперы. Для
получения дополнительной информации о том, почему следует продолжать
использовать компоненты представления, см. запись в моем блоге «Не заме-
няйте компоненты представления на компоненты Razor»: http://mng.bz/1rKq.
В этом разделе вы узнаете, как создать специальный компонент пред-
ставления для приложения с рецептами, которое вы создали в предыду -
щих главах, как показано на рис. 20.4. Если текущий пользователь вы-
полнил вход, компонент представления отображает панель со списком
ссылок на недавно созданные рецепты пользователя. Для пользовате-
лей, не прошедших аутентификацию, компонент представления отобра-
жает ссылки для входа и регистрации.
Этот компонент является отличным кандидатом на роль компонента
представления, поскольку он содержит доступ к базе данных и бизнес-
логику (выбирая, какие рецепты отображать), а также логику отрисовки
(решая, как должна отображаться панель).
СОВЕТ  Используйте частичные представления, если хотите ин-
капсулировать отрисовку определенной модели представления
или ее части. Если у  вас есть логика отрисовки, требующая биз-
нес-логики или доступа к базе данных, или если раздел логически
отличается от содержимого главной страницы, рассмотрите воз-
можность использования компонента представления.
Компоненты представления вызываются непосредственно из пред-
ставлений и  макетов Razor с  использованием синтаксиса в  стиле тег-
хелпера с префиксом vc:
<vc:my-recipes number-of-recipes="3">
</vc:my-recipes>

758 Глава 20 Создание специальных компонентов MVC и Razor Pages
Если пользователь выполнил вход,
компонент представления отображает
список рецептов, созданных текущим
пользователем, загруженных из базы
данных
Если пользователь не выполнил вход,
компонент представления отображает
ссылки на страницы регистрации
и входа
Рис. 20.4 Компонент представления отображает различное содержимое
в зависимости от текущего пользователя, выполнившего вход. Он включает в себя
как бизнес-логику (определяя, какие рецепты загружать из базы данных), так
и логику отрисовки (указывающую, как отображать данные)
Специальные компоненты представления обычно наследуют от базо-
вого класса ViewComponent и реализуют метод InvokeAsync(), как показа-
но в листинге 20.5. Наследуя от этого базового класса, вы обеспечиваете
доступ к полезным вспомогательным методам почти так же, как если бы
вы наследовали от класса ControllerBase в случае с контроллерами API.
В отличие от контроллеров API, параметры, передаваемые в  InvokeAsync,
не зависят от привязки модели. Вместо этого вы передаете параметры
компоненту представления, используя свойства элемента тег-хелпера
в представлении Razor.
Листинг 20.5  Специальный компонент представления
для отображения рецептов текущего пользователя
public class MyRecipesViewComponent : ViewComponent
{
private readonly RecipeService _recipeService;
private readonly UserManager<ApplicationUser> _userManager;
public MyRecipesViewComponent(RecipeService recipeService,
UserManager<ApplicationUser> userManager)
{
_recipeService = recipeService;
_userManager = userManager;
}Наследование от базового класса ViewComponent
предоставляет полезные методы, такие как View().
Вы можете
использовать
внедрение
зависимостей
в компоненте
представления.

759 Компоненты представления: добавление логики в частичные представления
public async Task<IViewComponentResult> InvokeAsync(
int numberOfRecipes)
{
if(!User.Identity.IsAuthenticated)
{
return View("Unauthenticated");
}
var userId = _userManager.GetUserId(HttpContext.User);
var recipes = await _recipeService.GetRecipesForUser(
userId, numberOfRecipes);
return View(recipes);
}
}
Данный компонент представления обрабатывает всю логику, необхо-
димую для отрисовки списка рецептов, когда пользователь выполнил
вход, или другого представления, если пользователь не аутентифициро-
ван. Имя компонента представления происходит от имени класса, как
и  в  случае тег-хелперов. В  качестве альтернативы можно применить
к классу атрибут [ViewComponent] и задать совершенно другое имя.
Метод InvokeAsync должен вернуть Task<IViewComponentResult>. Это
похоже на то, как вы возвращаете IActionResult из метода действия или
обработчика страницы, но более ограничено; компоненты представ-
ления	должны визуализировать какое-то содержимое, поэтому нельзя
возвращать коды состояния или переадресацию. Обычно для отрисов-
ки частичного шаблона представления используется вспомогательный
метод View() (как в предыдущем листинге), хотя можно также возвра-
щать строку напрямую с по мощью вспомогательного метода Content(),
который кодирует содержимое в HTML и напрямую отображает его на
странице.
Методу InvokeAsync можно передавать любое количество параметров.
В  именах параметров (в  данном случае numberOfRecipes) используется
дефис, и они отображаются в виде свойства в тег-хелпере компонента
представления (<number-of-recipes>). Вы можете предоставить эти па-
раметры, когда вызываете компонент представления из представления,
и получите поддержку IntelliSense, как показано на рис. 20.5.
Рис. 20.5 Visual Studio обеспечивает поддержку IntelliSense для параметров метода
компонента представления InvokeAsync. Имя параметра, в данном случае numberOfRecipes,
теперь пишется с использованием дефисов, чтобы его можно было применить в качестве
атрибута в тег-хелпереInvokeAsync отображает компонент
представления. Он должен вернуть
Task<IViewComponentResult>.Вы можете
передавать
параметры
компоненту из
представления.Вызов метода View() отобразит частичное
представление с указанным именем.
Вы можете использовать внешние
асинхронные сервисы, что позволяет
инкапсулировать логику в вашей
предметной области.Вы можете передать модель просмотра
частичному представлению. Файл Default.cshtml
используется по умолчанию.

760 Глава 20 Создание специальных компонентов MVC и Razor Pages
Компоненты представления имеют доступ к текущему запросу и  Http-
Context. В листинге 20.5 видно, что мы проверяем, поступил ли текущий
запрос от пользователя, прошедшего аутентификацию. Также видно, что
мы использовали некую условную логику: если пользователь не прошел
аутентификацию, то отображается шаблон Razor «Не аутентифициро-
ван»; если он прошел аутентификацию, то отображается шаблон Razor
по умолчанию, и мы передаем модели представления, загруженные из
базы данных.
ПРИМЕЧАНИЕ  Если вы не укажете конкретный шаблон пред-
ставления Razor для использования в функции View(), компоненты
представления будут использовать имя шаблона «Default.cshtml».
Частичные представления для компонентов представления работа-
ют аналогично другим частичным представлениям Razor, о которых вы
узна ли в главе 7, но хранятся отдельно. Нужно создавать частичные пред-
ставления для компонентов представления в одном из следующих мест:
Views/Shared/Components/ComponentName/TemplateName;
Pages/Shared/Components/ComponentName/TemplateName.
Оба места подходят, поэтому для приложений Razor Pages я обычно ис -
пользую папку Pages/. Для компонента представления из листинга 20.5,
например, вы должны создать свои шаблоны представления:
Pages/Shared/Components/MyRecipes/Default.cshtml;
Pages/Shared/Components/MyRecipes/Unauthenticated.cshtm.
Это было краткое введение в компоненты представления, но оно долж -
но вам помочь. Компоненты представления – простой способ встроить
в систему изолированную сложную логику в свои макеты Razor. Однако
при этом помните о следующих предостережениях:
классы компонентов представления должны быть открытыми, не-
вложенными и неабстрактными;
хотя они и  похожи на контроллеры MVC, нельзя использовать
фильт ры с компонентами представления;
вы можете использовать макеты в представлениях своих компонен-
тов представления для извлечения логики отрисовки, общей для
определенного компонента. Этот макет может содержать @sections,
как было показано в главе 7, но данные секции не зависят от макета
основного представления Razor;
компоненты представления изолированы от страницы Razor, на
которой они отображаются, поэтому нельзя, например, определить
@section в макете страницы Razor, а затем добавить это содержимое
из компонента представления; контексты полностью разделены;
при использовании синтаксиса тег-хелпера <vc: my-recipes> для
вызова компонента представления нужно импортировать его в ка-
честве специального тег-хелпера, как было показано в разделе 20.1;
вместо использования синтаксиса тег-хелпера можно вызвать ком-
понент представления из представления напрямую с  по мощью

761 Создание специального атрибута валидации
компонента IViewComponentHelper Component, хотя я не рекомендую
использовать этот синтаксис. Например:
@await Component.InvokeAsync("MyRecipes", new { numberOfRecipes = 3 })
Мы рассмотрели тег-хелперы и компоненты представления, которые
являются функциями Razor в ASP .NET Core. В следующем разделе вы уз-
наете о другой, но близкой теме: как создать собственный атрибут Data-
Annotations. Если вы использовали предыдущие версии ASP .NET, то это
будет вам знакомо, но в ASP .NET Core есть несколько хитростей, которые
могут быть вам полезны.
20.3 Создание специального атрибута валидации
В этом разделе вы узнаете, как создать специальный атрибут валидации
DataAnnotations, указывающий конкретные значения, которые может
принимать строковое свойство. Затем вы узнаете, как расширить эту
функциональность, чтобы сделать ее более универсальной, делегировав
ее отдельному сервису, который настроен в вашем контроллере внедре-
ния зависимостей. Это позволит вам создавать собственные проверки
для конкретных предметных областей в своих приложениях.
Мы рассматривали привязку модели в главе 6, где вы узнали, как ис -
пользовать встроенные  атрибуты DataAnnotations в своих моделях при-
вязки для проверки ввода данных пользователем. Они предоставляют
несколько встроенных проверок:
[Required] – свойство является обязательным и должно быть предо-
ставлено;
[StringLength(min, max)] – длина строкового значения должна на-
ходиться в пределах между min и max;
[EmailAddress] – значение должно иметь допустимый формат адре-
са электронной почты.
Но что, если эти атрибуты не отвечают вашим требованиям? Рассмот -
рим следующий листинг, где показана модель привязки из конвертера
валют. Модель содержит три свойства: валюта, из которой нужно конвер-
тировать, валюта, в которую нужно конвертировать, и количество.
Листинг 20.6 Начальная модель привязки конвертера валют
public class CurrencyConverterModel
{
[Required]
[StringLength(3, MinimumLength = 3)]
public string CurrencyFrom { get; set; }
[Required]
[StringLength(3, MinimumLength = 3)]
public string CurrencyTo { get; set; }
[Required]Все свойства
обязательны.Строки должны содержать
ровно 3 символа.

762 Глава 20 Создание специальных компонентов MVC и Razor Pages
[Range(1, 1000)]
public decimal Quantity { get; set; }
}
Эта модель проходит базовую валидацию, но во время тестирования
обнаруживается проблема: пользователи могут ввести любую трехбук -
венную строку для свойств CurrencyFrom и  CurrencyTo. Пользователи
должны иметь возможность выбирать только действительный код валю-
ты, например "USD" или "GBP", но какой-нибудь злоумышленник может
легко отправить "XXX" или "£$%".
Предполагая, что вы поддерживаете ограниченный набор валют, на-
пример фунт стерлингов, доллар США, евро и канадский доллар, можно
выполнить проверку несколькими способами. Один из способов – про-
верить значения CurrencyFrom и  CurrencyTo в методе обработчика стра-
ницы Razor после того, как валидация привязки модели и атрибутов уже
произошли.
Еще один способ – использовать атрибут [RegularExpresssion] для по-
иска разрешенных строк. Подход, который я буду использовать здесь, за-
ключается в создании специального атрибута ValidationAttribute. Цель
состоит в том, чтобы иметь в своем распоряжении специальный атрибут
проверки, который можно применить к свойствам CurrencyFrom и  Cur-
rencyTo, чтобы ограничить диапазон допустимых значений. Это выгля-
дит примерно так, как показано в следующем примере.
Листинг 20.7  Применение специальных атрибутов валидации
к модели привязки
public class CurrencyConverterModel
{
[Required]
[StringLength(3, MinimumLength = 3)]
[CurrencyCode("GBP", "USD", "CAD", "EUR")]
public string CurrencyFrom { get; set; }
[Required]
[StringLength(3, MinimumLength = 3)]
[CurrencyCode("GBP", "USD", "CAD", "EUR")]
public string CurrencyTo { get; set; }
[Required]
[Range(1, 1000)]
public decimal Quantity { get; set; }
}
Создать специальный атрибут валидации просто; можно начать с ба-
зового класса ValidationAttribute и переопределить только один метод.
В следующем листинге показано, как реализовать класс CurrencyCodeAt-
tribute, чтобы гарантировать, что предоставленные коды валют соот -
ветствуют ожидаемым значениям.Количество может составлять от 1 до 1000.
CurrencyCodeAttribute проверяет,
есть ли у свойства одно
из указанных значений.

763 Создание специального атрибута валидации
Листинг 20.8 Специальный атрибут валидации для кодов валют
public class CurrencyCodeAttribute : ValidationAttribute
{
private readonly string[] _allowedCodes;
public CurrencyCodeAttribute(params string[] allowedCodes)
{
_allowedCodes = allowedCodes;
}
protected override ValidationResult IsValid(
object value, ValidationContext context)
{
var code = value as string;
if(code == null || !_allowedCodes.Contains(code))
{
return new ValidationResult("Not a valid currency code");
}
return ValidationResult.Success;
}
}
Валидация выполняется в конвейере фильтров действий после при-
вязки модели до выполнения действия или обработчика Razor Page.
Фреймворк валидации вызывает метод IsValid() для каждого экземп-
ляра ValidationAttribute проверяемого свойства модели и  передает
value (значение проверяемого свойства) и  ValidationContext к каждому
атрибуту по очереди. Объект контекста содержит детали, которые можно
использовать для валидации свойства.
Особо следует отметить свойство ObjectInstance. Его можно использо-
вать для доступа к проверяемой модели верхнего уровня при проверке
вложенного свойства. Например, если проверяется свойство Currency-
From класса CurrencyConverterModel, можно получить доступ к  объекту
верхнего уровня из ValidationAttribute следующим образом:
var model = validationContext.ObjectInstance as CurrencyConverterModel;
Это может быть полезно, если допустимость свойства зависит от зна-
чения другого свойства модели. Например, вам может потребоваться
правило проверки, в  котором указано, что GBP является допустимым
значением для CurrencyTo, за	исключением случаев, когда CurrencyFrom
также является GBP . ObjectInstance упрощает подобные проверки-срав-
нения.Наследует от ValidationAttribute, чтобы гарантировать,
что ваш атрибут используется во время валидации.
Атрибут принимает
массив разрешенных
кодов валют.
В метод IsValid передается значение
для валидации и объект контекста.
Если предоставленное значение не является строкой, имеет
значение null или недопустимый код, возвращается ошибка.В противном случае возвращаем
успешный результат.

764 Глава 20 Создание специальных компонентов MVC и Razor Pages
ПРИМЕЧАНИЕ  Хотя использование ObjectInstance упрощает
создание подобных сравнений на уровне модели, это снижает пе-
реносимость атрибута валидации. В  этом случае вы сможете ис -
пользовать только атрибут в приложении, которое определяет Cur-
rencyConverterModel.
В методе IsValid можно привести value к требуемому типу данных
(в данном случае это строка) и  проверить список разрешенных кодов.
Если данного кода нет в  списке, атрибут возвращает ValidationResult
с сообщением об ошибке, указывающим на то, что возникла проблема.
Если код разрешен, возвращается ValidationResult.Success, и проверка
успешно завершается.
Тестирование нашего атрибута на рис. 20.6 показывает, что если Cur-
rencyTo имеет недопустимое значение (£$%), то валидация свойства за-
канчивается неудачей, и в  ModelState добавляется ошибка. Вы могли бы
немного подправить этот атрибут, чтобы можно было задать собствен-
ное сообщение, дабы разрешить пустые значения или отобразить имя
недействительного свойства, но все важные функции здесь есть.
Специальный атрибут валидации
идентифицирует недопустимое
значение и добавляет ошибку
в ModelState Пользователь вводит неверный код валюты
Рис. 20.6 Окно Watch в Visual Studio, где показан результат проверки
с использованием ValidationAttribute. Пользователь указал недопустимое
значение currencyTo, £$%. Следовательно, ModelState недействителен и содержит
единственную ошибку с сообщением «Недействительный код валюты»
Основная функция, отсутствующая в этом специальном атрибуте, – ва-
лидация на стороне клиента. Вы видели, что атрибут хорошо работает на
стороне сервера, но если пользователь ввел недопустимое значение, он не
получит соответствующую информацию до тех пор, пока недопустимое
значение не будет отправлено на сервер. Это безопасно, и этого достаточ-
но для обеспечения безопасности и согласованности данных, но проверка
на стороне клиента может улучшить опыт взаимодействия с  пользова-
тельским интерфейсом, обеспечивая незамедлительную обратную связь.
Проверку на стороне клиента можно реализовать несколькими спо-
собами, но в значительной мере она зависит от библиотек Java Script, ко-
торые вы используете для обеспечения функциональности. В настоящее
время при выполнении валидации на стороне клиента шаблоны Razor
ASP .NET Core полагаются на jQuery. См. раздел «Специальная валидация
на стороне клиента» документа Microsoft «Валидация модели в ASP .NET

765 Создание специального атрибута валидации
Core MVC и Razor Pages», где приводится пример создания адаптера ва-
лидации jQuery для атрибутов: http://mng.bz/Wd6g.
Еще одно усовершенствование для вашего атрибута валидации – за-
грузка списка валют из сервиса внедрения зависимостей, например
ICurrencyProvider. К сожалению, вы не можете использовать конструк -
тор внедрения зависимостей в  CurrencyCodeAttribute, поскольку в .NET
в конструктор атрибута можно передавать только постоянные значения.
В главе 13 обошли это ограничение для фильтров, используя атрибуты
[TypeFilter] или [ServiceFilter], но для ValidationAttribute такого ре-
шения нет.
Для атрибутов валидации нужно использовать паттерн Локатор	 сер-
висов. Как уже обсуждалось в главе 10, по возможности лучше избегать
применения этого антипаттерна, но, к сожалению, в данном случае это
необходимо. Вместо объявления явной зависимости через конструктор
нужно напрямую запросить у контейнера внедрения зависимостей эк -
земпляр требуемого сервиса.
В листинге 20.9 показано, как переписать листинг 20.8, чтобы загру -
зить допустимые валюты из экземпляра ICurrencyProvider, вместо того
чтобы жестко зашивать допустимые значения в  код в  конструкторе
атрибута. Атрибут вызывает метод GetService<T>() в  ValidationContext
для разрешения экземпляра ICurrencyProvider из контейнера внедре-
ния зависимостей. Обратите внимание, что ICurrencyProvider – это ги-
потетический сервис, которую необходимо зарегистрировать в  методе
ConfigureServices() приложения в файле Startup.cs.
Листинг 20.9  Использование паттерна Локатор сервисов
для доступа к сервисам
public class CurrencyCodeAttribute : ValidationAttribute
{
protected override ValidationResult IsValid(
object value, ValidationContext context)
{
var provider = context.GetService<ICurrencyProvider>();
var allowedCodes = provider.GetCurrencies();
var code = value as string;
if(code == null || !_allowedCodes.Contains(code))
{
return new ValidationResult("Not a valid currency code");
}
return ValidationResult.Success;
}
}
СОВЕТ  Обобщенный метод GetService<T> – это метод расшире-
ния, доступный в пространстве имен Microsoft.Extensions.Depen-
dencyInjection. В качестве альтернативы можно использовать ме-
тод GetService(Type type).Извлекает экземпляр
ICurrencyProvider прямо
из контейнера внедрения
зависимостей.
Получает коды валют
через поставщика.
Проверяет
свойство,
как и раньше.

766 Глава 20 Создание специальных компонентов MVC и Razor Pages
Система валидации на основе DataAnnotations, используемая по умол-
чанию, может быть удобна благодаря своему декларативному характеру,
но у нее есть компромиссы, как показала выше проблема внедрения за-
висимостей. К счастью, можно полностью заменить систему валидации,
используемую вашим приложением, как показано в следующем разделе.
20.4 Замена фреймворка валидации
на FluentValidation
В этом разделе вы узнаете, как заменить фреймворк проверки на осно-
ве DataAnnotations, который используется по умолчанию в ASP .NET Core.
Вы увидите аргументы в пользу этого и узнаете, как использовать сто-
роннюю альтернативу: FluentValidation. Этот проект с открытым исход-
ным кодом позволяет определять требования к валидации моделей от -
дельно от самих моделей. Такое разделение может упростить некоторые
типы проверки и гарантировать, что каждый класс в вашем приложении
имеет единственную ответственность.
Валидация – важная часть процесса привязки модели в ASP .NET Core.
До сих пор мы использовали атрибуты DataAnnotations, применяемые
к свойствам модели привязки, чтобы определить свои требования. В раз-
деле 20.3 мы даже создали специальный атрибут валидации.
По умолчанию ASP .NET Core настроен на использование этих атри-
бутов для управления проверочной частью привязки модели. Но ASP .
NET Core очень гибкий и позволяет при желании заменять целые части
фреймворка. Система валидации – одна из таких областей, которую мно-
гие предпочитают заменять.
FluentValidation (https://fluentvalidation.net/) – популярный альтерна-
тивный фреймворк валидации для ASP .NET Core. Это давно существую-
щая библиотека, корни которой уходят далеко в прошлое, еще до появ-
ления ASP .NET Core. С FluentValidation код валидации пишется отдельно
от кода модели привязки. Это дает ряд преимуществ:
вы не ограничены ограничениями атрибутов, такими как проблема
внедрения зависимостей, которую нам пришлось решать в листин-
ге 20.9;
намного проще создать правила проверки, которые применяются
к нескольким свойствам, например чтобы гарантировать, что свой-
ство EndDate содержит более позднее значение, чем свойство Start-
Date. Добиться этого с по мощью атрибутов DataAnnotations можно,
но сложно;
как правило, тестировать валидаторы FluentValidation проще, чем
атрибуты DataAnnotations;
валидация строго типизирована, по сравнению с атрибутами Data-
Annotations, где атрибуты можно применять бессмысленными спо-
собами, например применять атрибут [EmailAddress] к  свойству
типа int;

767 Замена фреймворка валидации на FluentValidation
отделение логики валидации от самой модели, возможно, лучше со-
ответствует принципу единственной ответственности1.
Последний момент часто приводится как причина не использовать
FluentValidation: FluentValidation отделяет модель привязки от правил
валидации. Некоторые рады принять ограничения DataAnnotations, что -
бы не разделять модель и правила валидации.
Прежде чем я покажу, как добавить FluentValidation в приложение, по-
смотрим, как выглядят валидаторы FluentValidation.
20.4.1 Сравнение FluentValidation и атрибутов
DataAnnotations
Чтобы лучше понять разницу между DataAnnotations и FluentValidation,
мы преобразуем модели привязки из раздела 20.3 для использования
Fluent-Validation. В следующем листинге показано, как будет выглядеть
модель привязки из листинга 20.7 при использовании FluentValidation.
С точки зрения структуры она идентична, но у нее нет атрибутов про-
верки.
Листинг 20.10  Начальная модель привязки конвертера валют
для использования с FluentValidation
public class CurrencyConverterModel
{
public string CurrencyFrom { get; set; }
public string CurrencyTo { get; set; }
public decimal Quantity { get; set; }
}
В FluentValidation правила валидации определяются в  отдельном
классе, на каждую модель по классу. Обычно они наследуют от базового
класса AbstractValidator<>, который предоставляет набор методов рас -
ширения для определения правил валидации.
В следующем листинге показан валидатор для CurrencyConverterMod-
el, который соответствует валидациям, добавленным с  использовани-
ем атрибутов в листинге 20.7. Вы создаете набор правил проверки для
свойства, вызывая метод RuleFor() и связывая вызовы методов, напри-
мер NotEmpty(), из него. Данный стиль объединения методов называется
«плавным» интерфейсом, отсюда и название.
Листинг 20.11  Валидатор FluentValidation для модели привязки
конвертера валют
public class CurrencyConverterModelValidator
: AbstractValidator<CurrencyConverterModel>
{
1 Принцип единственной ответственности – один из принципов SOLID: https://
en.wikipedia.org/wiki/SOLID .Валидатор наследует
от AbstractValidator.

768 Глава 20 Создание специальных компонентов MVC и Razor Pages
private readonly string[] _allowedValues
= new []{ "GBP", "USD", "CAD", "EUR" };
public InputValidator()
{
RuleFor(x => x.CurrencyFrom)
.NotEmpty()
.Length(3)
.Must(value => _allowedValues.Contains(value))
.WithMessage("Not a valid currency code");
RuleFor(x => x.CurrencyTo)
.NotEmpty()
.Length(3)
.Must(value => _allowedValues.Contains(value))
.WithMessage("Not a valid currency code");
RuleFor(x => x.Quantity)
.NotNull()
.InclusiveBetween(1, 1000);
}
}
Впервые увидев этот код, вы можете подумать, что он не отличается
компактностью по сравнению с листингом 20.7, но помните, что в лис -
тинге 20.7 использовался специальный атрибут валидации, [Currency-
Code]. Валидации в листинге 20.11 больше ничего не требуется  – логика,
реализованная атрибутом [CurrencyCode], находится прямо там, в  ва-
лидаторе, благодаря чему проще рассуждать о  поведении кода. Метод
Must() может использоваться для выполнения произвольно сложных
проверок без дополнительных уровней косвенности, необходимых для
специальных атрибутов DataAnnotations.
Кроме того, вы заметите, что можете определять только те правила ва-
лидации, которые имеют смысл для проверяемого свойства. Раньше ни-
что не мешало нам применить атрибут [CurrencyCode] к свойству Quan-
tity; с FluentValidation это просто невозможно.
Конечно, тот факт, что вы можете написать собственную логику [Cur-
rencyCode] в режиме реального времени, не обязательно означает, что
вы должны это делать. Если правило используется в нескольких частях
приложения, возможно, имеет смысл извлечь его во вспомогательный
класс. В следующем листинге показано, как извлечь логику кода валюты
в метод расширения, который может использоваться в нескольких вали-
даторах.
Листинг 20.12 Метод расширения для проверки валюты
public static class ValidationExtensions
{
public static IRuleBuilderOptions<T, string>
MustBeCurrencyCode<T>(
this IRuleBuilder<T, string> ruleBuilder)Определяет статический список
поддерживаемых кодов валют.
Вы определяете правила валидации
в конструкторе валидатора.
Метод RuleFor
используется для
добавления нового
правила валидации.
Синтаксис
лямбда-функции
позволяет
использовать
строгую типизацию.Существуют эквивалентные правила для общих
атрибутов валидации DataAnnotations.
Вы можете легко добавлять
собственные правила валидации,
не создавая отдельных классов.
Благодаря строгой типизации доступные
правила зависят от проверяемого свойства.
Создает метод расширения,
который можно связать
с методом RuleFor()
для свойств строки.

769 Замена фреймворка валидации на FluentValidation
{
return ruleBuilder
.Must(value => _allowedValues.Contains(value))
.WithMessage("Not a valid currency code");
}
private static readonly string[] _allowedValues =
new []{ "GBP", "USD", "CAD", "EUR" };
}
Затем можно обновить CurrencyConverterModelValidator, чтобы ис -
пользовать новый метод расширения, удалив дублирование кода в ва-
лидаторе и обеспечив согласованность между полями для кодов стран:
RuleFor(x => x.CurrencyTo)
.NotEmpty()
.Length(3)
.MustBeCurrencyCode();
Еще одно преимущество FluentValidation при использовании авто-
номных классов валидации заключается в том, что они создаются с ис -
пользованием внедрения зависимостей, поэтому вы можете внедрять
в них сервисы. В качестве примера рассмотрим атрибут валидации [Cur-
rencyCode] из листинга 20.9, который использовал сервис ICurrencyPro-
vider из контейнера внедрения зависимостей. Он требует применения
паттерна Локатор	 сервисов для получения экземпляра ICurrencyProvider
с использованием внедренного объекта контекста.
С помощью библиотеки FluentValidation можно просто вставить ICur-
rencyProvider прямо в свой валидатор, как показано в следующем лис -
тинге. Это требует меньшего количества усилий, чтобы получить желае-
мую функциональность, и делает зависимости валидатора явными.
Листинг 20.13  Валидатор конвертера валют, использующий
внедрение зависимостей
public class CurrencyConverterModelValidator
: AbstractValidator<CurrencyConverterModel>
{
public CurrencyConverterModelValidator(ICurrencyProvider provider)
{
RuleFor(x => x.CurrencyFrom)
.NotEmpty()
.Length(3)
.Must(value => provider
.GetCurrencies()
.Contains(value))
.WithMessage("Not a valid currency code");
RuleFor(x => x.CurrencyTo)
.NotEmpty()
.Length(3)Применяет ту же логику
валидации, что и раньше.
Допустимые значения
кодов валют.
Внедрение сервиса с использованием
внедрения зависимостей через
стандартный конструктор.
Использование внедренного сервиса
по правилу Must().

770 Глава 20 Создание специальных компонентов MVC и Razor Pages
.MustBeCurrencyCode(provider.GetCurrencies());
RuleFor(x => x.Quantity)
.NotNull()
.InclusiveBetween(1, 1000);
}
}
Последняя функция, которую я покажу, демонстрирует, насколько про-
ще писать валидаторы, охватывающие несколько свойств, с  по мощью
FluentValidation. Например, представьте, что мы хотим проверить, что
значение CurrencyTo отличается от CurrencyFrom. Используя FluentValida-
tion, это можно реализовать с по мощью перегруженного варианта мето-
да Must(), который предоставляет и модель, и проверяемое свойство, как
показано в следующем листинге.
Листинг 20.14  Использование метода Must(), чтобы проверить,
что два свойства различаются
RuleFor(x => x.CurrencyTo)
.NotEmpty()
.Length(3)
.MustBeCurrencyCode()
.Must((InputModel model, string currencyTo)
=> currencyTo != model.CurrencyFrom)
.WithMessage("Cannot convert currency to itself");
Создание такого валидатора, безусловно, возможно и  с  атрибутами
DataAnnotations, но для этого требуется гораздо больше церемоний, чем
с FluentValidation, и, как правило, его труднее тестировать. В FluentVali-
dation есть еще много функций, облегчающих написание и тестирование
валидаторов:
валидация	 сложных	 свойств  – валидаторы могут применяться
к сложным типам, а также к примитивным типам, таким как string
и int, показанным здесь в этом разделе;
специальные	 валидаторы	 свойств – помимо простых методов рас -
ширения можно создавать собственные валидаторы свойств для
сложных сценариев проверки;
правила	 коллекций  – когда типы содержат коллекции, такие как
List<T>, вы можете применить валидацию к  каждому элементу
спис ка, а также ко всей коллекции;
наборы	правил – можно создать несколько наборов правил, которые
могут применяться к объекту в различных обстоятельствах. Это мо-
жет быть особенно полезно, если вы используете FluentValidation
в дополнительных областях своего приложения;
валидация	 на	стороне	 клиента – FluentValidation – это серверный
фреймворк, но он генерирует те же атрибуты, что и атрибуты Data-Использование внедренного сервиса
с методом расширения.
Сообщение об ошибке будет связано
со свойством CurrencyT o.Функция Must передает
проверяемую модель верхнего
уровня и текущее свойство.
Выполняем валидацию –
валюты должны быть разными.
Используем
предоставленное сообщение
как сообщение об ошибке.

771 Замена фреймворка валидации на FluentValidation
Annotations, для активации проверки на стороне клиента, исполь-
зуя jQuery.
В дополнение к этим функциям есть еще и много других, поэтому обя-
зательно просмотрите документацию на странице https://docs.fluentval-
idation.net/ для получения подробной информации. В следующем разде-
ле вы увидите, как добавить FluentValidation в приложение ASP .NET Core.
20.4.2 Добавляем FluentValidation в приложение
Замена всей системы валидации ASP .NET Core кажется серьезным ша-
гом, но библиотеку FluentValidation легко добавить в свое приложение.
Просто выполните следующие действия.
1  Установите NuGet-пакет FluentValidation.AspNetCore с  по мощью
диспетчера пакетов NuGet Visual Studio через интерфейс команд-
ной строки, выполнив команду dotnet add package FluentValida-
tion.AspNetCore или добавив <PackageReference> в свой файл с рас -
ширением .csproj:
<PackageReference Include="FluentValidation.AspNetCore" Version="9.3.0" />
2  Настройте библиотеку FluentValidation в методе ConfigureServices
своего класса Startup, вызвав метод AddFluentValidation(). Вы мо-
жете дополнительно настроить библиотеку, как показано в листин-
ге 20.15.
3  Зарегистрируйте валидаторы (например, CurrencyConverterModel-
Validator из листинга 20.13) в  контейнере внедрения зависимо-
стей. Их можно зарегистрировать вручную, используя любую об-
ласть действия, которую вы выберете:
public void ConfigureServices(IServiceCollection services)
{
services.AddRazorPages()
.AddFluentValidation();
services.AddScoped<
IValidator<CurrencyConverterModelValidator>,
CurrencyConverterModelValidator>();
}
В качестве альтернативы вы можете разрешить FluentValidation ав-
томатически регистрировать все свои валидаторы, используя пара-
метры, показанные в листинге 20.15.
Будучи зрелой библиотекой, FluentValidation имеет относительно
мало параметров конфигурации. В  следующем листинге показаны не-
которые из доступных опций; в  частности, показано, как автоматиче-
ски зарегистрировать все специальные валидаторы в приложении и как
полностью отключить валидацию на основе DataAnnotations.

772 Глава 20 Создание специальных компонентов MVC и Razor Pages
Листинг 20.15 Настройка FluentValidation в приложении ASP.NET Core
public void ConfigureServices(IServiceCollection services)
{
services.AddRazorPages()
.AddFluentValidation(opts =>
{
opts.RegisterValidatorsFromAssemblyContaining<Startup>();
opts.ImplicitlyValidateChildProperties = true;
opts.LocalizationEnabled = false;
opts.RunDefaultMvcValidationAfterFluentValidationExecutes
= false;
});
}
Важно понять этот последний момент. Если вы не зададите для RunDe-
faultMvcValidationAfterFluentValidationExecutes значение false, ASP .
NET Core выполнит валидацию, используя и  DataAnnotations, и Fluent -
Validation. Это может быть полезно, если вы находитесь в процессе пере-
хода с одной системы на другую, но в противном случае я рекомендую
отключить ее. Такое разделение валидации – худшее, что можно себе
представить!
И последнее, о  чем следует подумать, – где разместить валидаторы.
Здесь нет технических требований: если вы зарегистрировали свой ва-
лидатор в контейнере внедрения зависимостей, он будет использоваться
правильно, поэтому выбор остается за вами. Лично я предпочитаю раз-
мещать валидаторы рядом с моделями, которые они проверяют.
Для валидаторов модели привязки Razor Pages я  создаю валидатор
в виде вложенного класса PageModel там же, где создаю InputModel, как
было описано в главе 6. Это дает иерархию классов на странице Razor,
подобную этой:
public class IndexPage : PageModel
{
public class InputModel { }
public class InputModelValidator: AbstractValidator<InputModel> { }
}
Конечно, это всего лишь мое предпочтение. При желании можно вы-
брать другой подход.
На этом мы подошли к концу главы, посвященной специальным ком-
понентам Razor Pages. В  сочетании с  компонентами из предыдущей
главы вы получаете отличную основу для расширения приложений ASP .
NET Core в соответствии со своими потребностями. Это свидетельство
дизайна ASP .NET Core: вы можете полностью менять местами целые раз-
делы, например фреймворк валидации. Если вам не нравится, как рабо-Вместо того чтобы регистрировать
валидаторы вручную, FluentValidation
может делать это автоматически за вас.Убедитесь, что проверяются сложные (вложенные)
свойства, а не только свойства верхнего уровня.
FluentValidation имеет полную поддержку локализации,
но вы можете отключить ее, если она вам не нужна.
Установка значения false полностью отключает проверку
DataAnnotations для привязки модели.

773 Резюме
тает какая-то часть фреймворка, посмотрите, не написал ли кто-нибудь
альтернативный вариант!
Резюме
С помощью тег-хелперов можно привязать свою модель данных к эле-
ментам HTML, облегчая генерацию динамического HTML. Тег-хелперы
могут настраивать элементы, к которым они прикрепляются, добав-
лять дополнительные атрибуты и  настраивать способ их отрисовки
в HTML. Это может значительно уменьшить количество разметки, ко-
торую вам нужно писать.
Имя класса тег-хелпера определяет имя элемента в  шаблонах Razor,
поэтому SystemInfoTagHelper соответствует элементу <system-info>.
Вы можете выбрать другое имя элемента, добавив атрибут [HtmlTar-
getElement] к своему тег-хелперу.
Вы можете задать свойства объекта тег-хелпера из синтаксиса Ra-
zor, декорировав свойство атрибутом [HtmlAttributeName("name")]
и  предо ставив имя. Можно задать эти свойства из Razor, используя
атрибуты HTML; например, <system-info name = "value">.
Параметр TagHelperOutput, передаваемый методам Process или Pro-
cessAsync, управляет HTML, отображаемым на странице. Можно за-
дать тип элемента с по мощью свойства TagName и внутреннее содержи-
мое с по мощью Content.SetContent() или Content.SetHtmlContent().
Вы можете предотвратить обработку внутреннего содержимого тег-
хелпера, вызвав метод SupressOutput(), и можете полностью удалить
элемент, задав для свойства TagName значение null. Это полезно, если
вы хотите условно отображать элементы.
Содержимое тег-хелпера можно получить, вызвав метод GetChild-
ContentAsync() параметра TagHelperOutput. Затем можно визуализи-
ровать это содержимое в  строку, вызвав метод GetContent(). Так вы
визуализируете все выражения Razor и тег-хелперы в HTML, позволив
себе управлять содержимым.
Компоненты представления похожи на частичные представления, но
они позволяют использовать сложную бизнес-логику и логику отри-
совки. Вы можете использовать их для разделов страницы, таких как
корзина покупок, динамическое меню навигации или рекомендуемые
статьи.
Создайте компонент представления, наследуя от базового класса
ViewComponent и реализовав метод InvokeAsync(). Вы можете передать
параметры этой функции из шаблона представления Razor, используя
атрибуты HTML, аналогично тег-хелперам.
Компоненты представления могут использовать внедрение зависи-
мостей, обращаться к  HttpContext и отображать частичные представ-
ления.
Частичные представления должны храниться в  папке Pages/Shared/
Components/<Name>/, где Name – это имя компонента представления.

774 Глава 20 Создание специальных компонентов MVC и Razor Pages
Если не указано иное, компоненты представления будут искать пред-
ставление по умолчанию с именем Default.cshtml.
Вы можете создать собственный атрибут DataAnnotations, наследуя от
класса ValidationAttribute и переопределив метод IsValid. Его можно
использовать, чтобы декорировать свойства своей модели привязки
и выполнить произвольную проверку.
Нельзя использовать конструктор внедрения зависимостей со специ-
альными атрибутами валидации. Если атрибуту валидации требуется
доступ к  службам из контейнера внедрения зависимостей, необхо-
димо использовать паттерн Локатор	 сервисов, чтобы загрузить их из
контекста валидации, используя метод GetService<T>.
FluentValidation – это альтернативная система валидации, которая мо-
жет заменить систему валидации DataAnnotations, используемую по
умолчанию. Она не основана на атрибутах, что упрощает написание
собственных проверок для правил валидации и  тестирование этих
правил.
Чтобы создать валидатор модели, создайте класс, производный от Ab-
stractValidator<>, и вызовите метод RuleFor<>() в конструкторе, что-
бы добавить правила валидации. Вы можете связать несколько требо-
ваний в  RuleFor<>() так же, как можно добавить в модель несколько
атрибутов DataAnnotations.
Если вам нужно создать собственное правило валидации, то можно
использовать метод Must(), чтобы указать предикат. Если вы хотите
повторно использовать правило валидации в  нескольких моделях,
инкапсулируйте правило, как метод расширения, чтобы уменьшить
дублирование кода.
Чтобы добавить FluentValidation в свое приложение, установите Nu-
Get-пакет FluentValidation.Asp-NetCore, вызовите метод AddFluentVal-
idation() после вызова методов AddRazorPages() или AddControllers()
и  зарегистрируйте свои валидаторы в  контейнере внедрения за-
висимостей. Так вы добавите проверки с  по мощью FluentValidation
к встроенной системе DataAnnotations.
Чтобы удалить систему валидации на основе DataAnnotations и  ис -
пользовать только FluentValidation, задайте для параметра RunDefault-
MvcValidationAfterFluentValidationExecutes значение false в вызове
метода AddFluentValidation(). По возможности придерживайтесь это-
го подхода, чтобы избежать выполнения методов валидации из двух
разных систем.
Вы можете разрешить FluentValidation автоматически обнаруживать
и  регистрировать все валидаторы в  своем приложении, вызвав Regi
sterValidatorsFromAssemblyContaining<T>(), где T – тип сканируемой
сборки. Это значит, что вам не нужно отдельно регистрировать каж -
дый валидатор в своем приложении в контейнере внедрения зависи-
мостей.

21Вызов	удаленных API
с помощью
IHttpClientFactory
В этой главе:
проблемы, вызванные неправильным использованием
HttpClient, чтобы вызывать HTTP API;
использование IHttpClientFactory для управления
жизненными циклами HttpClient;
инкапсуляция конфигурации и обработка временных
ошибок с по мощью IHttpClientFactory.
До сих пор в  этой книге мы рассматривали создание веб-страниц
и  предо ставление доступа к  API. Будь то клиенты, просматривающие
приложение Razor Pages или клиентские одностраничные приложения
и приложения для мобильных устройств, использующие ваши API, мы
писали API, чтобы их потребляли другие.
Однако очень часто ваше приложение взаимодействует со сторонними
сервисами, потребляя их	API. Например, сайту онлайн-торговли необхо-
димо принимать платежи, отправлять сообщения по электронной почте
и SMS-сообщения, а также получать курсы обмена валют от стороннего
сервиса. Наиболее распространенный подход к взаимодействию с серви-
сами – использование протокола HTTP . До сих пор в этой книге мы рас -
сматривали, как предоставлять HTTP-сервисы, используя контроллеры
API, но не рассматривали, как их потреблять.

776 Глава 21 Вызов удаленных API с помощью IHttpClientFactory
В разделе 21.1 вы узнаете, как лучше всего взаимодействовать с HTTP-
службами с по мощью HttpClient. Если у вас есть опыт работы с C#, то,
скорее всего, вы использовали этот класс для отправки HTTP-запросов,
но здесь есть две ловушки, которые нужно учитывать. В противном слу -
чае ваше приложение может столкнуться с трудностями.
IHttpClientFactory был представлен в .NET Core версии 2.1; он упро-
щает создание экземпляров HttpClient и управление ими и позволяет из-
бежать распространенных ошибок. В разделе 21.2 вы узнаете, как IHttp-
ClientFactory это делает, управляя конвейером обработчика HttpClient .
Вы познакомитесь с созданием именованных	 клиентов для централиза-
ции конфигурации для вызова удаленных API и использованием типи-
зированных	клиентов для инкапсуляции поведения удаленного сервиса.
Сбои в сети – жизненный факт, когда вы работаете с API для протокола
HTTP , поэтому важно, чтобы вы правильно с ними справлялись. В разде-
ле 21.3 вы узнаете, как использовать Polly, библиотеку, предоставляющую
возможности обеспечения отказоустойчивости и обработки временных
сбоев с  открытым исходным кодом для обработки распространенных
временных ошибок с помощью простых повторных попыток с возмож -
ностью применения более сложных политик.
Наконец, в  разделе 21.4 вы увидите, как создать собственный обра-
ботчик HttpMessageHandler, управляемый IHttpClientFactory. Вы можете
использовать собственные обработчики для реализации сквозных задач,
таких как журналирование, метрики или аутентификация, когда функ -
ция должна выполняться каждый раз, когда вы вызываете API для про-
токола HTTP . Вы также увидите, как создать обработчик, который авто-
матически добавляет API-ключ ко всем исходящим запросам к API.
Перефразируя Джона Донна, можно сказать, что «приложение – это не
остров» и наиболее распространенный способ взаимодействия с други-
ми приложениями и сервисами – это протокол HTTP . В .NET это означает
использование класса HttpClient.
21.1 Вызов API для протокола HTTP:
проблема с классом HttpClient
В этом разделе вы узнаете, как использовать класс HttpClient для вы-
зова API для протокола HTTP . Я остановлюсь на двух распространенных
ошибках, возникающих при использовании HttpClient, – это исчерпание
сокетов и  проблемы ротации DNS – и  покажу, почему они возникают.
В разделе 21.2 вы увидите, как избежать этих проблем с по мощью интер-
фейса IHttpClientFactory.
Приложение очень часто взаимодействует с  другими сервисами
для выполнения своих обязанностей. Возьмем, к примеру, типичный
онлайн-магазин. Даже в самой базовой версии приложения вам, ве-
роятно, потребуется отправлять электронные письма и  принимать
платежи с по мощью кредитных карт или других сервисов. Можно по-

777 Вызов API для протокола HTTP: проблема с классом HttpClient
пробовать создать эту функциональность самостоятельно, но, вероят -
но, оно того не стоит.
Вместо этого имеет смысл делегировать эти обязанности сторонним
сервисам, которые специализируются на данной функциональности. Ка-
кой бы сервис вы ни использовали, они почти наверняка предоставят
API для протокола HTTP для взаимодействия. Для многих сервисов это
будет единственный способ.
RESTful HTTP, gRPC и GraphQL
Существует множество способов взаимодействия со сторонними сервиса-
ми, но REST-совместимые HTTP-сервисы по-прежнему удерживают пальму
первенства, спустя десятилетия после того, как был впервые предложен про-
токол HTTP. Каждая платформа и язык программирования, которые только
можно себе представить, включают в  себя поддержку выполнения HTTP-
запросов и обработки ответов. Такая повсеместность делает его наиболее
популярным вариантом для большинства сервисов.
Несмотря на это, REST-совместимые сервисы не идеальны. Они не отли-
чаются компактностью, а это означает, что в конечном итоге отправляется
и принимается больше данных, чем при использовании некоторых других
протоколов.
Также может быть сложно развить REST-совместимые API после их развер-
тывания. Эти ограничения вызвали интерес, в частности, к двум альтернатив-
ным протоколам: gRPC и GraphQL.
gRPC призван стать эффективным механизмом обмена данными между сер-
верами. Он построен на основе протокола HTTP/2, но обычно обеспечивает
гораздо более высокую производительность по сравнению с традиционны-
ми REST-совместимыми API. Поддержка gRPC была добавлена в .NET Core
3.0, и он постоянно улучшается для повышения производительности и до-
бавления новых функций. Полный обзор поддержки .NET можно найти в до-
кументации на странице https://docs.microsoft.com/aspnet/core/grpc.
В то время как gRPC в первую очередь предназначен для обмена данными
между серверами, GraphQL лучше всего использовать для предоставления
расширяемых API приложениям для мобильных устройств и одностраничным
приложениям. Он стал очень популярным среди frontend-разработчиков, по-
скольку может снизить неудобства, связанные с развертыванием и использо-
ванием новых API. Для получения дополнительной информации рекомендую
прочитать книгу Самера Буна «GraphQL в действии» (Manning, 2021).
Несмотря на преимущества и  улучшения, которые могут принести gRPC
и GraphQL, REST-совместимые HTTP-сервисы останутся в обозримом буду-
щем, поэтому стоит убедиться, что вы понимаете, как использовать их с  Http-
Client.
В .NET мы используем класс HttpClient, чтобы вызвать API для про-
токола HTTP . Вы можете применять его для выполнения HTTP-вызовов
API, предоставления всех заголовков и  тела для отправки в  запросе

778 Глава 21 Вызов удаленных API с помощью IHttpClientFactory
и чтения заголовков ответов и данных, которые вы получаете обратно.
К сожалению, его сложно использовать правильно, и даже когда вы это
делаете, у него есть ограничения.
Источник этих трудностей частично связан с тем, что данный класс
реализует интерфейс IDisposable. Когда вы используете класс, реализу -
ющий этот интерфейс, то должны заключать класс в конструкции using
всякий раз, когда создаете новый экземпляр. Это гарантирует, что не-
управляемые ресурсы, используемые типом, будут очищены при удале-
нии класса.
using (var myInstance = new MyDisposableClass())
{
// use myInstance
}
Это может привести вас к  мысли, что правильный способ создания
HttpClient показан в следующем листинге. Это простой пример, когда
API-контроллер вызывает внешний API для получения последних курсов
обмена валют и возвращает их в качестве ответа.
ВНИМАНИЕ!  Не используйте класс HttpClient, как показано
в  листинге 21.1. Использование этого способа может привести
к нестабильности вашего приложения, как вскоре будет показано.
Листинг 21.1 Неправильный способ использования класса HttpClient
[ApiController]
public class ValuesController : ControllerBase
{
[HttpGet("values")]
public async Task<string> GetRates()
{
using (HttpClient client = new HttpClient())
{
client.BaseAddress
= new Uri("https://api.exchangeratesapi.io");
var response = await client.GetAsync("latest");
response.EnsureSuccessStatusCode();
return await response.Content.ReadAsStringAsync();
}
}
}
HttpClient – особенный класс, и  не	следует использовать его таким
образом! Проблема в первую очередь связана с тем, как работает реали-
зация базового протокола. Когда вашему компьютеру нужно отправить
запрос на HTTP-сервер, вы должны создать соединение между своим
компьютером и  сервером. Чтобы создать соединение, ваш компьютер
открывает порт, который имеет случайное число от 0 до 65 535, и под-Заключение HttpClient
в оператор using означает,
что он удаляется в конце
блока using.
Настраиваем
базовый
URL-адрес,
используемый
для выполнения
запросов
с по мощью
HttpClient.Выполняем
GET-запрос к API
курсов валют.
Возбуждаем
исключение, если
запрос не был
успешным.Считываем результат в виде строки
и возвращаем его из метода действия.

779 Вызов API для протокола HTTP: проблема с классом HttpClient
ключается к IP-адресу и порту HTTP-сервера, как показано на рис. 21.1.
После этого ваш компьютер может отправлять HTTP-запросы на сервер.
ОПРЕДЕЛЕНИЕ  Комбинация IP-адреса и порта называется соке-
том.
8080
104.18.30.39
104.18.30.39Клиент
82.28.118.105
Клиент
82.28.118.105Прежде чем HttpClient сможет
отправить запрос на удаленный
сервер, он должен установить
соединение
Клиент выбирает случайный
порт для подключения.
Комбинация номера порта
и IP-адреса называется сокетом
Как только соединение установлено,
запросы можно отправить на сервер
Рис. 21.1 Чтобы создать соединение, клиент выбирает случайный порт
и подключается к порту и IP-адресу HTTP-сервера. После этого клиент может
отправлять HTTP-запросы на сервер
Основная проблема с  инструкцией using и  HttpClient заключается
в том, что это может привести к проблеме, которая носит название исчер-
пание	сокетов, как показано на рис. 21.2. Это происходит, когда все пор-
ты на вашем компьютере заняты другими HTTP-соединениями, поэтому
ваш компьютер больше не может отправлять запросы. В этот момент ваше
приложение зависает, ожидая освобождения сокета. Очень плохой опыт!
Учитывая вышесказанное, нужно отметить, что существует 65 536 раз-
личных номеров портов, и вы можете подумать, что такая ситуация ма-
ловероятна. Это правда, вы, скорее всего, столкнетесь с подобной проб-
лемой только на сервере, который устанавливает много подключений,
но такое явление не настолько редкое, как вы думаете.
Проблема состоит в том, что когда вы удаляете HttpClient, он	не	за-
крывает	 сокет	немедленно. Особенность протокола TCP/IP , используе-
мого для HTTP-запросов, состоит в том, что соединение после попытки
закрыть его переходит в состояние, называемое TIME_WAIT. Затем соеди-
нение ожидает в течение определенного периода (в Windows это период
составляет 240 с), прежде чем полностью закрыть сокет.
Пока период TIME_WAIT не истечет, вы не можете повторно использо-
вать сокет в другом HttpClient для выполнения HTTP-запросов. Если вы
делаете много запросов, это может быстро привести к исчерпанию со-
кетов, как показано на рис. 21.2.
СОВЕТ  Вы можете просмотреть состояние активных портов или
сокетов в Windows и Linux, запустив команду netstat из команд-
ной строки или окна терминала. Обязательно выполните команду
netstat -n в Windows, чтобы пропустить разрешение DNS.

780 Глава 21 Вызов удаленных API с помощью IHttpClientFactory
6291
6291
6291
4523ASP.NET Core app
ASP.NET Core app
ASP.NET Core appУдаленный сервер
Удаленный сервер
Удаленный сервер1.  Приложение создает
новый экземпляр
HttpClient и инициирует
запрос к удаленному
серверу
3.  После получения ответа
приложение избавляется
от HttpClient и начинает
закрывать соединение
5.  Когда приложение хочет
отправить другой запрос,
оно создает новый
экземпляр HttpClient
7.  При достаточном количестве
запросов на компьютере, где
выполняется ваше приложение,
могут закончиться порты,
поскольку все они застряли
в TIME_WAIT, и вы больше
не сможете отправлять или
получать новый запрос 2.  Назначен случайный порт 6291,
и установлено соединение
с удаленным сервером
4.  Порт остается в состоянии
TIME_WAIT в течение 240 с
6.  Порт 6291 все еще
используется, поэтому
необходимо использовать
другой порт, например порт
4523
Рис. 21.2 Удаление HttpClient может привести к исчерпанию ресурсов сокета.
Каждое новое подключение требует, чтобы операционная система назначила новый
сокет, и закрытие сокета делает его недоступным, пока не истечет период TIME_WAIT,
равный 240 с. В конце концов, у вас могут закончиться сокеты, и тогда вы не можете
отправлять исходящие HTTP-запросы
Вместо того чтобы избавляться от HttpClient, рекомендовалось (до
того как IHttpClientFactory был введен в .NET Core 2.1) использовать
один экземпляр HttpClient, как показано в следующем листинге.
Листинг 21.2  Использование одного экземпляра HttpClient
для предотвращения исчерпания сокетов
[ApiController]
public class ValuesController : ControllerBase
{
private static readonly HttpClient _client = new HttpClient
{
BaseAddress = new Uri("https://api.exchangeratesapi.io")
};Создается единственный экземпляр
HttpClient и сохраняется как
статическое поле.

781 Вызов API для протокола HTTP: проблема с классом HttpClient
[HttpGet("values")]
public async Task<string> GetRates()
{
var response = await _client.GetAsync("latest");
response.EnsureSuccessStatusCode();
return await response.Content.ReadAsStringAsync();
}
}
Это решает проблему исчерпания сокетов. Поскольку вы не удаляете
HttpClient, сокет не удаляется, поэтому вы можете повторно использо-
вать один и тот же порт для нескольких запросов. Независимо от того,
сколько раз вы вызываете метод GetRates() в предыдущем примере, вы
будете использовать только один сокет. Задача решена!
К сожалению, это создает другую проблему, связанную с DNS. DNS –
это то, как удобные имена хостов, которые мы используем, например
manning.com, преобразуются в IP-адреса, которые нужны компьютерам.
Когда требуется новое соединение, HttpClient сначала проверяет DNS-
запись для хоста, чтобы найти IP-адрес, а затем устанавливает соедине-
ние. Для последующих запросов соединение уже установлено, поэтому
повторный вызов DNS не осуществляется.
Для отдельных экземпляров HttpClient это может быть проблемой,
потому что HttpClient не обнаруживает изменения DNS. DNS часто ис -
пользуется в  облачном окружении для балансировки нагрузки, чтобы
выполнять постепенное развертывание1. Если DNS-запись сервиса, ко-
торый вы вызываете, изменяется в течение жизненного цикла вашего
приложения, единственный экземпляр HttpClient продолжит вызывать
старый сервис, как показано на рис. 21.3.
ПРИМЕЧАНИЕ  HttpClient не будет учитывать изменение в DNS,
пока существует исходное соединение. Если исходное соединение
закрыто (например, если исходный сервер переходит в автоном-
ный режим), то он будет учитывать изменение в DNS, поскольку
ему нужно установить новое соединение.
Похоже, что в  обоих случаях у  вас будут неприятности! К  счастью,
IHttpClientFactory может позаботиться обо всем этом за вас.
1 Например, Azure Traffic Manager использует DNS для маршрутизации запро-
сов. Подробнее узнать о  том, как это работает, можно на странице https://
azure.microsoft.com/en-gb/services/traffic-manager/.Несколько запросов
используют один и тот же
экземпляр HttpClient.

782 Глава 21 Вызов удаленных API с помощью IHttpClientFactory
manning.com
108.18.30.39
HttpClient
HttpClientDNS-сервер
Сервер
104.18.30.39
Старый сервер
104.18.30.39Сервер
123.1.2.31.  HttpClient отправляет запрос
на https://manning.com2.  HttpClient делает DNS-запрос,
чтобы найти связанный
с доменом manning.com IP-адрес
3.  DNS-сервер отвечает
IP-адресом сервера
5.  Вскоре после этого manning.com
меняет свою DNS-запись, чтобы
указать на другой сервер,
123.1.2.3
6.  Поскольку у HttpClient все еще
есть соединение с исходным
сервером, он не будет
учитывать изменение DNS
и продолжит отправлять
HTTP-запросы на неправильный
сервер 4.  HttpClient отправляет
запрос на IP-адрес
и получает ответ
Рис. 21.3 HttpClient выполняет поиск в DNS перед установкой соединения, чтобы
определить IP-адрес, связанный с именем хоста. Если DNS-запись имени хоста
изменится, единственный экземпляр HttpClient не обнаружит его и продолжит
отправку запросов на исходный сервер, к которому он подключен
21.2 Создание экземпляров класса HttpClient
с помощью интерфейса IHttpClientFactory
В этом разделе вы узнаете, как использовать интерфейс IHttpClientFac-
tory, чтобы избежать распространенных ошибок, связанных с  HttpCli-
ent. Я  покажу несколько шаблонов, которые можно использовать для
создания экземпляров HttpClient:
использование метода CreateClient() в  качестве замены Http-
Client;
использование именованных	 клиентов для централизации конфигу -
рации HttpClient, применяемой для вызова определенного сторон-
него API;
использование типизированных	 клиентов для инкапсуляции взаи-
модействия со сторонним API, чтобы упростить потребление со сто-
роны своего кода.
Интерфейс IHttpClientFactory был представлен в  .NET Core 2.1. Он
упрощает правильное создание экземпляров класса HttpClient, вместо

783 Создание экземпляров класса HttpClient с помощью интерфейса IHttpClientFactory
того чтобы полагаться на один из ошибочных подходов, которые мы
обсуждали в разделе 21.1. Он также упрощает настройку нескольких эк -
земпляров HttpClient и позволяет создавать конвейер промежуточного
ПО для исходящих запросов.
Прежде чем мы рассмотрим, как IHttpClientFactory делает все это,
разберемся, как HttpClient работает «за кулисами».
21.2.1 Использование IHttpClientFactory для управления
жизненным циклом HttpClientHandler
В этом разделе мы рассмотрим конвейер обработчиков, используемый
HttpClient. Вы увидите, как IHttpClientFactory управляет жизненным
циклом этого конвейера и как это позволяет ему избежать нехватки со-
кетов и проблем с DNS.
Класс HttpClient, который вы обычно используете для выполнения
HTTP-запросов, отвечает за оркестровку запросов, но не за создание са-
мого соединения. Вместо этого HttpClient вызывает конвейер HttpMes-
sageHandler, в  конце которого находится HttpClientHandler, который
устанавливает фактическое соединение и отправляет HTTP-запрос, как
показано на рис. 21.4.
GET /index.html 200 OK
200 OKHttpClient
GET /index.html
User-Agent: TESTHttpMessageHandler
HttpMessageHandler
HttpClientHandlerЗапрос выполняется
с экземпляром HttpClient
путем отправки HttpRequestMessage
Запрос проходит через конвейер
обработчиков HttpMessageHandlers,
каждый из которых может изменять
запрос
Последний обработчик в цепочке –
HttpClientHandler. Это основной
обработчик, который фактически
устанавливает соединение TCP/IP
и отправляет HTTP-запросОтветное сообщение проходит
обратно через каждого
делегирующего обработчика,
давая им возможность
проверить или изменить ответ
Рис. 21.4 Каждый экземпляр класса HttpClient содержит конвейер, состоящий
из HttpMessageHandlers. Последний обработчик – HttpClientHandler, который
устанавливает соединение с удаленным сервером и отправляет HTTP-запрос.
Эта конфигурация аналогична конвейеру промежуточного ПО ASP.NET Core
и позволяет вносить сквозные корректировки в исходящие запросы
Эта конфигурация очень напоминает конвейер промежуточного ПО,
используемый приложениями ASP .NET Core, но это исходящий конвейер.

784 Глава 21 Вызов удаленных API с помощью IHttpClientFactory
Когда HttpClient делает запрос, каждый обработчик получает возмож -
ность изменить запрос до того, как последний HttpClientHandler выпол-
нит настоящий HTTP-запрос. Каждый обработчик, в свою очередь, полу -
чает возможность просмотреть ответ после его получения.
СОВЕТ  Вы увидите пример использования этого конвейера для
сквозной задачи в  разделе 21.2.4, когда мы добавим обработчик
временных ошибок.
Проблемы исчерпания сокетов и DNS, описанные в разделе 21.1, свя-
заны с удалением HttpClientHandler в конце конвейера. По умолчанию,
когда вы удаляете HttpClient, вы также удаляете конвейер обработчиков.
IHttpClientFactory отделяет жизненный цикл HttpClient от базового
HttpClientHandler.
Разделение жизненного цикла этих двух компонентов позволяет
IHttpClientFactory решать проблемы исчерпания сокетов и  ротации
DNS. Это достигается двумя способами:
путем	создания	 пула	доступных	 обработчиков – исчерпание соке-
тов происходит при удалении HttpClientHandler из-за проблемы
с TIME_WAIT, описанной ранее. IHttpClientFactory решает эту проб-
лему, создавая пул обработчиков. IHttpClientFactory поддерживает
активный обработчик, который используется для создания всех эк -
земпляров класса HttpClient в течение двух минут. Когда HttpClient
удаляется, базовый обработчик не удаляется, поэтому соединение
не закрывается. В результате исчерпание сокетов – не проблема;
периодически	 удаляя	обработчики – совместное использование кон-
вейеров обработчиков решает проблему исчерпания сокетов, но не
решает проблему DNS. Чтобы обойти ее, IHttpClientFactory перио-
дически (каждые две минуты) создает новый активный HttpClien-
tHandler, который используется для каждого экземпляра HttpClient,
созданного впоследствии. Поскольку эти экземпляры используют
новый обработчик, они создают новое соединение TCP/IP , поэтому
изменения DNS учитываются.
IHttpClientFactory периодически удаляет обработчики с «истекшим
сроком действия» в фоновом режиме, если они больше не используются
HttpClient. Это гарантирует, что экземпляры HttpClient в вашем прило-
жении используют только ограниченное количество подключений1.
Ротация обработчиков с  по мощью IHttpClientFactory решает обе
проб  лемы, которые мы обсуждали. Еще один бонус заключается в том,
что существующие способы использования HttpClient можно легко за-
менить на IHttpClientFactory.
1 Я  написал статью в  блоге, в  котором подробно рассматривается, как IHttp-
ClientFactory выполняет эту ротацию. Это подробный пост, но он может быть
интересен тем, кто хочет знать, как все реализуется за кулисами: http://mng.
bz/8NRK.

785 Создание экземпляров класса HttpClient с помощью интерфейса IHttpClientFactory
IHttpClientFactory по умолчанию включен в ASP .NET Core; вам просто
нужно добавить его в сервисы своего приложения в методе Configure-
Services() файла Startup.cs:
public void ConfigureServices(IServiceCollection services)
{
services.AddHttpClient()
}
Так вы регистрируете IHttpClientFactory в качестве объекта-одиноч-
ки в своем приложении, поэтому можете внедрить его в любой другой
сервис. Например, в следующем листинге показано, как заменить под-
ход, где используется HttpClient из листинга 21.2, версией, использую-
щей IHttpClientFactory.
Листинг 21.3  Использование IHttpClientFactory для создания
экземпляра класса HttpClient
[ApiController]
public class ValuesController : ControllerBase
{
private readonly IHttpClientFactory _factory;
public ValuesController(IHttpClientFactory factory)
{
_factory = factory;
}
[HttpGet("values")]
public async Task<string> GetRates()
{
HttpClient client = _factory.CreateClient();
client.BaseAddress =
new Uri("https://api.exchangeratesapi.io");
client.DefaultRequestHeaders.Add(
HeaderNames.UserAgent, "ExchangeRateViewer");
var response = await client.GetAsync("latest");
response.EnsureSuccessStatusCode();
return await response.Content.ReadAsStringAsync();
}
}
Непосредственным преимуществом использования IHttpClientFac-
tory, таким образом, является эффективное решение проблем, связан-
ных с  сокетами и  DNS. Чтобы воспользоваться преимуществами этого
шаблона, необходимо внести минимальные изменения, поскольку ос -
новная часть вашего кода остается неизменной. Это хороший выбор,
если вы проводите рефакторинг существующего приложения.Внедряем IHttpClientFactory
с по мощью внедрения
зависимостей.
Создаем экземпляр HttpClient
с HttpClientHandler,
управляемым фабрикой.
Настраиваем HttpClient для
вызова API, как и раньше.
Используем HttpClient
точно так же, как и раньше.

786 Глава 21 Вызов удаленных API с помощью IHttpClientFactory
SocketsHttpHandler и IHttpClientFactory
Ограничения HttpClient, описанные в разделе 21.1, применяются конкретно
к HttpClientHandler в конце конвейера обработчиков HttpClient. IHttp-
ClientFactory предоставляет механизм для управления жизненным циклом
и повторного использования экземпляров HttpClientHandler.
В .NET Core 2.1 была представлена   замена HttpClientHandler: Socket-
sHttpHandler. Этот обработчик имеет несколько преимуществ, в  первую
очередь повышение производительности и согласованность между платфор-
мами. SocketsHttpHandler также можно настроить для использования пула
соединений и повторного использования, как и IHttpClientFactory.
Итак, если HttpClient уже может использовать пул соединений, стоит ли ис -
пользовать IHttpClientFactory? В большинстве случаев я бы сказал: да. Вы
должны вручную настроить пул соединений с по мощью SocketsHttpHandler,
а у IHttpClientFactory есть дополнительные функции, такие как именован-
ные и типизированные клиенты.
Тем не менее, если вы работаете в сценарии, где нет внедрения зависимо-
стей и где нельзя использовать IHttpClientFactory, обязательно активируйте
пул соединений SocketsHttpHandler, как описано в этом посте Стива Гордона:
http://mng.bz/E27q.
Решение проблемы сокетов – одно из существенных преимуществ ис -
пользования IHttpClientFactory вместо HttpClient, но не единственное
преимущество. Вы также можете использовать IHttpClientFactory для
очистки конфигурации клиента, как будет показано в следующем раз-
деле.
21.2.2 Настройка именованных клиентов во время
регистрации
В этом разделе вы узнаете, как использовать паттерн Именованный	 кли-
ент с IHttpClientFactory. Этот паттерн инкапсулирует логику для вызо-
ва стороннего API в одном месте, что упрощает использование HttpCli-
ent в коде потребления.
Использование IHttpClientFactory решает технические проблемы, ко-
торые я описал в разделе 21.1, но код в листинге 21.3 по-прежнему вы-
глядит довольно запутанным, в первую очередь потому, что вы должны
настроить HttpClient таким образом, чтобы он указывал на ваш сервис,
прежде чем использовать его. Если вам нужно создать экземпляр Http-
Client для вызова API в нескольких местах приложения, вы также долж -
ны настроить его в разных местах.
IHttpClientFactory предоставляет удобное решение этой проблемы,
позволяя централизованно настраивать именованных	 клиентов. У этих
клиентов есть строковое имя и  функция конфигурации, которая за-
пускается всякий раз, когда запрашивается экземпляр именованного

787 Создание экземпляров класса HttpClient с помощью интерфейса IHttpClientFactory
клиента. Вы можете определить несколько функций конфигурации, ко-
торые запускаются последовательно для настройки нового экземпляра
HttpClient.
Например, в  следующем листинге показано, как зарегистрировать
именованного клиента "rates". Этот клиент настроен с  правильным
BaseAddress и задает заголовки по умолчанию, которые должны отправ-
ляться с каждым исходящим запросом.
Листинг 21.4  Настройка именованного клиента с использованием
IHttpClientFactory в файле Startup.cs
public void ConfigureServices(IServiceCollection services)
{
services.AddHttpClient("rates", (HttpClient client) =>
{
client.BaseAddress =
new Uri("https://api.exchangeratesapi.io");
client.DefaultRequestHeaders.Add(
HeaderNames.UserAgent, "ExchangeRateViewer");
})
.ConfigureHttpClient((HttpClient client) => {})
.ConfigureHttpClient(
(IServiceProvider provider, HttpClient client) => {});
}
После того как вы настроили именованного клиента, вы можете соз-
дать его из экземпляра IHttpClientFactory, используя имя клиента,
"rates". В следующем листинге показано, как обновить листинг 21.3, что-
бы использовать именованного клиента, настроенного в листинге 21.4.
Листинг 21.5  Использование IHttpClientFactory для создания
именованного клиента
[ApiController]
public class ValuesController : ControllerBase
{
private readonly IHttpClientFactory _factory;
public ValuesController(IHttpClientFactory factory)
{
_factory = factory;
}
[HttpGet("values")]
public async Task<string> GetRates()
{
HttpClient client = _factory.CreateClient("rates");Указываем имя клиента и функцию конфигурации.
Функция конфигурации
выполняется каждый
раз, когда запрашивается
именованный HttpClient.
Вы можете добавить дополнительные функции
конфигурации для именованного клиента,
которые будут выполняться последовательно.Существуют дополнительные перегруженные варианты,
которые разрешают доступ к контейнеру внедрения
зависимостей при создании именованного клиента.
Внедряем IHttpClientFactory
с помощью внедрения
зависимостей.
Запрашиваем именованного клиента
"rate" и настраиваем его, как определено
в методе ConfigureServices().

788 Глава 21 Вызов удаленных API с помощью IHttpClientFactory
var response = await client.GetAsync("latest");
response.EnsureSuccessStatusCode();
return await response.Content.ReadAsStringAsync();
}
}
ПРИМЕЧАНИЕ  Вы по-прежнему можете создавать ненастроен-
ных клиентов с по мощью метода CreateClient() без имени. Имей-
те в  виду, что если вы передаете ненастроенное имя, например
CreateClient("MyRates"), то возвращаемый клиент не будет скон-
фигурирован. Будьте внимательны: имена клиентов чувствитель-
ны к регистру, поэтому "rates" и "Rates" – это разные клиенты.
Именованные клиенты позволяют централизовать конфигурацию
HttpClient в одном месте, снимая ответственность за настройку клиен-
та с кода потребления. Но на этом этапе вы все еще работаете с низко-
уровневыми HTTP-вызовами – например, предоставляя относительный
URL-адрес для вызова ("/latest") и разбирая ответ. IHttpClientFactory
включает в себя функцию, упрощающую очистку этого кода.
21.2.3 Использование типизированных клиентов
для инкапсуляции HTTP-вызовов
Существует распространенный шаблон, когда вам нужно взаимодей-
ствовать с API, – это инкапсуляция механизма такого взаимодействия
в отдельный сервис. Это можно легко сделать с по мощью уже знакомых
вам функций IHttpClientFactory, извлекая тело функции GetRates() из
листинга 21.5 в  отдельный сервис. Но в  IHttpClientFactory также есть
более основательная поддержка данного шаблона.
IHttpClientFactory поддерживает типизированных	 клиентов. Ти -
пизированный клиент – это класс, который принимает настроенный
HttpClient в  своем конструкторе. Он использует его для взаимодей-
ствия с  удаленным API и  предоставляет понятный интерфейс для
вызова потребителей. Вся логика взаимодействия с  удаленным API
инкапсулирована в  типизированном клиенте, например какие пути
к  URL-адресам нужно вызвать, какие HTTP-методы использовать
и типы ответов, возвращаемых API. Эта инкапсуляция упрощает вызов
стороннего API из нескольких мест в приложении с по мощью типизи-
рованного клиента.
Например, в следующем листинге показан пример типизированного
клиента для API курсов обмена валют, показанного в предыдущих лис -
тингах. Он принимает HttpClient в своем конструкторе и предоставляет
метод GetLatestRates(), который инкапсулирует логику взаимодействия
со сторонним API.Используем HttpClient
так же, как и раньше.

789 Создание экземпляров класса HttpClient с помощью интерфейса IHttpClientFactory
Листинг 21.6  Создание типизированного клиента для API курсов
обмена валют
public class ExchangeRatesClient
{
private readonly HttpClient _client;
public ExchangeRatesClient(HttpClient client)
{
_client = client;
}
public async Task<string> GetLatestRates()
{
var response = await _client.GetAsync("latest");
response.EnsureSuccessStatusCode();
return await response.Content.ReadAsString();
}
}
Затем мы можем внедрить этот ExchangeRatesClient в потребляющие
сервисы, и им не нужно ничего знать о том, как выполнять HTTP-запросы
к удаленной службе; им просто нужно взаимодействовать с типизиро-
ванным клиентом. Мы можем обновить листинг 21.3, чтобы использо-
вать типизированного клиента, как показано в  следующем листинге,
пос ле чего метод действия GetRates() становится пустяком.
Листинг 21.7  Использование типизированного клиента
для инкапсуляции вызовов удаленного HTTP-сервера
[ApiController]
public class ValuesController : ControllerBase
{
private readonly ExchangeRatesClient _ratesClient;
public ValuesController(ExchangeRatesClient ratesClient)
{
_ratesClient = ratesClient;
}
[HttpGet("values")]
public async Task<string> GetRates()
{
return await _ratesClient.GetLatestRates();
}
}
На этом этапе вы можете быть немного сбиты с толку: я еще не упомя-
нул, как задействован IHttpClientFactory!
ExchangeRatesClient принимает HttpClient в  своем конструкторе.
IHttpClientFactory отвечает за создание HttpClient, его настройку для
вызова удаленной службы и  внедрение в  новый экземпляр типизиро-
ванного клиента.Внедряем HttpClient с по мощью
внедрения зависимостей вместо
IHttpClientFactory.
Логика метода GetLatestRates()
инкапсулирует логику
взаимодействия с API.
Используем HttpClient
так же, как и раньше.
Внедряем
типизированного
клиента в конструктор.
Вызываем API типизированного
клиента. Типизированный
клиент обрабатывает
правильные HTTP-запросы.

790 Глава 21 Вызов удаленных API с помощью IHttpClientFactory
Можно зарегистрировать ExchangeRatesClient как типизированного
клиента и  настроить HttpClient, который внедряется в  ConfigureSer-
vices, как показано в  следующем листинге. Это очень похоже на на-
стройку именованного клиента, поэтому вы можете зарегистрировать
дополнительную конфигурацию для HttpClient, которая будет внедрена
в типизированного клиента.
Листинг 21.8  Регистрация типизированного клиента с по мощью
HttpClientFactory в файле Startup.cs
public void ConfigureServices(IServiceCollection services)
{
services.AddHttpClient<ExchangeRatesClient>
(HttpClient client) =>
{
client.BaseAddress =
new Uri("https://api.exchangeratesapi.io");
client.DefaultRequestHeaders.Add(
HeaderNames.UserAgent, "ExchangeRateViewer");
})
.ConfigureHttpClient((HttpClient client) => {});
}
СОВЕТ  Типизированного клиента можно рассматривать как обо-
лочку для именованного клиента. Я  большой поклонник этого
подхода, поскольку он объединяет всю логику для взаимодействия
с удаленной службой в одном месте, а также избегает «волшебных
строк», которые используются с именованными клиентами, устра-
няя возможность опечаток.
Еще один вариант при регистрации типизированных клиентов – заре-
гистрировать интерфейс, помимо реализации. Часто это хорошая прак -
тика, поскольку значительно упрощает тестирование потребляющего
кода. Например, если типизированный клиент из листинга 21.6 реализу -
ет интерфейс IExchangeRatesClient, вы можете зарегистрировать интер-
фейс и реализацию типизированного клиента, используя
services.AddHttpClient<IExchangeRatesClient, ExchangeRatesClient>()
Затем можно внедрить это в  потребляющий код, используя тип ин-
терфейса:
public ValuesController(IExchangeRatesClient ratesClient)
Еще один часто используемый шаблон – не предоставлять никакой
конфигурации для типизированного клиента в  методе ConfigureSer-Регистрируем типизированного клиента,
используя обобщенный метод AddHttpClient.
Вы можете предоставить
дополнительную
функцию конфигурации
для HttpClient, который
будет внедрен.
Что касается именованных клиентов, то вы можете
предоставить несколько методов конфигурации.

791 Обработка временных ошибок HTTP с помощью библиотеки Polly
vices(). Вместо этого вы можете поместить данную логику в конструк -
торе ExchangeRatesClient с использованием внедренного HttpClient:
public class ExchangeRatesClient
{
private readonly HttpClient _client;
public ExchangeRatesClient(HttpClient client)
{
_client = client;
_client.BaseAddress = new Uri("https://api.exchangeratesapi.io");
}
}
Функционально это эквивалентно подходу, показанному в листинге 21.8.
Куда вы бы предпочли поместить конфигурацию для своего HttpClient –
это вопрос вкуса. Если вы воспользуетесь этим подходом, то вам не нужно
предоставлять лямбда-функцию конфигурации в C onfigureServices:
services.AddHttpClient<ExchangeRatesClient>();
Именованные и  типизированные клиенты удобны для управления
и  инкапсуляции конфигурации HttpClient, но IHttpClientFactory дает
еще одно преимущество, на которое мы еще не обратили внимания: рас -
ширить конвейер обработчиков HttpClient становится проще.
21.3 Обработка временных ошибок HTTP
с помощью библиотеки Polly
В этом разделе вы узнаете, как справиться с очень распространенной си-
туацией: «временными» ошибками при вызове удаленной службы, вы-
званными ошибкой на удаленном сервере или временными проблемами
сети. Вы увидите, как использовать IHttpClientFactory для решения по-
добных сквозных задач, добавляя обработчики в конвейер обработчиков
HttpClient.
В разделе 21.2.1 я писал, что HttpClient состоит из «конвейера» обра-
ботчиков. Существенное преимущество этого конвейера, как и конвейе-
ра промежуточного ПО вашего приложения, заключается в том, что он
позволяет решать сквозные задачи для всех запросов. Например, IHttp-
ClientFactory автоматически добавляет обработчик к каждому экземп-
ляру HttpClient, который регистрирует код состояния и продолжитель-
ность каждого исходящего запроса.
Помимо журналирования, еще одним очень распространенным требо-
ванием является обработка временных ошибок при вызове внешнего API.
Временные ошибки могут возникать при отключении сети или времен-
ном отключении удаленного API. В  случае временных ошибок простая
повторная попытка отправить запрос часто может быть успешной, но
необходимость вручную писать код для этого довольно обременительна.

792 Глава 21 Вызов удаленных API с помощью IHttpClientFactory
У ASP .NET Core есть библиотека Microsoft.Extensions.Http.Polly, кото-
рая упрощает обработку временных ошибок. Популярная библиотека
с  открытым исходным кодом Polly (https://github.com/App-vNext/Polly)
используется для автоматического повторения запросов, которые не вы-
полняются из-за временных ошибок сети.
Polly – уже давно существующая библиотека для обработки времен-
ных ошибок, которая включает в себя множество различных стратегий
обработки ошибок, таких как простые повторные отправки, экспонен-
циальная задержка отправки, паттерны Предохранитель и Bulkhead	 Isola-
tion, и многое другое. Каждая стратегия подробно описана на странице
https://github.com/App-vNext/Polly , поэтому обязательно прочтите обо
всех преимуществах и компромиссах при выборе стратегии.
Чтобы получить представление о том, какие варианты доступны, мы
добавим простую стратегию повторной отправки в  ExchangeRatesCli-
ent, как было показано в разделе 21.2. Если запрос не выполняется из-за
проб  лемы в сети, такой как тайм-аут или ошибка сервера, мы настроим
Polly для автоматической повторной отправки запроса как часть кон-
вейе ра обработчиков, как показано на рис. 21.5.
Чтобы добавить обработку временных ошибок для именованного кли-
ента или HttpClient, выполните следующие действия.
1  Установите пакет NuGet Microsoft.Extensions.Http.Polly в свой про-
ект, выполнив команду dotnet add package Microsoft.Extensions.
Http.Polly, используя проводник NuGet в Visual Studio или добавив
элемент <PackageReference> в файл своего проекта:
<PackageReference Include="Microsoft.Extensions.Http.Polly"  Version="5.0.0" />
2  Настройте именованного или типизированного клиента, как пока-
зано в листингах 21.5 и 21.7.
3  Настройте для своего клиента стратегию обработки временных
ошибок, как показано в листинге 21.9.
Листинг 21.9  Настройка стратегии обработки временных ошибок
для типизированного клиента в файле Startup.cs
public void ConfigureServices(IServiceCollection services)
{
services.AddHttpClient<ExchangeRatesClient>()
.AddTransientHttpErrorPolicy(policy =>
policy.WaitAndRetryAsync(new[] {
TimeSpan.FromMilliseconds(200),
TimeSpan.FromMilliseconds(500),
TimeSpan.FromSeconds(1)
})
);
}Вы можете добавить обработчики временных ошибок
к именованным или типизированным клиентам.
Используем методы расширения,
предоставленные пакетом NuGet,
для добавления обработчиков
временных ошибок.
Настраиваем стратегию повторной
отправки, используемую обработчиком.
Есть много типов стратегий на выбор.
Настраивает стратегию, которая выжидает и трижды
повторяет запросы в случае возникновения ошибки.

793 Обработка временных ошибок HTTP с помощью библиотеки Polly
ExchangeRatesClient
ExchangeRatesClientPollyHttpMessageHandler
PollyHttpMessageHandlerHttpClientHandler
HttpClientHandlerValuesController
ValuesController200 OK
200 OK1.  ValuesController отправляет запрос
на удаленный сервер с помощью
ExchangeRatesClient
2.  Обработчик Polly передает
запрос HttpClientHandler, который
отправляет запрос на удаленный
сервер
4.  Обработчик Polly незамедлительно
(или после небольшого периода
ожидания) отправляет тот же запрос
обратно по конвейеру обработчиков
и на удаленный сервер3.  Удаленный сервер возвращает
код ошибки, указывающий
на временную ошибку. Она
проходит обратно через конвейер
обработчиков и перехватывается
обработчиком Polly
5.  На этот раз сервер возвращает
валидный ответ. Ответ проходит
обратно через конвейер
обработчиков, через обработчик
Polly и отправляется исходной
вызывающей стороне
Рис. 21.5 Использование PolicyHttpMessageHandler для обработки временных ошибок.
Если при вызове удаленного API возникает ошибка, обработчик Polly автоматически повторит
запрос. Если запрос завершается успешно, результат возвращается вызывающей стороне.
Вызывающей стороне не пришлось самостоятельно обрабатывать ошибку, что упростило
использование HttpClient, сохраняя устойчивость к временным ошибкам
В приведенном выше листинге мы настраиваем обработчик ошибок
для перехвата временных ошибок и трех повторных попыток, ожидая
увеличения промежутка времени между запросами. Если запрос завер-
шится неудачно с третьей попытки, обработчик проигнорирует ошибку
и вернет ее клиенту, как если бы обработчика ошибок не было вообще.
По умолчанию обработчик будет повторять любой запрос, который либо:
возбуждает исключение HttpRequestException, указывая на ошибку
на уровне протокола, например закрытое соединение;
возвращает код состояния HTTP 5xx, указывая на ошибку сервера
в API;
возвращает код состояния HTTP 408, указывая на тайм-аут.

794 Глава 21 Вызов удаленных API с помощью IHttpClientFactory
СОВЕТ  Если вы хотите обрабатывать больше случаев автомати-
чески или ограничивать ответы, которые будут автоматически по-
вторяться, можно настроить логику выбора, как описано в доку -
ментации «Polly и HttpClientFactory» на сайте GitHub: http://mng.
bz/NY7E.
Использование стандартных обработчиков, таких как обработчик вре-
менных ошибок, позволяет применять одну и ту же логику ко всем за-
просам, которые выполняются определенным экземпляром HttpClient.
Точная стратегия, которую вы выберете, будет зависеть от характеристик
сервиса и запроса, но хорошая стратегия повторных отправок необходи-
ма всякий раз, когда вы взаимодействуете с потенциально ненадежны-
ми API для протокола HTTP .
Обработчик ошибок Polly – это пример необязательного обработчика
HttpMessageHandler, который вы можете подключить к своему HttpCli-
ent, но вы также можете создать собственный обработчик. В следующем
разделе вы увидите, как создать обработчик, который добавляет заголо-
вок ко всем исходящим запросам.
21.4 Создание специального обработчика
HttpMessageHandler
Для большинства сторонних API при их вызове требуется некая форма
аутентификации. Например, многие службы требуют, чтобы вы прикре-
пили API-ключ к исходящему запросу, чтобы запрос можно было при-
вязать к вашей учетной записи. Вместо того чтобы не забывать об этом
и вручную добавлять этот заголовок для каждого запроса к API, можно
настроить собственный обработчик HttpMessageHandler для автоматиче-
ского прикрепления заголовка.
ПРИМЕЧАНИЕ  Более сложные API-интерфейсы могут исполь-
зовать веб-токены JSON (JWT), полученные от поставщика иден-
тификационной информации. В  таком случае рассмотрите воз-
можность использования библиотеки IdentityModel с  открытым
исходным кодом (https://identitymodel.readthedocs.io), обеспечи-
вающую точки интеграции для ASP .NET Core Identity и  HttpClient-
Factory.
Вы можете настроить именованного или типизированного клиента
с по мощью IHttpClientFactory для использования обработчика API-клю  ча
как часть конвейера обработчиков HttpClient, как показано на рис. 21.6.
Когда вы используете HttpClient для отправки сообщения, HttpRequest-
Messsage передается через каждый обработчик по очереди. Обработчик
API-ключа добавляет дополнительный заголовок и передает запрос сле-
дующему обработчику в конвейере. В конце концов, HttpClientHandler

795 Создание специального обработчика HttpMessageHandler
делает сетевой запрос для отправки HTTP-запроса. После получения от -
вета каждый обработчик получает возможность проверить (и потенци-
ально изменить) ответ.
GET /index.html 200 OK
# 200 OKX-API-KEY
GET /index.html
X-API-KEY: ABCHttpClient
ApiKeyMessageHandler
PolicyHttpMessageHandler
HttpClientHandlerЗапрос выполняется
с экземпляром HttpClient путем
отправки HttpRequestMessage
ApiKeyMessageHandler
изменяет запрос
и добавляет заголовок API
HttpClientHandler
отправляет запрос, включая
дополнительный заголовокВ случае ошибки обработчик
временных ошибок повторно
отправляет запрос
Рис. 21.6 Можно использовать собственный обработчик HttpMessageHandler
для изменения запросов до того, как они будут отправлены сторонним API. Каждый
запрос проходит через специальный обработчик до того, как финальный обработчик
(HttpClientHandler) отправит запрос в API для протокола HTTP. После получения
ответа каждый обработчик получает возможность проверить и изменить ответ
Чтобы создать собственный HttpMessageHandler и добавить его в кон-
вейер типизированного или именованного клиента, можно выполнить
следующие действия.
1  Создайте специальный обработчик, наследуя от базового класса
DelegatingHandler.
2  Переопределите метод SendAsync(), чтобы обеспечить специальное
поведение. Вызовите base.SendAsync(), чтобы выполнить остав-
шуюся часть конвейера обработчиков.
3  Зарегистрируйте обработчик в  контейнере внедрения зависимо-
стей. Если вашему обработчику не требуется состояние, то можно
зарегистрировать его как сервис с  жизненным циклом Singleton;
в противном случае следует зарегистрировать его как сервис с жиз-
ненным циклом Transient.
4  Добавьте обработчик к одному или нескольким именованным или
типизированным клиентам, вызвав метод AddHttpMessage Hand-
ler<T>() в  IHttpClientBuilder, где T – ваш тип обработчика. Поря-
док, в котором вы регистрируете обработчики, определяет порядок,
в котором они будут добавлены в конвейер обработчиков HttpCli-

796 Глава 21 Вызов удаленных API с помощью IHttpClientFactory
ent. При желании можно добавить один и тот же тип обработчика
несколько раз в конвейер, а также для нескольких типизированных
или именованных клиентов.
В следующем листинге показан пример специального обработчика
HttpMessageHandler, который добавляет заголовок к каждому исходяще-
му запросу. В этом примере мы будем использовать собственный заголо-
вок "X-API-KEY", но нужный заголовок будет зависеть от стороннего API,
который вы вызываете. В этом примере используется строго типизиро-
ванная конфигурация для внедрения секретного API-ключа, как было
показано в главе 10.
Листинг 21.10 Создание специального обработчика HttpMessageHandler
public class ApiKeyMessageHandler : DelegatingHandler
{
private readonly ExchangeRateApiSettings _settings;
public ApiKeyMessageHandler(
IOptions<ExchangeRateApiSettings> settings)
{
_settings = settings.Value;
}
protected override async Task<HttpResponseMessage> SendAsync(
HttpRequestMessage request,
CancellationToken cancellationToken)
{
request.Headers.Add("X-API-KEY", _settings.ApiKey);
HttpResponseMessage response =
await base.SendAsync(request, cancellationToken);
return response;
}
}
Чтобы использовать обработчик, вы должны зарегистрировать его
в контейнере внедрения зависимостей и добавить его к именованному
или типизированному клиенту. В  следующем листинге мы добавляем
его в ExchangeRatesClient наряду с  обработчиком временных ошибок,
который мы зарегистрировали в листинге 21.8. Так мы создаем конвей-
ер, аналогичный тому, что показан на рис. 21.6.
Листинг 21.11  Регистрация специального обработчика
в Startup.ConfigureServices
public void ConfigureServices(IServiceCollection services)
{
services.AddTransient<ApiKeyMessageHandler>();Специальные обработчики
HttpMessageHandler
должны наследовать
от DelegatingHandler.Внедряем строго типизированные значения конфигурации
с по мощью внедрения зависимостей.
Переопределяем
метод SendAsync,
чтобы реализовать
специальное
поведение.Добавляем дополнительный заголовок
ко всем исходящим запросам.
Вызываем оставшуюся часть
конвейера и получаем ответ.
Вы можете проверить или изменить ответ,
прежде чем возвращать его.
Регистрируем специальный
обработчик в контейнере
внедрения зависимостей.

797 Резюме
services.AddHttpClient<ExchangeRatesClient>()
.AddHttpMessageHandler<ApiKeyMessageHandler>()
.AddTransientHttpErrorPolicy(policy =>
policy.WaitAndRetryAsync(new[] {
TimeSpan.FromMilliseconds(200),
TimeSpan.FromMilliseconds(500),
TimeSpan.FromSeconds(1)
})
);
}
Каждый раз, когда вы делаете запрос, используя типизированного
клиента ExchangeRatesClient, вы можете быть уверены, что API-ключ
будет добавлен и  временные ошибки будут обрабатываться автомати-
чески.
На этом мы подошли к концу главы, посвященной IHttpClientFactory.
Учитывая трудности, связанные с  правильным использованием класса
HttpClient, которые были показаны в разделе 21.1, по возможности всег -
да следует отдавать предпочтение IHttpClientFactory. В качестве бонуса
IHttpClientFactory позволяет легко централизовать конфигурацию API
с  использованием именованных клиентов и  инкапсулировать взаимо-
действия с API, используя типизированных клиентов.
Резюме
Используйте класс HttpClient для вызова API для протокола HTTP . Вы
можете использовать его для выполнения вызовов API по протоколу
HTTP , предоставляя все заголовки и тела для отправки в запросе и чи-
тая заголовки ответов и данные, которые вы получаете обратно.
HttpClient использует конвейер обработчиков, состоящий из несколь-
ких обработчиков HttpMessageHandler, подключенных аналогично
конвейеру промежуточного ПО, используемому в  ASP .NET Core. По-
следний обработчик – HttpClientHandler, который отвечает за уста-
новку подключения к сети и отправку запроса.
HttpClient реализует интерфейс IDisposable, но обычно избавляться
от него не следует. Когда HttpClientHandler, который устанавливает
соединение TCP/IP , удаляется, он сохраняет соединение открытым
в течение периода TIME_WAIT. Удаление большого числа экземпляров
HttpClient за короткий период времени может привести к исчерпа-
нию сокетов, что не позволит машине обрабатывать никакие запросы.
До появления .NET Core версии 2.1 рекомендовалось использовать
один экземпляр HttpClient на протяжении всего жизненного цикла
приложения. К сожалению, при таком варианте не будут учитываться
изменения в DNS, которые обычно используются для управления тра-
фиком в облачном окружении.
IHttpClientFactory решает обе эти проблемы, управляя жизненным
циклом конвейера HttpMessageHandler. Вы можете создать новый эк -Настраиваем
типизированного клиента
для использования
настраиваемого
обработчика.
Добавляем обработчик временных
ошибок. Порядок их регистрации
определяет их порядок в конвейере.

798 Глава 21 Вызов удаленных API с помощью IHttpClientFactory
земпляр HttpClient, вызвав метод CreateClient(), а  IHttpClientFacto-
ry позаботится об удалении конвейера обработчиков, если он больше
не используется.
Вы можете централизовать конфигурацию HttpClient в  методе Con-
figureServices() с  использованием именованных клиентов, вызвав
AddHttpClient("test", c => {}). Затем можно получить настроенный
экземпляр клиента в  своих сервисах, вызвав IHttpClientFactory.
CreateClient("test").
Вы можете создать типизированного клиента, внедрив HttpClient
в сервис T и настроив клиента с по мощью AddHttpClient<T>(c => {}).
Типизированные клиенты отлично подходят для абстрагирования ме-
ханизмов HTTP от потребителей клиента.
Вы можете использовать библиотеку Microsoft.Extensions.Http.Polly,
чтобы добавить обработку временных ошибок HTTP в  свои экземп-
ляры HttpClient. Вызовите метод AddTransientHttpErrorPolicy() при
настройке IHttpClientFactory в  ConfigureServices и  предоставьте
стратегию Polly, чтобы контролировать, когда ошибки должны авто-
матически обрабатываться, а запросы повторяться.
Обычно используется простая стратегия повторной отправки, что-
бы попытаться сделать запрос несколько раз, прежде чем отказаться
и вернуть ошибку. При проектировании стратегии обязательно учи-
тывайте ее влияние; в некоторых случаях может быть лучше быстро
потерпеть неудачу, нежели повторять запрос, который никогда не бу -
дет успешным. Polly включает дополнительные стратегии, такие как
предохранители, для создания более продвинутых подходов.
По умолчанию промежуточное ПО для обработки временных ошибок
обрабатывает ошибки подключения, ошибки сервера, которые воз-
вращают код 5xx, и ошибки 408 (тайм-аут). Вы можете выполнить на-
стройку, если хотите обрабатывать дополнительные типы ошибок, но
убедитесь, что повторяете только безопасные запросы.
Можно создать собственный обработчик HttpMessageHandler, чтобы
изменять каждый запрос, сделанный через именованного или типи-
зированного клиента. Собственные обработчики хорошо подходят
для реализации сквозных задач, таких как журналирование, метрики
и аутентификация.
Чтобы создать собственный обработчик HttpMessageHandler, насле-
дуйте от DelegatingHandler и переопределите метод SendAsync(). Вы -
зовите метод base.SendAsync(), чтобы отправить запрос следующему
обработчику в конвейере, и, наконец, HttpClientHandler, который вы-
полняет HTTP-запрос.
Зарегистрируйте свой обработчик в контейнере внедрения зависимо-
стей с жизненным циклом Transient или Singleton. Добавьте его к име-
нованному или типизированному клиенту с  по мощью Add HttpMes-
sageHandler<T>(). Порядок, в  котором вы регистрируете обработчик
в IHttpClientBuilder, – это порядок, в котором обработчик будет по-
являться в конвейере обработчиков HttpClient.

22Создание	фоновых	задач
и сервисов
В этой главе:
создание задач, которые выполняются в фоновом режиме
для вашего приложения;
использование обобщенного интерфейса IHost
для создания служб Windows и демонов Linux;
использование Quartz.NET для выполнения задач
по расписанию в кластерном окружении.
На данный момент мы рассмотрели в этой книге очень много вопросов.
Вы узнали, как создавать приложения с по мощью Razor Pages и API для
мобильных клиентов и служб, как добавить аутентификацию и автори-
зацию в свое приложение, как использовать EF Core для хранения состоя-
ния в базе данных и создавать специальные компоненты в соответствии
со своими требованиями.
Помимо этих приложений, ориентированных на пользовательский
интерфейс, вам может потребоваться создать фоновые или пакетные
сервисы. Эти сервисы не предназначены для прямого взаимодействия
с  пользователями. Они продолжают работать в  фоновом режиме, об-
рабатывая элементы из очереди или периодически выполняя процесс
с длительным временем запуска.
Например, вам может потребоваться фоновый сервис, который от -
правляет подтверждения по электронной почте для заказов из онлайн-
магазина, или пакетное задание, которое рассчитывает продажи и убыт -

800 Глава 22 Создание фоновых задач и сервисов
ки для розничных магазинов после закрытия магазинов. ASP .NET Core
включает поддержку этих фоновых задач, предоставляя абстракции для
выполнения задачи в фоновом режиме при запуске приложения.
В разделе 22.1 вы узнаете о поддержке фоновых задач, предоставля-
емой в ASP .NET Core интерфейсом IHostedService. Вы узнаете, как ис -
пользовать вспомогательный класс BackgroundService для создания за-
дач, запускаемых по таймеру, и как правильно управлять жизненными
циклами внедрения зависимостей в долгосрочной задаче.
В разделе 22.2 мы пойдем дальше и  создадим «автономные» серви-
сы рабочей роли (worker service) с  использованием обобщенного ин-
терфейса IHost. Сервисы рабочей роли не используют Razor Pages или
контроллеры API; они состоят только из экземпляров IHostedService,
выполняющих задачи в фоновом режиме. Вы также узнаете, как настро-
ить и установить сервис рабочей роли в качестве службы Windows или
демона Linux.
В разделе 22.3 я представлю библиотеку с открытым исходным кодом
Quartz.NET, которая предоставляет широкие возможности планирова-
ния для создания фоновых сервисов. Вы узнаете, как установить Quartz.
NET в свои приложения, как создавать сложные расписания для своих
задач и как добавить избыточность в сервисы рабочей роли с по мощью
кластеризации.
Прежде чем перейти к  более сложным сценариям, мы рассмотрим
встроенную поддержку для запуска фоновых задач в  ваших приложе-
ниях.
22.1 Запуск фоновых задач с по мощью
интерфейса IHostedService
В большинстве приложений обычно создаются задачи, которые выпол-
няются в фоновом режиме, а не в ответ на запрос. Это может быть задача
по обработке очереди электронных писем, обработка событий, опубли-
кованных в какой-то шине сообщений, или запуск пакетного процесса
для расчета ежедневной прибыли. Перенося эту работу в  фоновую за-
дачу, ваш пользовательский интерфейс может оставаться отзывчивым.
Например, вместо того чтобы пытаться сразу же отправить электронное
письмо, вы можете добавить запрос в очередь и немедленно вернуть от -
вет пользователю. Фоновая задача может обслуживать эту очередь в фо-
новом режиме.
В ASP .NET Core можно использовать интерфейс IHostedService для
выполнения задач в фоновом режиме. Классы, реализующие этот интер-
фейс, запускаются при запуске вашего приложения, вскоре после того,
как приложение начинает обрабатывать запросы, и  останавливаются
незадолго до остановки приложения, что дает вам точки подключения,
необходимые для выполнения большинства задач.

801 Запуск фоновых задач с по мощью интерфейса IHostedService
ПРИМЕЧАНИЕ  Даже сервер ASP .NET Core, Kestrel, работает как
IHostedService. В некотором смысле почти все в приложении ASP .
NET Core является «фоновой» задачей.
В этом разделе вы увидите, как использовать IHostedService для соз-
дания фоновой задачи, которая непрерывно выполняется на протяже-
нии всего жизненного цикла вашего приложения. Его можно использо-
вать для разных целей, но в следующем разделе вы увидите, как с его
помощью заполнить простой кеш. Вы также узнаете, как использовать
сервисы с жизненным циклом Scoped в фоновых задачах Singleton, само-
стоятельно управляя областями контейнера.
22.1.1 Запуск фоновых задач по таймеру
В этом разделе вы узнаете, как создать фоновую задачу, которая перио-
дически запускается по таймеру на протяжении всего жизненного цик -
ла вашего приложения. Запуск фоновых задач может быть полезен по
многим причинам, например для планирования работы, которая будет
выполняться позже, или выполнения работы заранее.
Например, в главе 21 мы использовали IHttpClientFactory и типизи-
рованного клиента для вызова стороннего сервиса, чтобы получить теку -
щий обменный курс между различными валютами и вернуть их в конт -
роллер API, как показано в следующем листинге.
Листинг 22.1  Использование типизированного клиента для возврата
обменных курсов валют из стороннего сервиса
[ApiController]
public class ValuesController : ControllerBase
{
private readonly ExchangeRatesClient _typedClient;
public ValuesController(ExchangeRatesClient typedClient)
{
_typedClient = typedClient;
}
[HttpGet("values")]
public async Task<string> GetRates()
{
return await _typedClient.GetLatestRatesAsync()
}
}
Простая оптимизация этого кода может заключаться в кешировании
значений обменного курса за какой-то период. Есть несколько способов
реализовать это, но в этом разделе мы будем использовать простой кеш,
который предварительно извлекает обменные курсы в фоновом режиме,
как показано на рис. 22.1. Контроллер API просто читает из кеша; ему не
нужно делать HTTP-вызовы, поэтому он остается быстрым.Типизированный клиент,
созданный с по мощью IHttpClientFactory,
внедряется в конструктор.
Типизированный клиент используется
для получения обменных курсов
из удаленного API и их возврата.

802 Глава 22 Создание фоновых задач и сервисов
while(!cancellationRequested)
{
var rates = _client.GetRates()
_cache.SetRates(rates)
Task.Delay(5 minutes)
}
GET /values 200 OK
ValuesControllerКеш
КешФоновая задача выполняется в течение всего
жизненного цикла приложения, выполняя цикл,
пока приложение не завершит работу
После получения последних курсов валют
фоновая задача бездействует в течение 5 минут,
прежде чем снова получить последние котировки
Когда контроллер API
получает запрос на получение
последних котировок,
он может получить значения
непосредственно из кешаФоновая задача
периодически получает
последние тарифы от
стороннего сервиса
Котировки хранятся в глобальном
кеше, доступном во всем
приложении
Рис. 22.1 Вы можете использовать фоновую задачу для кеширования результатов стороннего
API по расписанию. Затем контроллер API может читать непосредственно из кеша, вместо того
чтобы вызывать сам сторонний API. Это уменьшает задержку запросов к вашему контроллеру
API, обеспечивая при этом актуальность данных
ПРИМЕЧАНИЕ  В  качестве альтернативного подхода можно до-
бавить кеширование в строго типизированного клиента Exchang-
eRateClient. Обратной стороной такого подхода является тот факт,
что, когда вам нужно обновить курсы, придется выполнить запрос
немедленно, а это замедлит общий ответ. Использование фоновой
службы обеспечивает стабильную работу вашего контроллера API.
Вы можете реализовать фоновую задачу с  по мощью интерфейса
IHostedService. Он состоит из двух методов:
public interface IHostedService
{
Task StartAsync(CancellationToken cancellationToken);
Task StopAsync(CancellationToken cancellationToken);
}
Существуют тонкости для правильной реализации интерфейса. В част -
ности, метод StartAsync(), хотя и является асинхронным, выполняется
встроенно как часть запуска вашего приложения.
Фоновые задачи, которые, как ожидается, будут выполняться в тече-
ние всего жизненного цикла вашего приложения, должны незамедли-
тельно вернуть Task и запланировать фоновую работу в другом потоке.

803 Запуск фоновых задач с по мощью интерфейса IHostedService
ВНИМАНИЕ!  Вызов await в методе IHostedService.StartAsync()
блокирует запуск вашего приложения до завершения метода. В не-
которых случаях это может быть полезно, но часто нежелательно
для фоновых задач.
Чтобы упростить создание фоновых сервисов с  использованием пе-
редовых паттернов, ASP .NET Core предоставляет абстрактный базовый
класс BackgroundService, который реализует интерфейс IHostedService
и  используется для длительных задач. Чтобы создать фоновую задачу,
нужно переопределить единственный метод этого класса, ExecuteAsync().
Вы можете использовать async-await внутри этого метода и продолжать
использовать метод в течение всего жизненного цикла приложения.
Например, в следующем листинге показан фоновый сервис, который
извлекает последние процентные ставки с по мощью типизированного
клиента и сохраняет их в кеше, как было показано на рис. 22.1. Метод
ExecuteAsync() продолжает цикл и обновляет кеш до тех пор, пока Can-
cellationToken, переданный в качестве аргумента, не укажет, что при-
ложение завершает работу.
Листинг 22.2  Реализация класса BackgroundService, который вызывает
удаленный API для протокола HTTP
public class ExchangeRatesHostedService : BackgroundService
{
private readonly IServiceProvider _provider;
private readonly ExchangeRatesCache _cache;
public ExchangeRatesHostedService(
IServiceProvider provider, ExchangeRatesCache cache)
{
_provider = provider;
_cache = cache;
}
protected override async Task ExecuteAsync(
CancellationToken stoppingToken)
{
while (!stoppingToken.IsCancellationRequested)
{
var client = _provider
.GetRequiredService<ExchangeRatesClient>();
string rates = await client.GetLatestRatesAsync();
_cache.SetRates(rates);
await Task.Delay(TimeSpan.FromMinutes(5), stoppingToken);
}
}
}Наследуем от BackgroundService, чтобы создать задачу, которая будет выполняться
в течение всего жизненного цикла вашего приложения.
Внедряем IServiceProvider,
чтобы вы могли создавать
экземпляры
типизированного клиента.Простой кеш
для курсов
валют.
Вы должны переопределить ExecuteAsync,
чтобы настроить поведение сервиса.
CancellationT oken, переданный
в качестве аргумента,
запускается при завершении
работы приложения.Продолжаем
цикл, пока
приложение
не закроется.
Создаем новый
экземпляр
типизированного
клиента, чтобы
HttpClient был
недолговечным.
Получаем последние курсы из удаленного API.Сохраняем курсы в кеше.Ждем 5 минут (или пока приложение
не завершит работу) перед обновлением кеша.

804 Глава 22 Создание фоновых задач и сервисов
ExchangeRateCache из листинга 22.2  – это простой объект-одиночка,
в  котором хранятся последние курсы обмена валют. Он должен быть
потокобезопасным, так как ваши контроллеры API будут обращаться
к нему одновременно. Простую реализацию можно увидеть в исходном
коде этой главы.
Чтобы зарегистрировать фоновый сервис в контейнере внедрения за-
висимостей, используйте метод расширения AddHostedService() в  ме-
тоде ConfigureServices() файла Startup.cs, как показано в  следующем
листинге.
Листинг 22.3  Регистрация IHostedService в контейнере внедрения
зависимостей
public void ConfigureServices(IServiceCollection services)
{
services.AddHttpClient<ExchangeRatesClient>();
services.AddSingleton<ExchangeRatesCache>();
services.AddHostedService<ExchangeRatesHostedService>();
}
Используя фоновый сервис для получения курсов валют, ваш контрол-
лер API становится очень простым. Вместо того чтобы извлекать самые
последние курсы, он возвращает значение из кеша, которое обновляется
фоновым сервисом:
[ApiController]
public class ValuesController : ControllerBase
{
private readonly ExchangeRatesCache _cache;
public ValuesController(ExchangeRatesCache cache)
{
_cache = cache;
}
[HttpGet("values"]
public string GetValues()
{
return _cache.GetLatestRates();
}
}
В листинге 22.2 есть один своеобразный аспект. Он заключается в том,
что я использовал паттерн Локатор	 сервисов	 для получения типизиро-
ванного клиента. Это не идеальный вариант, но вам не следует напря-
мую внедрять типизированных клиентов в фоновые сервисы. Эти кли-
енты предназначены для кратковременного существования, чтобы вы
могли воспользоваться преимуществами ротации обработчиков Http-
Client, как описано в главе 21. Напротив, фоновые сервисы – это сингл-Регистрируем
типизированного клиента,
как и раньше.
Добавляем объект кеша в качестве объекта-одиночки,
потому что вы должны использовать один и тот же
экземпляр во всем приложении.Регистрируем сервис
ExchangeRatesHostedService как IHostedService.

805 Запуск фоновых задач с по мощью интерфейса IHostedService
тоны, которые существуют в  течение всего жизненного цикла вашего
приложения.
СОВЕТ  При желании можно избежать использования паттерна
Локатор	 сервисов	 из листинга 22.2, используя паттерн Фабрика,
описанный в посте Стива Гордона: http://mng.bz/opDZ.
Потребность в краткосрочных сервисах порождает еще один распро-
страненный вопрос – как использовать сервисы с  жизненным циклом
Scoped в фоновой задаче?
22.1.2 Использование сервисов с жизненным циклом Scoped
в фоновых задачах
Фоновые сервисы, реализующие интерфейс IHostedService, создаются
один раз при запуске вашего приложения. Это означает, что по необхо-
димости они являются синглтонами, поскольку экземпляр класса всегда
будет только один.
Это приводит к проблеме, если вам нужно использовать сервисы, за-
регистрированные с жизненным циклом Scoped. Любые сервисы, кото-
рые вы внедряете в конструктор своего синглтона IHostedService, сами
должны быть зарегистрированы как синглтоны. Означает ли это, что фо-
новому сервису нельзя использовать зависимости с жизненным циклом
Scoped?
НАПОМИНАНИЕ  Как я уже говорил в главе 10, зависимости сер-
виса всегда должны иметь такой же или более продолжительный
жизненный цикл, чем сам сервис, чтобы избежать захваченных за-
висимостей.
Например, давайте представим небольшую вариацию примера c ке-
шированием из раздела 22.1.1. Вместо того чтобы хранить курсы ва-
лют в объекте-одиночке, вы хотите хранить курсы в базе данных, чтобы
иметь возможность искать старые курсы.
Большинство поставщиков баз данных, включая DbContext от EF Core,
регистрируют свои сервисы с жизненным циклом Scoped. Это означает,
что вам нужно получить доступ к  DbContext с жизненным циклом Scoped
изнутри синглтон-сервиса ExchangeRatesHostedService, что исключает
внедрение DbContext с по мощью внедрения конструктора. Решение со-
стоит в том, чтобы создавать новую область контейнера каждый раз, ког -
да вы обновляете обменные курсы.
В типичных приложениях ASP .NET Core фреймворк создает новую
область контейнера каждый раз при получении нового запроса, непо-
средственно перед выполнением конвейера промежуточного ПО. Все
сервисы, которые используются в этом запросе, извлекаются из scoped-
контейнера. Однако в фоновом сервисе запросы	 отсутствуют, поэтому
области контейнера не создаются. Решение – создать собственную.

806 Глава 22 Создание фоновых задач и сервисов
Вы можете создать новую область контейнера везде, где есть доступ
к IServiceProvider, вызвав метод IServiceProvider.CreateScope(). Так
вы создаете контейнер, который можно использовать для получения
сервисов с жизненным циклом Scoped.
ВНИМАНИЕ!  Всегда избавляйтесь от IServiceScope, который
возвращает метод CreateScope(), когда закончите с ним, обычно
с  по мощью инструкции using. Так вы удалите все сервисы, ко-
торые были созданы контейнером с  жизненным циклом Scoped,
и предотв ратите утечку памяти.
В следующем листинге показана версия сервиса ExchangeRatesHost-
edService, которая хранит последние курсы обмена валюты в качестве
сущности EF Core в базе данных. Здесь мы создаем новую область для
каждой итерации цикла while и  извлекаем AppDbContext с  жизненным
циклом Scoped из контейнера.
Листинг 22.4  Использование сервисов с жизненным циклом Scoped
из IHostedService
public class ExchangeRatesHostedService : BackgroundService
{
private readonly IServiceProvider _provider;
public ExchangeRatesHostedService(IServiceProvider provider)
{
_provider = provider;
}
protected override async Task ExecuteAsync(
CancellationToken stoppingToken)
{
while (!stoppingToken.IsCancellationRequested)
{
using(IServiceScope scope = _provider.CreateScope())
{
var scopedProvider = scope.ServiceProvider;
var client = scope.ServiceProvider
.GetRequiredService<ExchangeRatesClient>();
var context = scope.ServiceProvider
.GetRequiredService<AppDbContext>();
var rates= await client.GetLatestRatesAsync();
context.Add(rates);
await context.SaveChanges(rates);
}BackgroundService регистрируется
в качестве объекта-одиночки.
Внедренный IServiceProvider можно
использовать для получения сервисов
с жизненным циклом Singleton
или для создания областей действия.
Создаем новую область
с по мощью корневого
IServiceProvider.Область действия предоставляет
IServiceProvider, который можно
использовать для получения
компонентов
с заданной областью
действия.
Извлекаем из
контейнера сервисы
с жизненным циклом
Scoped.
Получаем последние
котировки
и сохраняем их
с помощью EF Core.Удаляем область действия
с по мощью оператора
using.

807 Создание сервисов рабочей роли без пользовательского интерфейса
await Task.Delay(TimeSpan.FromMinutes(5), stoppingToken);
}
}
}
Создание таких областей – общее решение, когда вы обнаруживаете,
что вам нужен доступ к сервисам с жизненным циклом Scoped, и вы не
работаете в контексте запроса. Яркий пример – реализация интерфейса
IConfigureOptions, как было показано в главе 19. Вы можете использо-
вать тот же подход – создав новую область, – как показано в посте моего
блога под названием «Доступ к сервисам внутри ConfigureServices с по-
мощью IConfigureOptions в ASP .NET Core»: http://mng.bz/nMD5.
СОВЕТ  Использование локации сервисов таким образом всегда
кажется немного запутанным. Обычно я пытаюсь извлечь тело за-
дачи в отдельный класс и использовать локацию сервисов только
для получения этого класса. Пример этого подхода можно увидеть
в  разделе «Использование службы с  жизненным циклом Scoped
в фоновой задаче» документа Microsoft «Фоновые задачи с разме-
щенными службами в ASP .NET Core»: http://mng.bz/4ZER.
IHostedService доступен в  ASP .NET Core, поэтому вы можете запус -
кать фоновые задачи на страницах Razor или в  приложениях с  API-
контроллерами. Однако иногда все, что вам необходимо, – это фоновая
задача, и  вам не нужен пользовательский интерфейс. В таких случаях
можно использовать низкоуровневую абстракцию IHost, абсолютно не
беспокоясь об обработке HTTP .
22.2 Создание сервисов рабочей роли
без пользовательского интерфейса
с использованием IHost
В этом разделе вы узнаете о сервисах рабочей роли, которые представля-
ют собой приложения ASP .NET Core, не обрабатывающие HTTP-трафик.
Вы узнаете, как создать новый сервис рабочей роли из шаблона, и срав-
ните сгенерированный код с традиционным приложением ASP .NET Core,
а также узнаете, как установить сервис рабочей роли в качестве службы
Windows или как демона systemd в Linux.
В разделе 22.1 мы кешировали курсы обмена валют, исходя из предпо-
ложения, что они потребляются напрямую пользовательским интерфей-
сом вашего приложения: Razor Pages или контроллерами API, например.
Однако в примере из раздела 22.1.2 мы сохранили курсы в базе данных,
вместо того чтобы хранить их в процессе. Это увеличивает вероятность
того, что другие приложения будут иметь доступ к  базе данных, также
используя эти курсы. Пойдем еще дальше: можно создать приложение, Ждем следующей итерации.
На следующей итерации создается новая область действия.

808 Глава 22 Создание фоновых задач и сервисов
которое отвечает только за кеширование этих курсов и вообще не имеет
пользовательского интерфейса?
Начиная с .NET Core версии 3.0 ASP .NET Core основывается на «уни-
версальной» (в отличие от «сетевой») реализации интерфейса IHost. Это
реализация, которая предоставляет такие функции, как конфигурация,
журналирование и  внедрение зависимостей. ASP .NET Core добавляет
конвейер промежуточного ПО для обработки HTTP-запросов, а  также
такие парадигмы, как Razor Pages или MVC, как показано на рис. 22.2.
ASP.NET Core
IHostПромежу-
точное ПО
Журнали-
рование
Конфигурация
Внедрение
зависимостейStartup.cs
Razor Page
Контроллеры
# MVC/API
Дополнительные
модели приложенийОбобщенная абстракция
IHost для .NET Core
обеспечивает абстракции
журналирования,
конфигурации и внедрения
зависимостейASP .NET Core добавляет обработку
HTTP с использованием
промежуточного ПО и файла
Startup.cs для отделения
конфигурирования внедрения
зависимостей и промежуточного ПО
от конфигурирования хоста
Помимо промежуточного ПО,
вы можете при желании добавить
модели программирования, такие как
Razor Pages и контроллеры API
Рис. 22.2 ASP.NET Core основан на реализации обощенного интерфейса IHost. IHost
предоставляет такие функции, как конфигурация, внедрение зависимостей и журналирование.
В ASP.NET Core к этому добавляется обработка HTTP-запросов с по мощью конвейера
промежуточного ПО, Razor Pages и контроллеры API. Если вам не нужна обработка
HTTP-запросов, вы можете использовать IHost без дополнительных библиотек ASP.NET Core
для создания небольшого приложения
Если вашему приложению не требуется обрабатывать HTTP-запросы,
нет реальной причины использовать ASP .NET Core. Вы можете приме-
нять только реализацию IHost для создания приложения, которое будет
иметь меньший объем памяти, более быстрый запуск и меньшее коли-
чество внешних интерфейсов, о которых следует беспокоиться с точки
зрения безопасности, вместо полноценного приложения ASP .NET Core.
Приложения .NET Core, использующие данный подход, обычно называ-
ются сервисами	рабочей	роли.
ОПРЕДЕЛЕНИЕ  Сервис	рабочей	 роли –	это приложение .NET Core,
которое использует обобщенный интерфейс IHost, но не включает
в себя библиотеки ASP .NET Core для обработки HTTP-запросов.
Иногда их называют «безголовыми» (headless), поскольку они не предо-
ставляют пользовательский интерфейс, с  которым можно взаимодей-
ствовать.
Сервисы рабочей роли обычно используются для выполнения фоно-
вых задач (реализации IHostedService), для которых не требуется поль-
зовательский интерфейс. Это могут быть задачи для запуска пакетных

809 Создание сервисов рабочей роли без пользовательского интерфейса
заданий, многократного выполнения задач по расписанию или для об-
работки событий с использованием шины сообщений. В следующем раз-
деле мы создадим сервис рабочей роли для получения последних курсов
валют из удаленного API, вместо того чтобы добавлять фоновую задачу
в приложение ASP .NET Core.
22.2.1 Создание сервиса рабочей роли из шаблона
В этом разделе вы увидите, как создать базовый сервис рабочей роли из
шаблона. Visual Studio включает в  себя шаблон для создания сервисов
рабочей роли: выберите File > New > Project > Worker Service. Можно
создать аналогичный шаблон с по мощью интерфейса командной стро-
ки .NET, выполнив команду dotnet new worker. Полученный в результате
шаб  лон состоит из двух файлов C#:
Worker.cs  – это простая реализация класса BackgroundService, ко -
торая ведет запись в журнал каждую секунду. Вы можете заменить
этот класс собственной реализацией фонового сервиса, например
воспользовавшись кодом из листинга 22.4;
Program.cs – как и в типичном приложении ASP .NET Core, он содер-
жит точку входа для вашего приложения, и именно там создается
и запускается IHost. В отличие от типичного приложения ASP .NET
Core, здесь вы также настраиваете контейнер внедрения зависимо-
стей для своего приложения.
Наиболее заметное различие между шаблоном сервиса рабочей роли
и  шаблоном ASP .NET Core заключается в  отсутствии файла Startup.cs.
В приложениях ASP .NET Core файл Startup.cs – это то место, где вы обыч-
но настраиваете контейнер внедрения зависимостей и конвейер проме-
жуточного ПО. У сервиса рабочей роли нет конвейера промежуточного
ПО (поскольку он не обрабатывает HTTP-запросы), но он использует
внедрение зависимостей. Так где же он настраивается?
В шаблонах сервисов рабочей роли внедрение зависимостей настра-
ивается в файле Program.cs с по мощью метода ConfigureServices(), как
показано в следующем листинге. Этот метод функционально идентичен
методу ConfigureServices() в файле Startup.cs, поэтому вы можете ис -
пользовать точно такой же синтаксис. В  следующем листинге показа-
но, как настроить EF Core, типизированного клиента для курсов обмена
валют из главы 21 и фоновый сервис, который сохраняет курсы обмена
в базе данных, как было показано в разделе 22.1.2.
Листинг 22.5  Файл Program.cs для сервиса рабочей роли,
который сохраняет курсы обмена валют с по мощью EF Core
public class Program
{
public static void Main(string[] args)
{
CreateHostBuilder(args).Build().Run();Сервис рабочей роли создает IHostBuilder
и IHost и запускает его так же, как это
делает приложение ASP.NET Core.

810 Глава 22 Создание фоновых задач и сервисов
}
public static IHostBuilder CreateHostBuilder(string[] args) =>
Host.CreateDefaultBuilder(args)
.ConfigureServices((hostContext, services) =>
{
services.AddHttpClient<ExchangeRatesClient>();
services
.AddHostedService<ExchangeRatesHostedService>();
services.AddDbContext<AppDbContext>(options =>
options.UseSqlite(
hostContext.Configuration
.GetConnectionString("SqlLiteConnection"))
);
});
}
СОВЕТ  Вы также можете использовать методы IHostBuilder.
ConfigureServices() в  приложениях ASP .NET Core, но по обще-
му соглашению вместо них используется файл Startup.cs. Методы
IHostBuilder полезны в некоторых случаях, когда вам нужно точно
контролировать время запуска фоновых задач, о чем пишу в по-
сте «Управление порядком выполнения IHostedService в ASP .NET.
Core 3.x»: http://mng.bz/Qm66.
Изменения в файле Program.cs и отсутствие файла Startup.cs являются
наиболее очевидными различиями между сервисом рабочей роли и при-
ложением ASP .NET Core, но есть и некоторые важные различия в фай-
ле проекта с расширением .csproj. В следующем листинге показан файл
проекта для сервиса рабочей роли, использующий интерфейс IHttpCli-
entFactory и EF Core. Здесь выделены некоторые отличия от аналогично-
го приложения ASP .NET Core.
Листинг 22.6 Файл проекта для сервиса рабочей роли
<Project Sdk="Microsoft.NET.Sdk.Worker">
<PropertyGroup>
<TargetFramework>net5.0</TargetFramework>
<UserSecretsId>5088-4277-B226-DC0A790AB790</UserSecretsId>
</PropertyGroup>
<ItemGroup>
<PackageReference Include="Microsoft.Extensions.Hosting"
Version="5.0.0" />
<PackageReference Include="Microsoft.Extensions.Http"
Version="5.0.0" />Используется тот
же код HostBuilder,
но нет вызова
ConfigureWeb-
HostDefaults.Добавляем
сервисы
в ConfigureServices,
как вы обычно
это делаете
в Startup.cs.
Доступ к IConfiguration можно получить
с помощью параметра HostBuilderContext.
Сервисы рабочей роли используют другой тип
Project SDK, в отличие от приложений ASP.NET Core.
Целевой
фреймворк
такой же,
как и для
приложений
ASP.NET Core.Сервисы рабочей роли применяют
конфигурацию, поэтому они могут
использовать UserSecrets,
как и приложения ASP.NET Core.
Все сервисы рабочей роли должны явно добавить этот пакет.
Приложения ASP.NET Core добавляют его неявно.
Если вы используете IHttpClientFactory, вам нужно будет добавить этот пакет в сервисы рабочей роли.

811 Создание сервисов рабочей роли без пользовательского интерфейса
<PackageReference Include="Microsoft.EntityFrameworkCore.Design"
Version="5.0.0" PrivateAssets="All" />
<PackageReference Include="Microsoft.EntityFrameworkCore.Sqlite"
Version="5.0.0" />
</ItemGroup>
</Project>
Некоторые части файла проекта одинаковы как для сервисов рабочей
роли, так и для приложений ASP .NET Core:
оба типа приложений должны указывать <TargetFramework>, напри-
мер netcoreapp3.1 для .NET Core 3.1 или net5.0 для .NET 5.0;
оба типа приложений используют систему конфигурации, поэтому
вы можете использовать <UserSecretsId> для управления секретами
в окружении разработки, как описано в главе 11;
оба типа приложений должны явно добавлять ссылки на пакеты
NuGet EF Core, чтобы использовать EF Core в приложении.
В шаблоне проекта также есть несколько отличий:
атрибут Sdk элемента <Project> для сервиса рабочей роли должен
выглядеть так: Microsoft.NET.Sdk.Worker, а  для приложения ASP .
NET Core – Microsoft.NET.Sdk.Web. Web SDK включает в себя неявные
ссылки на дополнительные пакеты, которые обычно не требуются
в сервисах рабочей роли;
сервис рабочей роли должен включать явную ссылку на PackageRe-
ference для пакета Microsoft. Extensions.Hosting. Этот пакет включа-
ет в себя универсальную реализацию IHost, используемую сервиса-
ми рабочей роли;
возможно, вам потребуется включить дополнительные пакеты для
ссылки на ту же функциональность по сравнению с  приложени-
ем ASP .NET Core. Пример  – пакет Microsoft.Extensions.Http (кото-
рый предоставляет IHttpClientFactory). На него неявно ссылаются
в приложениях ASP .NET Core, но в сервисах рабочей роли это следу -
ет делать явно.
Запуск сервиса рабочей роли аналогичен запуску приложения ASP .
NET Core: используйте команду dotnet run из командной строки или на-
жмите клавишу F5 в Visual Studio. По сути, сервис рабочей роли – это
просто консольное приложение (как и  приложения ASP .NET Core), по-
этому запускается так же.
Сервисы рабочей роли можно запускать практически в тех же местах,
что и приложение ASP .NET Core, хотя, поскольку сервис рабочей роли не
обрабатывает HTTP-трафик, некоторые параметры имеют больше смыс -
ла. В следующем разделе мы рассмотрим два поддерживаемых способа
запуска вашего приложения: в качестве службы Windows или в качестве
демона systemd Linux.Пакеты EF Core должны быть добавлены явно,
как и для приложений ASP.NET Core.

812 Глава 22 Создание фоновых задач и сервисов
22.2.2 Запуск сервисов рабочей роли в промышленном
окружении
В этом разделе вы узнаете, как запускать сервисы рабочей роли в про-
мышленном окружении. Вы узнаете, как установить сервис рабочей роли
в качестве службы Windows, чтобы операционная система отслеживала
и запускала его автоматически, а также как подготовить свое приложе-
ние для установки в качестве демона systemd в Linux.
Сервисы рабочей роли, как и приложения ASP .NET Core, в основном
представляют собой консольные приложения .NET Core. Разница состо-
ит в том, что обычно они предназначены для приложений с длительным
временем запуска. Обычным подходом к запуску этих типов приложе-
ний в Windows является использование службы Windows или использо-
вание демона systemd в Linux.
ПРИМЕЧАНИЕ  Также очень часто приложения запускают в  об-
лаке с  использованием контейнеров Docker или специализиро-
ванных платформ, таких как Azure App Service. Процесс разверты-
вания сервиса рабочей роли в этих управляемых службах обычно
идентичен развертыванию приложения ASP .NET Core.
Добавить поддержку служб Windows или systemd очень просто благо-
даря двум дополнительным пакетам NuGet:
Microsoft.Extensions.Hosting.Systemd  – добавляет поддержку для за-
пус ка приложения в виде приложения systemd. Чтобы активировать
интеграцию с systemd, вызовите метод UseSystemd() в своем IHost-
Builder в файле Program.cs;
Microsoft.Extensions.Hosting.WindowsServices  – добавляет поддержку
для запуска приложения в качестве службы Windows. Чтобы активи-
ровать интеграцию, вызовите метод UseWindowsService() для IHost-
Builder в файле Program.cs.
Каждый из них добавляет один метод расширения к  IHostBuilder,
который обеспечивает соответствующую интеграцию при запуске в ка-
честве демона systemd или службы Windows. Например, в  следующем
лис тинге показано, как активировать поддержку службы Windows.
Листинг 22.7  Добавление поддержки службы Windows в сервис
рабочей роли
public class Program
{
public static void Main(string[] args)
{
CreateHostBuilder(args).Build().Run();
}

813 Создание сервисов рабочей роли без пользовательского интерфейса
public static IHostBuilder CreateHostBuilder(string[] args) =>
Host.CreateDefaultBuilder(args)
.ConfigureServices((hostContext, services) =>
{
services.AddHostedService<Worker>();
})
.UseWindowsService();
}
Во время разработки или если вы запускаете свое приложение как
консольное, использование метода WindowsService() ничего не дает; оно
работает точно так же, как и без вызова метода. Однако теперь прило-
жение можно установить в качестве службы Windows, поскольку у него
есть необходимые средства интеграции для работы с  системой служб
Windows.
Следующие шаги показывают, как установить сервис рабочей роли
в качестве службы Windows.
1  Добавьте пакет Microsoft.Extensions.Hosting.WindowsServices в свое
приложение с  по мощью Visual Studio, выполнив команду dotnet
add package Microsoft.Extensions.Hosting.WindowsServices в папке
проекта или добавив элемент <PackageReference> в файл с расши-
рением .csproj:
<PackageReference Include="Microsoft.Extensions.Hosting.WindowsServices"
Version="5.0.0" />
2  Добавьте вызов метода UseWindowsService() интерфейса IHost-
Builder, как показано в листинге 22.7.
3  Опубликуйте приложение, как описано в  главе 16. Из командной
строки вы можете выполнить команду dotnet publish -c Release из
папки проекта.
4  Откройте командную строку от имени администратора и устано-
вите приложение с по мощью утилиты Windows sc. Вам необходимо
указать путь к файлу опубликованного проекта с расширением .exe
и имя, которое будет использоваться для службы, например My Test
Service:
sc create "My Test Service" BinPath="C:\path\to\MyService.exe"
5  Вы можете управлять службой из панели управления службами
в Windows, как показано на рис. 22.3. В качестве альтернативы, что-
бы запустить службу из командной строки, выполните команду sc
start "My Test Service" или, чтобы удалить службу, воспользуйтесь
командой sc delete "My Test Service".
После выполнения этих шагов сервис рабочей роли будет работать как
служба Windows.Настраиваем
сервис
рабочей роли,
как обычно.Добавляем поддержку запуска
в качестве службы Windows.

814 Глава 22 Создание фоновых задач и сервисов
Рис. 22.3 Панель управления службами в Windows. После установки сервиса рабочей
роли в качестве службы Windows с по мощью утилиты sc вы можете управлять им отсюда.
Это позволяет контролировать, когда служба Windows запускается и останавливается, с какой
учетной записью пользователя запускается приложение и способы обработки ошибок
ПРЕДУПРЕЖДЕНИЕ  Эти шаги  – лишь минимум, необходимый
для установки службы Windows. При работе в  промышленном
окружении нужно учитывать множество аспектов безопасности,
которые здесь не рассматриваются. Дополнительные сведения см.
в документе Microsoft: http://mng.bz/Xdy9.
Интересно отметить, что установка в  качестве службы Windows или
демона systemd не ограничивается только сервисами рабочей роли – точ-
но так же можно установить приложение ASP .NET Core. Просто следуйте
предыдущим инструкциям, добавьте вызов метода UseWindowsService()
и установите приложение ASP .NET Core. Все это осуществляется благода-
ря тому, что функциональность ASP .NET Core строится непосредственно
на универсальной функциональности Host.
Чтобы установить сервис рабочей роли в  качестве демона systemd,
можно выполнить аналогичный процесс, установив пакет Microsoft.Ex -
tensions.Hosting.Systemd и вызвав метод UseSystemd() для IHostBuilder.
Для получения дополнительных сведений о настройке systemd см. раз-
дел «Мониторинг приложения» в документации Microsoft: http://mng.bz/
yYDp.
До сих пор в этой главе мы использовали интерфейс IHostedService
и класс BackgroundService для выполнения задач, которые повторяются
с интервалом, и вы видели, как установить сервисы рабочей роли в ка-
честве приложений с длительным временем запуска, установив их как
службу Windows.
В последнем разделе этой главы мы рассмотрим, как создавать более
сложные расписания для фоновых задач, а также как повысить отказо-
устойчивость своего приложения, запустив несколько экземпляров сер-
висов рабочей роли. Для этого мы будем использовать стороннюю биб-
лиотеку Quartz.NET.

815 Координация фоновых задач с по мощью Quartz.NET
22.3 Координация фоновых задач с по мощью
Quartz.NET
В этом разделе вы узнаете, как использовать библиотеку планировщика
с открытым исходным кодом Quartz.NET, как установить и настроить ее,
а также как добавить фоновое задание для выполнения по расписанию.
Вы также узнаете, как активировать кластеризацию для своих приложе-
ний, чтобы можно было запускать несколько экземпляров сервиса рабо-
чей роли и обмениваться заданиями.
Все фоновые задачи, которые вы видели до сих пор в этой главе, по-
вторяют задачу с интервалом до бесконечности с момента запуска при-
ложения. Однако иногда нужно больше контроля. Может быть, вы всегда
хотите запускать приложение через 15 минут каждый час. Или, может
быть, вы хотите запустить задачу только во второй вторник месяца
в 3 ча са ночи. Кроме того, возможно, вам нужно запустить несколько эк -
земпляров своего приложения для обеспечения избыточности, но убе-
диться, что только одна из служб выполняет задачу одновременно.
Конечно, можно было бы самостоятельно встроить всю эту допол-
нительную функциональность в  приложение, но есть отличные биб-
лиотеки, у  которых уже все это есть. Две наиболее известные из них
в .NET-пространстве – это Hangfire (www.hangfire.io) и Quartz.NET (www.
quartz-scheduler.net).
Hangfire  – это библиотека с  открытым исходным кодом, у  которой
также имеется вариант подписки «Pro». Одной из ее самых популярных
функций является пользовательский интерфейс панели инструментов,
который показывает состояние всех ваших запущенных заданий, исто-
рию каждой задачи и любые возникающие ошибки.
Quartz.NET – это библиотека с полностью открытым исходным кодом.
По сути, она предлагает расширенную версию функциональности класса
BackgroundService. У нее имеются обширные возможности для планиро-
вания, а также она поддерживает работу в  кластерном окружении, где
несколько экземпляров вашего приложения координируют распределе-
ние заданий.
ПРИМЕЧАНИЕ  Quartz.NET основана на аналогичной библиоте-
ке Java под названием Quartz Scheduler. При поиске информации
о  Quartz.NET убедитесь, что это именно та библиотека, которая
вам нужна.
Quartz.NET основана на четырех основных концепциях:
задания – это фоновые задачи, реализующие вашу логику;
триггеры – определяют, когда задание будет запускаться по распи-
санию, например «каждые пять минут» или «каждый второй втор-
ник». У задания может быть несколько триггеров;

816 Глава 22 Создание фоновых задач и сервисов
фабрика	 заданий – фабрика заданий отвечает за создание экземпля-
ров заданий. Quartz.NET интегрируется с контейнером внедрения
зависимостей ASP .NET Core, поэтому вы можете использовать внед-
рение зависимостей в классах заданий;
планировщик  – планировщик Quartz.NET отслеживает триггеры
в вашем приложении, создает задания, используя фабрику заданий,
и запускает их. Обычно он работает как IHostedService на протяже-
нии всего жизненного цикла вашего приложения.
Фоновые сервисы и задания cron
Обычно задания cron используются для выполнения задач по расписанию
в Linux, а в Windows используется планировщик заданий. Они применяются
для периодического запуска приложения или файла сценария, что обычно
является кратковременной задачей.
Напротив, приложения .NET Core, использующие фоновые сервисы, спроек -
тированы как приложения с длительным жизненным циклом, даже если они
используются только для выполнения задач по расписанию. Это позволяет
приложению корректировать свое расписание по мере необходимости или
выполнять оптимизацию. Кроме того, долговечность означает, что вашему при-
ложению не нужно просто выполнять задачи по расписанию. Оно может реа-
гировать на специальные события, такие как события в очереди сообщений.
Конечно, если вам не нужны эти возможности и не нужно приложение с дли-
тельным временем запуска, можно использовать .NET Core в сочетании с за-
даниями cron. Вы можете создать простое консольное приложение .NET,
которое запускает задачу, а затем закрывается, и запланировать его перио-
дическое выполнение в качестве задания cron. Выбор за вами!
В этом разделе я покажу, как установить Quartz.NET и настроить фоно-
вый сервис для запуска по расписанию. Затем я объясню, как активиро-
вать кластеризацию, чтобы можно было запускать несколько экземпля-
ров приложения и распределять задания между ними.
22.3.1 Установка Quartz.NET в приложение ASP.NET Core
В этом разделе я покажу, как установить планировщик Quartz.NET в при-
ложение ASP .NET Core. Quartz.NET будет работать в фоновом режиме так
же, как и реализации IHostedService. Фактически Quartz.NET использует
абстракции IHostedService для планирования и выполнения заданий.
ОПРЕДЕЛЕНИЕ  Задание в Quartz.NET – это выполняемая задача,
реализующая интерфейс IJob. Здесь вы определяете логику, кото-
рую будут выполнять ваши задачи.
Quartz.NET можно установить в любое приложение .NET Core, поэтому
вы также увидите, как установить Quartz.NET в сервис рабочей роли. Мы

817 Координация фоновых задач с по мощью Quartz.NET
установим необходимые зависимости и настроим планировщик Quartz.
NET для работы в  качестве фонового сервиса в  сервисе рабочей роли.
В разделе 22.3.2 мы преобразуем задачу загрузчика курсов обмена валют
из раздела 22.1 в интерфейс Quartz.NET IJob и настроим триггеры для
запуска по расписанию.
ПРИМЕЧАНИЕ  Инструкции в этом разделе можно использовать
для установки Quartz.NET либо в сервис рабочей роли, либо в пол-
ноценное приложение ASP .NET Core. Единственная разница со-
стоит в том, используете ли вы метод ConfigureServices() в файле
Program.cs или Startup.cs.
Чтобы установить Quartz.NET, выполните следующие действия.
1  Установите пакет Quartz.AspNetCore в  свой проект, выполнив
коман ду dotnet add package Quartz.Extensions.Hosting, используя
обозреватель NuGet в  Visual Studio или добавив элемент <Pack-
ageReference> в файл проекта:
<PackageReference Include="Quartz.Extensions.Hosting" Version="3.2.3" />
2  Добавьте планировщик Quartz.NET IHostedService, вызвав метод
AddQuartzHostedService() в IServiceCollection в методе Configure-
Services, как показано ниже. Задайте для WaitForJobsToComplete
значение true, чтобы ваше приложение ожидало завершения всех
текущих заданий при завершении работы.
services.AddQuartzHostedService(q => q.WaitForJobsToComplete = true);
3  Настройте необходимые сервисы Quartz.NET в методе Configure-
Services. В  следующем листинге мы настраиваем фабрику зада-
ний Quartz.NET для получения реализаций заданий из контейнера
внед рения зависимостей с жизненным циклом Scoped и добавляем
требуемый сервис.
Листинг 22.8 Настройка Quartz.NET в методе ConfigureServices
public void ConfigureServices(IService collection)
{
services.AddQuartz(q =>
{
q.UseMicrosoftDependencyInjectionScopedJobFactory();
});
services.AddQuartzHostedService(
q => q.WaitForJobsToComplete = true);
}Добавляем Quartz.NET в файл Startup.cs для приложений
ASP.NET Core или в файл Program.cs для сервисов рабочей роли.
Регистрируем сервисы Quartz.NET
в контейнере внедрения зависимостей.
Настраиваем Quartz.NET для загрузки заданий
из контейнера внедрения зависимостей.
Добавляем IHostedService от Quartz.NET,
который запускает планировщик Quartz.NET.

818 Глава 22 Создание фоновых задач и сервисов
Эта конфигурация регистрирует все необходимые компоненты Quartz.
NET, поэтому теперь вы можете запускать свое приложение, используя
команду dotnet run или нажав клавишу F5 в Visual Studio. Когда ваше
приложение запускается, IHostedService запускает свой планировщик,
как показано на рис. 22.4. У нас еще нет заданий для запуска, поэтому
планировать пока нечего.
СОВЕТ  Рекомендуется запускать приложение до добавления
каких-либо заданий. Это позволяет проверить, правильно ли вы
установили и настроили Quartz.NET, прежде чем перейти к более
сложной конфигурации.
По умолчанию Quartz.NET
использует хранилище
в памяти для отслеживания
заданий и расписаний
По умолчанию
Quartz.NET работает
в некластеризованном
режиме, поэтому каждый
запущенный экземпляр
вашего приложения
независим
Для этого приложения
задания или триггеры
не настроены
Рис. 22.4 Планировщик Quartz.NET запускается при запуске приложения
и записывает его конфигурацию. В конфигурации по умолчанию список заданий
и их расписаний хранится в памяти и запускается в некластеризованном состоянии.
В этом примере видно, что не было зарегистрировано ни одного задания или
триггера, поэтому планировщику еще нечего планировать
Планировщик без заданий для планирования не очень полезен, поэто-
му в следующем разделе мы создадим задание и добавим триггер, чтобы
запускать его по таймеру.
22.3.2 Настройка запуска задания по расписанию с по мощью
Quartz.NET
В разделе 22.1 мы создали экземпляр интерфейса IHostedService, кото -
рый скачивает курсы обмена валют из удаленного сервиса и сохраняет
результаты в базе данных с по мощью EF Core. В этом разделе вы увидите,
как создать аналогичный экземпляр интерфейса Quartz.NET, IJob, и на-
строить его для запуска по расписанию.
В следующем листинге показана реализация IJob, загружающая по-
следние курсы обмена валют из удаленного API с по мощью типизиро-
ванного клиента ExchangeRatesClient. Затем результаты сохраняются
с использованием AppDbContext.

819 Координация фоновых задач с по мощью Quartz.NET
Листинг 22.9  Экземпляр IJob для загрузки и сохранения курсов
обмена валют
public class UpdateExchangeRatesJob : IJob
{
private readonly ILogger<UpdateExchangeRatesJob> _logger;
private readonly ExchangeRatesClient _typedClient;
private readonly AppDbContext _dbContext;
public UpdateExchangeRatesJob(
ILogger<UpdateExchangeRatesJob> logger,
ExchangeRatesClient typedClient,
AppDbContext dbContext)
{
_logger = logger;
_typedClient = typedClient;
_dbContext = dbContext;
}
public async Task Execute(IJobExecutionContext context)
{
_logger.LogInformation("Fetching latest rates");
var latestRates = await _typedClient.GetLatestRatesAsync();
_dbContext.Add(latestRates);
await _dbContext.SaveChangesAsync();
_logger.LogInformation("Latest rates updated");
}
}
Функционально IJob из листинга 22.9 выполняет задачу, аналогичную
реализации класса BackgroundService из листинга 22.4, с  несколькими
заметными исключениями:
IJob только	определяет	 задачу,	которую	 нужно	выполнить;	 он	не
определяет	 информацию	 о времени. В  реализации BackgroundSer-
vice мы также должны были контролировать частоту выполнения
задачи;
новый	экземпляр IJob создается	 каждый	раз	при	выполнении	 задания.
Напротив, реализация BackgroundService создается только один раз,
и его метод Execute вызывается только один раз;
мы	можем	внедрить	 зависимости	 с жизненным	 циклом	Scoped	непо-
средственно	 в реализацию IJob. Чтобы использовать зависимости
с  жизненным циклом Scoped в  реализации IHostedService, нам
пришлось вручную создать собственную область и  использовать
локацию сервисов для загрузки зависимостей. Quartz.NET делает
это за нас, позволяя использовать чистое внедрение конструктора.
Каждый раз, когда задание выполняется, создается новая область,
которая используется для создания нового экземпляра IJob.
IJob определяет, что выполнять, но не определяет, когда это делать.
Для этого Quartz.NET использует триггеры. Триггеры можно использо-Задания
Quartz.NET
должны
реализовывать
интерфейс IJob.Вы можете
использовать
стандартное внедрение
зависимостей для
внедрения любых
зависимостей.
IJob требует,
чтобы вы
реализовали
единственный
асинхронный
метод Execute.Скачиваем курсы
из удаленного API.
Сохраняем курсы в базу данных.

820 Глава 22 Создание фоновых задач и сервисов
вать для определения произвольно сложных интервалов времени, в те-
чение которого должно быть выполнено задание. Например, можно
указать начало и время окончания, сколько раз повторять и временные
интервалы, когда задание должно или не должно запускаться (например,
только с 9:00 до 17:00 с понедельника по пятницу).
В следующем листинге мы регистрируем UpdateExchangeRatesJob
в  контейнере внедрения зависимостей, используя метод AddJob<T>(),
и предоставляем уникальное имя для идентификации задания. Мы так -
же настраиваем триггер, который срабатывает немедленно, а затем каж -
дые пять минут, пока приложение не завершит работу.
Листинг 22.10 Настройка IJob и триггера
public void ConfigureServices(IService collection)
{
services.AddQuartz(q =>
{
q.UseMicrosoftDependencyInjectionScopedJobFactory();
var jobKey = new JobKey("Update exchange rates");
q.AddJob<UpdateExchangeRatesJob>(opts =>
opts.WithIdentity(jobKey));
q.AddTrigger(opts => opts
.ForJob(jobKey)
.WithIdentity(jobKey.Name + " trigger")
.StartNow()
.WithSimpleSchedule(x => x
.WithInterval(TimeSpan.FromMinutes(5))
.RepeatForever())
);
});
services.AddQuartzHostedService(q => q.WaitForJobsToComplete = true);
}
Простые триггеры, такие как определенное здесь расписание, доволь-
но распространены, но вы также можете получить более сложные кон-
фигурации, используя другое расписание. Например, следующая конфи-
гурация делает так, чтобы триггер запускался каждую неделю, в пятницу
в 17:30:
q.AddTrigger(opts => opts
.ForJob(jobKey)
.WithIdentity("Update exchange rates trigger")
.WithSchedule(CronScheduleBuilder
.WeeklyOnDayAndHourAndMinute(DayOfWeek.Friday, 17, 30))
С помощью Quartz.NET можно настроить широкий спектр триггеров
на основе времени и календаря. Вы также можете контролировать, как Создаем уникальный ключ задания,
чтобы связать его с триггером.
Добавляем IJob в контейнер
внедрения зависимостей
и связываем его с ключом задания.Регистрируем
триггер для IJob
с по мощью ключа
задания.
Указываем уникальное имя триггера, которое будет
использоваться при журналировании и в кластерных сценариях.Запускаем триггер, как только запускается
планировщик Quartz.NET при запуске приложения.Запускаем триггер
каждые пять минут,
пока приложение
не завершит работу.

821 Координация фоновых задач с по мощью Quartz.NET
Quartz.NET обрабатывает пропущенные триггеры, то есть триггеры, ко-
торые должны были сработать, но ваше приложение в то время не было
запущено. Чтобы увидеть подробное описание параметров конфигура-
ции триггера и другие примеры, см. документацию по Quartz.NET: www .
quartz-scheduler.net/documentation/.
СОВЕТ  Распространенная проблема, с которой приходится стал-
киваться при выполнении заданий с  длительным временем вы-
полнения, заключается в  том, что Quartz.NET будет продолжать
запускать новые экземпляры задания при срабатывании триггера,
даже если он уже запущен. Чтобы этого избежать, нужно указать
Quartz.NET не запускать другой экземпляр, декорировав свою реа-
лизацию IJob с по мощью атрибута [DisallowConcurrentExecution].
Возможность настраивать расширенные расписания, простое ис -
пользование внедрения зависимостей в  фоновых задачах и  отделение
заданий от триггеров – для меня этого достаточно, чтобы рекомендо-
вать Quartz.NET, если у вас есть что-то большее, чем самые простые по-
требности фоновых сервисов. Однако настоящий переломный момент
наступает, когда вам нужно масштабировать приложение по причинам
избыточности или производительности  – именно тогда возможности
кластеризации Quartz.NET проявляются во всей своей красе.
22.3.3 Использование кластеризации для добавления
избыточности в фоновые задачи
В этом разделе вы узнаете, как настроить Quartz.NET для сохранения его
конфигурации в базе данных. Это необходимый шаг для активации клас -
теризации, чтобы несколько экземпляров вашего приложения могли ко-
ординировать запуск заданий.
По мере того как ваши приложения становятся более популярными, вы
можете обнаружить, что вам нужно запускать больше экземпляров при-
ложения для обработки получаемого ими трафика. Если вы оставите при-
ложения ASP .NET Core без сохранения состояния, процесс масштабиро-
вания будет относительно простым: чем больше у вас есть приложений,
тем больше трафика вы сможете обработать при прочих равных условиях.
Однако масштабирование приложений, использующих IHostedService
для запуска фоновых задач, может оказаться не такой простой задачей.
Например, представьте, что ваше приложение включает в себя фоновый
сервис, который мы создали в разделе 22.1.2, сохраняющий курсы валют
в базе данных каждые пять минут. Когда вы запускаете один экземпляр
приложения, задача запускается каждые пять минут, как и ожидалось.
Но что произойдет, если масштабировать приложение и  запустить
десять его экземпляров? Каждое из этих приложений будет запускать
BackgroundService, и  все они будут обновляться каждые пять минут с мо-
мента запуска каждого экземпляра!

822 Глава 22 Создание фоновых задач и сервисов
Один из вариантов – переместить BackgroundService в отдельный сер-
вис рабочей роли. Затем вы можете продолжить масштабирование при-
ложения ASP .NET Core для обработки трафика по мере необходимости,
но развернуть один экземпляр сервиса рабочей роли. Поскольку будет
запущен только один экземпляр BackgroundService, курсы обмена валют
снова будут обновляться по правильному расписанию.
СОВЕТ  Разные требования к масштабированию, как в этом при-
мере, являются одной из самых подходящих причин для разделе-
ния больших приложений на более мелкие микросервисы. Однако
такое разделение приложения связано с накладными расходами на
сопровождение, поэтому подумайте о компромиссах, если решите
пойти по данному пути. Чтобы узнать больше об этом компромис -
се, я рекомендую книгу «Микросервисы	 в .NET	Core», 2-е изд., Крис -
тиана Хорсдала Гаммельгаарда (Manning, 2021).
Однако если вы выберете этот путь, то добавите жесткое ограничение,
согласно которому у вас может быть только один экземпляр сервиса ра-
бочей роли. Если вам нужно будет запустить больше экземпляров для
обработки дополнительной нагрузки, вы застрянете.
Альтернативным вариантом принудительного использования единого
сервиса является использование кластеризации. Кластеризация позволяет
запускать несколько экземпляров приложения, а задачи распределяются
между всеми его экземплярами. Quartz.NET обеспечивает кластеризацию,
используя базу данных в качестве резервного хранилища. Когда триггер
указывает, что задание необходимо выполнить, планировщики Quartz.
NET в каждом приложении пытаются получить блокировку для выполне-
ния задания, как показано на рис. 22.5. Только одно приложение может
быть успешным, если одно приложение обрабатывает триггер для IJob.
Quartz.NET полагается на базу данных для долговременного хранения
данных. Он хранит описания заданий и триггеров в базе данных, вклю-
чая время последнего срабатывания триггера. Это функции блокировки
базы данных, которые гарантируют, что только одно приложение может
выполнять задачу одновременно.
СОВЕТ  Можно активировать долговременное хранение без ис -
пользования кластеризации. Это позволяет планировщику Quartz.
NET корректно обработать пропущенные триггеры.
В следующем листинге показано, как активировать долговременное
хранение для Quartz.NET и, кроме того, кластеризацию. В этом примере
данные хранятся на сервере MS SQL Server (или LocalDB), но Quartz.NET
поддерживает множество других баз данных. В данном примере исполь-
зуются рекомендуемые значения для активации кластеризации и долго-
временного хранения, как указано в документации1.
1 В документации Quartz.NET обсуждается множество элементов управления па-
раметрами конфигурации для долговременного хранения: http://mng.bz/PP0R.

823 Координация фоновых задач с по мощью Quartz.NET
Задание 21.  Расписание триггера указывает,
что задание должно быть запущено
2.  Все экземпляры приложения пытаются
получить блокировку для запуска задания3.  Т олько один
экземпляр
получает
блокировку
задания,
экземпляр 3.
Экземпляр 3
может выполнить
заданиеПланировщик Qaurtz.Net Планировщик Qaurtz.Net Планировщик Qaurtz.Net
Рабочая служба 1 Рабочая служба 2 Рабочая служба 3
Блокировки заданий
Задание 1 – запуск
Задание 2 –
экземпляр 3
Рис. 22.5 Использование кластеризации с Quartz.NET допускает горизонтальное
масштабирование. Quartz.NET использует базу данных в качестве резервного хранилища,
гарантируя, что только один экземпляр приложения обрабатывает триггер за один раз.
Это дает возможность запускать несколько экземпляров приложения для удовлетворения
требований масштабируемости
Листинг 22.11  Активация долговременного хранения и кластеризации
для Quartz.NET
public void ConfigureServices(IService collection)
{
var connectionString = Configuration
.GetConnectionString("DefaultConnection");
services.AddQuartz(q =>
{
q.SchedulerId = "AUTO";
q.UseMicrosoftDependencyInjectionScopedJobFactory();
q.UsePersistentStore(s =>
{
s.UseSqlServer(connectionString);
s.UseClustering();
s.UseProperties = true;
s.UseJsonSerializer();
});
var jobKey = new JobKey("Update exchange rates");
q.AddJob<UpdateExchangeRatesJob>(opts =>
opts.WithIdentity(jobKey));
q.AddTrigger(opts => optsКонфигурация идентична как для приложений ASP.NET Core,
так и для сервисов рабочей роли.
Получаем строку подключения для
своей базы данных из конфигурации.
Каждый экземпляр приложения должен
иметь уникальный SchedulerId. Значение
AUTO позаботится об этом за вас.
Активируем долговременное хранение в базе
данных для данных планировщика Quartz.NET.Сохраняем данные
планировщика
в базе данных
SQL Server
(или LocalDb).
Активирует
кластеризацию
между несколькими
экземплярами
приложения.Добавляет рекомендуемую конфигурацию
для сохранения задания.

824 Глава 22 Создание фоновых задач и сервисов
.ForJob(jobKey)
.WithIdentity(jobKey.Name + " trigger")
.StartNow()
.WithSimpleSchedule(x => x
.WithInterval(TimeSpan.FromMinutes(5))
.RepeatForever())
);
});
services.AddQuartzHostedService(q => q.WaitForJobsToComplete = true);
}
В этой конфигурации Quartz.NET хранит список заданий и триггеров
в базе данных и использует блокировку базы данных, чтобы гарантиро-
вать, что только один экземпляр вашего приложения обрабатывает триг -
гер и запускает соответствующее задание.
ПРИМЕЧАНИЕ  SQLite не поддерживает примитивы блокиров-
ки базы данных, необходимые для кластеризации. Вы можете ис -
пользовать SQLite в качестве долговременного хранилища, но не
сможете использовать кластеризацию.
Quartz.NET хранит данные в вашей базе данных, но не пытается соз-
давать таблицы, которые использует сам. Нужно вручную добавлять не-
обходимые таблицы. Quartz.NET предоставляет SQL-скрипты на сайте
GitHub для всех поддерживаемых типов серверов баз данных, включая
MS SQL Server, SQLite, PostgreSQL, MySQL и многие другие: http://mng.
bz/JDeZ.
СОВЕТ  Если вы используете миграции EF Core для управления
своей базой данных, то предлагаю использовать их даже для таких
специальных сценариев. В  примере кода для этой главы можно
увидеть миграцию, которая создает необходимые таблицы с  по-
мощью скриптов Quartz.NET.
Кластеризация – одна из тех расширенных функций, которая необ-
ходима только в начале масштабирования приложения, но это важный
инструмент, который нужно иметь наготове. Она дает вам возможность
безопасно масштабировать свои сервисы по мере добавления новых за-
даний. Однако следует помнить о  некоторых важных вещах, поэтому
я предлагаю прочитать предупреждения, приведенные в документации
Quartz.NET: http://mng.bz/aozj.
На этом мы подошли к  концу главы, посвященной фоновым серви-
сам. В  последней главе этой книги я  опишу один важный аспект веб-
разработки, который иногда, несмотря на самые лучшие намерения,
часто оставляют напоследок: тестирование. Вы узнаете, как писать прос -
тые модульные тесты для своих классов, как проектировать приложения
с возможностью тестирования и как создавать интеграционные тесты,
чтобы протестировать все приложение.

825 Резюме
Резюме
 Вы можете использовать интерфейс IHostedService для запуска за-
дач в  фоновом режиме приложений ASP .NET Core. Вызовите метод
AddHostedService<T>(), чтобы добавить реализацию Т в  контейнер
внедрения зависимостей. IHostedService полезен для реализации за-
дач с длительным временем выполнения.
Как правило, для создания экземпляра IHostedService нужно наследо-
вать от класса BackgroundService, поскольку он реализует передовые
практики, необходимые для задач с длительным временем выполне-
ния. Вы должны переопределить единственный метод ExecuteAsync,
который вызывается при запуске приложения. Вы должны запускать
свои задачи в этом методе, пока предоставленный CancellationToken
не укажет на то, что приложение завершает работу.
Вы можете вручную создавать области внедрения зависимостей с по-
мощью IServiceProvider.CreateScope(). Это полезно для доступа
к сервисам с жизненным циклом Scoped в рамках компонента с жиз-
ненным циклом Singleton, например из реализации IHostedService.
Сервис	рабочей	 роли –	это приложение .NET Core, использующее обоб-
щенный интерфейс IHost, но оно не включает в себя библиотеки ASP .
NET Core для обработки HTTP-запросов. Обычно оно имеет меньший
объем памяти и дискового пространства, по сравнению с аналогами
ASP .NET Core.
Сервисы рабочей роли используют те же системы журналирования,
конфигурации и внедрения зависимостей, что и приложения ASP .NET
Core. Однако они не используют файл Startup.cs, поэтому нужно на-
страивать свои сервисы внедрения зависимостей в  IHostBuilder.Con-
figureServices().
Чтобы запустить сервис рабочей роли или приложение ASP .NET Core
как службу Windows, добавьте пакет Microsoft.Extensions.Hosting.
Win dowsServices и  вызовите метод UseWindowsService() интерфейса
IHost Builder. Вы можете установить свое приложение и управлять им
с по мощью утилиты Windows, sc.
Чтобы установить демон systemd в  Linux, добавьте пакет Microsoft.
Extensions.Hosting.Systemd и вызовите метод AddSystemd() для IHost-
Builder. Оба пакета ничего не делают при запуске приложения в ка-
честве консольного приложения, что отлично подходит для тестиро-
вания приложения.
Quartz.NET запускает задания на основе триггеров с использованием
расширенных расписаний. Он основан на реализации IHostedService,
чтобы добавлять дополнительные функции и масштабируемость. Вы
можете установить Quartz, добавив NuGet-пакет Quartz.AspNetCore
и вызвав методы AddQuartz() и  AddQuartzHostedService() в  Configure-
Services().
Вы можете создать задание Quartz.NET, реализовав интерфейс IJob.
Он требует реализации единственного метода, Execute. Можно акти-
вировать внедрение зависимостей для задания, вызвав UseMicrosoft-

826 Глава 22 Создание фоновых задач и сервисов
DependencyInjectionScopedJobFactory в методе AddQuartz(). Это позво-
ляет напрямую внедрять сервисы с жизненными циклами Scoped или
Transient в свое задание, не создавая собственных областей.
Вы должны зарегистрировать свое задание T с  по мощью внедрения
зависимостей, вызвав метод AddJob<T>() и указав JobKey. Можно до-
бавить ассоциированный триггер, вызвав метод AddTrigger() и предо-
ставив JobKey. Для триггеров доступно большое количество расписа-
ний, чтобы контролировать время выполнения задания.
По умолчанию триггеры продолжат порождать новые экземпляры за-
дания настолько часто, насколько это необходимо. В случае с задания-
ми с длительным временем выполнения, запланированными с корот -
ким интервалом, это приведет к тому, что многие экземпляры вашего
приложения будут работать одновременно. Если вам нужен триггер,
только чтобы выполнить задание, когда экземпляр еще не запущен,
декорируйте задание атрибутом [DisallowConcurrentExecution].
Quartz.NET поддерживает долговременное хранение в  базе данных
при выполнении триггеров. Чтобы активировать его, вызовите метод
UsePersistentStore() в методе конфигурации AddQuartz() и настрой-
те базу данных, применяя, например, метод UseSqlServer(). Исполь-
зуя долговременное хранение, Quartz.NET может сохранять сведения
о заданиях и триггерах между перезапусками приложения.
Активация долговременного хранения также допускает использова-
ние кластеризации. Кластеризация позволяет нескольким приложе-
ниям, использующим Quartz.NET, координировать свои действия, так
чтобы задания распределялись по нескольким планировщикам. Что-
бы активировать ее, сначала активируйте долговременное хранение,
а затем вызовите метод UseClustering().

23Тестирование	приложения
В этой главе:
создание проектов модульного тестирования с по мощью
xUnit;
написание модульных тестов для специального
промежуточного ПО и контроллеров API;
использование пакета Test Host для написания
интеграционных тестов;
тестирование реального поведения вашего приложения
с по мощью класса WebApplicationFactory;
тестирование кода, зависящего от EF Core, с по мощью
поставщика базы данных в памяти.
Когда я только начинал программировать, то не понимал преимуществ
автоматизированного тестирования. Для этого требовалось писать так
много кода – не лучше было работать над новыми функциями? Я оценил
эти преимущества только тогда, когда мои проекты стали расти. Вместо
того чтобы вручную запускать приложение и тестировать каждый сцена-
рий, я мог бы нажать кнопку «Воспроизвести» в наборе тестов и автома-
тически протестировать свой код.
Тестирование повсеместно признано хорошей практикой, но то, как
оно вписывается в  ваш процесс разработки, часто может превратиться
в религиозные дебаты. Сколько тестов вам нужно? Если покрытие вашей

828 Глава 23 Тестирование приложения
кодовой базы составляет менее 100 %, то будет ли этого достаточно? Сле-
дует ли писать тесты до, во время или после выполнения основного кода?
В этой главе не рассматривается ни один из этих вопросов. Вместо
этого я  сосредоточусь на механике	 тестирования приложения ASP .NET
Core. Я покажу, как использовать изолированные модульные	 тесты для
проверки изолированного поведения ваших сервисов, как тестировать
контроллеры API и специальное промежуточное ПО и как создавать ин-
теграционные	 тесты, которые одновременно проверяют несколько ком-
понентов вашего приложения. Наконец, я коснусь поставщика EF Core
в памяти, функции, которая позволяет тестировать компоненты, завися-
щие от DbContext, без необходимости подключаться к базе данных.
СОВЕТ  Для более широкого обсуждения тестирования или если
вы новичок в модульном тестировании, см. книгу «Искусство мо-
дульного тестирования», 3-е изд., Роя Ошерова (Manning, 2021).
Если вы хотите изучить передовые практики модульного тести-
рования на примерах C#, см. книгу «Модульное тестирование:
принципы, практики и паттерны» Владимира Хорикова (Manning,
2020). Кроме того, для более подробного изучения тестирования
с по мощью xUnit в .NET Core см. книгу «.NET Core в действии» Дас -
тина Мецгара (Manning, 2018).
В разделе 23.1 я расскажу о фреймворке тестирования .NET SDK и о том,
как использовать его для создания приложений для модульного тести-
рования. Я  опишу задействованные компоненты, включая SDK и  сами
фреймворки для тестирования, такие как xUnit и MSTest. Наконец, я рас -
смотрю некоторые термины, которые буду использовать в этой главе.
В разделе 23.2 вы создадите свой первый тестовый проект. На дан-
ном этапе вы будете тестировать простой класс, но это позволит вам
разобраться с  различными концепциями тестирования. Вы создадите
несколько тестов, используя фреймворк xUnit, составите утверждения
о поведении ваших сервисов и выполните тестовый проект из Visual Stu-
dio и из командной строки.
В разделах 23.3 и  23.4 мы рассмотрим, как тестировать распростра-
ненные функции приложений ASP .NET Core: контроллеры API и специ-
альное промежуточное ПО. Я покажу, как писать изолированные модуль-
ные тесты для них, как и для любого другого сервиса, и укажу на важные
моменты, на которые следует обратить внимание.
Чтобы компоненты работали правильно, важно тестировать их по
отдельности. Но также необходимо проверить правильность их работы
в конвейере промежуточного ПО. ASP .NET Core предоставляет удобный
пакет Test Host, который позволяет легко писать эти	 интеграционные
тес	ты	 для своих компонентов. Можно пойти еще дальше, используя
вспомогательный класс WebApplicationFactory, и  проверить правиль-
ность работы своего приложения. В разделе 23.5 вы увидите, как исполь-
зовать его для имитации запросов к приложению и как проверить, что
оно генерирует правильный ответ.

829 Тестирование в ASP.NET Core
В последнем разделе этой главы я  продемонстрирую, как использо-
вать поставщик базы данных SQLite для EF Core с базой данных в памяти.
Вы можете использовать его для тестирования сервисов, которые зави-
сят от DbContext, без использования реальной базы данных. Это позволя-
ет избежать неудобств, связанных с неизвестной инфраструктурой базы
данных и сбросом базы данных между тестами, и того обстоятельства,
что у разных людей могут быть разные конфигурации базы данных.
Начнем с  рассмотрения общего ландшафта тестирования ASP .NET
Core, доступных вариантов и задействованных компонентов.
23.1 Тестирование в ASP.NET Core
В этом разделе вы узнаете об основах тестирования в ASP .NET Core, о раз-
личных типах тестов, которые вы можете написать, таких как модульные
и интеграционные тесты, а также о том, почему следует писать оба типа.
Наконец, вы увидите, как тестирование вписывается в ASP .NET Core.
Если у  вас есть опыт создания приложений с  полной версией .NET
Framework или приложений для мобильных устройств с Xamarin, то, воз-
можно, у вас уже имеется опыт работы с фреймворками для модульного
тестирования. Если вы создавали приложения в Visual Studio, шаги по
созданию тестового проекта в разных фреймворках (xUnit, NUnit, MST -
est) различались бы, и для запуска тестов в Visual Studio часто требова-
лось установить подключаемый модуль. Кроме того, запуск тестов из ко-
мандной строки также отличался в зависимости от фреймворка.
С помощью .NET SDK тестирование в ASP .NET Core и .NET Core теперь
стало объектом первого класса наравне со сборкой, восстановлением па-
кетов и запуском вашего приложения. Так же, как вы можете выполнить
команду dotnet build для сборки проекта или dotnet run для его выпол-
нения, вы можете использовать команду dotnet test для выполнения
тестов в тестовом проекте, независимо от используемого фреймворка.
Команда dotnet test использует базовый набор средств разработки
.NET для выполнения тестов для определенного проекта. Это то же са-
мое, когда вы запускаете свои тесты с  по мощью выполняющего тесты
механизма Visual Studio, поэтому какой бы подход вы ни предпочли, ре-
зультаты будут одинаковыми.
Тестовые проекты – это консольные приложения, содержащие несколь-
ко тестов. Обычно тест представляет собой метод, который оценивает,
ведет ли себя определенный класс в вашем приложении так, как ожида-
лось. Тестовый проект обычно зависит как минимум от трех компонентов:
набор средств разработки для тестирования на платформе .NET;
фреймворк для модульного тестирования, такой как xUnit, NUnit,
Fixie или MSTest;
адаптер тестирования для выбранного вами фреймворка тестиро-
вания, чтобы вы могли выполнять тесты, вызвав команду dotnet
test.

830 Глава 23 Тестирование приложения
Эти зависимости представляют собой обычные пакеты NuGet, кото-
рые можно добавить в проект, но они позволяют подключиться к коман-
де dotnet test и выполняющему тесты механизму Visual Studio. В сле-
дующем разделе вы увидите пример файла с  расширением .csproj из
тестового приложения.
Обычно тест состоит из метода, который запускает небольшую часть
вашего приложения изолированно и проверяет, что оно имеет нужное
поведение. Если бы вы тестировали класс Calculator, то могли бы ис -
пользовать тест, который проверяет, что при передаче значений 1 и  2
методу Add() возвращается ожидаемый результат, 3.
Вы можете написать множество небольших изолированных тестов,
подобных этому, для классов своего приложения, чтобы убедиться, что
каждый компонент работает правильно, независимо от других компо-
нентов. Подобные небольшие изолированные тесты называются модуль-
ными.
Используя фреймворк ASP .NET Core, можно создавать приложения,
которые легко тестировать с  по мощью модульных тестов; вы можете
протестировать некоторые аспекты своих контроллеров отдельно от
фильтров действий и привязки модели, потому что фреймворк:
избегает статических типов;
использует интерфейсы вместо конкретных реализаций;
имеет модульную архитектуру, например вы можете протестиро-
вать свои контроллеры отдельно от фильтров действий и привязки
модели.
Но то, что все ваши компоненты работают независимо друг от друга,
не означает, что они будут работать, когда вы соберете их вместе. Для
этого нужны интеграционные	 тесты, которые проверяют, как несколько
компонентов взаимодействуют между собой.
Определение интеграционного теста – еще один довольно спорный
вопрос, но я рассматриваю интеграционные тесты как ситуации, когда
вы тестируете несколько компонентов вместе или большие вертикаль-
ные срезы своего приложения: тестируете класс диспетчера пользовате-
лей, который может сохранять значения в базе данных, например, или
проверяете, что запрос, сделанный к конечной точке проверки работо-
способности, возвращает ожидаемый ответ. Интеграционные тесты не
обязательно включают	все  приложение, но они определенно используют
больше компонентов, по сравнению с модульными тестами.
ПРИМЕЧАНИЕ  Я не рассматриваю тесты пользовательского ин-
терфейса, которые, например, взаимодействуют с браузером, что-
бы обеспечить настоящее сквозное автоматизированное тести-
рование. Selenium (www.seleniumhq.org) и  Cypress (www.cypress.
io) – два самых известных инструмента для тестирования пользо-
вательского интерфейса.

831 Модульное тестирование с xUnit
Когда дело доходит до интеграционного тестирования, у ASP .NET Core
есть в рукаве пара трюков. Вы можете использовать пакет Test Host для
запуска внутрипроцессного сервера ASP .NET Core, на который можно от -
правлять запросы и проверять ответы. Это избавит вас от головной боли
при попытке запустить веб-сервер в другом процессе, убедившись, что
порты доступны и т. д., но тем не менее позволяет использовать все при-
ложение.
С другой стороны, поставщик баз данных EF Core SQLite в памяти по-
зволяет изолировать тесты от базы данных. Взаимодействие с базой дан-
ных и ее настройка часто являются одним из самых сложных аспектов
автоматизации тестов, поэтому этот поставщик позволяет полностью
обойти данную проблему. Вы увидите, как его использовать, в  разде-
ле 23.6.
Самый простой способ разобраться, что такое тестирование,  – это
опробовать, как оно работает, поэтому в следующем разделе вы созда-
дите свой первый тестовый проект и воспользуетесь им для написания
модульных тестов для простого специального сервиса.
23.2 Модульное тестирование с xUnit
В этом разделе вы узнаете, как создавать проекты модульных тестов,
ссылаться на классы в других проектах и как запускать тесты с по мощью
Visual Studio или интерфейса командной строки .NET. Вы создадите тес -
товый проект и воспользуетесь им для проверки работы базового кон-
вертера валют. Вы напишете несколько простых модульных тестов, кото-
рые проверяют, что сервис возвращает ожидаемые результаты и выдает
исключения, когда вы этого ожидаете.
Как я  уже писал в  разделе 23.1, для создания тестового проекта не-
обходимо использовать фреймворк для тестирования. У вас есть много
вариантов, таких как NUnit или MSTest, но чаще всего с .NET Core исполь-
зуется фреймворк xUnit (https://xunit.net/). Сам ASP .NET Core применяет
xUnit в качестве фреймворка для тестирования, поэтому он стал чем-то
вроде соглашения. Если вы знакомы с другим фреймворком, то можете
смело использовать его.
23.2.1 Создание первого тестового проекта
Visual Studio включает в  себя шаблон для создания тестового проекта
.NET Core с xUnit, как показано на рис. 23.1. Выберите File > New Project
(Файл > Новый проект) и  xUnit Test Project (.NET Core) (Тестовый про-
ект для xUnit (.NET Core)) в диалоговом окне «Новый проект». В качестве
альтернативы можно выбрать Unit Test Project (.NET Core) (Проект мо-
дульного тестирования (.NET Core)) или NUnit Test Project (.NET Core),
если вам удобнее работать с этими фреймворками.

832 Глава 23 Тестирование приложения
Вы можете
создавать проекты
с различными
фреймворками
тестирования .NET
Убедитесь, что вы
не выбрали проект
.NET FrameworkВыберите xUnit T est
Project (.NET Core
Рис. 23.1 Диалоговое окно «Новый проект» в Visual Studio. Выберите тестовый
проект для xUnit, чтобы создать проект xUnit, или выберите проект модульного
теста, чтобы создать проект для MST est
Кроме того, если вы не используете Visual Studio, то можете создать
аналогичный шаблон с по мощью интерфейса командной строки .NET:
dotnet new xunit
Независимо от того, используете ли вы Visual Studio или интерфейс
командной строки .NET, шаблон создает консольный проект и добавляет
необходимые тестовые пакеты NuGet в файл с расширением .csproj, как
показано в следующем листинге. Если вы решили создать тестовый про-
ект для MSTest (или другого фреймворка), пакеты для xUnit и xUnit будут
заменены пакетами, соответствующими выбранному вами фреймворку.
Листинг 23.1 Файл с расширением .csproj для тестового проекта с xUnit
<Project Sdk="Microsoft.NET.Sdk">
<PropertyGroup>
<TargetFramework>net5.0</TargetFramework>
<IsPackable>false</IsPackable>
</PropertyGroup>
<ItemGroup>
<PackageReference
Include="Microsoft.NET.Test.Sdk" Version="16.8.0" />
<PackageReference Include="xunit" Version="2.4.1" />
<PackageReference
Include="xunit.runner.visualstudio" Version="2.4.3" />
<PackageReference Include="coverlet.collector" Version="1.3.0" />
</ItemGroup>
</Project>
Помимо пакетов NuGet, шаблон включает в себя один пример модуль-
ного теста. Он ничего не делает, но тем не менее это действительный
тест xUnit, как показано в следующем листинге. В xUnit тест – это метод
открытого класса, декорированный атрибутом [Fact].Т естовый проект представляет
собой стандартный проект .NET Core,
ориентированный на .NET 5.0.
.NET T est SDK, необходимый
для всех тестовых проектов.
Фреймворк тестирования xUnit.
Т естовый адаптер xUnit для .NET T est SDK.Необязательный пакет, который собирает метрики
о том, какая часть вашего кода покрыта тестами.

833 Модульное тестирование с xUnit
Листинг 23.2  Пример модульного теста с xUnit, созданного
с по мощью шаблона по умолчанию
public class UnitTest1
{
[Fact]
public void Test1()
{
}
}
Несмотря на то что этот тест ничего не проверяет, он выделяет неко-
торые характеристики тестов для xUnit:
тесты обозначаются атрибутом [Fact];
метод должен быть открытым, без аргументов метода;
метод ничего не возвращает. Это также может быть асинхронный
метод, который возвращает Task;
метод находится внутри открытого нестатического класса.
ПРИМЕЧАНИЕ  Атрибут [Fact] и  эти ограничения относятся
к фреймворку тестирования xUnit. Другие фреймворки будут ис -
пользовать иные способы обозначения тестовых классов и будут
иметь иные ограничения на сами классы и методы.
Также стоит отметить, что, хотя я и сказал, что тестовые проекты явля-
ются консольными приложениями, здесь нет класса Program или метода
static void main. Приложение здесь больше похоже на библиотеку клас -
сов. Это связано с тем, что SDK для тестирования автоматически внедря-
ет класс Program во время сборки. В целом вам не о чем беспокоиться, но
у вас могут возникнуть проблемы, если вы попытаетесь добавить соб-
ственный файл Program.cs в свой тестовый проект1.
Прежде чем мы продолжим и  создадим несколько полезных тестов,
мы запустим тестовый проект как есть, используя Visual Studio и .NET
SDK, чтобы увидеть ожидаемый результат.
23.2.2 Запуск тестов командой dotnet test
Когда вы создаете тестовое приложение, использующее .NET Test SDK, то
можете запускать тесты либо с по мощью Visual Studio, либо с по мощью
интерфейса командной строки .NET. В Visual Studio вы запускаете тесты,
выбрав Tests > Run All Tests (Тесты > Выполнить все тесты) в главном
меню или щелкнув по кнопке Run All (Выполнить все) в окне обозрева-
теля тестов, как показано на рис. 23.2.
1 Такое бывает нечасто, но мне иногда приходилось встречаться с подобными
случаями. Я подробно описываю эту проблему и способы ее устранения в пос -
те своего блога «Устранение ошибки “У программы имеется несколько точек
входа” для консольных приложений, содержащих тесты xUnit»: http://mng.bz/
w9q5. Т есты xUnit должны находиться в открытых классах.
Атрибут [Fact] указывает на то, что метод является тестовым.
Метод, отмеченный атрибутом [Fact],
должен быть открытым и не иметь параметров.

834 Глава 23 Тестирование приложения
Щелкните Run All (Запустить все),
чтобы запустить все тесты в решении
Все тесты в решении
и их последний статусДетали выполнения текущего выбранного теста
Рис. 23.2 В окне обозревателя тестов в Visual Studio перечислены все тесты,
которые есть в решении, и их последний статус: пройден / не пройден. Щелкните по
тесту на левой панели, чтобы просмотреть сведения о самом последнем запуске на
правой панели
В окне обозревателя тестов перечислены все тесты, которые есть
в  вашем решении, и  результаты каждого теста. В  xUnit тест считается
пройденным, если он не возбуждает исключение, поэтому Test1 прошел
успешно.
Кроме того, можно запускать тесты из командной строки с по мощью
интерфейса командной строки .NET
dotnet test
из папки проекта unit-test, как показано на рис. 23.3.
Команда dotnet test
собирает проект
Указан окончательный
результат вместе с общим
временем выполнения.NET T est SDK
запускает все
тесты в проекте
Рис. 23.3 Вы можете запускать тесты из командной строки, используя команду
dotnet test. Она восстанавливает и создает тестовый проект перед выполнением
всех тестов в проекте
ПРИМЕЧАНИЕ  Вы также можете выполнить эту команду из пап-
ки Решение. Она запустит все тестовые проекты, указанные в фай-
ле с расширением .sln.
Вызов команды dotnet test запускает восстановление и сборку вашего
тестового проекта, а затем запускает тесты, как видно из вывода консоли
на рис. 23.3. За кулисами интерфейс командной строки .NET вызывает
ту же базовую инфраструктуру, что и Visual Studio (.NET SDK), поэтому
вы можете использовать подход, который лучше подходит вашему стилю
разработки.

835 Модульное тестирование с xUnit
Вы видели успешный запуск теста, так что пришло время заменить
его чем-нибудь полезным. Но все по порядку: вам нужно что-то протес -
тировать.
23.2.3 Ссылка на приложение из тестового проекта
При разработке через тестирование модульные тесты обычно пишутся
до того, как будет написан фактический класс, который вы тестируете, но
мы пойдем по более традиционному пути и сначала создадим класс для
тестирования, а потом напишем для него тесты.
Предположим, вы создали приложение под названием ExchangeRates.
Web, которое используется для конвертации разных валют, и хотите до-
бавить для него тесты. Вы добавили тестовый проект для своего реше-
ния, как описано в разделе 23.2.1, поэтому ваше решение выглядит так,
как показано на рис. 23.4.
Проект приложения для тестирования
Т естовый проект xUnit
Рис. 23.4 Базовое решение, содержащее приложение ASP.NET Core под названием
ExchangeRates.Weband и тестовый проект ExchangeRates.Web.T ests
Чтобы проект ExchangeRates.Web.Tests мог тестировать классы в про-
екте ExchangeRates.Web, необходимо добавить ссылку на веб-проект
в  свой тестовый проект. В  Visual Studio это можно сделать, щелкнув
правой кнопкой мыши по узлу тестового проекта «Зависимости» и вы-
брав «Добавить ссылку», как показано на рис. 23.5. После этого можно
выбрать веб-проект в диалоговом окне «Добавить ссылку». После добав-
ления в  проект он отображается внутри узла «Зависимости» в  разделе
«Проекты».
Кроме того, вы можете напрямую отредактировать файл с расширени-
ем .csproj и добавить элемент <ProjectReference> внутрь элемента <Item-
Group> с относительным путем к файлу проекта .csproj:
<ItemGroup>
<ProjectReference
Include="..\..\src\ExchangeRates.Web\ExchangeRates.Web.csproj" />
</ItemGroup>
Обратите внимание, что это относительный путь. Знак «..» в  пути
озна чает родительскую папку, поэтому показанный относительный путь

836 Глава 23 Тестирование приложения
правильно проходит через структуру каталогов решения, включая папки
src и test, показанные в обозревателе решений на рис. 23.5.
СОВЕТ  Помните, что вы можете редактировать файл с  расши-
рением .csproj прямо в Visual Studio, дважды щелкнув мышью по
проекту в обозревателе решений.
1.  Щелкните правой кнопкой мыши
Dependencies (Зависимости)
и выберите Add Project Reference
(Добавить ссылку на проект) 2.  В диалоговом окне выберите
ExchangeRates.Web
3.  Проект, на который вы ссылаетесь,
указан в узле Dependencies в разделе Projects
Рис. 23.5 Чтобы протестировать проект приложения, нужно добавить ссылку на
него из тестового проекта. Щелкните правой кнопкой мыши узел «Зависимости»
и выберите «Добавить ссылку на проект». Ссылка на проект приложения
отображается внутри узла «Зависимости» в разделе «Проекты»
Общепринятые соглашения для расположения проекта
Расположение и именование проектов в рамках решения полностью зависят
от вас, но в проектах ASP.NET Core обычно используется несколько соглаше-
ний, которые немного отличаются от принятых по умолчанию Visual Studio
File > New. Эти соглашения применяются командой ASP.NET в GitHub, а также
во многих других проектах C# с открытым исходным кодом.
На следующем рисунке показан пример этих соглашений. Вкратце они вы-
глядят так:
  файл решения с расширением .sln находится в корневом каталоге;
  основные проекты помещаются во вложенный каталог src;
  тестовые проекты помещаются во вложенный каталог test или tests;

837 Модульное тестирование с xUnit
  у каждого основного проекта есть эквивалент тестового проекта, назван-
ный так же, как и связанный с ним основной проект, с суффиксом «.Test»
или «.Tests»;
  другие папки, такие как samples, tools или docs, содержат образцы про-
ектов, инструменты для создания проекта или документацию.
Основные проекты помещаются
во вложенный каталог src
Т естовые проекты помещаются
во вложенный каталог test
Т естовые проекты соответствуют
основному эквиваленту проекта
и имеют суффикс " .T ests"
Другие вложенные каталоги содержат,
например, образцы,
инструменты или документы
Файл решения находится
в корневом каталоге
Соглашения о структурах проектов появились в библиотеках фреймворка
ASP.NET Core и в проектах с открытым исходным кодом на GitHub.
Вам не обязательно следовать им в собственном проекте, но о них стоит
знать
Будете вы следовать этим соглашениям или нет, полностью зависит от вас,
но, по крайней мере, о них полезно будет знать, чтобы вы могли легко пере-
мещаться по другим проектам на GitHub.
Теперь ваш тестовый проект ссылается на ваш веб-проект, поэтому
вы можете писать тесты для классов в веб-проекте. Мы будем тестиро-
вать простой класс, используемый для конвертации валют, как показано
в следующем листинге.
Листинг 23.3  Пример класса CurrencyConverter для конвертации валют
в фунты стерлингов
public class CurrencyConverter
{
public decimal ConvertToGbp(
decimal value, decimal exchangeRate, int decimalPlaces)
{Метод ConvertT oGbp преобразует значение,
используя указанный обменный курс, и округляет его.

838 Глава 23 Тестирование приложения
if (exchangeRate <= 0)
{
throw new ArgumentException(
"Exchange rate must be greater than zero",
nameof(exchangeRate));
}
var valueInGbp = value / exchangeRate;
return decimal.Round(valueInGbp, decimalPlaces);
}
}
У этого класса есть только один метод, ConvertToGbp(), который преоб-
разует value из одной валюты в фунты стерлингов с учетом предостав-
ленного параметра exchangeRate. Затем он округляет значение до необ-
ходимого количества десятичных знаков и возвращает его.
ВНИМАНИЕ!  Данный класс – лишь базовая реализация. На прак -
тике вам нужно будет обрабатывать арифметические переполне-
ния / потери значимости для больших или отрицательных зна-
чений, а также учитывать другие крайние случаи. Здесь этот код
приводится в сугубо демонстрационных целях!
Представьте, что вы хотите конвертировать 5,27 доллара США в фунт
стерлингов, а обменный курс составляет 1,31 доллара за 1 фунт. Если вы
хотите округлить до четырех знаков после запятой, то должны выпол-
нить следующий вызов:
converter.ConvertToGbp(value: 5.27, exchangeRate: 1.31, decimalPlaces: 4);
У вас есть образец приложения, класс для тестирования и тестовый
проект, так что пора писать тесты.
23.2.4 Добавление модульных тестов с атрибутами Fact
и Theory
Когда я пишу модульные тесты, то обычно выбираю один из трех разных
путей:
успешный	 путь –	когда приводятся типичные аргументы с ожидае-
мыми значениями;
путь	ошибок – когда переданные аргументы недействительны и тес -
тируются;
граничные	 случаи – когда предоставленные аргументы находятся на
грани ожидаемых значений.Используется граничный
оператор, поскольку
действительны только
положительные курсы
обмена.
Преобразует значение.
Округляет результат и возвращает его.

839 Модульное тестирование с xUnit
Я понимаю, что это обширная классификация, но она помогает мне
представить различные сценарии, которые мне нужно рассмотреть1.
Начнем с успешного пути, написав модульный тест, который прове-
ряет, что метод ConvertToGbp() работает должным образом с типичными
входными значениями.
Листинг 23.4  Модульный тест для метода ConvertToGbp
с использованием ожидаемых аргументов
[Fact]
public void ConvertToGbp_ConvertsCorrectly()
{
var converter = new CurrencyConverter();
decimal value = 3;
decimal rate = 1.5m;
int dp = 4;
decimal expected = 2;
var actual = converter.ConvertToGbp(value, rate, dp);
Assert.Equal(expected, actual);
}
Это ваш первый правильный модульный тест, который был настроен
с по мощью паттерна Arrange- Act-Assert (AAA):
Arrange – определить все параметры и создать экземпляр тестируе-
мой системы (класса);
Act – выполнить тестируемый метод и зафиксировать результат;
Assert –	убедиться, что результат этапа Act имеет ожидаемое значе-
ние.
Большая часть кода в этом тесте – стандартный C#, но если вы нови-
чок в тестировании, то вызов Assert будет вам незнаком. Это вспомо-
гательный класс, предоставляемый xUnit для установки утверждений
в  отношении вашего кода. Если параметры, предоставленные Assert.
Equal(), не равны, вызов Equal() возбудит исключение, и тест завершит -
ся неудачно. Если вы измените переменную expected в листинге 23.4 на
2,5 вместо 2, например, и запустите тест, то увидите, что обозреватель
тестов показывает сбой, как видно на рис. 23.6.
1 Совершенно иной подход к  тестированию  – это тестирование на основе
свойств. Этот увлекательный подход распространен в  сообществах функ -
ционального программирования, таких как F#. Вы можете найти отличное
введение Скотта Влашина в его статье «Введение в тестирование на основе
свойств»: http://mng.bz/e5j9. В этой статье используется язык F#, но тем не ме-
нее здесь все очень доходчиво изложено, даже если вы новичок в этом языке.Атрибут [Fact] помечает метод как тестовый.
Вы можете называть тест как хотите.
Т естируемый класс, обычно
называемый «тестируемой системой».
Параметры теста, которые
будут переданы в ConvertT oGbp. Ожидаемый
результат.
Выполняет метод и фиксирует результат.
Проверяет соответствие ожидаемых и фактических значений.
Если они не совпадают, возбуждается исключение.

840 Глава 23 Тестирование приложения
Неудачные тесты отмечены
красным крестиком
На панели сведений
подробно описано, почему
тест не был пройден
Рис. 23.6 Если тест завершается неудачно, он помечается красным крестиком в обозревателе
тестов. Если щелкнуть по тесту на левой панели, на правой панели отобразится причина сбоя.
В этом случае ожидаемое значение равнялось 2,5, но фактическое значение было равно 2
СОВЕТ  Альтернативные библиотеки утверждений, такие как
Fluent Assertions (https://fluentassertions.com/) и Shouldly (https://
github.c om/shouldly/shouldly), позволяют писать утверждения в бо-
лее естественном стиле, например actual.Should().Be(expected).
Эти библиотеки не являются обязательными, но я считаю, что они
делают тесты более читабельными, а сообщения об ошибках про-
ще понять.
В листинге 23.4 вы выбрали определенные значения для value, ex-
changeRate и  decimalPlaces, чтобы протестировать счастливый путь. Но
это только один набор значений из бесконечного числа возможностей,
поэтому вам, вероятно, следует протестировать хотя бы несколько раз-
личных комбинаций.
Один из способов сделать это – скопировать и вставить тест несколько
раз, настроить параметры и изменить имя метода тестирования, чтобы
сделать его уникальным. xUnit предоставляет альтернативный способ
добиться того же, не требуя такого дублирования кода.
ПРИМЕЧАНИЕ  Имена вашего тестового класса и  метода ис -
пользуются во фреймворке тестирования для описания теста. Вы
можете настроить их отображение в Visual Studio и в интерфейсе
командной строки, настроив файл xunit.runner.json, как описано
здесь: https://xunit.net/docs/configuration-files.
Вместо создания метода тестирования с атрибутом [Fact] можно соз-
дать метод тестирования с атрибутом [Theory]. Он предоставляет способ
параметризации методов тестирования, позволяя брать метод тестиро-
вания и запускать его несколько раз с разными аргументами. Каждый
набор аргументов считается отдельным тестом.
Можно переписать тест с атрибутом [Fact] из листинга 23.4, чтобы он
стал тестом с атрибутом [Theory], как показано ниже. Вместо того чтобы
указывать переменные в теле метода, передайте их методу в  качестве
параметров, а затем декорируйте метод тремя атрибутами [InlineData].
Каждый экземпляр атрибута предоставляет параметры для одного за-
пуска теста.

841 Модульное тестирование с xUnit
Листинг 23.5  Тест для метода ConvertToGbp с атрибутом [Theory],
тестирующий несколько наборов значений
[Theory]
[InlineData(0, 3, 0)]
[InlineData(3, 1.5, 2)]
[InlineData(3.75, 2.5, 1.5)]
public void ConvertToGbp_ConvertsCorrectly (
decimal value, decimal rate, decimal expected)
{
var converter = new CurrencyConverter();
int dps = 4;
var actual = converter.ConvertToGbp(value, rate, dps);
Assert.Equal(expected, actual);
}
Если вы запустите этот тест с по мощью команды dotnet test или Visual
Studio, он будет отображаться как три отдельных теста, по одному для
каждого набора [InlineData], как показано на рис. 23.7.
Рис. 23.7  Каждый набор параметров в атрибуте [InlineData] для теста с атрибутом
[Theory] создает отдельный запуск теста. В этом примере у одного такого теста три атрибута
[InlineData], поэтому он создает три теста, которые названы в соответствии с названием
метода и предоставленными параметрами
[InlineData] – не единственный способ указать параметры для подоб-
ного рода тестов, но один из наиболее часто используемых. Вы также мо-
жете использовать статическое свойство своего тестового класса с атри-
бутом [MemberData] или сам класс с по мощью атрибута [ClassData]1.
Теперь у  вас есть несколько тестов для успешного пути метода Con-
vertToGbp(), и я даже внедрил граничный случай в листинг 23.5, тестируя
ситуацию, когда value = 0. Последняя концепция, о которой я расскажу, –
это тестирование ошибочных случаев, когда недопустимые значения
передаются в тестируемый метод.
1 Я  описываю, как можно использовать атрибуты [ClassData] и  [MemberData],
в статье «Создание параметризованных тестов в xUnit с по мощью атрибутов
[InlineData], [ClassData] и [MemberData]»: http://mng.bz/8ayP .Помечает метод как параметризованный тест.
Каждый атрибут [InlineData] предоставляет все параметры
для одного запуска метода тестирования.
Метод принимает параметры,
предоставляемые атрибутами
[InlineData].
Запускает
тестируемую систему. Проверяет результат.

842 Глава 23 Тестирование приложения
23.2.5 Тестирование условий отказа
Ключевой частью модульного тестирования является проверка того,
что тестируемая система правильно обрабатывает граничные случаи
и  ошибки. В  случае с  классом CurrencyConverter это означало бы про-
верку того, как класс обрабатывает отрицательные значения, малые или
нулевые обменные курсы, большие значения и курсы и т. д.
Некоторые из этих случаев могут быть редкими, но допустимыми,
тогда как другие могут быть технически недопустимыми. Вызов метода
ConvertToGbp с отрицательным значением, вероятно, допустим; преоб-
разованный результат тоже должен быть отрицательным. Отрицатель-
ный обменный курс концептуально не имеет смысла, поэтому его следу -
ет рассматривать как недопустимое значение.
В зависимости от конструкции метода, когда в метод передаются недо-
пустимые значения, обычно возбуждаются исключения. В листинге 23.3
было показано, что мы генерируем исключение ArgumentException, если
параметр exchangeRate меньше или равен 0.
xUnit включает в себя множество вспомогательных методов в классе
Assert, чтобы проверить, возбуждает ли метод исключение ожидаемого
типа. Затем вы можете установить дополнительные утверждения в отно-
шении исключения; например, чтобы проверить, есть ли у исключения
ожидаемое сообщение.
ВНИМАНИЕ!  Старайтесь не связывать свои методы тестирова-
ния слишком тесно с внутренней реализацией метода. Это может
сделать тесты хрупкими, когда тривиальные изменения класса бу -
дут нарушать модульные тесты.
В следующем листинге показан тест с атрибутом [Fact] для проверки
поведения метода ConvertToGbp(), когда вы передаете ему нулевой па-
раметр exchangeRate. Метод Assert.Throws принимает лямбда-функцию,
описывающую выполняемое действие, которое должно возбудить ис -
ключение при запуске.
Листинг 23.6  Использование Assert.Throws<>, чтобы проверить,
генерирует ли метод исключение
[Fact]
public void ThrowsExceptionIfRateIsZero()
{
var converter = new CurrencyConverter();
const decimal value = 1;
const decimal rate = 0;
const int dp = 2;
var ex = Assert.Throws<ArgumentException>(
() => converter.ConvertToGbp(value, rate, dp));
// Дальнейшие утверждения относительно сгенерированного исключения, ex.
}Недействительное значение.Вы ожидаете, что будет возбуждено
исключение ArgumentException.
Метод для выполнения, который должен возбудить исключение.

843 Модульное тестирование специального промежуточного ПО
Метод Assert.Throws выполняет лямбда-функцию и  перехватывает
исключение. Если сгенерированное исключение соответствует ожидае-
мому типу, тест будет пройден. Если исключение не генерируется или
генерируется исключение не того типа, который вы ожидали, метод As-
sert.Throws сгенерирует исключение, и тест завершится неудачно.
На этом мы подошли к  концу введения в  модульное тестирование
с по мощью xUnit. Примеры в этом разделе описывают, как использовать
новый .NET Test SDK, но мы не коснулись ничего, относящегося к ASP .
NET Core. В оставшейся части этой главы мы сосредоточимся конкретно
на тестировании проектов ASP .NET Core и начнем с модульного тестиро-
вания промежуточного ПО.
23.3 Модульное тестирование специального
промежуточного ПО
В этом разделе вы узнаете, как тестировать специальное промежуточ-
ное ПО изолированно. Вы увидите, как проверить, обработало ли ваше
промежуточное ПО запрос или же вызвало следующий компонент в кон-
вейере, а также увидите, как читать поток ответов.
В главе 19 вы видели, как создать собственное промежуточное ПО
и как инкапсулировать его в виде класса с функцией Invoke. В этом раз-
деле вы создадите модульные тесты для простого компонента промежу -
точного ПО для проверки работоспособности, аналогичного тому, что
описан в главе 19. Это базовая реализация, но она демонстрирует под-
ход, который можно использовать для более сложных компонентов.
Промежуточное ПО, которое вы будете тестировать, показано в лис -
тинге 23.7. При вызове оно проверяет, начинается ли путь с  /ping, и если
да, то возвращает ответ в  виде простого текста "pong". Если запрос не
совпадает, вызывается следующий компонент в конвейере (предостав-
ленный RequestDelegate).
Листинг 23.7  Тестируемый класс StatusMiddleware, возвращающий
ответ "pong"
public class StatusMiddleware
{
private readonly RequestDelegate _next;
public StatusMiddleware(RequestDelegate next)
{
_next = next;
}
public async Task Invoke(HttpContext context)
{
if(context.Request.Path.StartsWithSegments("/ping"))
{
context.Response.ContentType = "text/plain";RequestDelegate, представляющий
остальную часть конвейера
промежуточного ПО.
Вызывается при выполнении
промежуточного ПО.
Если путь начинается
с "/ping" , возвращается
ответ "pong" .

844 Глава 23 Тестирование приложения
await context.Response.WriteAsync("pong");
return;
}
await _next(context);
}
}
В этом разделе мы протестируем только два простых случая:
когда запрос выполнен с использованием пути "/ping";
когда запрос выполнен с использованием другого пути.
ВНИМАНИЕ!  По возможности я рекомендую не проверять пути
в промежуточном ПО таким способом. Лучше использовать марш-
рутизацию конечных точек, как обсуждалось в главе 19. Промежу -
точное ПО в этом разделе предназначено лишь для демонстраци-
онных целей.
Промежуточное ПО сложновато поддается модульному тестирова-
нию, поскольку концептуально объект HttpContext представляет собой
большой класс. Он содержит все сведения о запросе и ответе, а это может
означать, что у  вашего промежуточного ПО есть много возможностей
для взаимодействия. Поэтому я считаю, что модульные тесты, как прави-
ло, тесно связаны с реализацией промежуточного ПО, что, как правило,
нежелательно.
Для первого теста мы рассмотрим случай, когда путь входящего за-
проса не начинается с  /ping. В этом случае класс StatusMiddleware дол -
жен оставить HttpContext без изменений и  вызвать RequestDelegate,
предоставленный в  конструкторе, который представляет следующий
компонент в конвейере.
Это поведение можно протестировать несколькими способами, но
в  листинге 23.8 вы проверяете, что RequestDelegate (по сути, однопа-
раметрическая функция) выполняется путем установки для локальной
переменной значения true. В Assert в конце метода вы проверяете, что
переменная была установлена и,  следовательно, был вызван делегат.
Чтобы вызвать StatusMiddleware, создайте и передайте DefaultHttpCon-
text1, который является реализацией HttpContext.
Листинг 23.8  Модульное тестирование класса StatusMiddleware,
когда указан несовпадающий путь
[Fact]
public async Task ForNonMatchingRequest_CallsNextDelegate()
{
var context = new DefaultHttpContext();
context.Request.Path = "/somethingelse";
1 DefaultHttpContext наследует от класса HttpContext и является частью базовой
абстракции фреймворка ASP .NET Core. Если хотите, то можете изучить его ис -
ходный код на сайте GitHub: http://mng.bz/q9qx.Если путь начинается
с "/ping" , возвращается
ответ "pong" .
В противном случае вызывается следующий
компонент промежуточного ПО в конвейере.
Создает DefaultHttpContext
и задает путь для запроса.

845 Модульное тестирование специального промежуточного ПО
var wasExecuted = false;
RequestDelegate next = (HttpContext ctx) =>
{
wasExecuted = true;
return Task.CompletedTask;
};
var middleware = new StatusMiddleware(next);
await middleware.Invoke(context);
Assert.True(wasExecuted);
}
Когда промежуточное ПО вызывается, оно проверяет предоставлен-
ный путь и обнаруживает, что он не соответствует требуемому значению
/ping. Поэтому вызывается следующий RequestDelegate и возвращается
ответ.
Другой очевидный случай, который нужно протестировать,  – когда
путь запроса – это "/ping"; промежуточное ПО должно сгенерировать
соответствующий ответ. Вы можете протестировать несколько характе-
ристик ответа:
в ответе должен быть код состояния 200 OK;
ответ должен иметь заголовок Content-Type:text/plain;
тело ответа должно содержать строку "pong".
Каждая из этих характеристик представляет собой отдельное требо-
вание, поэтому обычно каждая из них кодифицируется как отдельный
модульный тест. Так проще определить, какое именно требование не
было выполнено, если тест завершился неудачно. Чтобы было проще,
в листинге 23.9 я показываю все эти утверждения в одном и том же тесте.
Положительный модульный тест усложняется тем, что необходимо
прочитать тело ответа, чтобы убедиться, что оно содержит слово "pong".
DefaultHttpContext использует Stream.Null для объекта Response.Body,
а это означает, что все, что пишется в  Body, теряется. Чтобы записать от -
вет и  прочитать его для проверки содержимого, вы должны заменить
Body на MemoryStream. После выполнения промежуточного ПО вы можете
использовать StreamReader для чтения содержимого MemoryStream в стро-
ку и проверить его.
Листинг 23.9  Модульное тестирование StatusMiddleware
при указании совпадающего пути
[Fact]
public async Task ReturnsPongBodyContent()
{
var bodyStream = new MemoryStream();
var context = new DefaultHttpContext();
context.Response.Body = bodyStream;
context.Request.Path = "/ping";
RequestDelegate next = (ctx) => Task.CompletedTask;
var middleware = new StatusMiddleware(next: next);Отслеживает,
был ли
выполнен
RequestDelegate.В этом примере должен быть вызван
RequestDelegate, представляющий
следующий компонент
промежуточного ПО.
Создает экземпляр
промежуточного ПО, передавая
следующий RequestDelegate.
Вызывает промежуточное ПО с HttpContext;
должен вызывать RequestDelegate. Проверяет, был ли вызван RequestDelegate.
Создает DefaultHttpContext
и инициализирует тело с по мощью
MemoryStream для захвата ответа.Для пути
задается
значение,
необходимое
для Status -
Middleware.Создает экземпляр
промежуточного ПО и передает
простой RequestDelegate.

846 Глава 23 Тестирование приложения
await middleware.Invoke(context);
string response;
bodyStream.Seek(0, SeekOrigin.Begin);
using (var stringReader = new StreamReader(bodyStream))
{
response = await stringReader.ReadToEndAsync();
}
Assert.Equal("pong", response);
Assert.Equal("text/plain", context.Response.ContentType);
Assert.Equal(200, context.Response.StatusCode);
}
Как видите, промежуточное ПО для модульного тестирования требу -
ет большой настройки, чтобы заставить его работать, но есть и положи-
тельная сторона: это позволяет тестировать промежуточное ПО изоли-
рованно, но в  некоторых случаях, особенно для простых компонентов
без каких-либо зависимостей от баз данных или других служб, интегра-
ционное тестирование может быть (что несколько удивительно) проще.
В разделе 23.5 вы создадите интеграционные тесты для таких компонен-
тов, чтобы увидеть разницу.
Специальное промежуточное ПО – обычное явление в проектах ASP .
NET Core, но гораздо более распространены Razor Pages и контроллеры
API. В следующем разделе вы увидите, как тестировать их отдельно от
других компонентов.
23.4 Модульное тестирование API-контроллеров
В этом разделе вы увидите, как проводить модульное тестирование конт -
роллеров API, узнаете о  преимуществах и  трудностях изолированного
тестирования этих компонентов, а также о ситуациях, когда это может
быть полезно.
Модульные тесты изолируют поведение; вам нужно протестировать
только логику, содержащуюся в  самом компоненте, отдельно от по-
ведения каких-либо зависимостей. Фреймворки Razor Pages и  MVC/API
используют конвейер фильтров, маршрутизацию и привязку к модели,
но все они являются внешними по отношению к контроллеру или Page-
Models. PageModels, и сами контроллеры несут ответственность только за
ограниченное количество вещей. Обычно:
в случае с  недействительными запросами (например, не прошед-
шие валидацию) они возвращают соответствующий ActionResult
(контроллеры API) или повторно отображают форму (Razor Pages);
в случае с  действительными запросами вызывают необходимые
сервисы бизнес-логики и возвращают соответствующий ActionRe-
sult (контроллеры API) или показывают либо перенаправляют на
страницу с сообщением об успешном результате (Razor Pages);
при необходимости применяют авторизацию на основе ресурсов.Вызывает промежуточное ПО.
Перематывает
MemoryStream в начало
и считывает тело ответа
в строку.
Проверяет правильность значения ответа.Проверяет
правильность
ответа
Content-T ype.
Проверяет правильность ответа с кодом состояния.

847 Модульное тестирование API-контроллеров
Контроллеры и  Razor Pages сами по себе не должны содержать биз-
нес-логику; они должны обращаться к другим сервисам. Рассматривайте
их скорее как оркестраторы, выступающие в качестве посредника между
HTTP-интерфейсами, которые предоставляет ваше приложение, и служ -
бами бизнес-логики.
Если вы будете следовать этому разделению, вам будет проще писать
модульные тесты для своей бизнес-логики, и вы получите больше гибко-
сти, когда захотите изменить свои контроллеры в соответствии со свои-
ми потребностями. Учитывая это, часто возникает стремление сделать
свои контроллеры и обработчики страниц как можно более легковесны-
ми до такой степени1, что тестировать практически уже нечего!
При этом контроллеры и  действия – это классы и  методы, поэтому
вы можете писать для них модульные тесты. Сложность состоит в том,
чтобы решить, что вы хотите протестировать. В  качестве примера мы
рассмотрим простой контроллер API из следующего листинга, который
преобразует значение с  использованием заданного обменного курса
и возвращает ответ.
Листинг 23.10 Тестируемый контроллер API
[Route("api/[controller]")]
public class CurrencyController : ControllerBase
{
private readonly CurrencyConverter _converter
= new CurrencyConverter();
[HttpPost]
public ActionResult<decimal> Convert(InputModel model)
{
if (!ModelState.IsValid)
{
return BadRequest(ModelState);
}
decimal result = _convert.ConvertToGbp(model)
return result;
}
}
Для начала рассмотрим успешный путь, когда контроллер получает
валидный запрос. В следующем листинге показано, что вы можете соз-
дать экземпляр контроллера API, вызвать метод действия и получить от -
вет ActionResult<T>.
1 Одним из первых моих знакомств с этой идеей была серия сообщений Джим-
ми Богарда. Следующая ссылка указывает на последнюю статью в этой серии,
а также содержит ссылки на все предыдущие статьи. Джимми Богард также
является автором библиотеки MediatR (ht tps://github.com/jbogard/MediatR),
которая делает создание легковесных контроллеров еще проще. См. «Посади-
те свои контроллеры на диету: POST и команды»: ht tp://mng.bz/7VNQ .CurrencyConverter обычно
внедряется с использованием
внедрения зависимостей.
Здесь он создан для простоты.
Метод Convert
возвращает
ActionResult<T>.
Если введенные данные не являются
валидными, возвращаем результат
400 Bad Request, включая ModelState.
Если модель валидна,
рассчитываем результат. Возвращаем результат напрямую.

848 Глава 23 Тестирование приложения
Листинг 23.11 Простой модульный тест контроллера API
public class CurrencyControllerTest
{
[Fact]
public void Convert_ReturnsValue()
{
var controller = new CurrencyController();
var model = new ConvertInputModel
{
Value = 1,
ExchangeRate = 3,
DecimalPlaces = 2,
};
ActionResult<decimal> result = controller.Convert(model);
Assert.NotNull(result);
}
}
Тут важно отметить, что вы тестируете только возвращаемое значе-
ние действия, ActionResult<T>, а не ответ, который отправляется обратно
пользователю. Процесс сериализации результата в ответ обрабатывает -
ся инфраструктурой форматера MVC, как было показано в главе 9, а не
конт роллером.
При модульном тестировании контроллеров вы тестируете их от-
дельно от инфраструктуры MVC, такой как форматирование, привязка
к  модели, маршрутизация и  аутентификация. Очевидно, что это дела-
ется намеренно, но, как и  в  случае тестирования промежуточного ПО
в разделе 23.3, это может несколько усложнить тестирование некоторых
аспектов контроллера.
Рассмотрите возможность валидации модели. Как было показано
в  главе 6, одна из ключевых задач методов действий и  обработчиков
страниц Razor – проверять свойство ModelState.IsValid и выполнять со-
ответствующие действия, если модель привязки не является валидной.
Когда вы проверяете, правильно ли ваши контроллеры и  PageModel об-
рабатывают ошибки валидации, это может стать хорошим кандидатом
для модульного теста.
К сожалению, и здесь все непросто. Razor Page и MVC автоматически
устанавливают свойство ModelState как часть процесса привязки модели.
На практике, когда ваш метод действия или обработчик страницы вызы-
вается в запущенном приложении, вы знаете, что ModelState будет соот -
ветствовать значениям модели привязки. Но в модульном тесте привяз-
ка к модели отсутствует, поэтому вы должны задать свойство вручную.
Представьте, что вы хотите протестировать путь ошибок для контрол-
лера из листинга 23.10, где модель не является валидной и контроллер
должен вернуть BadRequestObjectResult. В  модульном тесте нельзя по-
лагаться на правильность свойства ModelState для модели привязки.
Вместо этого вы должны вручную добавить ошибку привязки модели Создает экземпляр ConvertController
для тестирования и модель
для отправки в API.
Вызывает метод ConvertT oGbp
и фиксирует возвращаемое значение.Утверждает,
что IActionResult
является
ViewResult.

849 Модульное тестирование API-контроллеров
к свойству контроллера ModelState перед вызовом действия, как пока-
зано здесь.
Листинг 23.12  Проверка обработки ошибок валидации
в контроллерах MVC
[Fact]
public void Convert_ReturnsBadRequestWhenInvalid()
{
var controller = new CurrencyController();
var model = new ConvertInputModel
{
Value = 1,
ExchangeRate = -2,
DecimalPlaces = 2,
};
controller.ModelState.AddModelError(
nameof(model.ExchangeRate),
"Exchange rate must be greater than zero"
);
ActionResult<decimal> result = controller.Convert(model);
Assert.IsType<BadRequestObjectResult>(result.Result);
}
ПРИМЕЧАНИЕ  В листинге 23.12 я передал недопустимую модель,
но с таким же успехом мог бы передать валидную	 модель или даже
null; контроллер не использует модель привязки, если свойство
ModelState недействительно, поэтому тест все равно будет прой-
ден. Но если вы пишете такие модульные тесты, то рекомендую
постараться, чтобы ваша модель соответствовала этому свойству;
в противном случае получится, что ваши модульные тесты не тес -
тируют ситуацию, которая возникает на практике.
Лично я  стараюсь избегать модульного тестирования контроллеров
API таким образом1. Как уже было показано на примере привязки мо-
дели, контроллеры в некоторой степени зависят от более ранних этапов
фреймворка MVC, которые вам часто нужно эмулировать. Точно так же,
если ваши контроллеры обращаются к  HttpContext (доступен в  базо-
вых классах ControllerBase), может потребоваться дополнительная на-
стройка.
1 Подробнее о том, почему я обычно не провожу модульное тестирование конт -
роллеров, можно узнать в  статье из моего блога «Нужно ли выполнять мо-
дульное тестирование контроллеров API/MVC в  ASP .NET Core?»: http://mng.
bz/YqMo.Создает экземпляр контроллера
для тестирования.
Создает невалидную модель привязки,
используя отрицательное значение
ExchangeRate.
Вручную добавляет ошибку модели
в ModelState контроллера, что задает
для ModelState.IsValid значение false.Вызывает
метод действия,
передавая
модели
привязки.
Проверяет метод действия,
возвращающий BadRequestObjectResult.

850 Глава 23 Тестирование приложения
ПРИМЕЧАНИЕ  В этом разделе я не слишком подробно обсуждал
страницы Razor Pages, поскольку по большей части они испытыва-
ют те же проблемы, в том смысле, что зависят от поддерживающей
инфраструктуры фреймворка. Тем не менее если вы действитель-
но хотите протестировать PageModel страницы Razor, то можете
прочитать об этом в  документации Microsoft «Модульные тесты
Razor Pages в ASP .NET Core»: http://mng.b z/GxmM.
Вместо использования модульного тестирования я стараюсь сделать
так, чтобы мои контроллеры и  Razor Pages были как можно легковес -
нее. Я помещаю как можно больше поведения в этих классах в сервисы
бизнес-логики, для которых можно легко выполнить модульное тестиро-
вание, или в промежуточное ПО и фильтры, которые легче тестировать
независимо.
ПРИМЕЧАНИЕ  Это личное предпочтение. Некоторым нравится
максимально приближаться к 100 % тестового покрытия кода, но
я считаю, что тестирование классов «оркестровки» часто доставля-
ет больше хлопот.
Хотя я часто отказываюсь от модульного тестирования контроллеров
и  Razor Pages, нередко я  пишу интеграционные тесты, которые тести-
руют их в контексте полноценного приложения. В следующем разделе
мы рассмотрим способы написания интеграционных тестов для вашего
приложения, чтобы вы могли протестировать различные его компонен-
ты в контексте фреймворка ASP .NET Core в целом.
23.5 Интеграционное тестирование:
тестирование всего приложения в памяти
В этом разделе вы узнаете, как создавать интеграционные тесты, про-
веряющие взаимодействие компонентов. Вы научитесь создавать Test-
Server, который отправляет HTTP-запросы в  памяти, чтобы упростить
тестирование специальных компонентов промежуточного ПО. Затем
вы узнаете, как запускать интеграционные тесты для реального при-
ложения, используя конфигурацию реального приложения, сервисы
и конвейер промежуточного ПО. Наконец, вы узнаете, как использовать
WebApplicationFactory для замены сервисов в  приложении тестовыми
версиями, чтобы избежать зависимости от сторонних API в своих тестах.
Если вы поищете в интернете различные типы тестирования, то найде-
те множество разных типов на выбор. Различие между ними иногда не
так ощутимо, и люди не всегда согласны с определениями. Я решил не
останавливаться на этом в данной книге – я  считаю модульные тесты
изолированными тестами компонента, а интеграционные тесты – теста-
ми, которые проверяют несколько компонентов одновременно.

851 Интеграционное тестирование: тестирование всего приложения в памяти
В этом разделе я  покажу, как написать интеграционные тесты для
класса StatusMiddleware из раздела 23.3 и  контроллера API из разде-
ла 23.4. Вместо того чтобы изолировать компоненты от окружающего
фреймворка и вызывать их напрямую, вы намеренно протестируете их
в контексте, аналогично тому, как вы их используете на практике.
Интеграционные тесты – важная часть подтверждения правильности
работы ваших компонентов, но они не устраняют необходимость в мо-
дульных тестах. Модульные тесты отлично подходят для тестирования
небольших логических элементов, содержащихся в ваших компонентах,
и обычно выполняются быстро. Интеграционные тесты чаще проходят
значительно медленнее, поскольку требуют гораздо большей конфигу -
рации и могут полагаться на внешнюю инфраструктуру, такую   как база
данных.
Следовательно, если у вас гораздо больше модульных тестов для при-
ложения, чем интеграционных, то это нормально. Как вы уже видели
в разделе 23.2, модульные тесты обычно проверяют поведение компо-
нента, используя допустимые входные данные, граничные случаи и не-
допустимые входные данные, чтобы гарантировать, что компонент
ведет себя правильно во всех случаях. Если у вас есть обширный набор
модульных тестов, вам, скорее всего, понадобится пройти несколько ин-
теграционных тестов, чтобы убедиться, что ваше приложение работает
правильно.
Вы можете написать множество различных типов интеграционных
тес тов для приложения и проверить, что сервис может правильно писать
данные в базу данных, может интегрироваться со сторонним сервисом
(например, для отправки электронных писем) или может обрабатывать
HTTP-запросы, которые выполняются к нему.
В этом разделе мы сосредоточимся на последнем пункте, проверив,
может ли ваше приложение обрабатывать поступающие к нему запросы,
как если бы вы обращались к приложению из браузера. Для этого мы бу -
дем использовать полезную библиотеку Microsoft.AspNetCore.TestHost,
предоставленную командой ASP .NET Core.
23.5.1 Создание TestServer с по мощью пакета Test Host
Представьте, что вы хотите написать несколько интеграционных тестов
для класса StatusMiddleware из раздела 23.3. Вы уже написали для него
модульные тесты, но хотите иметь хотя бы один интеграционный тест,
который тестирует промежуточное ПО в контексте инфраструктуры ASP .
NET Core.
Можно сделать это по-разному. Возможно, наиболее полным подхо-
дом было бы создание отдельного проекта и настройка класса Status-
Middleware как единственного компонента в конвейере. Затем нужно бу -
дет запустить этот проект, дождаться начала его работы, отправить ему
запросы и проверить ответы.
Возможно, это будет хороший тест, но он также потребует большо-
го количества настроек, а кроме того, будет ненадежным и подвержен

852 Глава 23 Тестирование приложения
ошибкам. Что делать, если тестовое приложение не запускается, потому
что пытается использовать уже занятый порт или не завершает работу
правильно? Сколько интеграционный тест должен ждать запуска при-
ложения?
Пакет Test Host позволяет приблизиться к  желаемой тестовой кон-
фигурации без дополнительных сложностей, связанных с запуском от -
дельного приложения. Добавить Test Host в свой тестовый проект можно,
используя пакет Microsoft.AspNetCore.TestHost, либо с по мощью графи-
ческого интерфейса NuGet Visual Studio, консоли диспетчера пакетов
или интерфейса командной строки .NET. Как вариант добавьте элемент
<PackageReference> непосредственно в  файл своего тестового проекта
с расширением .csproj:
<PackageReference Include="Microsoft.AspNetCore.TestHost" Version="5.0.0"/>
В типичном приложении ASP .NET Core вы создаете HostBuilder в клас -
се Program, настраиваете веб-сервер (Kestrel) и определяете конфигура-
цию своего приложения, сервисы и конвейер промежуточного ПО (с ис -
пользованием файла Startup). Наконец, вы вызываете метод Build()
класса HostBuilder для создания экземпляра IHost, который может быть
запущен и который будет слушать запросы по определенному URL-ад ре-
су и порту.
Пакет Test Host использует тот же HostBuilder для определения вашего
тестового приложения, но вместо того, чтобы слушать запросы на уров-
не сети, создает экземпляр IHost, который использует объекты запроса
в памяти, как показано на рис. 23.8.
Он даже предоставляет объект HttpClient, который можно использо-
вать для отправки запросов в тестовое приложение. Вы можете взаимо-
действовать с  HttpClient, как если бы он отправлял запросы по сети, но
на самом деле запросы целиком хранятся в памяти.
В листинге 23.13 показано, как использовать пакет Test Host для созда-
ния простого интеграционного теста для класса StatusMiddleware. Снача-
ла создайте экземпляр HostBuilder и вызовите метод ConfigureWebHost(),
чтобы определить приложение, добавив промежуточное ПО в метод Con-
figure. Это эквивалентно методу Startup.Configure(), который обычно
используетcя для настройки приложения.
Вызовите метод расширения UseTestServer() в методе ConfigureWeb-
Host(), который заменяет сервер Kestrel по умолчанию на TestServer из
пакета Test Host. TestServer – главный компонент пакета Test Host, бла-
годаря которому вся эта магия становится возможной. После настройки
HostBuilder вызовите метод StartAsync(), чтобы построить и запустить
тестовое приложение. Затем вы можете создать объект HttpClient, ис -
пользуя метод расширения GetTestClient(). Он возвращает HttpClient,
настроенный для выполнения запросов в памяти к TestServer.

853 Интеграционное тестирование: тестирование всего приложения в памяти
Request Response
HttpContext HttpContextHttpRequestMessage HttpResponseMessageHTTP-запросы выполняются
клиентом по сетиМетод тестирования xUnit
создает объект запроса в памяти,
используя предоставленный
HttpClient Приложение, работающее с использованием Kestrel Приложение, работающее с использованием TestServer
HTTP-сервер Kestrel
StatusMiddleware StatusMiddleware
MvcMiddleware MvcMiddlewareТестовый сервер
Kestrel преобразует низкоуровневые HTTP-запросы
в объект HttpContext и передает его в конвейер
промежуточного ПО приложения T estServer получает от HttpClient объект запроса в памяти
и создает объект HttpContext. Что касается приложения,
то для него HttpContext ничем не отличается от обычного
запроса.
Рис. 23.8 Когда ваше приложение работает в обычном режиме, то использует сервер Kestrel.
Он слушает HTTP-запросы и преобразует их в объект HttpContext, который передается
в конвейер промежуточного ПО. TestServer не слушает запросы в сети. Вместо этого вы
используете HttpClient для выполнения запросов в памяти. С точки зрения промежуточного
ПО никакой разницы нет
Листинг 23.13 Создание интеграционного теста с TestServer
public class StatusMiddlewareTests
{
[Fact]
public async Task StatusMiddlewareReturnsPong()
{
var hostBuilder = new HostBuilder()
.ConfigureWebHost(webHost =>
{
webHost.Configure(app =>
app.UseMiddleware<StatusMiddleware>());
webHost.UseTestServer();
});Настраиваем HostBuilder для определения
тестового приложения в памяти.Добавляем
StatusMiddleware
в качестве
единственного
компонента
промежуточного ПО
в конвейере.Настраиваем хост на использование
T estServer вместо Kestrel.

854 Глава 23 Тестирование приложения
IHost host = await hostBuilder.StartAsync();
HttpClient client = host.GetTestClient();
var response = await client.GetAsync("/ping");
response.EnsureSuccessStatusCode();
var content = await response.Content.ReadAsStringAsync();
Assert.Equal("pong", content);
}
}
Этот тест гарантирует, что тестовое приложение, определенное Host-
Builder, вернет ожидаемое значение при получении запроса пути /ping.
Запрос полностью находится в памяти, но с точки зрения StatusMiddle-
ware это то же самое, как если бы запрос пришел из сети.
Конфигурация HostBuilder в этом примере проста. Хотя я и назвал этот
тест интеграционным, вы тестируете именно класс StatusMiddleware сам
по себе, а не в контексте «реального» приложения. Я думаю, что такая
настройка во многих отношениях предпочтительнее для тестирования
специального промежуточного ПО по сравнению с «правильными» мо-
дульными тестами, которые я показывал в разделе 23.3.
Независимо от того, как вы его назовете, этот тест основан на очень
простой конфигурации тестового приложения. Вы также можете протес -
тировать промежуточное ПО в контексте реального приложения, чтобы
результат соответствовал его реальной конфигурации.
Если вы хотите запускать интеграционные тесты на основе существую-
щего приложения, вам не нужно настраивать тестовый HostBuilder вруч -
ную, как вы это делали в листинге 23.13. Вместо этого можно использо-
вать еще один вспомогательный пакет, Microsoft.AspNetCore.Mvc.Testing.
23.5.2 Тестирование приложения с по мощью класса
WebApplicationFactory
Создание экземпляра HostBuilder и использование пакета Test Host, как
вы делали в  разделе 23.5.1, могут быть полезны, когда вы хотите про-
тестировать изолированные компоненты «инфраструктуры», такие как
промежуточное ПО.
Также очень часто у  вас может возникнуть желание протестировать
«реальное» приложение с  полностью настроенным конвейером проме-
жуточного ПО и всеми необходимыми сервисами, добавленными в кон-
тейнер внедрения зависимостей. Это дает максимальную уверенность
в том, что ваше приложение будет работать в промышленном окружении.
TestServer, который предоставляет сервер в  памяти, можно исполь-
зовать для тестирования реального приложения, но, в принципе, здесь
требуется гораздо больше настроек. Ваше реальное приложение, веро-
ятно, загружает файлы конфигурации или статические файлы и может
использовать страницы и представления Razor.Собираем
и запускаем хост.Создает HttpClient, или вы
можете взаимодействовать
с серверным объектом
напрямую.
Делаем запрос в памяти, который
обрабатывается приложением, как обычно.Проверяет, что ответ был успешным:
код состояния – 2xx.Считывает содержимое тела и проверяет, содержит ли оно "pong" .

855 Интеграционное тестирование: тестирование всего приложения в памяти
До выхода .NET Core версии 2.1 настраивать все это было обремени-
тельно. К счастью, пакет Microsoft.AspNetCore.Mvc.Testing и класс WebAp-
plicationFactory в значительной степени решают все эти проблемы кон-
фигурации за вас.
Вы можете использовать класс WebApplicationFactory (из пакета Mi-
crosoft.AspNetCore.Mvc.Testing) для запуска версии вашего реального
приложения в памяти.
Он использует TestServer за кулисами, но работает с  реальной кон-
фигурацией вашего приложения, регистрацией сервисов в  контейнере
внедрения зависимостей и конвейером промежуточного ПО. Например,
в следующем листинге показан пример, который проверяет, что, когда
ваше приложение получает запрос "/ping", в ответе вы получаете "pong".
Листинг 23.14  Создание интеграционного теста с классом
WebApplicationFactory
public class IntegrationTests:
IClassFixture<WebApplicationFactory<Startup>>
{
private readonly WebApplicationFactory<Startup> _fixture;
public IntegrationTests(
WebApplicationFactory<Startup> fixture)
{
_fixture = fixture;
}
[Fact]
public async Task PingRequest_ReturnsPong()
{
HttpClient client = _fixture.CreateClient();
var response = await client.GetAsync("/ping");
response.EnsureSuccessStatusCode();
var content = await response.Content.ReadAsStringAsync();
Assert.Equal("pong", content);
}
}
Одно из преимуществ использования класса WebApplicationFactory,
как показано в листинге 23.14, состоит в том, что для него требуется мень-
ше ручной настройки, чем при использовании TestServer напрямую, как
показано в листинге 23.13, несмотря на выполнение большего количества
настроек за кулисами. WebApplicationFactory тестирует приложение, ис -
пользуя конфигурацию, определенную в файлах Program.cs и Startup.cs.
Листинги 23.14 и 23.13	 концептуально также сильно различаются. В лис -
тинге 23.13 вы проверяете, что класс StatusMiddleware ведет себя должным
образом в  контексте фиктивного приложения ASP .NET Core; в  листин-
ге 23.14 вы проверяете, что	 ваше	приложение	 ведет	себя	должным	 образом
при	определенных	 входных	 данных. В нем не говорится ничего конк  ретного Ваш тест должен реализовывать
интерфейс, хотя методов
для реализации нет.
Внедряем экземпляр
WebApplication-
Factory<T>, где
T – это класс в вашем
приложении.
Создаем HttpClient,
который отправляет запросы
к T estServer в памяти.
Выполняем запросы
и проверяем ответ,
как и раньше.

856 Глава 23 Тестирование приложения
о том, как это происходит. Вашему приложению не обязательно исполь-
зовать класс StatusMiddleware для прохождения теста, указанного в лис -
тинге 23.14; оно просто должно правильно ответить на данный запрос.
Это означает, что тесту меньше известно о деталях внутренней реализа-
ции вашего приложения и его волнует только его поведение.
ОПРЕДЕЛЕНИЕ  Тесты, которые завершаются неудачно при не-
значительном изменении приложения, называются неустойчивы-
ми, или хрупкими. Старайтесь избегать таких тестов, убедившись,
что они не зависят от деталей реализации вашего приложения.
Чтобы создать тесты, использующие класс WebApplicationFactory:
1  установите пакет Microsoft.AspNetCore.Mvc.Testing в  свой проект,
выполнив команду dotnet add package Microsoft.AspNetCore.Mvc.
Testing, используя проводник NuGet в  Visual Studio или добавив
элемент <PackageReference> в файл своего проекта:
<PackageReference Include="Microsoft.AspNetCore.Mvc.Testing" Version="5.0.0" />
2  обновите элемент <Project> в файле тестового проекта с расшире-
нием .csproj:
<Project Sdk="Microsoft.NET.Sdk.Web">
Этого требует класс WebApplicationFactory, чтобы он мог найти
ваши конфигурационные и статические файлы;
3  внедрите IClassFixture<WebApplicationFactory<T>> в тестовый класс
xUnit, где T – это класс в  проекте вашего реального приложения.
По соглашению для T обычно используется класс Startup из прило-
жения:
–  WebApplicationFactory использует ссылку на T для поиска мето-
да Program.CreateHostBuilder() для создания соответствующего
TestServer для тестов;
–  IClassFixture<TFixture>  – это интерфейс маркера xUnit, кото-
рый дает указание xUnit создать экземпляр TFixture перед по-
строением тестового класса и внедрить экземпляр в конструктор
тестового класса. Подробнее можно узнать на странице https://
xunit.net/docs/shared-c ontext;
4  примите экземпляр WebApplicationFactory<T> в конструкторе тес -
тового класса. Вы можете использовать его для создания объекта
HttpClient, чтобы отправлять запросы в памяти к  TestServer. Эти
запросы имитируют поведение вашего приложения в промышлен-
ном окружении, поскольку используются реальная конфигурация,
сервисы и промежуточное ПО приложения.
Существенное преимущество класса WebApplicationFactory состоит
в том, что вы можете с легкостью протестировать поведение реального
приложения. Но не стоит забывать и об ответственности – ваше прило-
жение будет вести себя так же, как и в реальной ситуации, поэтому оно

857 Интеграционное тестирование: тестирование всего приложения в памяти
будет осуществлять запись в базу данных и отправлять данные сторон-
ним API! В зависимости от того, что вы тестируете, вы можете заменить
некоторые из своих зависимостей, чтобы избежать этого, а также облег -
чить тестирование.
23.5.3 Замена зависимостей в классе WebApplicationFactory
Когда вы используете класс WebApplicationFactory для запуска интегра-
ционных тестов в  своем приложении, приложение будет запускаться
в памяти, но в остальном это похоже на то, как если бы вы запускали его
с  по мощью команды dotnet run. Это означает, что любые строки под-
ключения, секреты или API-ключи, которые можно загрузить локально,
также будут использоваться для запуска вашего приложения.
СОВЕТ  По умолчанию класс WebApplicationFactory использует
окружение «Разработка» так же, как и при локальном запуске.
С одной стороны, это означает, что у вас есть подлинный тест, позво-
ляющий правильно запускать приложение. Например, если вы забыли
зарегистрировать нужную зависимость, обнаруживаемую при запуске
приложения, любые тесты, использующие WebApplicationFactory, завер-
шатся ошибкой.
С другой стороны, это означает, что все ваши тесты будут использо-
вать то же соединение с базой данных и сервисы, что и при локальном
запуске приложения, и часто у вас может возникнуть желание заменить
их альтернативными «тестовыми» версиями своих сервисов.
Простой пример. Представим, что сервис CurrencyConverter, который
вы тестировали в этом приложении, использует интерфейс IHttpClient-
Factory для вызова стороннего API, чтобы получить последние курсы
валют. Вы не хотите повторно использовать этот API в своих интегра-
ционных тестах, поэтому хотите заменить сервис CurrencyConverter на
собственный сервис StubCurrencyConverter.
Первый шаг – убедиться, что сервис CurrencyConverter реализует ин-
терфейс, например ICurrencyConverter, и что ваше приложение исполь-
зует его, а не реализацию. В нашем простом примере интерфейс, веро-
ятно, будет выглядеть примерно так:
public interface ICurrencyConverter
{
decimal ConvertToGbp(decimal value, decimal rate, int dps);
}
Нужно зарегистрировать сервис в Startup.ConfigureServices():
services.AddScoped<ICurrencyConverter, CurrencyConverter>();
Теперь, когда ваше приложение только косвенно зависит от сервиса
CurrencyConverter, можно предоставить альтернативную реализацию
в своих тестах.

858 Глава 23 Тестирование приложения
СОВЕТ  Использование интерфейса отделяет сервисы вашего
приложения от конкретной реализации, позволяя заменять аль-
тернативные реализации. Это ключевая практика для тестирова-
ния классов.
Мы создадим простую альтернативную реализацию интерфейса ICur-
rencyConverter для наших тестов, которая всегда возвращает одно и то
же значение, 3. Очевидно, что она не очень полезна в качестве реально-
го конвертера, но дело не в этом: у вас есть полный контроль! Создайте
в своем тестовом проекте следующий класс:
public class StubCurrencyConverter : ICurrencyConverter
{
public decimal ConvertToGbp(decimal value, decimal rate, int dps)
{
return 3;
}
}
Теперь у вас есть все необходимое для замены реализации в тестах.
Для этого мы будем использовать функцию класса WebApplicationFac-
tory, которая позволяет настроить контейнер внедрения зависимостей
перед запуском тестового сервера.
СОВЕТ  Важно помнить, что нужно заменять реализацию только
при запуске в тестовом проекте. Я видел, как некоторые пытались
настроить реальные приложения, чтобы заменить действующие
службы фейковыми, например когда задано определенное значе-
ние. Как правило, в этом нет необходимости, в приложении появ-
ляется слишком много тестовых сервисов, и обычно это приводит
к путанице!
Класс WebApplicationFactory предоставляет метод WithWebHostBuilder,
который позволяет настраивать приложение до запуска TestServer в па -
мяти. В следующем листинге показан интеграционный тест, в котором
этот метод используется для замены реализации интерфейса ICurrency-
Converter, используемой «по умолчанию», с по мощью нашей заглушки.
Листинг 23.15  Замена зависимости в тесте с по мощью метода
WithWebHostBuilder
public class IntegrationTests:
IClassFixture<WebApplicationFactory<Startup>>
{
private readonly WebApplicationFactory<Startup> _fixture;
public IntegrationTests(WebApplicationFactory<Startup> fixture)
{
_fixture = fixture;
}Реализуем
требуемый
интерфейс
и внедряем
его
в конструктор.

859 Интеграционное тестирование: тестирование всего приложения в памяти
[Fact]
public async Task ConvertReturnsExpectedValue()
{
var customFactory = _fixture.WithWebHostBuilder(
(IWebHostBuilder hostBuilder) =>
{
hostBuilder.ConfigureTestServices(services =>
{
services.RemoveAll<ICurrencyConverter>();
services.AddSingleton
<ICurrencyConverter, StubCurrencyConverter>();
});
});
HttpClient client = customFactory.CreateClient();
var response = await client.GetAsync("/api/currency");
response.EnsureSuccessStatusCode();
var content = await response.Content.ReadAsStringAsync();
Assert.Equal("3", content);
}
}
В этом примере следует отметить несколько важных моментов:
метод WithWebHostBuilder() возвращает новый экземпляр класса
Web ApplicationFactory. У этого экземпляра есть ваша индивидуаль-
ная конфигурация, в то время как исходный внедренный экземпляр
_fixture остается неизменным;
метод ConfigureTestServices() вызывается после метода Config-
ureServices() реального приложения. Это означает, что вы можете
заменить ранее зарегистрированные сервисы, а также можете ис -
пользовать его для переопределения значений конфигурации, как
будет показано в разделе 23.6.
Метод WithWebHostBuilder() удобен, когда вы хотите заменить сервис
для одного теста.
Но что, если вы хотите заменить интерфейс ICurrencyConverter в каж -
дом тесте? Весь этот шаблонный код быстро станет проблемой. Вместо
этого можно создать специальный класс WebApplicationFactory.
23.5.4 Уменьшение дублирования кода за счет создания
специального класса WebApplicationFactory
Если вы обнаружите, что часто пишете метод WithWebHostBuilder() в сво-
их интеграционных тестах, возможно, стоит создать специальный класс
WebApplicationFactory. В следующем листинге показано, как централи-
зовать службу тестирования, которую мы использовали в листинге 23.15,
в специальный класс WebApplicationFactory.Создаем свою фабрику
с дополнительной
конфигурацией.
ConfigureT estServices
выполняется после
того, как все остальные
сервисы внедрения
зависимостей будут
настроены в вашем
реальном
приложении.Удаляет все реализации
ICurrencyConverter из
контейнера внедрения
зависимостей.
Добавляет тестовый сервис в качестве замены.
Вызов CreateClient
загружает приложение
и запускает T estServer.
Вызываем
конечную точку
конвертера валют.
Поскольку тестовый конвертер всегда возвращает 3,
конечная точка API делает то же самое.

860 Глава 23 Тестирование приложения
Листинг 23.16  Создание класса CustomWebApplicationFactory
для уменьшения дублирования кода
public class CustomWebApplicationFactory
: WebApplicationFactory<Startup>
{
protected override void ConfigureWebHost(
IWebHostBuilder builder)
{
builder.ConfigureTestServices(services =>
{
services.RemoveAll<ICurrencyConverter>();
services.AddSingleton
<ICurrencyConverter, StubCurrencyConverter>();
});
}
}
В этом примере мы переопределяем ConfigureWebHost и  настраива-
ем тестовые сервисы для фабрики1. Вы можете использовать этот класс
в любом тесте, внедрив его в виде IClassFixture, как делали это раньше.
Например, в следующем листинге показано, как можно было бы обно-
вить листинг 23.15, чтобы использовать специальную фабрику, опреде-
ленную в листинге 23.16.
Листинг 23.17  Использование CustomWebApplicationFactory
в интеграционном тесте
public class IntegrationTests:
IClassFixture<CustomWebApplicationFactory>
{
private readonly CustomWebApplicationFactory _fixture;
public IntegrationTests(CustomWebApplicationFactory fixture)
{
_fixture = fixture;
}
[Fact]
public async Task ConvertReturnsExpectedValue()
{
HttpClient client = _fixture.CreateClient();
var response = await client.GetAsync("/api/currency");
response.EnsureSuccessStatusCode();
var content = await response.Content.ReadAsStringAsync();
Assert.Equal("3", content);
}
}
1 У  класса WebApplicationFactory есть много других методов, которые можно
переопределить для иных сценариев. Подробнее см. http://mng.b z/mgq8.Наследуем от класса WebApplicationFactory.
Есть много функций, которые можно
переопределить. Это эквивалентно
вызову WithWebHostBuilder.
Добавляем
специальную
конфигурацию
для своего
приложения.
Реализуем интерфейс IClassFixture
для специальной фабрики.
Внедряем экземпляр фабрики в конструктор.
Клиент уже содержит
конфигурацию
тестового сервиса.
Результат подтверждает,
что использовался тестовый сервис.

861 Изоляция базы данных с по мощью поставщика EF Core в памяти
Вы также можете объединить свой класс WebApplicationFactory, заме-
щающий сервисы, которые вы всегда хотите заменить, с методом With-
Web  HostBuilder(), чтобы переопределить дополнительные сервисы для
каждого теста. Эта комбинация дает вам лучшее из обоих миров: вы умень-
шаете дублирование кода с по мощью класса CustomWebApplicationFactory
и получаете контроль с по мощью конфигурации для каждого теста.
Выполнение интеграционных тестов с использованием реальной кон-
фигурации приложения максимально приближает вас к  гарантии его
правильной работы. Камнем преткновения в этой ситуации почти всегда
являются внешние зависимости, такие как сторонние API и базы данных.
В последнем разделе этой главы мы рассмотрим, как использовать
поставщика SQLite для EF Core с  базой данных в  памяти. Этот подход
можно использовать для написания тестов для сервисов, использующих
контекст базы данных EF Core, без необходимости доступа к реальной
базе данных.
23.6 Изоляция базы данных с по мощью
поставщика EF Core в памяти
В этом разделе вы узнаете, как писать модульные тесты для кода, кото-
рый полагается на экземпляр класса DbContext от EF Core. Вы узнаете, как
создать базу данных в памяти, а также узнаете разницу между поставщи-
ком EF в памяти и поставщиком SQLite в памяти. Наконец, вы увидите,
как использовать поставщик SQLite для создания быстрых изолирован-
ных тестов для кода, который полагается на экземпляр DbContext.
Как вы уже видели в главе 12, EF Core – это инструмент объектно-реля-
ционного отображения, который используется в основном с реляцион-
ными базами данных. В этом разделе мы обсудим способ тестирования
служб, зависящих от экземпляра класса DbContext, без необходимости
настраивать реальную базу данных или взаимодействовать с ней.
ПРИМЕЧАНИЕ  Чтобы узнать больше о  тестировании кода EF
Core,	см. книгу «Entity	 Framework	 Core	в действии», 2-е изд., Джона
П. Смита (Manning, 2021), http://mng.bz/5j87 .
В следующем листинге показана сильно урезанная версия класса Rec-
ipeService, который вы создали в главе 12 для приложения с рецептами.
Он показывает единственный способ получить подробную информацию
о рецепте с использованием внедренного экземпляра класса DbContext.
Листинг 23.18  Класс RecipeService для тестирования, использующий
EF Core для хранения и загрузки сущностей
public class RecipeService
{

862 Глава 23 Тестирование приложения
readonly AppDbContext _context;
public RecipeService(AppDbContext context)
{
_context = context;
}
public RecipeViewModel GetRecipe(int id)
{
return _context.Recipes
.Where(x => x.RecipeId == id)
.Select(x => new RecipeViewModel
{
Id = x.RecipeId,
Name = x.Name
})
.SingleOrDefault();
}
}
Написание модульных тестов для этого класса – небольшая проблема.
Модульные тесты должны быть быстрыми, повторяемыми и  изолиро-
ванными от других зависимостей, но у вас есть зависимость от DbContext
из вашего приложения. Вы вряд ли захотите вести запись в  реальную
базу данных в модульных тестах, поскольку это сделает тесты медлен-
ными, потенциально неповторяемыми и сильно зависимыми от конфи-
гурации базы данных: сбой по всем трем требованиям!
ПРИМЕЧАНИЕ  В зависимости от окружения разработки вы, воз-
можно, захотите использовать реальную базу данных для своих
интеграционных тестов, несмотря на эти недостатки. Использо-
вание базы данных, подобной той, которую вы будете применять
в  промышленном окружении, увеличивает вероятность обнару -
жения каких-либо проблем в тестах. Вы можете найти пример ис -
пользования Docker, чтобы добиться этой цели в  документации
Microsoft «Тестирование служб и веб-приложений ASP .NET Core»:
http://mng.bz/zxDw .
К счастью, для этого сценария у Microsoft есть два поставщика баз дан-
ных в  памяти. Напомню, что в  главе 12 говорится, что при настройке
DbContext в  Startup.ConfigureServices() вы настраиваете конкретного
поставщика базы данных, например SQL Server:
services.AddDbContext<AppDbContext>(options =>
options.UseSqlServer(connectionString);
Поставщики баз данных в памяти – это альтернативные поставщики,
предназначенные только	для	тестирования. Microsoft включает в  ASP .
NET Core двух поставщиков в памяти:
Microsoft.EntityFrameworkCore.InMemory – этот поставщик не модели-
рует базу данных. Вместо этого он хранит объекты непосредственно В конструктор внедряется
DbContext от EF Core.
Использует свойство DbSet<Recipes>
для загрузки рецептов и создает
RecipeViewModel.

863 Изоляция базы данных с по мощью поставщика EF Core в памяти
в памяти. Это не реляционная база данных как таковая, поэтому она
не обладает всеми функциями обычной базы данных. Вы не можете
выполнить к ней SQL-запрос напрямую, и она не будет обеспечи-
вать соблюдение ограничений, но работает она быстро;
Microsoft.EntityFrameworkCore.Sqlite – SQLite – это реляционная база
данных. Она очень ограничена в функциях по сравнению с такой ба-
зой данных, как SQL Server, но это настоящая реляционная база дан-
ных, в отличие от поставщика базы данных в памяти. Обычно база
данных SQLite пишется в файл, но у поставщика есть режим in-mem-
ory, при котором база данных остается в  памяти. Это значительно
ускоряет и упрощает его создание и использование для тестирования.
Вместо того чтобы хранить данные в базе данных на диске, оба этих
поставщика хранят данные в памяти, как показано на рис. 23.9. Это дает
возможность создавать новую базу данных для каждого теста, чтобы
ваши тесты оставались изолированными друг от друга.
ПРИМЕЧАНИЕ  В этом разделе я описываю, как использовать по-
ставщика SQLite в качестве базы данных в памяти, поскольку она
более полнофункциональна, чем поставщик в памяти. Для получе-
ния подробной информации об использовании поставщика в па-
мяти	см. http://mng.bz/hdIq.
Чтобы использовать поставщик SQLite в памяти, добавьте пакет Mi-
crosoft.EntityFrameworkCore.Sqlite в файл тестового проекта с расшире-
нием .csproj. Он добавляет метод расширения UseSqlite(), который вы
будете использовать для настройки поставщика базы данных для своих
модульных тестов.
В листинге 23.19 показано, как использовать поставщик в  памяти
SQLite для тестирования метода GetRecipe() из класса RecipeService.
Начните с  создания объекта SqliteConnection и  использования строки
подключения "DataSource=:memory:". Так вы сообщаете поставщику со-
хранить базу данных в памяти, а затем открыть соединение.
ПРЕДУПРЕЖДЕНИЕ  База данных в памяти уничтожается, когда
соединение закрыто. Если вы не откроете соединение самостоя-
тельно, EF Core закроет его в базу данных в памяти при удалении
DbContext. Если вы хотите использовать базу данных в  памяти
между экземплярами DbContext, то должны явно открыть соедине-
ние самостоятельно.
Затем передайте экземпляр SqlLiteConnection в  DbContextOptions-
Builder <> и вызовите метод UseSqlite(). Так вы настраиваете резуль-
тирующий объект DbContextOptions<>, используя необходимые сервисы
для поставщика SQLite, и  обеспечиваете подключение к  базе данных
в памяти. При передаче этого объекта параметров в экземпляр AppDbCon-
text все вызовы DbContext приводят к вызовам поставщика базы данных
в памяти.

864 Глава 23 Тестирование приложения
_context.Recipes.First()
_context.Recipes.First()
_context.Recipes.First()DbContext
DbContext
DbContext1.  Приложение выполняет
LINQ-запрос к свойству DbSet
в DbContext
1.  Приложение выполняет
LINQ-запрос к свойству DbSet
в DbContext
1.  Приложение выполняет
LINQ-запрос к свойству DbSet
в DbContext2.  Приложение передает запрос
провайдеру базы данных SQL
Server
2.  Приложение передает запрос
провайдеру базы данных SQLite
2.  Приложение передает запрос
провайдеру базы данных в памяти 4.  Провайдер базы данных
преобразует возвращаемые
данные SQL в объекты
и возвращает их приложению
4.  Провайдер базы данных
преобразует возвращаемые
данные SQL в объекты
и возвращает их приложениюБаза данных сохраняется
на диске, она может быть
на другом сервере
База данных хранится
в памяти
Данные не хранятся
в реляционной базе данных,
только как объекты в памяти3.  Провайдер базы данных
преобразует запрос в SQL
и запрашивает базу данных
3.  Провайдер базы данных
преобразует запрос в SQL
и запрашивает базу данных,
которая хранится в памяти
3.  Провайдер базы данных
запрашивает объекты
в памяти, преобразует их
и возвращает в приложение Провайдер базы данных SQL Server
Провайдер базы данных SQLite
Провайдер базы данных в памятиПровайдер базы данных
SQL Server
Провайдер базы данных
SQLite
Провайдер базы данных
в памяти
Рис. 23.9 Поставщик базы данных в памяти и поставщик SQLite (режим in-memory)
по сравнению с поставщиком серверной базы данных SQL. Поставщик базы данных в памяти
не моделирует базу данных как таковую. Вместо этого он сохраняет объекты в памяти
и напрямую выполняет к ним LINQ-запросы

865 Изоляция базы данных с по мощью поставщика EF Core в памяти
Листинг 23.19  Использование поставщика базы данных в памяти для
тестирования DbContext
[Fact]
public void GetRecipeDetails_CanLoadFromContext()
{
var connection = new SqliteConnection("DataSource=:memory:");
connection.Open();
var options = new DbContextOptionsBuilder<AppDbContext>()
.UseSqlite(connection)
.Options;
using (var context = new AppDbContext(options))
{
context.Database.EnsureCreated();
context.Recipes.AddRange(
new Recipe { RecipeId = 1, Name = "Recipe1" },
new Recipe { RecipeId = 2, Name = "Recipe2" },
new Recipe { RecipeId = 3, Name = "Recipe3" });
context.SaveChanges();
}
using (var context = new AppDbContext(options))
{
var service = new RecipeService(context);
var recipe = service.GetRecipe (id: 2);
Assert.NotNull(recipe);
Assert.Equal(2, recipe.Id);
Assert.Equal("Recipe2", recipe.Name);
}
}
Этот пример следует стандартному формату для каждого случая, когда
вам нужно протестировать класс, зависящий от DbContext.
1  Создайте SqliteConnection со строкой подключения "Data Source
=:memory:" и откройте соединение.
2  Создайте DbContextOptionsBuilder<> и вызовите метод UseSqlite(),
передавая открытое соединение.
3 Извлеките объект DbContextOptions из свойства Options.
4  Передайте параметры экземпляру DbContext и убедитесь, что база
данных соответствует модели EF Core, вызвав context.Database.
EnsureCreated(). Это аналогично запуску миграций в  вашей базе
данных, но это следует использовать только для тестовых баз дан-
ных. Создайте и добавьте все необходимые тестовые данные в базу
данных в памяти и вызовите метод SaveChanges(), чтобы сохранить
данные.
5  Создайте новый экземпляр DbContext и внедрите его в свой тесто-
вый класс. Все запросы будут выполняться в базе данных в памяти.Настраивает соединение с SQLite
в памяти с по мощью специальной
строки подключения «в памяти».Открывает соединение, поэтому EF Core не закрывает его автоматически.
Создает экземпляр
DbContextOptions<> и настраивает
его для использования
соединения SQLite.Создает DbContext
и передает
параметры.
Обеспечивает
соответствие базы
данных в памяти
модели EF Core
(аналогично
запуску
миграций).Добавляет несколько
рецептов в DbContext.
Сохраняет изменения в базе данных в памяти.
Создает новый DbContext
для проверки возможности
извлечения данных из DbContext.
Создает RecipeService для
тестирования и передачи
нового DbContext.
Выполняет функцию GetRecipe.
Она выполняет запрос к базе
данных в памяти.Проверяет,
правильно ли вы
получили рецепт
из базы данных
в памяти.

866 Глава 23 Тестирование приложения
Используя два отдельных экземпляра DbContext, можно избежать
ошибок в тестах из-за кеширования данных EF Core без их записи в базу
данных. При таком подходе вы можете быть уверены, что все данные,
считанные во втором экземпляре DbContext, сохраняются в базовом по-
ставщике базы данных в памяти.
Это было очень краткое знакомство с  использованием поставщика
SQLite в качестве поставщика базы данных в памяти и тестированием
с использованием EF Core в целом, но если вы последуете настройке, по-
казанной в листинге 23.19, это займет у вас много времени. В исходном
коде для этой главы показано, как объединить этот код с  CustomWebApp-
licationFactory, чтобы использовать базу данных в  памяти для своих
интеграционных тестов. Дополнительные сведения о тестировании с EF
Core, включая дополнительные параметры и стратегии, см. в книге «En-
tity	Framework	 Core	в действии», 2-е изд., Джона П. Смита (Manning, 2021).
Резюме
Приложения модульного тестирования – это консольные приложения
с зависимостью от .NET Test SDK, фреймворка для тестирования, та-
кого как xUnit, MSTest или NUnit, и адаптера выполнения тестов. Вы
можете запускать тесты в тестовом проекте, вызвав команду dotnet
test из командной строки в тестовом проекте или с по мощью обозре-
вателя тестов в Visual Studio.
Многие фреймворки для тестирования совместимы с .NET Test SDK,
но xUnit стал практически стандартом де-факто для проектов ASP .
NET Core. Сама команда ASP .NET Core использует его для тестирова-
ния фреймворка.
Чтобы создать тестовый проект xUnit, выберите xUnit Test Project
(.NET Core) в Visual Studio или используйте команду интерфейса ко-
мандной строки dotnet new xunit. Так вы создаете тестовый проект,
содержащий пакеты Microsoft.NET.Test.Sdk, xunit и  xunit.runner.visu-
alstudio.
xUnit включает в себя два разных атрибута для идентификации мето-
дов тестирования. Методы с атрибутом [Fact] должны быть открыты-
ми и не иметь параметров. Методы с атрибутом [Theory] могут содер-
жать параметры, поэтому их можно использовать для многократного
выполнения аналогичного теста с разными параметрами. Вы можете
предоставить данные для каждого запуска с атрибутом [Theory], ис -
пользуя атрибут [InlineData].
Используйте утверждения в своих методах тестирования, чтобы убе-
диться, что тестируемая система (SUT) вернула ожидаемое значение.
Утверждения существуют для наиболее распространенных сценариев,
включая проверку того, что вызов метода вызвал исключение опреде-
ленного типа. Если ваш код возбуждает необработанное исключение,
тест завершится неудачно.

867 Резюме
Используйте класс DefaultHttpContext для модульного тестирования
специальных компонентов промежуточного ПО. Если вам нужен до-
ступ к  телу ответа, вы должны заменить значение по умолчанию
Stream.Null экземпляром MemoryStream и  вручную прочитать поток
после вызова промежуточного ПО.
Для контроллеров API и моделей страниц Razor можно применять мо-
дульное тестирование, как и для других классов, но они, как правило,
не должны содержать бизнес-логики, поэтому усилия могут не оку -
питься. Например, контроллер API тестируется независимо от марш-
рутизации, проверки модели и  фильтров, поэтому будет непросто
протестировать логику, которая зависит от любого из этих аспектов.
Интеграционные тесты позволяют тестировать сразу несколько ком-
понентов приложения, обычно в контексте самого фреймворка ASP .
NET Core. Пакет Microsoft.AspNetCore.TestHost предоставляет объект
TestServer, который можно использовать для создания простого веб-
хоста для тестирования. Он создает сервер в памяти, к которому мож -
но отправлять запросы и  получать ответы. Вы можете использовать
TestServer напрямую, если хотите создавать интеграционные тесты
для специальных компонентов, таких как промежуточное ПО.
Для более обширных интеграционных тестов реального приложения
следует использовать класс WebApplicationFactory из пакета Micro-
soft.AspNetCore.Mvc.Testing. Реализуйте IClassFixture<WebApplicati
onFactory<Startup>> в  своем тестовом классе и  внедрите экземпляр
WebApplicationFactory<Startup> в  конструктор. Так вы создадите
версию всего своего приложения в памяти с использованием той же
конфигурации, сервисов внедрения зависимостей и  конвейера про-
межуточного ПО. Вы можете отправлять в свое приложение запросы
в памяти, чтобы получить представление о том, как ваше приложение
будет вести себя в промышленном окружении.
Чтобы настроить класс WebApplicationFactory, вызовите методы With-
WebHostBuilder() и  ConfigureTestServices(). Этот метод вызывается
после стандартной конфигурации внедрения зависимостей приложе-
ния, что позволяет добавлять или удалять сервисы по умолчанию для
своего приложения, например заменять класс, который связывается
со сторонним API, используя реализацию-заглушку.
Если вы обнаружите, что вам необходимо настраивать сервисы для
каждого теста, то можно создать специальный класс WebApplication-
Factory путем наследования и переопределив метод ConfigureWebHost.
Вы можете разместить всю свою конфигурацию в этом классе и реа-
лизовать IClassFixture<CustomWebApplicationFactory> в  своих тесто-
вых классах, вместо того чтобы вызывать метод WithWebHostBuilder()
в каждом тестовом методе.
Вы можете использовать поставщик EF Core SQLite в  качестве базы
данных в памяти для тестирования кода, который зависит от экземп-
ляра DbContext. Вы настраиваете поставщика в  памяти, создавая
SqliteConnection со строкой подключения "DataSource=:memory:". Соз -
дайте объект DbContextOptionsBuilder<> и вызовите метод Use Sqlite(),

868 Глава 23 Тестирование приложения
передавая подключение. Наконец, передайте DbContextOptions<> в эк -
земпляр DbContext своего приложения и вызовите метод context.Da-
tabase.EnsureCreated() для подготовки базы данных в памяти для ис -
пользования с EF Core.
Сопровождение базы данных SQLite в памяти осуществляется до тех
пор, пока существует открытый SqliteConnection. Открывая соедине-
ние вручную, базу данных можно использовать с несколькими экземп-
лярами DbContext. Если вы не вызываете метод Open() для соединения,
EF Core закрывает соединение (и удаляет базу данных в памяти) при
удалении DbContext.

Приложение	А
Подготовка
окружения разработки
В этом приложении:
установка набора средств разработки .NET;
выбор редактора или интегрированной среды разработки.
Для разработчиков на .NET в  мире, ориентированном на Windows, Vi-
sual Studio в прошлом была в значительной степени требованием раз-
работчика. Но теперь, когда .NET и  ASP .NET Core становятся кросс-
платформенными, это уже не так.
Все, что относится к ASP .NET Core (создание новых проектов, сборка,
тестирование и  публикация), может запускаться из командной строки
для любой поддерживаемой операционной системы. Все, что вам нуж -
но, – это набор средств разработки .NET, который предоставляет интер-
фейс командной строки .NET. Кроме того, если вы работаете в Windows
и незнакомы с командной строкой, вы все равно можете выбрать File >
New Project в Visual Studio, чтобы сразу приступить к работе. С ASP .NET
Core выбор за вами!
Аналогичным образом теперь вы можете получить отличные возмож -
ности редактирования за пределами Visual Studio благодаря проекту Om-

870
Приложение А
niSharp1. Это набор библиотек и плагинов с открытым исходным кодом,
которые предлагают автодополнение кода (IntelliSense) в широком диа-
пазоне редакторов и операционных систем. То, как вы настроите свое
окружение, скорее всего, будет зависеть от того, какую операционную
систему вы используете и к чему привыкли.
Помните, что в случае с .NET Core и .NET 5.0 операционная система,
которую вы выбираете для разработки, не имеет отношения к конечным
системам, на которых вы можете запускать ваши приложения, – незави-
симо от того, выберете ли вы Windows, macOS или Linux для разработки,
вы можете развернуть приложение в любой поддерживаемой системе.
В этом приложении я покажу, как установить набор средств разработ -
ки .NET, чтобы вы могли создавать, запускать и публиковать приложения
.NET, а также расскажу о некоторых интегрированных средах разработки
и редакторах для создания приложений.
ПРИМЕЧАНИЕ  В  этой книге для большинства примеров я  ис -
пользую Visual Studio, но вы можете использовать любой из ин-
струментов, которые я  здесь обсуждаю. Предполагается, что вы
успешно установили на свой компьютер .NET 5.0 и редактор.
A.1 Установка .NET SDK
Самое важное, что вам нужно для разработки на .NET Core и .NET 5.0, –
это набор средств разработки .NET. В этом разделе я опишу, как устано-
вить его и как проверить, какую версию вы установили.
Чтобы начать программировать на .NET, необходимо установить на-
бор средств разработки .NET (прежнее название – набор средств разра-
ботки .NET Core). Он содержит базовые библиотеки, инструменты и ком-
пилятор, которые вам понадобятся для создания приложений на .NET.
Вы можете скачать его на странице https://dotnet.microsof t.com/down-
load. Здесь есть ссылки для скачивания последней версии .NET для ва-
шей операционной системы. Если вы используете Windows или macOS,
то на этой странице вы найдете ссылки для скачивания инсталлятора;
если вы используете Linux, то здесь есть инструкции по установке .NET
с по мощью диспетчера пакетов вашего дистрибутива, в виде пакета Snap
или загрузки вручную.
ПРЕДУПРЕЖДЕНИЕ  Убедитесь, что вы скачиваете .NET SDK, а не
среду выполнения .NET. Среда выполнения .NET используется для
выполнения приложений .NET, но ее нельзя применять для их соз-
дания. .NET SDK включает в себя копию среды выполнения, поэто-
му он может запускать ваши приложения, но также может созда-
вать, тестировать и публиковать их.
1 Информацию о проекте OmniSharp можно найти на сайте www.omnisharp.net,
а исходный код – на странице https://github.com/omnisharp.

Подготовка окружения разработки 871
После установки .NET SDK вы можете запускать команды из интер-
фейса командной строки .NET с по мощью команды dotnet. Выполните
команду dotnet --info, чтобы увидеть информацию о версии .NET. SDK,
которая используется в настоящее время, а также установленные вами
.NET SDK и среды выполнения, как показано на рис. A.1.
Т екущая версия .NET SDK,
используемая для выполнения команды
Все версии .NET SDK, установленные
в системе
Все версии среды выполнения
.NET, установленные в системе
Подробная информация
об оборудовании и операционной
системе
Рис. A.1 Используйте команду dotnet --info, чтобы проверить, какая версия .NET
SDK применяется в настоящее время и какие версии доступны. На этом скриншоте
показано, что в настоящее время я использую SDK для .NET 5, версию 5.0.100
Как видно на рис. A.1, у меня установлено несколько версий .NET SDK.
Это прекрасно, но не обязательно. Более новые версии .NET SDK мо-
гут создавать приложения, предназначенные для более старых версий
.NET Core. Например, SDK для .NET 5.0 может создавать приложения для
.NET 5.0, .NET Core 3.x, .NET Core 2.x и .NET Core 1.x, а вот SDK для .NET
Core 3.1 не может создавать приложения для .NET 5.0.
СОВЕТ  Некоторые интегрированные среды разработки, напри-
мер Visual Studio, могут автоматически устанавливать .NET 5.0. Вы
вполне можете установить несколько версий .NET Core и .NET 5.0
одновременно, поэтому всегда можно установить .NET SDK вруч-
ную, независимо от того, устанавливает ли ваша интегрированная
среда разработки другую версию или нет.
По умолчанию, когда вы запускаете команды dotnet из командной
строки, вы будете использовать последнюю версию установленного
вами .NET SDK. Вы можете контролировать это и использовать более
старую версию SDK, добавив в папку файл global.json. Чтобы получить
представление об этом файле, о том, как его использовать, и о систе-
ме управления версиями .NET, см. статью в моем блоге: http://mng.bz/
KMzP .
После установки .NET SDK пора выбрать интегрированную среду раз-
работки или редактор. Доступные варианты будут зависеть от того, ка-

872
Приложение А
кую операционную систему вы используете, и в значительной степени
будут определяться личными предпочтениями.
А.2 Выбор интегрированной среды разработки
или редактора кода
В этом разделе я опишу несколько самых популярных IDE и редакторов
для разработки на платформе .NET, а также способы их установки. Выбор
IDE – очень личный вопрос, поэтому в этом разделе описаны только не-
которые из вариантов. Если вашей любимой IDE нет в списке, обратитесь
к документации, чтобы узнать, поддерживается ли .NET.
А.2.1 Visual Studio (Windows)
Долгое время Windows была лучшей системой для создания приложе-
ний на .NET, и, учитывая доступность Visual Studio, возможно, что это
по-прежнему так.
Visual Studio (рис. A.2) – это полнофункциональная интегрированная
среда разработки, которая предоставляет одно из лучших универсаль-
ных средств разработки приложений ASP .NET Core. К  счастью, теперь
есть бесплатная версия Visual Studio Community для студентов и неболь-
ших групп разработчиков.
Рис. A.2 Visual Studio предоставляет одно из самых полноценных окружений для разработки
на ASP.NET Core для пользователей Windows

Подготовка окружения разработки 873
Visual Studio поставляется с целым набором шаблонов для создания
новых проектов, лучшей в своем классе отладки и публикации без не-
обходимости прикасаться к командной строке. Она особенно подходит,
если вы публикуете приложения в Azure, поскольку у нее есть множество
прямых подключений к  функциям Azure, чтобы упростить разработку
и развертывание.
Вы можете установить Visual Studio, посетив страницу https://visu-
alstudio.microsoft.com/vs/ и  щелкнув Download Visual Studio (Скачать
Visual Studio). Выберите Community Edition (если у  вас нет лицензии
на версию Professional или Enterprise) и следуйте инструкциям по уста-
новке.
Установщик Visual Studio – само по себе приложение, и он попросит
вас выбрать рабочие	 нагрузки	 для установки. Вы можете выбрать столько,
сколько захотите, но для разработки на ASP .NET Core убедитесь, что вы
выбрали как минимум эти две:
ASP .NET и веб-разработка;
кросс-платформенная разработка на .NET Core.
После выбора этих рабочих нагрузок нажмите Download (Скачать)
и  выберите напиток на свой вкус. Несмотря на то что размер инстал-
лятора недавно уменьшился, Visual Studio по-прежнему требуется мно-
го гигабайт для загрузки и установки. По завершении вы будете готовы
приступить к созданию приложений на ASP .NET Core.
А.2.2 Rider от компании JetBrains (Windows, Linux, macOS)
Rider (рис. A.3) от компании JetBrains представляет собой кросс-платфор-
менную интегрированную среду разработки, альтернативу Visual Studio.
Выпущенная в 2017 году, Rider – еще одна полнофункциональная сре-
да разработки, созданная на базе маститого плагина ReSharper. Если вы
привыкли использовать Visual Studio с плагином ReSharper и множество
функций рефакторинга, которые он предоставляет, то настоятельно ре-
комендую изучить Rider. Кроме того, если вы знакомы с продуктами In-
telliJ от JetBrains, с Rider вы будете чувствовать себя как дома.
Чтобы установить Rider, посетите сайт https://www.jetbrains.com/rider/
и  щелкните Download (Скачать). Есть 30-дневная бесплатная пробная
версия, а по истечении этого срока нужно будет приобрести лицензию.
Если у вас есть лицензия ReSharper, то, возможно, у вас уже есть лицензия
и на Rider. Они также предлагают скидки или бесплатные лицензии для
различных пользователей, например студентов и стартапов, так что это
стоит вашего внимания.

874
Приложение А
Рис. A.3 Rider – это кросс-платформенная интегрированная среда разработки от JetBrains. Она
основана на плагине ReSharper для Visual Studio, поэтому включает в себя множество тех же
функций рефакторинга, а также отладчик, средство запуска тестов и все остальные функции
интеграции, которые вы ожидаете от полнофункциональной среды разработки
А.2.3 Visual Studio для Mac (macOS)
Несмотря на фирменный стиль, Visual Studio для Mac полностью отлича-
ется от Visual Studio. Это обновленная и расширенная версия по сравне-
нию с предшественником, Xamarin Studio, и теперь вы можете исполь-
зовать Visual Studio для Mac для создания приложений ASP .NET Core на
macOS. Visual Studio для Mac обычно имеет меньше функций, чем Visual
Studio или Rider, но предлагает нативную IDE и  находится в  активной
разработке.
Чтобы установить Visual Studio для Mac, посетите страницу https://vi-
sualstudio.microsoft.com/vs/mac, щелкните Download Visual Studio for
Mac (Скачать Visual Studio для Mac), скачайте и запустите установщик.
А.2.4 Visual Studio Code (Windows, Linux, macOS)
Иногда полноценная интегрированная среда разработки не нужна.
Возможно, вы хотите быстро просмотреть или отредактировать файл,
или вам не нравится иногда непредсказуемая производительность Vi-
sual Studio. В этих случаях простой редактор кода – возможно все, что
вам нужно, и Visual Studio Code – отличный выбор. Visual Studio Code
(рис. A.4) – это легковесный редактор с открытым исходным кодом, ко-
торый обеспечивает редактирование, IntelliSense и отладку для широко-
го диапазона языков, включая C# и ASP .NET Core.

Подготовка окружения разработки 875
Рис. A.4 Visual Studio Code обеспечивает кросс-платформенную технологию IntelliSense
и отладку
Чтобы установить Visual Studio Code, посетите сайт https://code.visual-
studio.com/, щелкните Download (Скачать) и запустите скачанный уста-
новщик. При первом открытии папки, содержащей проект C# или файл
решения с Visual Studio Code, вам будет предложено установить расши-
рение C#. Это дает возможность использовать IntelliSense и интеграцию
между Visual Studio Code и .NET SDK.
Модель расширений VS Code – одно из самых больших его преиму -
ществ, поскольку вы можете добавить огромное количество дополни-
тельных функций. Независимо от того, работаете вы с Azure, AWS или
любой другой технологией, обязательно посетите каталог расширений
на странице https://marketplace.visualstudio.com/vscode, чтобы узнать,
какие варианты вам доступны. Если вы ищете «.NET Core», то также
найде те огромное количество расширений, которые могут приблизить
VS Code к полноценной среде разработки, если вы этого хотите.

Приложение	В
Экосистема	 .NET
В этом приложении:
история .NET, ведущая к разработке .NET Core;
положение .NET 5.0 в экосистеме .NET;
совместное использование кода проектами с .NET Standard;
будущее .NET Standard с .NET 5.0.
Экосистема .NET сильно изменилась с тех пор, как была впервые пред-
ставлена платформа .NET, но разработка на .NET Core и .NET 5.0 привела
к особенно значительным изменениям и появлению множества новых
концепций.
Это неудивительно, учитывая недавно обретенную Microsoft прозрач-
ность в отношении открытого процесса разработки и сборки на GitHub.
К сожалению, это может сбивать с толку разработчиков, плохо знакомых
с .NET, и даже опытных ветеранов! Здесь я постараюсь разъяснить неко-
торые термины, которые часто приводят новичков в недоумение, а так -
же дать некий контекст для изменений.
В этом приложении я  расскажу об истории экосистемы .NET, о том,
как она развивалась, и о проблемах, которые Microsoft пыталась решить.
В  частности, я  расскажу о  сходствах и  различиях между .NET 5.0, .NET
Core и .NET Framework.

Приложение В Экосистема .NET 877
Разработка платформы.NET Core не велась изолированно, и одной из
основных целей было улучшение возможности совместного использо-
вания кода между несколькими платформами. В  разделе B.2 я  опишу,
как этого удалось добиться в то время, когда .NET Core и .NET 5.0 еще не
было, с использованием кросс-платформенных библиотек классов (PCL),
и последующий подход с использованием .NET Standard. Наконец, в раз-
деле B.3 мы обсудим, что означает .NET 5.0 для .NET Standard.
B.1 Эволюция .NET в  .NET 5.0
В этом разделе я расскажу об истории .NET 5.0 и .NET Core и о причинах
их создания. Вы узнаете о  различных платформах .NET, существовав-
ших в начале 2010-х годов, и о том, почему их сегментирование привело
к  разработке .NET Core в  качестве новой кросс-платформенной среды
выполнения. Наконец, вы узнаете о том, как .NET 5.0 выросла из .NET
Core, и о будущем .NET.
B.1.1 Платформы .NET, которые привели к появлению
.NET Core
Если вы разработчик на .NET, то, скорее всего, вы уже знакомы с .NET
Framework. .NET Framework версии 4.8 на момент написания этих строк
представляет собой платформу разработки только для Windows, кото-
рую можно использовать как для разработки настольных приложений,
так и для веб-разработки. Она устанавливается в  Windows по умолча-
нию и  традиционно используется для большинства серверных .NET-
разработок и разработки настольных приложений.
Если вы разработчик приложений для мобильных устройств, вы также
можете быть знакомы с платформой Xamarin, которая использует кросс-
платформенную реализацию Mono платформы .NET Framework. Эта
платформа – альтернативная .NET Framework, и ее можно использовать
для создания мобильных приложений для Windows, Android и iOS.
Исторически эти две платформы были полностью отдельными, но со-
стояли из множества похожих компонентов и реализовывали похожие
API. Каждая платформа содержала специфичные библиотеки и модели
приложений, но они использовали аналогичные фундаментальные биб-
лиотеки и типы, как показано на рис. B.1.
В нижней части каждого стека находятся инструменты, позволяющие
компилировать и  запускать приложения .NET, такие как компилятор
и  общеязыковая среда выполнения (CLR). В  верхней части стека у  вас
есть библиотеки для конкретных приложений, которые вы используе-
те, чтобы создавать приложения для своей платформы. Например, вы
можете создать приложение Windows Forms на платформе .NET Frame-
work, но не использовать платформу Xamarin, и наоборот, если речь идет
о приложениях для iOS.

878 Приложение В Экосистема .NET
.NET Framework Xamarin
.NET Framework BCL Mono BCLWindows Forms Android
WindowsWindows Presentation
Foundation (WPF)ASP.NET macOS Console iOS
Модели
приложений
Библиотеки BCL
Общая
инфраструктураКомпиляторы Языки Среда выполненияМодели приложений представляют различные типы приложений,
которые вы можете создавать с помощью платформы.
Обычно они сильно различаются в зависимости от платформы
Библиотека BCL содержит базовые
типы и API для работы с файлами,
потоками и сериализацииРазличные библиотеки BCL
содержат похожие, но немного
разные API
Рис. B.1 Слои, образующие .NET Framework. Каждый из них основан на возможностях нижнего
слоя, а на самом высоком уровне представлены модели приложений, которые вы будете
использовать для создания приложений
В середине каждого стека находятся библиотеки базовых классов
(BCL). Это основные типы .NET, которые вы ежедневно используете
в своих приложениях: типы int и string, API для чтения файлов, API за-
дач и т. д. Хотя обе платформы .NET имеют много похожих типов, они
принципиально разные, поэтому нельзя гарантировать, что какой-либо
тип будет существовать на обеих платформах или будет предоставлять
одни и те же методы и свойства.
До сих пор мы обсуждали только две платформы: .NET Framework
и Xamarin, но у .NET есть множество различных реализаций, и это толь-
ко две из них. В Windows также есть платформа Windows 8/8.1 и уни-
версальная платформа Windows (UWP). На телефонах, помимо Xamarin,
существуют платформы Windows Phone 8.1 и Silverlight Phone. Список
можно продолжать и продолжать (Unity, .NET Compact Framework (CF),
.NET Micro...)!
Каждая из этих платформ использует немного разный набор API (клас -
сы и методы) в своих библиотеках базовых классов. У платформы име-
ется определенное количество похожих API-интерфейсов в этих библио-
теках, но это пересечение неоднородно. Вдобавок ко всему библиотеки,

Приложение В Экосистема .NET 879
составляющие библиотеки базовых классов платформы, принципиально
не совместимы. Любой исходный код, написанный для данного набора
API, необходимо специально компилировать повторно для каждой це-
левой платформы.
Несколько лет назад корпорация Microsoft осознала, что такое сегмен-
тирование .NET является проблемой. Разработчики должны были знать
набор API, который слегка отличался в зависимости от платформы, и со-
вместное использование кода, чтобы его можно было использовать на
нескольких платформах, было проблемой.
Кроме того, основная платформа веб-разработки .NET Framework де-
монстрировала свой возраст. Индустрия программного обеспечения
двигалась в  сторону небольших, легковесных облачных фреймворков,
которые можно было развертывать в кросс-платформенном окружении.
Централизованно устанавливаемая только на Windows, платформа .NET
Framework не была предназначена для этих сценариев. Microsoft при-
ступила к разработке нового фреймворка, который во время разработки
носил название «Project K» и в конечном итоге и стал .NET Core.
B.1.2 Представляем .NET Core
Платформа .NET Core  – решение от Microsoft для централизованной
устанавливаемой платформы .NET Framework, предназначенной только
для Windows. .NET Core имеет модульную структуру, и ее можно развер-
тывать параллельно с другими инсталляциями .NET Core (или же распро-
странять вместе с приложением), и она кросс-платформенная. Термин
.NET	Core несколько перегруженный, поскольку он использовался в про-
цессе разработки как обобщающий термин для описания разнообразных
изменений. Платформа .NET Core состоит из:
кросс-платформенной	 библиотеки	 BCL – это библиотеки BCL плат -
формы .NET Core, которые традиционно называют CoreFX. Они со-
держат все примитивные типы и библиотеки для создания прило-
жений .NET Core;
новой	кросс-платформенной	 среды	выполнения – это среда выполне-
ния для .NET Core, CoreCLR, которая выполняет приложения .NET
Core;
инструментов	 интерфейса	 командной	 строки	.NET – это инструмент
dotnet, используемый для создания и публикации приложений;
библиотек	 ASP.NET	 Core	и EF	Core  – это библиотеки уровня приложе-
ния, используемые для создания приложений ASP .NET Core.
Эти компоненты образуют платформу .NET Core и находят свои анало-
ги различным компонентам, составляющим платформы .NET Framework
и Xamarin, которые вы видели на рис. B.1. Создав новую платформу, Micro-
soft смогла сохранить обратную совместимость для приложений, исполь-
зующих .NET Framework, в  то же время позволяя разрабатывать новые
приложения с применением .NET Core, чтобы воспользоваться преимуще-
ствами ее кросс-платформенной базы и изолированного развертывания.

880 Приложение В Экосистема .NET
ПРИМЕЧАНИЕ  Вы можете подумать: «Подождите, у  них и  так
слишком много платформ .NET, поэтому они создали еще	одну?»
Если вы так и подумали, то вы схватываете все на лету. Но, к сча-
стью, с .NET Core пришел и .NET Standard.
Сама по себе .NET Core означала еще одну BCL-библиотеку API-ин тер-
фейсов, которую разработчикам на .NET пришлось бы учить. Но в рам-
ках разработки .NET Core Microsoft представила .NET Standard. .NET Stan-
dard, как следует из названия, обеспечивала доступность стандартного
набора API для каждой платформы .NET. Больше не нужно было изучать
конкретный набор API, доступных для той разновидности .NET, которую
вы использовали; если бы вы могли использовать стандартные API .NET
Standard, то знали, что у вас все будет в порядке при работе на несколь-
ких платформах. Подробнее о .NET Standard я расскажу в разделе B.2.
.NET Standard стала хорошим временным решением для написания
кода, который мог бы работать на нескольких платформах, но это не
решает одну фундаментальную проблему: платформ по-прежнему не-
сколько. У каждой платформы был свой	отдельный код, который Micro-
soft должна была сопровождать, несмотря на то что во многих местах он
почти	одинаков.
Microsoft быстро вводила новшества в  .NET Core, предлагая новые
функции C#, такие как асинхронные потоки и  Span<T>, а также множест -
во улучшений производительности1.
К сожалению, ни одна из остальных платформ не могла воспользо-
ваться этими нововведениями, не прилагая значительных усилий. Для
решения этой проблемы Microsoft предложила концепцию One.NET.
B.1.3 .NET 5.0 и концепция One .NET: первые шаги
В мае 2019 года Microsoft объявила, что следующей основной версией
.NET Core после 3.0 будет .NET 5.02. Это был первый шаг в попытке уни-
фицировать платформу .NET.
Ранее, как уже обсуждалось в разделе B.1.1, нам приходилось исполь-
зовать .NET Framework для создания настольных приложений Windows,
Xamarin для создания приложений для iOS или Android и .NET Core для
создания кросс-платформенных веб-приложений. Каждая модель при-
ложения была привязана к базовой платформе и использовала отдель-
ную библиотеку BCL. Концепция One .NET, которая началась с .NET 5.0,
заключается в  наличии единой	 платформы .NET с  единой библиотекой
BCL, которую можно использовать с  любой моделью приложения: на-
1 В блоге, посвященном .NET, есть статья, в которой подробно описаны обшир-
ные низкоуровневые улучшения, внесенные в .NET Core. Это восхитительно,
если вы увлекаетесь подобными вещами! Этот пост можно найти на странице
http://mng.bz/9MEx.
2 Эту статью можно найти здесь: https://devblogs.microsoft.com/dotnet/introduc -
tion-net-5/. В ней содержится много подробностей касательно планов на буду -
щее, поэтому настоятельно рекомендую прочитать ее.

Приложение В Экосистема .NET 881
стольными приложениями Windows, приложениями для iOS или An-
droid, а также кросс-платформенными веб-приложениями, как показано
на рис. B.2.
.NET 5.0 BCLWindows
FormsAndroid ARM64
UWPWPFDesktop
# ASP.NET
CoreWeb
UnityGaming
iOSMobile
ARM32IoT
Модели
приложений
Библиотеки
# BCL
Общая
инфраструктураКомпиляторы Языки Среда выполненияНачиная с .NET 5.0
существует единая
платформа
.NET, которая
предоставляет
библиотеку BCL
для всех моделей
приложений. Все
модели приложений
основаны на одной
и той же базовой
библиотеке BCL
Рис. B.2 .NET 5.0 положила начало концепции предоставления единой платформы
для запуска нескольких моделей приложений. Вместо каждой модели приложения, требующей
отдельной платформы .NET с отдельной библиотекой BCL, все модели приложений смогут
использовать одну и ту же базовую платформу .NET и BCL
С практической точки зрения .NET 5.0 – на самом деле «всего лишь»
следующая версия .NET Core. При переносе приложения ASP .NET Core 3.1
на .NET 5.01 критических изменений очень мало, и обновление по боль-
шей части очень простое .NET 5.0 добавляет дополнительные функции
(такие как gRPC и Blazor), но принципиально для большинства приложе-
ний ASP .NET Core мало что изменилось.
ПРИМЕЧАНИЕ  Часто причиной путаницы является название:
.NET 5.0. Слово «Core» было отброшено, чтобы попробовать обо-
значить, что «сейчас существует только одна версия .NET». Кроме
того, версия 4 была пропущена, чтобы избежать путаницы между
новой версией и .NET Framework 4. Надеюсь, данное решение об
именовании окупится в долгосрочной перспективе, даже если сей-
час это сбивает с толку.
Microsoft намеревалась выполнить унификацию BCL и  инфраструк -
туры в .NET 5.0, но задержки привели к тому, что до сих пор была уни-
фицирована только библиотека BCL; приложения Xamarin по-прежнему
используют инфраструктуру сборки и среду выполнения на основе Mono
в .NET 5.0. Microsoft планирует завершить работу по унификации, объ-
1 Список критических изменений можно увидеть в  документации Microsoft
«Критические изменения в .NET 5.0» на странице http://mng.bz/j4Dz.

882 Приложение В Экосистема .NET
единив инфраструктуру сборки и  среду выполнения Mono и  .NET 5.0.
в следующем выпуске, .NET 6.0.
.NET 5.0 представляет собой первый шаг на пути к One .NET. Есть на-
дежда, что если все будущие усилия по разработке будут базироваться
на одной платформе, это уменьшит дублирование усилий и обеспечит
бóльшую стабильность и прогресс для платформы. Учитывая это, Micro-
soft старается регулярно выпускать новые релизы, поэтому вы можете
легко спланировать, как поддерживать свои приложения в актуальном
состоянии по мере выхода новых версий .NET.
B.1.4 Будущее: .NET 6.0 и последующие версии
Как и во многих проектах с открытым исходным кодом, открытая разра-
ботка часто связана с более быстрым циклом выпуска, чем с традицион-
ной .NET Framework. Это, безусловно, относится к .NET Core: новые вы-
пуски выходят регулярно в течение первых нескольких лет разработки.
Хотя многим разработчикам нравится такой ускоренный ритм и но-
вые функции, это может привести к некоторой неопределенности. Стоит
ли тратить время и обновляться до последней версии сейчас, если новая
версия будет выпущена на следующей неделе?
Чтобы противодействовать потенциальному оттоку и вселить в поль-
зователей уверенность в  постоянной поддержке, каждый выпуск .NET
Core (и .NET 5.0+) попадает в одну из двух категорий	поддержки:
выпуски	с долгосрочной	поддержкой (long term support, LTS) – эти вы-
пуски поддерживаются в течение трех лет с момента первого вы-
пуска;
текущие	 выпуски – эти выпуски поддерживаются в течение трех ме-
сяцев после следующего	LTS-релиза или текущего выпуска.
Наличие двух поддерживаемых вариантов оставляет вам простой
выбор: если вы хотите больше функций и готовы чаще обновлять свое
приложение, выберите «Текущие выпуски»; если вам нужно меньше об-
новлений, но и  меньше функций, выберите «Выпуски с  долгосрочной
поддержкой».
Такой подход в  некоторой степени уменьшил неопределенность, но
пользователи по-прежнему точно не знали, когда именно выйдет новый
релиз и, следовательно, как долго будет поддерживаться текущая версия.
С выходом .NET 5.0 Microsoft взяла на себя обязательство придержи-
ваться четко определенного цикла выпуска, выпуская новую старшую
версию .NET каждый год, чередуя выпуски с долгосрочной поддержкой
и текущие выпуски, как показано на рис. B.3. Незначительные обновле-
ния не будут частыми, но при необходимости будут происходить в про-
межуточные месяцы.
С помощью этой временной шкалы вы теперь знаете, как долго будет
поддерживаться версия .NET. Если вы используете текущий релиз (на-
пример, .NET 5.0), вы знаете, что он будет поддерживаться еще три меся-
ца после выпуска .NET 6.0 в ноябре 2021 года. Что касается релиза LTS, то
.NET 6.0 будет поддерживаться до ноября 2024 года.

Приложение В Экосистема .NET 883
Каждый год
в ноябре будет
выходить новая
версия .NETРелизы будут чередоваться между
долгосрочной поддержкой (L TS)
c поддержкой в течение 3 лет
и текущими (Current) с 15 месяцами
поддержки LTS LTS LTS Current Current
.NET Core 3.1
Нояб. 2019.NET 6.0
Нояб. 2021.NET 8.0
Нояб. 2023.NET 5.0
Нояб. 2020.NET 7.0
Нояб. 2022
Рис. B.3 Временная шкала выпуска новых версий .NET. Новая версия .NET будет выходить
каждый год в ноябре. Выпуски будут чередоваться между версиями с долгосрочной
поддержкой (L TS) и текущими версиями
Унификация нескольких платформ .NET, начиная с .NET 5.0, означает,
что в будущем будет меньше необходимости в совместном использова-
нии кода между несколькими платформами: это одно из главных пре-
имуществ One .NET. Тем не менее вам, несомненно, придется работать
с  уже существующими устаревшими приложениями в течение многих
лет, поэтому совместное использование кода по-прежнему вызывает
беспокойство.
Как я описал в разделе B.1.2, .NET Standard был представлен наряду
с .NET Core как способ совместного использования кода между прило-
жениями .NET Core и  существующими устаревшими приложениями.
Прежде чем подробно обсуждать .NET Standard, я кратко расскажу о его
предшественнике, кросс-платформенных библиотеках классов, и поче-
му они устарели в связи с появлением .NET Standard.
B.2 Совместное использование кода в проектах
В этом разделе я расскажу об истории совместного использования кода
платформами .NET с по мощью кросс-платформенных библиотек клас -
сов. Затем познакомлю вас с .NET Standard как альтернативным решени-
ем, представленным в .NET Core.
При таком большом количестве различных реализаций .NET экоси-
стеме .NET требовался способ совместного использования кода между
библиотеками задолго до появления .NET Core. Что, если вы хотите ис -
пользовать одни и те же классы и  в  проекте ASP .NET .NET Framework,
и  в  проекте Silverlight? Пришлось бы создавать отдельный проект для
каждой платформы, копировать и вставлять файлы и повторно компи-
лировать код для каждой платформы. В  результате появились бы две
разные библиотеки из одного и того же кода. Первоначально для реше-
ния этой проблемы использовались кросс-платформенные библиотеки
классов.
B.2.1 Поиск общих точек пересечения
с кросс-платформенными библиотеками классов
Эти библиотеки появились, чтобы упростить процесс компиляции и со-
вместного использования кода между несколькими платформами. При
создании библиотеки разработчики могли указать платформы, которые

884 Приложение В Экосистема .NET
они хотят поддерживать, и проект имел бы доступ только к набору API,
которые были общими для всех них. Каждая дополнительная поддержи-
ваемая платформа уменьшала количество поддерживаемых API, огра-
ничиваясь теми API, которые доступны на всех выбранных платформах,
как показано на рис. B.4.
Xamarin
.NET FrameworkUniversal Windows
Platform (UWP)API, общие для Xamarin и UWP
API, общие для Xamarin
и .NET FrameworkAPI, общие для UWP
и .NET FrameworkAPI, общие для всех
трех фреймворков
Рис. B.4 Каждый дополнительный фреймворк, который должен поддерживаться
кросс-платформенной библиотекой классов, сокращает количество API, доступных
для вашего приложения. Если вы поддерживаете несколько фреймворков, вам будет
доступно значительно меньше API
Чтобы создать кросс-платформенную библиотеку классов (далее:
PCL-библиотеку), нужно было создать библиотеку, ориентированную на
определенный «профиль» PCL. Этот профиль содержал предварительно
вычисленный список API-интерфейсов, и  было известно, что они до-
ступны на ассоциированных платформах. Таким образом, можно было
создать одну библиотеку, которую можно использовать на выбранных
платформах. У вас мог быть один проект и один результирующий пакет –
копировать и вставлять файлы или дублировать проекты было не нужно.
Такой подход был явным улучшением по сравнению с предыдущим
вариантом, но создание PCL-библиотек часто было непростым делом.
Существовали врожденные сложности с  инструментами, с  которыми
приходилось бороться, и было сложно понять API, доступные для каждой
комбинации платформ, составляющих профиль PCL1.
Помимо этих проблем, каждая дополнительная платформа, на кото-
рую вы ориентируетесь, будет сокращать количество API, доступных для
использования в  вашей библиотеке. Например, .NET Framework может
1 Весь этот ужасающий список целиком можно найти здесь: https://portableli-
braryprofiles.stephencleary.com/.

Приложение В Экосистема .NET 885
содержать API A, B и C. Но если у Xamarin есть только API A, а у Универ-
сальной платформы Windows (UWP) – только API C, ваша библиотека не
сможет использовать ни один из них, как показано на рис. B.5.
Xamarin
.NET FrameworkUniversal Windows
Platform (UWP).NET Framework поддерживает API A, B и C
Xamarin поддерживает
только API A UWP поддерживает
только API C
Рис. B.5 Каждая платформа предоставляет несколько разные API. При создании
PCL-библиотек доступны только те API, которые доступны на всех целевых
платформах. В данном случае ни один из API-интерфейсов, A, B или C, не доступен
ни на одной из платформ, поэтому ни один из них нельзя использовать в PCL
Еще одна проблема, связанная с  библиотеками PCL, заключалась
в том, что они по своей природе были привязаны к базовым платфор-
мам, для которых были предназначены. Чтобы работать с новой целевой
платформой, вам пришлось бы повторно компилировать PCL, даже если
никаких изменений исходного кода не требовалось.
Допустим, вы используете библиотеку PCL, которая поддержива-
ет универсальную платформу Windows 10.0 и .NET Framework 4.5. Если
бы Microsoft выпустила новую платформу, скажем .NET Fridge, которая
предоставляет тот же API, что и UWP 10.0, вы не смогли бы использовать
существующую библиотеку с  новым приложением .NET Fridge. Вместо
этого вам пришлось бы ждать, пока автор библиотеки перекомпилиру -
ет свою PCL-библиотеку для поддержки новой платформы, и кто знает,
когда это произошло бы!
PCL-библиотеки решили определенную проблему, но если говорить
о современной разработке, то .NET Standard обеспечивает гораздо более
чистый подход.
B.2.2 .NET Standard: общий интерфейс для .NET
В рамках разработки .NET Core Microsoft объявила .NET Standard преем-
ником библиотек PCL. .NET Standard берет связь, существующую меж -
ду поддержкой платформы и доступными API при использовании PCL,
и переворачивает ее с ног на голову:

886 Приложение В Экосистема .NET
PCL-библиотеки – 	профиль PCL предназначен для определенного
набора платформ. API, доступные для библиотеки PCL, представля-
ют собой общие API, совместно используемые всеми платформами
в профиле;
.NET	Standard – версия .NET Standard определяет конкретный на-
бор API. Эти API всегда доступны в библиотеке .NET Standard. Лю-
бая платформа, реализующая все эти API, поддерживает эту версию
.NET Standard.
.NET Standard – это не то, что вы скачиваете. Это список API, которые
должна реализовать платформа, совместимая с .NET Standard1. Вы мо-
жете создавать библиотеки, предназначенные для .NET Standard, и ис -
пользовать их в любом приложении, предназначенном для совместимой
с .NET Standard платформы.
.NET Standard имеет несколько версий, каждая из которых является
надмножеством предыдущих версий. Например, .NET Standard 1.2 вклю-
чает в себя все API из .NET Standard 1.1, которая, в свою очередь, включа-
ет в себя все API из .NET Standard 1.0, как показано на рис. B.6.
.NET Standart 1.0
.NET Standart 1.1
.NET Standart 1.2API, доступные в .NET Standard 1.0, 1.1 и 1.2
API, доступные в .NET Standard 1.1 и 1.2
API, доступные только в .NET Standard 1.2
Рис. B.6 Каждая версия .NET Standard включает в себя все API из предыдущих
версий. Чем меньше версия .NET Standard, тем меньше количество API
Когда вы создаете библиотеку .NET Standard, то ориентируетесь на
конкретную версию .NET Standard и  можете ссылаться на любую биб-
1 Буквально .NET Standard – это список API. Вы можете просмотреть API, вклю-
ченные в каждую версию .NET Standard, на сайте GitHub: http://mng.bz/yYqe.
Например, здесь можно увидеть API, включенные в .NET Standard 1.0: http://
mng.bz/MXY8.

Приложение В Экосистема .NET 887
лиотеку, предназначенную для этой или более ранней версии. Если вы
пишете библиотеку, предназначенную для .NET Standard 1.2, то можете
ссылаться на пакеты, предназначенные для .NET Standard 1.2, 1.1 или 1.0.
На ваш пакет, в свою очередь, может ссылаться любая библиотека, пред-
назначенная для .NET Standard 1.2 или поздней версии, или библиотека,
предназначенная для платформы, которая реализует .NET Standard 1.2
либо более позднюю версию.
Платформа реализует определенную версию .NET Standard, если она
содержит все API, которые требуются этой версии .NET Standard. По сути,
платформа, поддерживающая конкретную версию .NET Standard, также
поддерживает все предыдущие версии .NET.Standard. Например, UWP
версии 10 поддерживает .NET Standard 1.4, а это означает, что она также
поддерживает .NET Standard версий 1.0–1.3, как показано на рис. B.7.
.NET Standart 1.0
.NET Standart 1.1
.NET Standart 1.2
.NET Standart 1.3
.NET Standart 1.4
UWP Version 10UWP версии 10 включает в себя все API
для .NET Standard 1.4 и ниже
Она также включает в себя API
для конкретных платформ, которые
не являются частью с .NET Standard
Рис. B.7  Платформа UWP версии 10 поддерживает .NET Standard 1.4. Это означает,
что она содержит все API-интерфейсы, которые требуются спецификации .NET
Standard версии 1.4, то есть она также содержит все API в более ранних версиях .NET
Standard и дополнительные API для конкретных платформ, которые не являются
частью какой-либо версии .NET Standard
Каждая версия платформы поддерживает отдельную версию .NET
Standard. .NET Framework 4.5 поддерживает .NET Standard 1.1, а  .NET
Framework 4.7.1 – .NET Standard 2.0. В табл. B.1 показаны версии, поддер-
живаемые различными платформами .NET. Чтобы увидеть более полный
список, см. обзор Microsoft «.NET Standard»: https://docs.microsoft.com/
dotnet/standard/net-standard.
Эта таблица часто используется для объяснения .NET Standard, но
для меня связь между .NET Standard и платформой .NET обрела смысл,

888 Приложение В Экосистема .NET
когда я увидел пример, объясняющий .NET Standard в терминах кон-
струкций C#1.
Таблица B.1 Максимальная поддерживаемая версия .NET Standard для различных
версий платформы .NET. Пустая ячейка означает, что версия .NET Standard
не поддерживается платформой
Версия .NET Standard 1.0 1.1 1.2 1.3 1.4 1.5 1.6 2.0 2.1
.NET Core и .NET 5.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 2.0 3.0
.NET Framework 4.5 4.5 4.5.1 4.6 4.6.1 4.6.2 4.7.1
Mono 4.6 4.6 4.6 4.6 4.6 4.6 4.6 5.4 6.4
Универсальная
платформа Windows10.0 10.0 10.0 10.0 10.0  10.0.16299 10.0.16299 10.0.16299
Windows 8.0 8.0 8.1
Windows Phone 8.1 8.1 8.1
Можно рассматривать каждую версию .NET Standard как серию уна-
следованных интерфейсов, а платформы .NET – как реализации одного
из этих интерфейсов. В следующем листинге я использую последние две
строки табл. B.1, чтобы проиллюстрировать это, рассматривая .NET Stan-
dard версий 1.0–1.2 и платформы Windows 8.0 и Windows Phone 8.1.
Листинг B.1 Интерпретация .NET Standard в C#
interface NETStandard1_0
{
void SomeMethod();
}
interface NETStandard1_1 : NETStandard1_0
{
void OtherMethod();
}
interface NETStandard1_2 : NETStandard1_1
{
void YetAnotherMethod();
}
class Windows8 : NETStandard1_1
{
void SomeMethod () { /* Реализация метода. */ }
void OtherMethod() { /* Реализация метода. */ }
void ADifferentMethod() { /* Реализация метода. */
}
1 Этот пример был первоначально предоставлен Дэвидом Фаулером из груп-
пы ASP .NET. Обновленную версию данной схемы можно увидеть здесь: http://
mng.bz/aoqX.Определяет API, доступные в .NET Standard 1.0.
NET Standard 1.1 наследует все API
от .NET Standard 1.0.
API-интерфейсы доступны в .NET Standard 1.1, но не в 1.0.
NET Standard 1.2 наследует все API
от .NET Standard 1.1.
API-интерфейсы доступны в .NET Standard 1.2,
но не в 1.1 или 1.0.
В Windows 8.0 реализован .NET Standard 1.1.
Реализации API, которые требуются
.NET Standard 1.1 и 1.0.
Дополнительные API-интерфейсы, не входящие
в .NET Standard, но существующие на платформе
Windows 8.0.

Приложение В Экосистема .NET 889
class WindowsPhone81 : NETStandard1_2
{
void SomeMethod () { /* Реализация метода. */ }
void OtherMethod() { /* Реализация метода. */ }
void YetAnotherMethod () { /* Реализация метода. */ }
void ExtraMethod1() { /* Реализация метода. */ }
void ExtraMethod2() { /* Реализация метода. */ }
}
Точно так же, как вы пишете программы для использования интер-
фейсов, а не конкретных реализаций, вы можете нацелить свои библио-
теки на интерфейс .NET Standard, не беспокоясь об отдельных деталях
реализации платформы. Затем вы можете использовать свою библио-
теку с любой платформой, которая реализует требуемую версию интер-
фейса.
Одно из преимуществ, которое вы получаете, ориентируясь на .NET
Standard, – это возможность ориентироваться на новые платформы без
необходимости повторно компилировать какие-либо библиотеки или
ждать, пока авторы зависимых библиотек перекомпилируют свои. Это
также значительно упрощает рассуждение о точно доступных API – чем
выше версия .NET Standard, на которую вы ориентируетесь, тем больше
API будет вам доступно.
ПРЕДУПРЕЖДЕНИЕ  Даже если платформа реализует опреде-
ленную версию .NET Standard, реализация метода может возбу -
дить исключение PlatformNotSupportedException. Например, неко-
торые API рефлексии могут быть доступны не на всех платформах.
.NET 5.0 включает в себя поддержку анализаторов Roslyn для об-
наружения такой ситуации и предупредит вас о проблеме во вре-
мя сборки.	 См. «Автоматический поиск скрытых ошибок в вашем
коде с .NET 5» в блоге, посвященном .NET (http://mng.bz/WdX4) для
получения дополнительной информации об анализаторах, пред-
ставленных в .NET 5.0.
К сожалению, не все так просто, как нам бы того хотелось. Хотя .NET
Standard 2.0 является строгим надмножеством .NET Standard 1.6, при-
ложения, ориентированные на .NET Framework 4.6.1, могут ссылаться
на библиотеки .NET Standard 2.0, хотя	технически	 она	реализует	 только
.NET	Standard	1.4, 	как	показано	в табл. 	B.11.
Причина этого шага заключалась в том, чтобы противостоять пробле-
ме «курица или яйцо». Одна из первых жалоб на .NET Core 1.x заключа-
лась в том, что доступных API было мало, а это усложняло перенос про-
1 Причина такого шага была изложена в  посте «Введение в  .NET Standard»
в блоге, посвященном .NET., который я настоятельно рекомендую прочитать:
https://devblogs.microsoft.com/dotnet/introduction-net-standard/.Windows
Phone 8.1
реализует
# .NET
Standard 1.2.Реализации API, которые
требуются .NET Standard 1.2,
1.1 и 1.0.
Дополнительные API-интерфейсы, не входящие в .NET Standard,
но существующие на платформе Windows Phone 8.1.

890 Приложение В Экосистема .NET
ектов на .NET Core. Поэтому в .NET Core 2.0 Microsoft добавила тысячи
API, которые были доступны в .NET Framework 4.6.1, наиболее популяр-
ной версии .NET Framework, и добавила их в .NET Standard 2.0. Предпо-
лагалось, что .NET Standard 2.0 будет предоставлять те же API, что и .NET
Framework 4.6.1.
К сожалению, .NET Framework 4.6.1 не содержит API в .NET Standard 1.5
или 1.6. Поскольку .NET Standard 2.0 является строгим надмножеством
.NET Standard 1.6, .NET Framework 4.6.1 не может напрямую поддержи-
вать .NET Standard 2.0.
Это поставило Microsoft перед проблемой. Если бы самая популярная
версия .NET Framework не поддерживала .NET Standard 2.0, никто бы
не стал писать библиотеки .NET Standard 2.0, что также затруднило бы
работу .NET Core 2.0. Тогда Microsoft приняла решение	 разрешить	 .NET
Framework	 4.6.1	ссылаться	 на	библиотеки	 .NET	Standard 2.0, как показано
на рис. B.8.
.NET Standard 1.4 .NET Standard 2.0 .NET Framework 4.6.1NET Framework 4.6.1 содержит все необходимые
API, поэтому поддерживает .NET Standard 1.4
В .NET Framework 4.6.1 отсутствуют
некоторые API-интерфейсы,
необходимые для .NET Standard 2.0,
поэтому он не может ссылаться на
библиотеки .NET. Standard 2.0
Однако для ускорения внедрения
и поскольку он содержит почти все
необходимые API, приложения и библиотеки
.NET Framework 4.6.1 могут ссылаться
на библиотеки .NET Standard 2.0
Рис. B.8. NET Framework 4.6.1 не содержит API, необходимых для .NET Standard
1.5, 1.6 или 2.0, но содержит почти все API, необходимые для .NET Standard 2.0.
Чтобы ускорить внедрение и упростить использование библиотек .NET Standard
2.0, вы можете ссылаться на библиотеки .NET Standard 2.0 для приложения на .NET
Framework 4.6.1
Все это приводит к принципиальным техническим трудностям. .NET
Framework 4.6.1 может ссылаться на библиотеки .NET Standard 2.0, хотя
технически не поддерживает их, но у вас должен быть установлен набор
средств разработки .NET Core 2.0, чтобы все работало правильно.
Чтобы еще больше все запутать, скажу, что библиотеки, скомпилиро-
ванные для .NET Framework 4.6.1, могут ссылаться на библиотеки .NET
Standard с  по мощью оболочки совместимости, о  которой пойдет речь
в следующем разделе.

Приложение В Экосистема .NET 891
План Microsoft в  отношении .NET Standard 2.0 состоял в том, чтобы
упростить создание приложений на .NET Core. Если бы пользователи соз-
давали библиотеки, ориентированные на .NET Standard 2.0, то все равно
могли бы использовать их в приложениях .NET Framework 4.6.1, а также
могли бы использовать библиотеки в приложениях .NET Core.
Проблема заключалась в том, что при первом выпуске .NET Standard
2.0 библиотеки (пакеты NuGet) ее еще не реализовывали. Учитывая, что
стандартные библиотеки .NET могут ссылаться только на другие библио-
теки .NET Standard, пришлось бы подождать, пока все ваши зависимости
обновятся до .NET Standard, которым сначала придется дождаться своих
зависимостей, и т. д.
Чтобы ускорить этот процесс, Microsoft создала «прослойку» совмес -
тимости. Она позволяет библиотеке .NET Standard 2.0 ссылаться	 на	биб-
лиотеки	 .NET	Framework	 4.6.1. Обычно такие ссылки были бы невозмож -
ны; библиотеки .NET Standard могут ссылаться лишь на библиотеки .NET
Standard такой же или более ранней версии, как показано на рис. B.91.
Приложения .NET Core 2.0
и .NET Framework 4.6.1 могут
ссылаться на библиотеки
.NET Standard 2.0
Библиотеки .NET Standard 2.0 могут ссылаться
на библиотеки .NET Standard версии 2.0 и нижеОболочка совместимости позволяет библиотекам
.NET Standard ссылаться на библиотеки
.NET FrameworkОбычно нельзя ссылаться
на библиотеки .NET Framework
из библиотеки .NET StandardПриложение .NET Core 2.0Приложение
.NET Framework 4.6.1
MyLibrary.dll
(.NET Standard 2.0)
NerStandardLibrary1.dll
(.NET Standard 2.0)NerStandardLibrary2.dll
(.NET Standard 1.х)NerFrameworkLibrary.dll
(.NET Framework)
Рис. B.9 По умолчанию библиотеки .NET Standard могут ссылаться только на другие
библиотеки .NET Standard, ориентированные на ту же версию .NET Standard или
ниже. С прослойкой совместимости библиотеки .NET Standard также могут ссылаться
на библиотеки, скомпилированные для .NET Framework 4.6.1
Активировав эту прослойку, приложения .NET Core 2.0 внезапно смог -
ли использовать любую из множества доступных библиотек NuGet для
.NET Framework версии 4.6.1 (или ниже). Пока библиотека, на которую
вы ссылаетесь, привязана к API, которые являются частью .NET Standard
2.0, вы сможете ссылаться на библиотеки .NET Framework в своих прило-
жениях .NET Core 2+ или библиотеках .NET Standard 2.0, даже если ваше
приложение работает на разных платформах, в Linux или macOS.
1 Процесс, с по мощью которого достигается эта магия, сложен. В статье «.NET
Standard 2» на сайте GitHub подробно описывается процесс унификации сбор-
ки: http://mng.bz/8NEZ.

892 Приложение В Экосистема .NET
ВНИМАНИЕ!  Если в библиотеке используются API для конкрет -
ной версии .NET Framework, вы получите исключение во время
выполнения. Нет простого способа узнать, безопасно ли использо-
вать библиотеку, за исключением изучения исходного кода, поэто-
му инструменты .NET будут выдавать предупреждение при каждой
сборке. Обязательно тщательно протестируйте свое приложение,
если используете эту прослойку.
Если у вас сейчас кружится голова, я вас не виню. Это был особенно за-
путанный момент в развитии .NET Standard, где правила менялись в со-
ответствии с текущим окружением, а это неизбежно вело к различным
предостережениям и  размахиванию руками, за которыми следовали
ошибки и исправления1. К счастью, если ваша разработка ориентиро вана
на .NET 5.0, .NET Standard – не та вещь, о которой вам, как правило, при-
дется беспокоиться.
B.3 .NET 5.0 и будущее .NET Standard
В этом разделе я расскажу о том, что означает .NET 5.0 для будущего .NET
Standard, и о том, какой подход нужно использовать для новых приложе-
ний, ориентированных на .NET 5.0.
ПРИМЕЧАНИЕ  Рекомендации, приведенные в этом разделе, ос -
нованы на официальном руководстве Microsoft относительно бу -
дущего .NET Standard: http://mng.bz/goqG.
NET Standard был необходим, когда .NET Core была молодой платфор-
мой, чтобы гарантировать, что у вас по-прежнему есть доступ к сущест -
вующей экосистеме пакетов NuGet. .NET 5.0 – это эволюция .NET Core,
поэтому вы можете воспользоваться преимуществами той же экосисте-
мы в .NET 5.0.
.NET 5.0 реализует .NET Standard 2.1, последнюю версию этого стан-
дарта, которая также реализована в .NET Core 3.0. Это означает, что при-
ложения .NET 5.0 могут ссылаться на:
любой пакет или библиотеку NuGet, реализующие .NET Standard
1.0–2.1;
любой пакет или библиотеку NuGet, реализующие .NET Core 1.x–3.x
или .NET 5.0.
.NET Standard был разработан для управления совместным использо-
ванием кода между несколькими платформами .NET. Но выпуск .NET 5.0
и концепция One .NET специально нацелены на создание	 единой плат -
формы. Так .NET Standard по-прежнему полезен?
1 Пример одной такой проблемы можно найти здесь, но, к сожалению, подоб-
ных случаев было много: https://github.com/dotnet/runtime/issues/29314.

Приложение В Экосистема .NET 893
И да, и нет. Начиная с .NET 5.0 и выше, новых версий .NET Standard
выпускать не планируется, поскольку последующие версии .NET (напри-
мер, .NET 7.0) уже смогут ссылаться на библиотеки, ориентированные на
более ранние версии .NET (например, .NET 5.0 и .NET 6.0).
К сожалению, концепция One .NET не была реализована в .NET 5.0 –
приложения Xamarin по-прежнему используют среду выполнения
и инструменты Mono (хотя они используют ту же BCL-библиотеку, что
и .NET 5.0). Это означает, что если вам нужно совместно использовать
код между приложениями .NET 5.0 и Xamarin, вам потребуется исполь-
зовать .NET Standard. В .NET 6.0, если все пойдет по плану, для этого сце-
нария .NET Standard не потребуется; вы сможете ориентироваться на
.NET 6.0 и использовать свой код в приложениях ASP .NET Core и Xamarin.
.NET Standard также будет полезен, когда вам нужно совместно ис -
пользовать код в приложениях .NET. 5.0+ и устаревших (.NET Core, .NET
Framework, Xamarin) приложениях. .NET Standard остается механизмом
для этого совместного использования кода в платформах .NET.
Резюме
.NET имеет множество различных реализаций, включая .NET Frame-
work, Mono и  Unity. Каждая из них представляет собой отдельную
платформу с отдельными библиотеками BCL и моделями приложений.
.NET Core – еще одна отдельная платформа.
У каждой платформы есть библиотека BCL, которая предоставляет
основные типы и классы .NET, такие как строки, операции с файлами
и потоки. У каждой платформы – своя BCL-библиотека с некоторыми
отличиями.
.NET 5.0 – это первый шаг в унификации этих платформ, в первую оче-
редь Mono (а следовательно, Xamarin) и .NET Core в рамках концепции
One .NET. Модели приложений, в настоящее время ассоциированные
с другими платформами, будут доступны на новой платформе .NET 5+.
.NET 5.0 объединяет базы кода для BCL Mono и .NET Core. В .NET 6.0
среда выполнения и  инструменты также будут унифицированы, за-
вершая видение One .NET. Это позволит создавать настольные и мо-
бильные приложения, веб-приложения и  многое другое с  по мощью
единой платформы .NET, .NET 6.0.
Новый основной выпуск .NET будет выходить каждый год. Они будут
чередоваться с выпусками с долгосрочной поддержкой, которые полу -
чают поддержку в течение 3 лет, и текущими выпусками с поддержкой
на протяжении 15 месяцев.
Кросс-платформенные библиотеки классов (PCL) попытались решить
проблему совместного использования кода между платформами .NET,
позволяя использовать одну библиотеку на разных платформах. Каж -
дая дополнительная платформа, на которую вы ориентировались,
озна чала меньшее число совместно используемых API.

894 Приложение В Экосистема .NET
.NET Standard определяет стандартный набор API, доступных на всех
поддерживающих ее платформах. Вы можете писать библиотеки,
предназначенные для конкретной версии .NET Standard, и они будут
совместимы с любой платформой, которая поддерживает эту версию.
Каждая версия .NET Standard является надмножеством предыдущей.
Например, .NET Standard 1.2 включает в  себя все API из .NET Stan-
dard 1.1, которая, в свою очередь, включает в себя все API из .NET Stan-
dard 1.0.
Каждая версия платформы поддерживает определенную версию .NET
Standard. Например, .NET Framework 4.5.1 поддерживает .NET Stan-
dard 1.2 (а следовательно, также .NET Standard 1.1 и 1.0).
Технически .NET Framework 4.6.1 поддерживает только .NET Stan-
dard  1.4. Благодаря прослойке совместимости вы можете ссылаться
на библиотеки .NET Standard 2.0 из приложения .NET Framework 4.6.1.
Точно так же можно ссылаться на библиотеку .NET Framework из биб-
лиотеки .NET Standard 2.0, что было бы невозможно без этой про-
слойки.
Если вы полагаетесь на прослойку совместимости для ссылки на биб-
лиотеку .NET Framework 4.6.1 из библиотеки .NET Standard 2.0, а ука-
занная библиотека использует API для конкретной .NET Framework, то
вы получите исключение во время выполнения.
Приложение должно быть нацелено на реализацию платформы .NET,
например .NET 5.0 или .NET Core 3.1. Оно не может работать с .NET
Standard.
.NET 5.0 поддерживает .NET Standard 2.1. Она может ссылаться на лю-
бую библиотеку .NET Standard и любую библиотеку .NET Core.

Приложение	C
Полезные	ссылки
В этом приложении я приведу ряд ссылок и справочных материалов, ко-
торые считаю полезными для изучения .NET Core / .NET 5.0, .NET Stan-
dard и ASP .NET Core.
C.1 Список литературы
В данной книге мы затронули несколько тем и аспектов экосистемы .NET,
которые в некоторой степени второстепенны при создании приложений
на ASP .NET Core. Для более глубокого понимания этих тем я рекомендую
книги, перечисленные в этом разделе. В них рассказывается о тех обла-
стях, с которыми вы неизбежно столкнетесь при создании приложений
на ASP .NET Core:
Владимир	 Хориков. Принципы, паттерны и  практики модульного
тестирования (Manning, 2020), http://mng.bz/E2go. Научитесь совер-
шенствовать свои модульные тесты, используя современные пере-
довые методы, из этой замечательной книги, содержащей примеры
на C#;
Дастин	 Метцгар. .NET Core в действии (Manning, 2018), http://mng.
bz/NY9N. Приложения ASP .NET Core создаются с  использованием
.NET Core и .NET 5.0. В этой книге есть все, что вам нужно знать о за-
пуске приложений на этой платформе;
Рой	Ошероув. Искусство модульного тестирования. 2-е изд. (Man-
ning, 2013), http://mng.bz/DRan. В книге «ASP .NET Core в действии»
я обсуждаю механизмы модульного тестирования приложений ASP .
NET Core. Для более подробного обсуждения того, как создавать свои
тесты, я рекомендую книгу «Искусство	модульного	тестирования»;

896 Приложение C Полезные ссылки
Крис	Сейнти. Blazor в  действии (Manning, 2021), http://mng.bz/l1P6.
Blazor – это новый захватывающий фреймворк, использующий мощь
отраслевого стандарта WebAssembly, для запуска .NET в  брау зере.
С Blazor вы можете создавать одностраничные приложения, как если
бы вы использовали фреймворк Java Script, такой как Angular или Re-
act, но применяя язык C# и инструменты, которые уже знаете;
Джон	П.	Смит. Entity Framework Core в действии. 2-е изд. (Manning,
2021), http://mng.bz/BRj0. Если вы используете EF Core в своих при-
ложениях, то настоятельно рекомендую эту книгу. Она охватывает
все функции и недостатки EF Core, а также способы настройки ва-
шего приложения для повышения производительности;
Стивен	Ван	Дерсен	и Марк	Симанн. Принципы, практики и паттерны
внедрения зависимостей (Manning, 2019), http://mng.bz/d4l. Внед-
рение зависимостей – это основной аспект ASP .NET Core, поэтому
данная книга особенно актуальна сейчас. Она познакомит вас с пат -
тернами и  антипаттернами внедрения зависимостей в  контексте
.NET и языка C#.
С.2 Объявления в блоге
Когда Microsoft выпускает новую версию ASP .NET Core или .NET Core, то
обычно объявляет об этом в своем блоге. Эти посты предоставляют об-
щий обзор темы со множеством примеров новых функций. Это отлич-
ное место для старта, если вы хотите быстро познакомиться с какой-то
темой:
Ричард Лэндер, «Анонс .NET 5.0», блог .NET (Microsoft, 10 ноября
2020  г.), https://devblogs.microsoft.com/dotnet/announcing-net-5-0/.
Объ  явление в блоге, посвященном .NET 5.0, где описываются неко-
торые особенности, появившиеся в .NET 5.0;
Ричард Лэндер, «Знакомство с .NET 5.0», блог .NET (Microsoft, 6 мая
2019 г.), https://devblogs.microsoft.com/dotnet/introduction-net-5/.
Статья, в которой описывается видение этой платформы;
Иммо Ландверт, «Будущее .NET Standard», блог .NET (Microsoft,
15  сентября 2020 г.), https://devblogs.microsoft.com/dotnet/the-fu-
ture-of-netstandard. Обсуждение того, что .NET 5.0 означает для бу -
дущего .NET Standard, включая руководство для авторов библиотек;
Иммо Ландверт, «.NET Standard  – проясняем мифы о  .NET Core и  .NET
Standard», Microsoft Developer Network (Microsoft, сентябрь 2017 г.),
https://docs.microsoft.com/en-us/archive/msdn-magazine/2017/sep-
tember/net-standard-demystifying-net-core-and-net-standard. Длин-
ная статья, знакомящая вас с .NET Core и объясняющая место .NET
Standard в экосистеме .NET;
Документация Microsoft, «Политика поддержки .NET Core и .NET 5»,
https://dotnet.microsoft.com/platform/support/policy/dotnet-core.
Официальная политика поддержки Microsoft для .NET Core и  .NET 5.0;

Приложение C Полезные ссылки 897
Дэниел Рот, «Аннонс ASP .NET Core в .NET 5», блог ASP .NET (Microsoft,
10 ноября 2020 г.), https://devblogs.microsof t.com/aspnet/announcing-
aspnet-core-in-net-5/. Статья, касающаяся ASP .NET Core 5.0. Здесь
описано, как обновить проект с версии 3.1 до 5.0, и предоставляют -
ся ссылки на некоторые специфические функции ASP .NET Core 5.0;
Мадс Торгерсен, «C# 9.0 для протокола», блог .NET (Microsoft, 10 но-
ября 2020 г.), https://devblogs.microsoft.com/dotnet/c-9-0-on-the-
record/. Статья, посвященная C# 9.0, который был выпущен вместе
с .NET 5.0.
С.3 Документация Microsoft
Исторически сложилось так, что документация Microsoft была скудной,
но с  появлением ASP .NET Core были предприняты огромные усилия,
чтобы обеспечить ее полезность и актуальность. Вы можете найти по-
шаговые инструкции, целевую документацию по конкретным функциям
и поддерживаемым API и даже компилятор C#, встроенный в браузер:
Microsoft Docs, «.NET API Browser», https://docs.microsoft.com/dot -
net/api/. Это браузер, который можно использовать, чтобы опреде-
лить, какие API и на каких платформах .NET доступны;
Microsoft Docs, «Документация по ASP .NET», https://docs.microsoft.
com/aspnet/core/. Это официальная документация по ASP .NET Core;
Microsoft Docs, «Ориентация на кросс-платформенность», https://
docs.microsoft.com/dotnet/standard/library -guidance/cross-platform-
targeting. Официальное руководство по выбору целевого фреймвор-
ка для своих библиотек;
Роуэн Миллер, Брайс Лэмбсон, Мария Вензель, Диего Вега и Мар-
тин Милан, «Entity Framework Core» (Microsoft, 20 сентября 2020 г.),
https://docs.microsoft.com/ef/core. Это официальная документация
по EF Core.
С.4 Ссылки по темам, связанным
с безопасностью
Безопасность – важный аспект современной веб-разработки. В этом раз-
деле содержатся материалы, на которые я регулярно ссылаюсь и в кото-
рых описываются передовые практики работы веб-разработки, а также
методы, которых следует избегать:
Брок Аллен и  Доминик Байер, «Документация по IdentityServer4
1.0.0», https://identityserver4.readthedocs.io/. Документация по Iden-
tityServer, OpenID Connect и OAuth 2.0 для ASP .NET Core;
Доминик Байер, «Доминик Байер об управлении идентификацией
и доступом» (блог), https://lessprivilege.com/. Личный блог Домини-

898 Приложение C Полезные ссылки
ка Байера, одного из авторов IdentityServer. Отличный ресурс при
работе с аутентификацией и авторизацией в ASP .NET Core;
Скотт Хельме, https://scotthelme.c o.uk/. Блог Скотта Хельме с сове-
тами по стандартам безопасности, особенно с заголовками безопас -
ности, которые можно добавлять в свое приложение;
Скотт Хельме, «SecurityHeaders.io – анализируйте заголовки HTTP-
ответов», https://securityheaders.com/. Проверьте заголовки безопас -
ности своего сайта и  получите совет относительно того, для чего
и как добавить их в свое приложение;
Трой Хант, https://www.troyhunt.com. Личный блог Троя Ханта с со-
ветами по безопасности для веб-разработчиков, в  частности для
разработчиков на .NET;
Microsoft Docs, «Обзор безопасности ASP .NET Core» (Microsoft,
24  октября 2018 г.), https://docs.microsoft.com/aspnet/core/security/.
Домашняя страница официальной документации ASP .NET Core по
всем вопросам, связанным с безопасностью.
C.5 Репозитории ASP.NET Core на GitHub
ASP .NET Core – проект с полностью открытым кодом и репозиториями на
сайте GitHub. Один из лучших способов, который я нашел, чтобы изучить
этот фреймворк, – просмотреть его исходный код. Этот раздел содержит
основные репозитории для ASP .NET Core, .NET 5.0 и EF Core:
.NET Foundation, «ASP .NET Core», https://github.com/dotnet/aspnet -
core. Библиотеки фреймворка, образующие ASP .NET Core;
.NET Foundation, «Entity Framework Core», https://github.com/dotnet/
efcore. Библиотека EF Core;
.NET Foundation, «.NET Runtime», https://github.com/dotnet/runtime.
Среда выполнения .NET CoreCLR и  библиотеки BCL, а  также биб-
лиотеки расширений;
.NET Foundation, «.NET SDK and CLI», https://github.com/dotnet/sdk.
Интерфейс командной строки .NET (CLI), ресурсы для сборки .NET
SDK и шаблоны проектов.
В этом разделе содержатся ссылки на инструменты и сервисы, кото-
рые можно использовать для создания проектов на ASP .NET Core:
.NET SDK – https://dotnet.microsoft.com/download;
Cloudflare, глобальная сеть доставки контента, которую можно ис -
пользовать, чтобы добавить кеширование и протокол HTTPS в свои
приложения бесплатно, – https://ww w.cloudflare.com;
JetBrains Rider – https://www.jetbrains.com/rider;
Let’s Encrypt, бесплатный, автоматизированный и открытый центр
сертификации. Вы можете использовать его, чтобы получить бес -
платные сертификаты SSL для защиты своего приложения, – https://
letsencrypt.org/;

Приложение C Полезные ссылки 899
.NET Boxed от Мухаммеда Рехана Саида, обширная коллекция шаб-
лонов, чтобы начать работать с ASP .NET Core, предварительно на-
строенных с учетом множества передовых методов, – https://github.
com/Dotnet-Boxed/Templates;
Visual Studio, Visual Studio для Mac и Visual Studio Code – https://
www. visualstudio.com.
С.7 Блоги, посвященные ASP.NET Core
Этот раздел содержит блоги, посвященные ASP .NET Core. Пытаетесь ли вы
получить обзор какой-то общей темы или решить конкретную проблему,
вам может быть полезно иметь несколько точек зрения по данной теме:
Халид Абухакмех, Абухакмех, https://khalidabuhakmeh.com/. Боль-
шой выбор статей от Халида, посвященных .NET и разработке про-
граммного обеспечения в целом;
Крис Алкок, Утреннее	 пиво, http://blog.cwa.me.uk/. Коллекция ста-
тей, посвященных .NET, обновляется ежедневно;
Дэмиен Боден, Разработка	 программного	 обеспечения, https://
damienbod.com. Отличный блог технического эксперта Microsoft
Дэмиена Бодена об ASP .NET Core с большим количеством статей об
ASP .NET Core и Angular;
Майк Бринд, Mikesdotnetting, https://www.mikesdotnetting.com/.
У  Майка Бринда много статей об ASP .NET Core, особенно тех, что
касаются ASP .NET Core Razor Pages;
Стив Гордон, Стив	Гордон – 	Пишите	 код	со	Стивом, https://www.ste-
vejgordon.co.uk/. Персональный блог Стива Гордона, посвященный
.NET. Часто уделяется внимание написанию высокопроизводитель-
ного кода с .NET;
Скотт Хансельман, Скотт	Хансельман, https://www.hanselman.com/
blog/. Персональный блог известного докладчика Скотта Хансель-
мана. Разнообразный блог, ориентированный преимущественно на
# .NET;
Эндрю Лок, .NET	Escapades, https://andrewlock.net. Мой персональ-
ный блог, посвященный ASP .NET Core;
Microsoft .NET Team, блог	.NET, https://blogs.msdn.microsoft.com/dot -
net. Блог команды .NET со множеством отличных ссылок;
Дэвид Пайн, IEvangelist, http://davidpine.net/. Персональный блог
технического эксперта Microsoft Дэвида Пайна с большим количест -
вом статей об ASP .NET Core;
Мухаммед Рехан Саид, https://rehansaeed.com. Персональный блог
Мухаммеда Рехана Саида, технического эксперта Microsoft и автора
.NET Boxed;
Рик Штраль, Веб-блог	 Рика	Штраля, https://weblog.west-wind.com/.
Отличный блог, охватывающий широкий спектр тем по ASP .NET
Core;

900 Приложение C Полезные ссылки
Филип В., StrathWeb, https://www.strathweb.com. Множество статей
об ASP .NET Core и ASP .NET от Филипа, технического эксперта Micro-
soft и активного участника проектов с открытым исходным кодом.
C.8 Ссылки на видео
Если вы предпочитаете видео для изучения предмета, то рекомендую
озна комиться со ссылками из этого раздела. В частности, видеотрансля-
ции от сообщества ASP .NET Core дают отличное представление об изме-
нениях, которые вы увидите в будущих версиях ASP .NET Core, непосред-
ственно от команды, занимающейся созданием фреймворка.
Microsoft, .NET	 Conf	2020, видеоплейлист YouTube (13 ноября 2020),
http://mng.bz/ryRB. Все сессии онлайн-конференции .NET Conf 2020,
посвященной анонсу .NET 5.0;
.NET Foundation, .NET	 Community	 Standup, https://do tnet.microsoft.
com/platform/community/standup. Еженедельные видеоролики,
в которых команда ASP .NET Core обсуждает разработку фреймвор-
ка. Также включает видеотрансляции с  командами .NET, Xamarin
и EF Core;
Иммо Ландверт, .NET	 Standard – 	Introduction, видео на YouTube (28 но-
ября 2016 г.), http://mng.b z/Vd0P . Первое видео из отличной серии,
посвященной .NET Standard;
Microsoft, «Channel 9: видео для разработчиков от тех, кто создает
продукты и сервисы Microsoft», https://channel9.msdn.com/. Офици-
альный видеоканал Microsoft. Содержит огромное количество ви-
део роликов о .NET и ASP .NET Core, среди прочего;
Шон Вильдермут, Создание	 веб-приложения	 с по	мощью	ASP.NET	 Core,
MVC,	Entity,	Framework	 Core,	Bootstrap	 и Angular, курс на сайте Plu-
ralsight, 9 часов 52 минуты (7 октября 2019 г.), http://mng.bz/xmRW .
Курс Шона Вильдермута по созданию приложения на ASP .NET Core;
Стив Гордон, «Интеграционное тестирование приложений ASP .NET
Core: передовой опыт», курс на сайте Pluralsight, 3 часа 25 минут
(15 июля 2020 г.), http://mng.b z/A09z. Один из курсов Стива Гордо-
на, где даются советы и рекомендации по созданию приложения на
ASP .NET Core.

Предметный	указатель
Символы
.csproj, 71
# .NET 5.0, 38
ссылка, 57
эволюция из .NET, 877
.NET Core, 879
# .NET SDK, 870
# A
Accept (заголовок), 342
# AJAX, 269
AppDbContext, 446
ASP .NET Core, 34
авторизация, 558
аутентификация, 517
внедрение зависимостей, 362
дочерние действия, 266
запуск приложений в Docker, 608
и обратные прокси-серверы, 55
конечная точка, 170
маршрутизация, 169
модель хостинга, 592
одностраничные приложения, 318
преимущества и ограничения, 36
тестирование приложения, 829
ASP .NET Core Identity, 524
ASP .NET Core MVC (фреймворк), 137
Azure Key Vault, 408B
Blazor WebAssembly (фреймворк), 315
# C
ConfigureWebHostDefaults (метод), 76
ContentRoot, 399
content-type (заголовок), 342
CreateDefaultBuilder (метод), 75
# E
EndpointMiddleware, 97
Entity Framework Core, 434
# F
FluentValidation, 766
# G
GetTypedHeaders(), 502
# H
HTTP-метод, 90
HttpContext (объект), 61, 99
HTTP (Hypertext Transfer Protocol), 53
HttpMessageHandler, 794

902 Предметный указатель
httpsRedirectionMiddleware, 679
HTTP Strict Transport Security (HSTS), 677
# I
IHost, 74
IntelliSense, 255
IWebHostEnvironment (объект), 82
# K
Kestrel, 61
# M
Markdown, 753
Model Binding, 133
# MVC, 43, 63, 134
# MVVM, 138
# N
Newtonsoft.Json, 344
NuGet, 49
использование пакетов, 73
# P
# POST-REDIRECT-GET, 230
ProblemDetails, 325
ProblemDetails, преобразование всех
ошибок, 340
Program (класс), 75
# Q
Quartz.NET, 815
# R
Razor Pages, 34, 63
настройка соглашений, 197
обработчики страниц, 155
отличие от Web Forms, 151
создание ответов, 86
REST (Representational State Transfer), 41
# S
Scoped, 386Singleton, 387
Startup (класс), 75
настройка приложения, 77
System.Text.Json, 344
# T
Transient, 385
# W
WebForms, 283
# А
Авторизация, 490, 515, 555
на основе ресурсов, 577
Антипаттерн, 497
Атака
путем внедрения SQL-кода, 702
с открытым перенаправлением, 700
Аутентификация, 490, 515, 555
# Б
Безопасность веб-приложений, 667
# В
Валидация, 467
замена фреймворка, 766
специальный атрибут, 761
Валидация модели, 224
на сервере, 228
на стороне клиента, 232
Веб-сайт
имя хоста, 53
многостраничный, 132
путь, 86
Веб-API, 316
применение паттерна проектирования
# MVC, 326
создание первого проекта, 318
Внедрение зависимостей, 353
открытые обобщенные типы, 372
преимущества, 354
Внешние значения, 191
Внешний ключ, 446
Выражения Razor, 252

903 Предметный указатель
# Г
Глобальные фильтры запросов, 466
Граф зависимостей, 356
# Д
Движок представлений в MVC, 156
Двунаправленный конвейер, 99
Двухфакторная аутентификация
# (2FA), 524
Действие, 150
Декларативное программирование, 579
Динамическая веб-страница, 35
создание с помощью Razor, 251
Директива, 246
# Ж
Жизненный цикл сервиса, 382
Scoped, 386
Singleton, 387
Transient, 385
Журналирование, 630
структурное (семантическое), 644
# З
Задание в Quartz.NET, 816
Запуск приложения, 68
Захваченные зависимости, 388
Значения маршрута, 180
# И
Изоляция базы данных, 861
Именованный клиент (паттерн), 786
Императивное программирование, 579
Имя хоста веб-сайта, 53
Инверсия управления, 358
Интерфейс командной строки .NET, 67
Истинное удаление, 464
Источник, 691
Источник привязки, 213
выбор, 221
# К
Категория сообщения журнала, 642
Кеширование, 494Коды состояния HTTP-ответа, 109
Компонент
конечной точки, 61
представления, 267, 755
Конвейер, 44, 98
прерывание выполнения, 506
промежуточного ПО, 712
фильтров, 473
Конечная точка, 170, 559
специальная, 724
Контейнер
внедрения зависимостей, 358
сторонний, 739
Контейнеризация, 44
Контекст базы данных, 439
Концепция контроллеров и методов
действий, 149
Корневой сертификат, 673
Кратковременные зависимости, 385
# Л
Локатор сервисов (паттерн), 804
# М
Макет
в Razor, 259
проекта, 70
Маркер синхронизатора (шаблон), 686
Маршрутизация, 165
конечных точек, 169
на основе атрибутов, 330
на основе соглашений, 330
ограничения и порядок, 186
преимущества и недостатки
стилей, 174
Межсайтовая подделка запросов (CSRF),
290, 685
Межсайтовый скриптинг, 681
Метаданные, 225
Метод действия, 150
Миграции, 449
Минификация, 618
Многостраничный веб-сайт, 132
Модель
предметной области, 141
представления, 142
привязки, 140, 205

904 Предметный указатель
приложения, 206
страницы, 89, 207
Модель–представление–контроллер
# (MVC), 37, 43, 63, 134
Модель–представление–представление
# (MVVM), 138
Модуль HTTP , 101
Мягкое удаление, 466
# Н
Настройка, 395
Небезопасная прямая ссылка
на объект, 704
Неустойчивые (хрупкие) тесты, 856
Неявный обработчик страницы, 197
# О
Области, 530
журналирования, 663
Область действия фильтра, 482
Обнаружение сервисов, 497
Обработчик страницы, 90, 155, 194
неявный, 197
Обработчик HTTP , 101
Обратный прокси-сервер, 593
Объект HttpContext, 61, 99
Одиночный объект, 371
Окружение размещения, 422
Открытые обобщенные типы, 372
Отражение (reflection), 78
# П
Параллелизм, 467
Параметр маршрута, 180
Параметры (паттерн), 420
Паттерн проектирования, 80
Первичный ключ таблицы, 445
Переопределение параметров, 397
Подстановка (шаблон), 622
Политика авторизации, 566
Получатель данных, 650
Поставщик конфигурации, 397
Поясняющая фраза HTTP-ответа, 109
Правило ограничения домена, 691
Представление, 136, 241
передача данных, 248создание, 245
шаблоны, 247
Привязка
загрузки файлов с помощью
IFormFile, 219
коллекций и словарей, 218
модели, 133, 157, 208
простых типов, 212
сложных типов, 216
Приложение веб-API, 63
Принципал, 515
Принцип единственной
ответственности, 79
Проект, 63
Промежуточное программное
обеспечение, 97
создание специального компонента, 721
Протокол передачи гипертекста
# (HTTP), 53
Публикация приложения, 600
Пул приложений, 601
Путь, 86
# Р
Развертывания, 597
Разделение ответственности, 143
Размещение приложения, 606
Регистрация, 362
многократная, 374
сервисов с использованием объектов
и лямбда-функций, 369
собственных сервисов
в контейнере, 367
три составляющие, 368
условная, 377
Редактор кода, 280
Реляционные базы данных, 435
# С
Сборка веб-хоста, 74
Сборка приложения, 66
Сброс кеша, 307
Связанность, 360
Связыватель, 415
Сегмент, 175
Секрет, 395
Сервис, 79

905 Предметный указатель
Сервис-локатор, 363
Сервис рабочей роли, 808
Сеть доставки содержимого, 624
Синглтон, 371
Синхронные и асинхронные
команды, 467
Скаффолдинг, 544
Скаффолдинг столбцов, 467
Слабосвязанный код, 360
Согласование содержимого, 342
Создание
приложения, 63
ссылок, 305
форм, 283
Сокет, 779
Строитель (паттерн), 75
Строка запроса, 167
Строка запроса со сбросом кеша, 307
Сущность, 439
Схема, 448
# Т
Тег-хелпер, 282
ввода, 292
добавления версии, 307
метки, 291
области текста, 296
окружения, 308
раскрывающегося списка, 296
сводки валидации, 303
сообщений валидации, 302
специальный, 746
формы, 288
якоря, 305
Терминология, проблемы, 48
Тестирование, 829
интеграционное, 850
модульное
специального промежуточного
# ПО, 843
с xUnit, 831API-контроллеров, 846
Тестовые проекты, 829
Типизированные клиенты, 788
# У
Универсальный узел, создание
служб, 76
Упаковка, 618
Управление пользователями, 547
Уровень сообщения журнала, 638
Условная разметка, 309
Утверждение, 516, 556, 567
# Ф
Файл ключа, 690
Фильтры
авторизации, 490
действий, 494
исключений, 499
результатов, 501
ресурсов, 492
страниц, 504
Фоновые задачи, 800
Форматер вывода, 330
Форматирование ответа, 341
# Ч
Частичные представления, 264, 269
# Ш
Шаблон, 59
Шаблон маршрута, 171, 175
синтаксис, 182
# Э
Экосистема .NET, 876

Книги издательства «ДМК ПРЕСС »
можно купить оптом и в розницу
в книготорговой компании «Галактика»
(представляет интересы издательств
«ДМК ПРЕСС », «СОЛОН ПРЕСС», «КТК Галактика»).
Адрес: г. Москва, пр. Андропова, 38;
тел.: (499) 782-38-89, электронная почта: books@alians-kniga.ru.
При оформлении заказа следует указать адрес (полностью),
по которому должны быть высланы книги;
фамилию, имя и отчество получателя.
Желательно также указать свой телефон и электронный адрес.
Эти книги вы можете заказать и в интернет-магазине: http://www.galaktika-dmk.com/.
Эндрю Лок
ASP .Net Core в действии
Главный редактор 	 Мовчан	 Д.	А.
dmkpress@gmail.com
Зам. главного редактора Сенченкова 	Е.	А.
Перевод Беликов	Д.	А.
Корректор Синяева	Г.	И.
Верстка	 Чаннова 	А.	А.
Дизайн обложки  Мовчан	А.	Г.
Гарнитура PT Serif. Печать цифровая.
Усл. печ. л. 34,94. Тираж 200 экз.
Веб-сайт издательства: www.dmkpress.com

