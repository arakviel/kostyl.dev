## Безпека

## 1\. Системні таблиці та представлення

Важливо знати, що кожна база даних, крім створених користувачем таблиць, містить додатковий набір системних таблиць. Імена більшості системних таблиць починаються з префікса _sys_. Більшість полів цих таблиць документовані, але трапляються і не документовані поля, звернення до яких здійснювати заборонено.

Отже, давайте розберемось, які системні таблиці існують і яка інформація в них представлена. Всі системні таблиці можна поділити на наступні групи:

-   Таблиці резервного копіювання тавідновлення.
-   Таблиці доставки журналів. Їх імена починаються з префікса _log\_shipping\_xxx_.
-   Таблиці системи відслідковування змін даних.
-   Таблиці реплікації.
-   Таблиці плану обслуговування бази даних.
-   Таблиці агента SQL Server.
-   Таблиці служб Integration Services, які фактично містять опис системних таблиць бази даних _msdb_.
-   Базові системні таблиці, які зберігають метадані окремої бази даних.

Отже, набір системних таблиць доволі великий. Основну увагу привертають базові системні таблиці. Вони розміщуються в базах даних користувачів та в головній базі даних _master_. Але дані базових системних таблиць закриті і недоступні для звичайних клієнтів SQL Server. Доступ до них мають лише співробітники корпорації Microsoft.

Існує ще одна база даних, яка містить перелік всіх системних об'єктів, які входять до складу SQL Server, тобто включають також в себе набір базових системних таблиць користувацьких баз даних. Це база даних _Resource_. Системні об'єкти SQL Server, такі як _sys.objects_, фізично зберігаються в базі даних _Resource_, а відображаються у схемі _sys_ для кожної бази даних (оскільки сама база даних _Resource_ невидима і доступ напряму до неї заборонений).

Варто відмітити, що ряд системних таблиць, які були присутні в попередніх версіях SQL Server, починаючи з версії MS SQL Server 2005 реалізовані у вигляді набору системних представлень. Ці системні представлення несуть загальну інформацію і реалізовані на серверному рівні, тобто можуть розповісти про будь-яку базу даних на сервері. Ряд цих представлень ви вже знаєте, оскільки про них ми згадували в попередніх уроках. Та не дивлячись на це, підсумуємо всю відому інформацію та приведемо співставлення системних таблиць SQL Server 2000 (остання версія, де використовувались приведені системні таблиці) та системних представлень SQL Server 2008.

Спочатку розглянемо системні представлення, які є в кожній базі даних на сервері.

**Таблиця 1**

**Системна таблиця SQL Server 2000**

**Системне представлення SQL Server 2008**

**Опис**

_sysobjects_

sys.objects

Містить перелік об'єктів бази даних, крім тригерів.

_syscomments_

sys.sql\_modules

Містить код оголошення об'єктів бази даних (модулів) та різноманітні параметри, з якими створювався кожен окремий об'єкт.

_syscolumns_

sys.columns

Містить загальний опис кожного поля таблиці, представлення та повертаємого табличне значення функції.

_sysdepends_

sys.sql\_expression\_ dependencies

Містить дані про іменовані залежності між представленнями, зберігаємими процедурами, тригерами і таблицями, які вказуються при їх оголошенні.

_sysfilegroups_

sys.filegroups

Містить інформацію про файлові групи, які є в базі даних.

_sysfiles_

sys.database\_files

Містить дані про файли бази даних.

_sysаforeignkeys_

sys.foreign\_key\_columns

Зберігає інформацію про всі зовнішні ключі, включаючи дані про те, з первинним полем якої таблиці він зв'язаний.

_sysconstraints_

sys.check\_constraints

sys.default\_constraints

sys.key\_constraints

sys.foreign\_keys

Містить інформацію про конструкції бази даних: обмеження (check), значення по замовчуванню (default), ключі (key), включаючи зовнішні (foreign keys).

_sysindexes_

sys.indexes

sys.partitions

sys.allocation\_units

sys.dm\_db\_partition\_stats

Містять інформацію про всі індекси бази даних.

_sysindexkeys_

sys.index\_columns

Містить інформацію про індекси і поля, на які вони вказують.

_sysmembers_

sys.database\_role\_members

Містить інформацію про користувачів і ролі, до яких вони відносяться.

_sysreferences_

sys.foreign\_keys

Містить карту зв'язків таблиць.

_systypes_

sys.types

Містить список всіх користувацьких та системних типів даних.

_sysusers_

sys.database\_principals

Містить дані про всіх користувачів та ролі SQL Server і Windows.

_sysfulltextcatalogs_

sys.fulltext\_catalogs

Містить список повнотекстових каталогів.

_syspermissions sysprotects_

sys.database\_permissions

sys.server\_permissions

Містить дані про всі права і обмеження окремого користувача або ролі: на рівні поля бази даних (sys.database\_permissions) або на рівні сервера (sys.server\_permissions).

Ряд системних таблиць бази даних _master_ в SQL Server 2008 також були замінені на системні представлення з аналогічними іменами. Наприклад, системна таблиця _sysconfigures_, яка містить параметри конфігурації сервера в системі, замінена на системне представлення sys.configurations, системна таблиця _sysdatabases_ з інформацією про перелік баз даних сервера — на системне представлення sys.databases тощо.

## 2\. Захист даних. Режими захисту даних. Поняття аутентифікації та авторизації на рівні MS SQL Server

### 2.1. Основні поняття

Сьогодні ми навчимось належним чином організовувати безпеку даних в SQL Server 2008, яка має важливе значення в діяльності різного роду організацій, що використовують бази даних. Адже без забезпечення надійного захисту даних, будь-хто може знищити цінні дані або отримати доступ до засекреченої інформації. Для цього в першу чергу слід вірно спроектувати систему управління користувачами, зокрема зменшити кількість користувачів з необмеженим доступом до мінімуму, ввести систему паролів тощо.

Система безпеки SQL Server 2008 для запобігання неавторизованого доступу до даних використовує режими захисту та облікові записи. Існує 2 режими захисту даних:

1.  Режим захисту Windows (_Windows authentication_) — це самий простий спосіб захисту і він являється режимом захисту даних по замовчуванню. Цей режим аутентифікації дозволяє підключатись до SQL Server, вводячи логін та пароль при вході в Windows. Щоб задіяти даний режим, достатньо на сервері додати ім'я входу Windows.
2.  Змішаний режим захисту (_Mixed mode_) — це режим захисту, при якому користувачі реєструються безпосередньо при доступі до SQL Server, окремо від реєстрації в операційній системі. При цьому доступ до даних можуть отримувати будь-які імена входу, включаючи імена входу Windows. Зазвичай, даний спосіб аутентифікації обирають у випадку використання відмінної від Windows операційної системи.

Корпорація Microsoft рекомендує використовувати режим захисту Windows, оскільки він дозволяє реалізувати переваги всіх централізованих політик безпеки домена _Active Directory_. Такий режим дійсно має ряд переваг для виробничої бази даних, серед яких можна виділити наступні:

-   користувачу не потрібно запам'ятовувати багато паролів, а достатньо одного — для входу на комп'ютер;
-   перевірка даних користувача при вході на сервер відбувається швидше.

Але вибір на користь змішаного режиму може також переважити:

-   на підприємстві не існує домена Windows, наприклад, при використанні Unix систем;
-   користувачі SQL Server не входять в домен, наприклад, якщо вони підключаються до сервера баз даних через Web-інтерфейс.

Підсумуємо: режим захисту Windows найбільш безпечний, але змішаний режим захисту більш гнучкий і незалежний від адміністратора мережі.

Режим захисту даних можна змінити. Для цього в SSMS необхідно викликати діалогове вікно Server Properties (_Властивості Сервера_) окремо взятого сервера та перейти на вкладку Security (_Безпека_):

![Рисунок 1](https://fsx1.itstep.org/api/v1/files/XszrJOGj5a3RNXHG6Yxib6wbctCwOTrc)

Рисунок 1

Крім того, в системі SQL Server організована двохрівнева модель обмеження доступу до даних. В зв'язку з цим порядок дій організації доступу до даних користувача буде наступний:

1.  Створити обліковий запис або ім'я входу користувача (login) на сервері, вказавши для нього пароль та набір інших параметрів. Це дозволить йому підключатись до самого сервера, але ще не дає доступу до баз даних. Даний етап являється першим рівнем безпеки SQL Server (аутентифікація користувача).
2.  До кожної необхідної бази даних додати користувача (user), який буде співставлятись з іменем входу. На основі прав користувача баз даних (user), його ім'я входу (login) отримує доступ до відповідної бази даних. В зв'язку з цим на одне ім'я входу може припадати кілька користувачів (для різних баз даних), кожен з яких може мати різні права доступу. Це другий рівень безпеки (авторизація користувача).
3.  Надати користувачу відповідні права на базу даних.

Розглянемо все по порядку.

### 2.2. Створення імен входу

Отже, для організації безпеки на сервері баз даних необхідно в першу чергу правильноспроектувати систему управління користувачами. В мові SQL немає набору стандартних команд, які призначені для створення імен входу та користувачів бази даних. В кожній СУБД для цього призначений свій набір команд, але їх суть у всіх реалізаціях однакова. В SQL Server 2008 для таких цілей можна скористатись засобами SSMS або набором операторів T-SQL.

В T-SQL для створення імен входу (облікових записів, логінів) на сервері використовують оператор CREATE LOGIN

```html
CREATE LOGIN логін {WITH список_опцій | FROM джерело_даних}

-- Список опцій:
PASSWORD = {'пароль' | 'хешируваний_пароль' HASHED} 
           [ MUST_CHANGE ] [, SID = sid ]    -- ідентифікатор безпеки; GUID нового
                                             -- імені входу SQL Server
[, DEFAULT_DATABASE = БД_по_замовчуванню ]   -- база даних, яка буде поточною
                                             -- при вході користувача
[, DEFAULT_LANGUAGE = мова_по_замовчуванню ]
[, CHECK_EXPIRATION = {ON | OFF} ]            -- чи необхідно встановлювати строк дії 
                                             -- пароля
[, CHECK_POLICY = {ON | OFF} ]                -- чи застосовувати до логіна 
                                             -- політику паролів Windows на комп'ютері,
                                             -- де виконується SQL Server
[, CREDENTIAL = ім'я_облікових_даних ]

-- Джерело даних:
-- для Windows аутентифікації
WINDOWS [ WITH [ DEFAULT_DATABASE = БД_по_замовчуванню ]
        [, DEFAULT_LANGUAGE = мова_по_замовчуванню] ] 
         | CERTIFICATE ім'я_сертифіката 
         | ASYMMETRIC KEY ім'я_асиметричного_ключа
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

При створенні логіна спочатку потрібно вказати його ім'я, яке може містити від 1 до 128 символів (літери, цифри і всі символи, крім символа зворотнього слеша ( \\ ) ). В якості імені входу не можна використовувати зарезервовані імена, а їх значення не може бути NULL або являтись пустим рядком (' '). Слід відмітити, що в SQL Server 2008 існує 4 типи імен входу:

-   імена входу SQL Server;
-   імена входу Windows, які співставляються з обліковим записом домена Windows. Формат таких імен має вигляд \[домен\\логін\];
-   імена входу, які співставлені за допомогою сертифіката;
-   імена входу, які співставлені за допомогою асиметричного ключа.

Для того, щоб створити ім'я входу SQL Server необхідно обрати конструкцію WITH. Для створення одного з трьох останніх типів підходить конструкція FROM оператора CREATE LOGIN.

Зупинимось коротко на поясненні останніх двох типів імен входу, а саме на іменах входу, які співставляються за допомогою сертифіката та асиметричного ключа. Почати напевно варто з того, що SQL Server 2008 підтримує ієрархічну структуру ключів, які дозволяють шифрувати дані. Сертифікати і асиметричні ключі являються одним із засобів такого шифрування. Вони повинні міститись в базі даних master і бути зв'язані з відповідним користувачем.

Асиметричний ключ (_asymmetric key_) — це комбінація закритого і відкритого ключа, який йому відповідає. Для його створення використовується оператор CREATE ASYMMETRIC KEY. Сертифікати (_certificates_) являють собою підписану цифровим підписом інструкцію, яка зв'язує значення відкритого ключа з ідентифікатором користувача (пристрою або служби), який має відповідний закритий ключ. В SQL Server 2008 можна створювати власні підписані сертифікати, які відповідають стандарту X.509 за допомогою інструкції CREATE SERTIFICATE. Сертифікати являються найнадійнішим способом шифрування даних, хоча разом з асиметричним ключем являється ресурсоємким і тому повільним методом. Найшвидший метод шифрування даних — це симетричний ключ. Більш детальніше про конфігурування шифрування в SQL Server можна прочитати в розділі «Ієрархія засобів шифрування» електронної документації SQL Server 2008.

Зауваження щодо створення імен входу SQL Server:

-   Якщо параметр HASHED не вказаний, тоді пароль хешується перед збереженням в базу даних. Даний параметр не рекомендується використовувати при створенні нових логінів. Він може бути корисний лише у конкретних випадках, наприклад, при перенесенні бази даних з одного сервера на інший.
-   База даних по замовчуванню — master.
-   Параметр MUST\_CHANGE вказує на те, що при першому використанні нового імені входу, SQL Server буде здійснювати запит нового пароля. Але тут існує один нюанс: вікно для зміни пароля з'являється лише в SQL Server Management Studio. Більшість інших додатків при підключенні такого користувача повернуть помилку.
-   Параметр CREDENTIAL на сьогоднішній день лише зв'язує з новим іменем входу об'єкт Credential, який являє собою пару «ім'я облікового запису Windows — пароль». Цей об'єкт використовується здебільшого у випадку, коли користувач хоче здійснити певні дії в ОС або на іншому сервері SQL Server з сценарію T-SQL. Об'єкт Credential можна створити за допомогою оператора CREATE CREDENTIAL.
-   Параметр CHECK\_POLICY буде працювати лише, якщо SQL Server працює під управлінням Windows 2003 Server або пізнішими версіями. Якщо він встановлений, то на пароль для даного логіна будуть просто поширюватись ті вимоги, які застосовуються до локальних облікових записів на даному комп'ютері.

Приведемо приклад створення логіну SQL Server з паролем.

```html
create login Vasja
with password = '123';
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Новий обліковий запис буде розміщений в директорії _Logins_ (логіни, імена входу) папки _Security_ (безпека) сервера.

![Рисунок 2](https://fsx1.itstep.org/api/v1/files/QuqneKYRaIBI2Ize-aleGHjIB75OCCoZ)

Рисунок 2

А тепер створимо ім'я входу Windows, яке буде зв'язане з обліковим записом користувача _Windows Pupki__n_ з групи _students_, яка знаходиться в домені _stepdom_:

```html
create login [stepdom\students\Pupkin]
from windows;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Якщо необхідно зареєструвати всіх користувачів з групи _students_ домена _stepdom_, крім користувача _Petrenko_, слід використати оператор DENY (більш детальніше вінбуде розглянутий нижче).

```html
create login [stepdom\students] from windows;    -- реєструєму групу користувачів
deny connect sql to [stepdom\students\Petrenko]; -- виключаємо з неї користувача Petrenko
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Список всіх імен входу розміщується в системному представленні sys.sql\_logins. Крім того, для перегляду списку всіх імен входу на сервері можна також скористатись системною зберігаємою процедурою безпеки sp\_helplogins:

```html
sp_helplogins[ [ @LoginNamePattern = ] 'логін' ]
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Наприклад:

```html
exec sp_helplogins 'sa';
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

![Рисунок 3](https://fsx1.itstep.org/api/v1/files/tjJS-dJ02UrgnsDnrrIYhOAlMblbnP8C)

Рисунок 3

Результатом роботи даної системної зберігаємої процедури буде 2 звіти:

1.  Перший звіт містить дані про ім'я входу.
2.  Другий звіт містить узагальнені дані про користувачів, які відповідаютьданому імені входу та список ролей, членом яких він являється.

В SSMS існує папка _Security->Logins_, яка містить набір імен входу сервера баз даних. Щоб додати новий логін необхідно викликати пункт контекстного меню New->Login… гілки _Security_ або _New Login…_ дочірного вузла _Logins_.

![Рисунок 4](https://fsx1.itstep.org/api/v1/files/iv-9OtDV1TL9Pd3MvqKD6nC_UVOm62w3)

Рисунок 4

Після цього з'явиться діалогове вікно створення нового імені входу. На закладці General (_Загальні_) необхідно вказати загальні властивості для нового імені входу. В першу чергу необхідно задати саме ім'я входу та пароль для нього. Якщо ви створюєте ім'я входу Windows, тоді можна скористатись кнопкою Search (_Пошук_) для вибору існуючого облікового запису з _Active Directory_. У випадку створення імені входу з сертифікатом або асиметричним ключем слід обрати існуючий об'єкт шифрування за допомогою випадаючих списків.

![Рисунок 5](https://fsx1.itstep.org/api/v1/files/aOa5lKROJcVbzzjhjT-x3cVk3poAwZyj)

Рисунок 5

Наступна закладка Server Roles (_Серверні ролі_) призначена для того, щоб вказати, яким фіксованим серверним ролям буде належати ім'я входу. По замовчуванню вона належить лише ролі PUBLIC. Тема ролей, включаючи і фіксовані серверні ролі розглядається в розділі «_Ролі_» даного уроку.

![Рисунок 6](https://fsx1.itstep.org/api/v1/files/n7XquBA7RrrZGOyyJXVo4sl1RPfjNYcz)

Рисунок 6

![Рисунок 7](https://fsx1.itstep.org/api/v1/files/oMrup3w6PxHrgBKVQs00urjQAOk7EwAJ)

Рисунок 7

На закладці співставлення користувачів (_User Mapping_) оберіть базу даних _Press_, яку ми з вами створювали. Після цього необхідно назначити права на цю базу даних для новоствореного імені входу. Для прикладу, надамо йому повноцінні права на базу даних _Press_, тобто назначимо його ролі _db\_owner_. Про ролі рівня бази даних розповідається в розділі «_Ролі_».

На вкладці Securables (_Захист_) ви маєте можливість одразу втановити права на:

-   Обраний сервер та його об'єкти;
-   Кінцеві точки HTTP (_Endpoints_);
-   Інші імена входу (_logins_) та їх об'єкти.

Наприклад, ви можете одразу створити користувача, який зможе змінювати паролі для інших імен входу, які закріплені за працівниками його відділу.

Остання вкладка Status (статус, стан) дозволяє налаштувати додаткові параметри для нового імені входу.

![Рисунок 8](https://fsx1.itstep.org/api/v1/files/h48z8XwuVFs36vzVPOZ-N3dwe9oNxGXR)

Рисунок 8

Параметри тут наступні:

1.  Permissions to connect to database engine (_дозвіл на підключення до ядра баз даних_) — значенням по замовчуванню для всіх логінів являється Grant, що вказує на дозвіл підключення до SQL Server. Значення Deny встановлюється, як правило, лише у випадку роздачі прав іменам входу групи Windows, але при цьому одному або кільком членам цієї групи планується заборонити доступ до сервера.
2.  Login (_Ім'я входу_), який визначає стан імені входу після створення: ввімкнений чи ні. Зазвичай всі логіни ввімкнені, але підстави для відключення також існують. Наприклад, звільнення працівника або переведення на його іншу посаду тощо. Найшвидшим способом вирішити дану стуацію буде просте відключення логіна.
3.  Status->SQL Server authentication->Login is locked out (_Заблокувати логін_). Ви можете лише зняти флажок блокування імені входу, якщо воно заблоковане. Ім'я входу автоматично блокується після використання всіх спроб невірного вводу пароля для вказаного логіна, а також якщо таке блокування налаштоване на рівні операційної системи і для логіна встановлена опція CHECK\_POLICY.
    
    Після натиснення кнопки OK створене вами ім'я входу буде відображатись в папці _Security->Logins_, як і раніше.

В SQL Server 2008 існує набір вбудованих логінів:

-   NT AUTHORITY\\NetworkService — ім'я входу мереженої служби, яке використовується для підключення до SQL Server Reporting Services. Він автоматично має права на бази даних _master_, _msdb_ і на бази даних і служби, які використовує Reporting Services. Для SQL Server Agent дане ім'я входу використовувати не рекомендується.
-   NT AUTHORITY\\LocalService — ім'я входу локальної служби, яке має обмежений набір прав доступу до ресурсів (на рівні групи «Users» (_Користувачі_)). Цей логін звертається до мережених ресурсів у формі нулевого сеансу без облікових даних. Логін локальної служби доступний лише в Microsoft Windows XP і Microsoft Windows Server 2003, а також не підтримується SQL Server Agent.
-   NT AUTHORITY\\System — локальний системний обліковий запис операційної системи. Він з'являється, якщо при інсталяції налаштувати роботу служби SQL Server від імені локального системного облікового запису. Він являється членом групи адміністраторів Windows на локальному комп'ютері та членом фіксованої серверної ролі _sysadmin_. Логін NT AUTHORITY\\System існує лише для зворотної сумісності.
-   sa (_System Administrator_) — ім'я входу, яке маєповні і невід'ємніправа системного адміністратора SQL Server. Це ім'я входу видалити не можна, його дозволяється лише переіменовувати або вимикати.
-   Існує також набір логінів, створених на основі сертифіката, імена яких обмежені подвійним символом «хеш» (
    -   ##
    -   ##MS\_SQLResourceSigningCertificate##,
    -   ##MS\_SQLReplicationSigningCertificate##,
    -   ##MS\_SQLAuthenticatorCertificate##,
    -   ##MS\_AgentSigningCertificate##,
    -   ##MS\_PolicyEventProcessingLogin##,
    -   ##MS\_PolicySigningCertificate##,
    -   ##MS\_PolicyTsqlExecutionLogin##.

### 2.3. Модифікація та видалення імен входу

Для зміни властивостей імен входу використовується оператор ALTER LOGIN, синтаксис якого представлений нижче:

```html
ALTER LOGIN логін
{
    {ENABLE  DISABLE} -- дозволити або заборонити використання імені входу
    | WITH список_опцій
    -- додати (або видалити) до імені входу облікові дані
    -- постачальника ЕКМ (Extensible Key Management - розширеного управління ключами)
    | {ADD CREDENTIAL ім'я_облікових_даних | DROP CREDENTIAL ім'я_облікових_даних }
}

-- Список опцій:
[ PASSWORD = { 'пароль' | 'хешований_пароль' HASHED}
             [ OLD_PASSWORD = 'старий_пароль'
               | опції_пароля [ MUST_CHANGE  UNLOCK /* розблокувати логін */]
             ]
]
[, DEFAULT_DATABASE = БД_по_замовчуванню ]
[, DEFAULT_LANGUAGE = мова_по_замовчуванню ]
[, NAME = логін ] -- нове ім'я для логіна, яке необхідно переіменувати
[, CHECK_POLICY = {ON | OFF} ]  -- чи застосовувати до логіна політику паролів
                                -- Windows на комп'ютері, де виконується SQL Server
[, CHECK_EXPIRATION = {ON | OFF} ] -- чи необхідно встановлювати строк дії пароля
[, CREDENTIAL = ім'я_облікових_даних ]
[, NO CREDENTIAL ] -- видаляє існуючі співставлення логіну та облікових даних сервера
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Параметр DISABLE оператора ALTER LOGIN не можна використовувати для заборони доступу групи Windows. Для цього призначений оператор DЕNY, який буде розглянутий нижче.

Іноді параметр ENABLE плутають з параметром UNLOCK. Щоб не було плутанини, пояснимо детальніше. Параметр ENABLE дозволяє використання імені входу, яке тимчасово було заборонене адміністратором. А параметр UNLOCK розблоковує ім'я входу, доступ якого був заборонений сервером через використання всіх спроб невірного вводу пароля для вказаного логіна. При цьому розблоковувати ім'я входу можна з новим паролем, а можна залишити йому старий, тоді як за допомогою ENABLE змінити пароль неможна, оскільки обліковий запис був просто тимчасово неактивний.

Приведемо кілька прикладів:

```html
-- змінимо пароль, а саме відмінимо його
alter login Vasja
with password = '';

-- переіменувати ім'я входу
alter login Vasja
with name = VPupkin;

-- розблокувати ім'я входу з новим паролем
alter login Vasja
with password = '111' unlock;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Для видалення імені входу використовується оператор DROP LOGIN:

```html
-- синтаксис
DROP LOGIN логін

-- наприклад, необхідно видалити ім'я входу Windows
drop login [stepdom\students\Petrenko];
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Варто відмітити, що для створення та управління іменами входу можна використовувати системні зберігаємі процедури безпеки. Наприклад, sp\_addlogin, sp\_defaultdb, sp\_droplogin, sp\_grantlogin тощо. Але всі ці зберігаємі процедури вважаються застарівшими та існують в SQL Server 2008 лише для забезпечення зворотньої сумісності. В наступній версії ці зберігаємі процедури будуть вилучені.

## 3\. Користувачі бази даних

Отже, ім'я входу для користувача створили. Але цього, нажаль, не достатньо для того, щоб доступитись до даних в SQL Server. Користувач повинен мати в необхідній базі даних ще й свого користувача баз даних (database user). Таке розділення імен входу (login) і користувачів баз даних (user) в SQL Server забезпечує велику гнучкість. Тепер користувач, маючи один логін, може мати кілька користувачів в різних базах даних і з різними правами доступу.

Таким чином користувач після аутентифікації на сервері проходить так звану авторизацію користувача. В ході авторизації SQL Server перевіряє чи відповідає зареєстроване ім'я входу (login) хоча б одному з існуючих користувачів бази даних (user), до якої планується доступ, і які права він на неї має.

Створити користувача бази даних можна за допомогою оператора T-SQL CREATE USER:

```html
CREATE USER ім'я_користувача
[ { { FOR | FROM}
    { LOGIN ім'я_входу -- ім'я входу SQL Server, для якого
                       -- створюється користувач бази даних
      | CERTIFICATE ім'я_сертифіката -- сертифікат, для якого створюється користувач БД
      | ASYMMETRIC KEY ім'я_асиметричного_ключа -- асиметричний ключ, для якого
                                               -- створюється користувач бази даних
    }
      | WITHOUT LOGIN -- створює користувача, який буде підключатись 
                     -- до бази даних як користувач guest
      ]
      [ WITH DEFAULT_SCHEMA = назва_схеми ] -- схема по замовч. для користувача БД, 
                                            -- інакше dbo
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Зауваження щодо створення користувача:

-   Якщо не вказати ім'я входу, тобто не задати аргумент FOR LOGIN, тоді новий користувач бази даних буде співставлятись з іменем входу SQL Server з аналогічним ім'ям.
-   Значення DEFAULT\_SCHEMA не можна вказувати для користувачів, які співставляються з групами Windows, сертифікатом або асиметричним ключем. Воно також ігнорується членами серверної ролі _sysadmin_, оскільки для них схемою по замовчуванню встановлена схема _dbo_.

Наприклад, створимо користувача бази даних для імені входу _Kovalenko_.

```html
create login Kovalenko
with password = 'qwerty';

use Press;
create user Kovalenko
for login Kovalenko;
-- або
-- create user Kovalenko;
Go
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Нові користувачі бази даних додаються в групу _Users_ вузла _Security_ поточної бази даних. Отже, щоб створити користувачів бази даних засобами SSMS, слід викликати контекстне меню _New User_ гілки _Security_ або вузла _Users_.

![Рисунок 9](https://fsx1.itstep.org/api/v1/files/Qkc-Ior8aDmW4HwjYIBpSWBx12F-ZyMy)

Рисунок 9

У випадку доступу до бази даних імені входу, з яким не співставлений жоден користувач бази даних, SQL Server надасть доступ через користувача guest, якщо в нього є відповідні права. По замовчуванню користувач guest не має права доступу до баз даних, але ви можете йому їх надати, ввімкнувши його для необхідної бази даних:

```html
-- ввімкнути користувача guest
grant connect to guest;

-- відмінити доступ користувача guest
revoke connect to guest;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Більш детальніше про оператори GRANT та REVOKE читайте у розділі «Управління правами доступу» даного уроку.

Щоб змінити властивості користувача, необхідно скористатись оператором ALTER USER, а щоб видалити користувача бази даних — DROP USER.

```html
-- змінити властивості користувача баз даних
ALTER USER ім'я_користувача
WITH [ NAME = нове_ім'я_користувача ]
     [, DEFAULT_SCHEMA = назва_схеми ]
     [, LOGIN = ім'я_входу ]

-- видалити користувача баз даних
DROP USER ім'я_користувача
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Відмітимо, що для створення користувачів бази даних використовується також системна зберігаєма процедура sp\_grantdbaccess, але вона вважається застарівшою і в наступній версії SQL Server буде вилучена, тому використовувати її не варто. Дані про всіх користувачів бази даних зберігаються в системному представленні sys.server\_principals.

На рівні бази даних виділяють також поняття «осиротівших» користувачів (orphaned users), які являють собою користувачів бази даних, з якими не співставляється жодне ім'я входу. В цю категорію попадають користувачі при видалені зв'язаних з ними імен входу. Для отримання інформації про таких користувачів використовується системна зберігаємо процедура sp\_change\_users\_login.

```html
-- синтаксис зберігаємої процедури sp_change_users_login
sp_change_users_login [ @Action = ] 'дія'
                      [ , [ @UserNamePattern = ] 'користувач' ]
                      [ , [ @LoginName = ] 'імя_входу' ]
                      [ , [ @Password = ] 'пароль' ]
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

В якості дії можна вказувати одне з наступних значень:

-   Auto\_Fix — зв'язує запис користувача в системному представленні sys.database\_principals поточної бази даних з іменем входу SQL Server, який має таке ж ім'я. З точки зору безпеки, намагайтесь уникати інструкції Auto\_Fix, оскільки при відсутності необхідного імені входу, воно створюється.
-   При використанні
    -   Auto\_Fix
    -   якщо імені входу ще не існує, тоді необхідно вказати аргументи user і password;
    -   якщо ім'я входу вже присутнє, тоді слід вказати аргумент user без password;
    -   аргумент login повинен мати значення NULL.
-   Report — виводить список «осиротівших» користувачів і їх ідентифікатори безпеки (SID) в поточній базі даних. При цьому аргументи user, login і password повинні мати значення NULL або бути відсутніми.
-   Update\_One — зв'язує вказаний аргумент UserNamePattern в поточній базі даних з існуючим аргументом LoginName. Аргумент password повинен бути відсутній або рівний NULL.

Наприклад:

```html
execsp_change_users_login @action = 'REPORT'
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 10](https://fsx1.itstep.org/api/v1/files/Py1_iz4sv8_xlkwEz56BOn-HgNLLsKjL)

Рисунок 10

При створенні нової бази даних, в ній автоматично створюються 4 користувачі:

-   dbo (_database owner_) — власник бази даних, яким автоматично стає той логін, від імені якого була створена база даних. Він входить до фіксованої ролі бази даних db\_owner і має всі права на базу даних.
-   guest (_гість_) — користувач, який надає право всім логінам, яким не відповідає жоден користувач бази даних.
-   INFORMATION\_SCHEMA — власник схеми INFORMATION\_SCHEMA, в якій зберігаються представлення з системною інформацією для бази даних. Даному користувачу не відповідає жодне ім'я входу.
-   sys — власник схеми SYS, до якої належать системні об'єкти бази даних. Даному користувачу не відповідає жодне ім'я входу.

## 4\. Ролі

### 4.1. Поняття ролей. Фіксовані ролі

А тепер час розглянути ще одних учасників системи безпеки сервера — ролі, які дозволяють визначити рівень доступу (права) до об'єктів сервера баз даних. По суті, роль — це група користувачів, які мають однакові права. Наприклад, якщо в нас існує група користувачів, яким потрібен доступ лише для читання, то ми можемо створити роль READER, присвоїти їй необхідні права, а потім назначати цю роль конкретному користувачу. Тобто, якщо ролі надаються які-небудь права, то ці ж права має кожен користувач, який входить в дану роль.

Крім того, в SQL Server 2008 користувач може входити до складу кількох ролей. Це дозволяє групувати права доступу в певні ролі, а потім використовувати їх комбінації, створюючи тим самим набори прав, які найбільше підходять конкретному користувачу. В зв'язку з цим ролі сервера часто порівнюють з групами користувачів Windows.

Відмітимо, в кожній базі даних, включаючи системні бази даних такі як master, model та інші, існує роль PUBLIC. Це спеціальна роль, яка призначена для надання прав одразу всім користувачам бази даних. Вона має налаштовані по замовчуванню права для користувачів бази даних і ні її члени, ні вона сама не може бути знищена. Її членом автоматично стає кожен користувач бази даних.

Всі інші ролі можна розділити на наступні види:

1\. Ролі рівня сервера (майже всі імена закінчуються на _xxxadmin_) — це ролі, які діють в рамках всього сервера і не належать жодній базі даних. Вони призначені для супроводження системи, включаючи управління обліковими записами та роботу з зв'язаними серверами. До вбудованих (фіксованих) серверних ролей відносяться:

-   sysadmin — користувачі даної ролі можуть виконувати будь-які дії з SQL Server, оскільки ця роль об'єднує в собі права всіх інших серверних ролей.
-   serveradmin — користувачі даної ролі можуть виконувати дії по конфігуруванню сервера: змінювати параметри сервера, завершувати його роботу тощо.
-   setupadmin — користувачі ролі можуть управляти (додавати, налаштовувати та видаляти) зв'язаними серверами, а також виконувати ряд системних зберігаємих процедур. Їм дозволяється також оголошувати процедури запуску.
-   securityadmin — дозволяє управляти іменами входу сервера, змінювати параметри налаштувань безпеки, включаючи віддалені сервери та права на створення бази даних, а також надає доступ до журналу помилок.
-   processadmin — дозволяє управляти процесами, які виконуються в екземплярі SQL Server.
-   diskadmin — користувачі даної ролі можуть управляти дисковими файлами (приєднувати і від'єднувати бази даних, вказувати, які файли входять до складу файлових груп тощо).
-   bulkadmin — користувачі цієї ролі мають право на виконання оператора BULK INSERT, який використовується для масової вставки даних. При цьому дана роль не надає права доступу до таблиць, до яких буде застосований даний оператор.
-   dbcreator — дозволяє створювати та управляти базами даних, включаючи відновлення з резервної копії.

Для того, щоб додати нового користувача або групу в серверну роль використовується системна зберігаєма процедура sp\_addsrvrolemember, а для виключення одного з членів — sp\_dropsrvrolemember.

```html
-- додати до ролі
sp_addsrvrolemember [ @loginame = ] 'логін', [ @rolename = ] 'серверна_роль'

-- виключити з ролі
sp_dropsrvrolemember [ @loginame = ] 'логін', [ @rolename = ] 'серверна_роль'
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Наприклад:

```html
-- додамо до ролі sysadmin користувача Verhiv
execsp_addsrvrolemember @loginame = 'Verhiv', @rolename = 'sysadmin'

-- виключити користувача Verhiv з серверної ролі diskadmin
execsp_dropsrvrolemember 'Verhiv', 'diskadmin'
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Відомості про членів серверної ролі можна отримати з системного представлення sys.server\_role\_member.

2\. Ролі рівня бази даних (їх імена мають префікс _db\_xxx_) існують на рівні бази даних та призначені для визначення прав по роботі з конкретною базою даних. До вбудованих ролей рівня бази даних відносять:

-   db\_owner — дана роль назначається власникам бази даних, які мають на неї повні права.
-   db\_accessadmin — користувачі даної ролі мають право роздавати і забирати права доступу до бази даних.
-   db\_backupoperator — набір прав для резервного копіювання бази даних.
-   db\_datareader — дана роль об'єднує всі права по зчитуванню даних з таблиць, представлень і функцій.
-   db\_datawriter — користувачі даної ролі мають права на додавання, обновлення і видалення даних в поточній базі даних.
-   db\_ddladmin — користувачі даної ролі мають права на управління даними в базі даних (INSERT, DELETE, UPDATE).
-   db\_denydatareader — забороняє всім користувачам зчитувати дані бази даних (SELECT).
-   db\_denydatawriter — забороняє всім користувачам управляти даними таблиць і представлень поточної бази даних (INSERT, DELETE, UPDATE).
-   db\_securityadmin — дана роль об'єднує в собі всі права по адмініструванню системи захисту бази даних, тобто дозволяє управляти членами ролей та їх правами.

В SQL Server існує також можливість створювати власні ролі рівня бази даних за допомогою оператора CREATE ROLE. Більш детальніше про цю можливість читайте в п. 4.2. «Користувацькі ролі» поточного розділу.

Щоб додати користувача, ім'я входу або іншу роль до ролі поточної бази даних, необхідно викликати системну зберігаєму процедуру sp\_addrolemember:

```html
sp_addrolemember [ @rolename = ] 'роль', [ @membername = ] 'обліковий_запис'
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Наприклад, необхідно до ролі рівня бази даних додати ім'я входу Windows.

```html
execsp_addrolemember 'db_owner', [Stepdom\Students\Pupkin];
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

При цьому до ролі рівня бази даних не можна додавати інші фіксовані ролі рівня бази даних, фіксовані серверні ролі або користувача _dbo_.

Видалити користувача, ім'я входу або іншу роль з ролі рівня бази даних допомагає серверна зберігаєма процедура sp\_droprolemember.

```html
sp_droprolemember [ @rolename = ] 'роль', [ @membername = ] 'обліковий_запис'
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

3\. Ролі рівня додатку дозволяють адміністратору бази даних обмежувати доступ користувачів до даних через прикладний додаток. Ця роль не містить в собі користувачів, тому перед використанням її необхідно активізувати в поточному з'єднанні, ввівши вірний пароль.

Процес роботи ролі рівня додатку відбувається наступним чином:

-   На сервері баз даних створюється роль рівня додатку (CREATE APPLICATION ROLE) і їй назначається певний набір прав.
-   Спочатку користувач реєструється в самому прикладному додатку передбаченим для цього способом, наприклад, за допомогою діалогового вікна.
-   Користувач перевіряється на існування і йому назначаються встановлені права.
-   Роль рівня додатку активізується (системна зберігаєма процедура sp\_setapprole).
-   Перевіряється роль рівня додатку і з'єднання переключається в контекст цієї ролі. Варто відмітити, що при активізації ролі рівня додатку всі права ролей користувачів на сервері ігноруються і вони отримують лише права, які діють на рівні прикладного додатку. В зв'язку з цим, якщо користувачу необхідно знову повернутись до заданих для нього параметрів безпеки, він повинен закрити з'єднання з сервером і зареєструватись на сервері знову.

Отже, створити роль рівня додатку можна за допомогою оператора CREATE APPLICATION ROLE:

```html
CREATE APPLICATION ROLE назва_ролі
  WITH PASSWORD = 'пароль'
  [, DEFAULT_SCHEMA = назва_схеми ]
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Аргумент DEFAULT\_SCHEMA вказує на схему по замовчуванню, тобто на першу схему, в якій сервер буде шукати об'єкти для цієї ролі. Якщо вона не задана, то схемою по замовчуванню стає схема _dbo_. Доречі, вказана схема в базі даних може бути тимчасово відсутня.

Щодо паролей ролей рівня додатку, то вони повинні зберігатись в зашифрованому вигляді.

Після створення ролі рівня додатку, щоб нею скористатись її необхідно активізувати за допомогою зберігаємої процедури sp\_setapprole:

```html
sp_setapprole [ @rolename = ] 'назва_ролі'
              [, @password = ] { encrypt N'пароль_ролі'} | 'password'
              [, [ @encrypt = ] {'none'  'odbc'} ]
              [, [ @fCreateCookie = ] true | false ] -- чи потрібно створювати cookie файл
              [, [ @cookie = ] @cookie OUTPUT ] -- вихідний параметр 
                                                -- (тип varbinary(8000))
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Аргумент encrypt дозволяє вказати тип шифрування пароля, але лише для з'єднань, які не використовують додаток SqlClient:

-   none — кодування пароля не використовується, тобто пароль передається SQL Server у вигляді звичайного тексту (по замовчуванню);
-   odbc — закодувати за допомогою функції ODBC encrypt перед відправкою компоненту SQL Server Database Engine. Але для захисту паролів, які передаються по мережі, її використовувати не слід, оскільки вона їх не шифрує. Слід відмітити, що даний аргумент може бути вказаний лише для клієнтів ODBC або постачальника даних OLE DB для SQL Server.

При використанні функції encrypt пароль повинен бути перетворений в рядок Unicode за допомогою модифікатора N. Якщо облікові дані необхідно зберігати в клієнтському додатку, тоді їх краще зашифровувати за допомогою функцій шифрування API.

Після ввімкнення ролі рівня додатку вона залишається активною до тих пір, поки користувач не відключиться від сервера або не виконає зберігаємо процедуру sp\_unsetapprole.

Приведемо невеличкий приклад створення ролі додатку та її активації:

```html
-- створюємо роль рівня додатку
create application role QRole
with password = 'AsDeF00MbXX';

-- активізуємо її
exec sp_setapprole 'QRole', 'AsDeF00MbXX';
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Змінити властивості ролі додатку можна за допомогою оператора ALTER APPLICATION ROLE.

```html
-- синтаксис
ALTER APPLICATION ROLE ім'я_ролі
WITH [ NAME = нове_ім'я_ролі ]
     [, PASSWORD = 'пароль' ]
     [, DEFAULT_SCHEMA = назва_схеми ]

-- наприклад, додамо до ролі додатку QRole схему по замовчуванню
alter application role QRole
with default_schema = sale;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Для видалення ролі рівня додатку використовують оператор DROP APPLICATION ROLE.

```html
DROP APPLICATION ROLE ім'я_ролі
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Застарілим аналогом оператора CREATE APPLICATION ROLE являється системна зберігаєма процедура sp\_addapprole. Нагадаємо, що в SQL Server 2008 вона існує лише для сумісності з попередніми версіями.

Ролі рівня додатку існують лише на рівні бази даних.Тобто, якщо звернутися до іншої бази даних, коли прикладний додаток знаходиться в контексті безпеки ролі додатку, тоді доступ до неї буде здійснюватись з врахуванням прав облікового запису guest в цій базі даних. Якщо обліковий запис guest неактивний для цієї бази даних, доступ до неї буде заборонений.

Ролідодатку діють також під час сеансів. Отже, якщо ваш прикладний додаток працює з багатьма сеансами, які використовують одну роль, в такому разі кожен сеанс повинен її спочатку активізувати.

Ця роль дуже корисна у випадках, коли на рівні сервера необхідно обмежити доступ користувачів, передавши повноваження у розподілі прав певному прикладному додатку. Наприклад, тепер клієнтський прикладний додаток може для одних підключень використовувати контекст безпеки користувача, а для інших контекстбезпеки ролі додатку.

При використанні ролі рівня додатку можуть бути корисними наступні функції:

-   USER\_NAME( \[ id \] ) — повертає ім'я поточного користувача або ім'я користувача з вказаним ідентифікатором;
-   SYSTEM\_NAME — повертає ім'я поточного імені входу.

### 4.2. Користувацькі ролі

Як вже було сказано раніше, SQL Server підтримує можливість створення власних ролей рівня бази даних, які будуть групувати користувачів баз даних з однаковими правами доступу до об'єктів. Це дозволить класифікувати користувачів по категоріям необхідності доступу.

Синтаксис оператора CREATE ROLE, який призначений для створення користувацької ролі бази даних має наступний вигляд:

```html
CREATE ROLE ім'я_ролі [ AUTHORIZATION власник ]
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

По замовчуванню власником ролі є власник поточної бази даних, але його можна змінити на іншого користувача бази даних або зробити ним іншу роль. На практиці, даний аргумент при створенні ролі майже не використовується.

Застарівшим аналогом даного оператора є системна зберігаєма процедура sp\_addrole. Після створення в роль необхідно додати користувачів за допомогою системної зберігаємої процедури sp\_addrolemember, а видалити користувача з ролі — sp\_droprolemember.

Наприклад, створимо роль бази даних _Management_ та додамо до неї користувача _Verhiv_.

```html
create role Management; -- створюємо роль бази даних
exec sp_addrolemember 'Management', 'Verhiv'; -- додаємо в нього користувача
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Для зміни властивостей ролі слід скористатись оператором ALTER ROLE. Але спектр її можливостей розповсюджується лише на зміну назви ролі.

```html
ALTER ROLE назва_ролі
WITH NAME = нове_ім'я_ролі
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Для видалення користувацької ролі бази даних використовується оператор DROP ROLE:

```html
DROP ROLE назва_ролі
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Створювати та управляти користувацькими ролями можна і засобами SSMS. Всі користувацькі ролі після створення розміщуються в гілці _Security->Roles_ відповідної бази даних. Отже, і створювати їх можна за допомогою контекстного меню New Role вузла _Roles_ або батьківського вузла _Security_.

![Рисунок 11](https://fsx1.itstep.org/api/v1/files/jCXTHSeNvvA8pi5lUwE_Z-Ev4lx7LfGH)

Рисунок 11

Щоб переглянути список ролей бази даних можна звернутись до системного представлення sys.database\_principals, яка містить також перелік користувачів бази даних, або скористатись системною зберігаємою процедурою sp\_helprole.

```html
-- синтаксис системної зберігаємої процедури sp_helprole
sp_helprole [ [ @rolename = ] 'ім'я_ролі' ]

-- приклади:
-- переглянемо всі ролі поточної бази даних
exec sp_helprole;

-- інформація про членів ролі 'Management'
exec sp_helprole 'Management';
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

```html
select * from sys.database_principals
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 12](https://fsx1.itstep.org/api/v1/files/nNGZPt6xWUwipJMp5YphymvLpfm_xD0s)

Рисунок 12

Розшифруємо коротко структуру даного системного представлення:

**Таблиця 1**

**Поле**

**Опис**

name

Учасник бази даних (роль або користувач).

principal\_id

Ідентифікатор учасника бази даних.

type

Тип учасника:

S — користувач SQL;

U — користувач Windows;

G — група Windows;

A — роль рівня додатку;

R — роль рівня бази даних;

C — користувач, співставлений з сертифікатом;

K — користувач, співставлений з асиметричним ключем.

type\_desc

Опис типу учасника.

default\_schema\_name

Схема по замовчуванню. Рівна NULL для учасників, які не належать типу S, U або A.

create\_date

Дата створення учасника.

modify\_date

Час останньої модифікації учасника.

owning\_principal\_id

Ідентифікатор власника учасника. Власником всіх учасників, крім ролей баз даних, являється _dbo_.

sid

Ідентифікатор захисту (SID), якщо учасник належить типу S, U або G, інакше NULL.

is\_fixed\_role

Флаг, який вказує на вбудовану (фіксовану) роль.

Для перегляду членів ролейбази даних, використовується системне представлення sys.database\_role\_members та зберігаєма процедура sp\_helpuser. Але sp\_helpuser не повертає інформацію про захищені об'єкти SQL Server 2008, тому для цих цілей краще скористатись системним представленням sys.database\_principals.

```html
exec sp_helpuser;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 13](https://fsx1.itstep.org/api/v1/files/txkKcGcG_nhCl3VIzIWK3_CI9GwGWD9L)

Рисунок 13

```html
select * from sys.database_role_members
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 14](https://fsx1.itstep.org/api/v1/files/scK1qqEcHo6IZR7SvT0rtbyryE26DvlP)

Рисунок 14

Як видно з результату, до ролі Management (role\_principal\_id = 9) поточної бази даних Press, входить один користувач з іменем Verhiv (member\_principal\_id = 9). Роль db\_owner (role\_principal\_id = 16384) цієї ж бази даних включає в себе двох користувачів: Verhiv та dbo (member\_principal\_id = 1).

## 5\. Управління правами доступу

### 5.1. Основні поняття

Після створення ролі або конкретного користувача та встановлення для них прав доступу до бази даних, їм необхідно надати права (привілеї) на об'єкти самої бази даних. Це необхідно для організації додаткового рівня безпеки даних. Наприклад, на підприємстві працівникам відділу постачання необхідно надати лише доступ до даних, які стосуються клієнтів, поставки і товару та заборонити переглядати інформацію про працівників підприємства, включаючи дані про зарплату. Здійснюється таке управління правами за допомогою операторів GRANT, DENY і REVOKE.

Права — це дозвіл користувачу здійснити певну операцію над об'єктом бази даних. Існують ряд видів об'єктів та операцій, на які можна встановлювати права для користувачів та ролей.

Права доступу, які отримує користувач, можна поділити на наступні типи:

1.  Неявні права — це набір прав, які визначаються приналежністю до певної фіксованої ролі (сервера, бази даних або ролі рівня додатку) користувача;
2.  Об'єктні права — це права по управлінню об'єктами бази даних;
3.  Командні права — права на виконання операцій над базою даних.

### 5.2. Об'єктні права доступу

В SQL Server, починаючи з версії SQL Server 2005, об'єктів в базі даних, на які можна назначити права, стало більше. Тепер, крім роздачі прав на користування таблицями, представленнями, функціями і зберігаємими процедурами, можна назначати права на управління такими об'єктами, як ролі, користувачі бази даних, повнотекстові каталоги тощо. Таким чином, до захищених об'єктів відносяться всі ресурси, доступ до яких регулюється системою авторизації компонента SQL Server Database Engine. Крім того, ряд захищених об'єктів можуть зберігатись всередині інших, створюючи так звані ієрархії областей, для яких також можна встановлювати права доступу.

Таких областей в SQL Server 2008 існує три:

1\. Сервер, який містить в собі такі захищаємі об'єкти, як:

-   ім'я входу (_login_), тобто можна одному користувачу SQL Server надати дозвіл на об'єкт іншого користувача;
-   база даних;
-   кінцеві точки (_endpoint_) HTTP.

2\. База даних, яка включає наступні захищаємі об'єкти:

-   користувач (user);
-   роль;
-   роль рівня додатку;
-   збірка (_assembly_) .NET;
-   тип повідомлень, який дозволяє здати дозвіл назахищаємий об'єкт компонента Service Broker;
-   маршрут;
-   служба;
-   прив'язка віддаленої служби;
-   повнотекстовий каталог;
-   сертифікат;
-   симетричний і асиметричний ключ;
-   контракт;
-   схема.

3\. Схема, яка містить такі захищаємі об'єкти:

-   користувацький тип даних (домен);
-   колекція схем XML;
-   об'єкт:
    -   таблиця;
    -   представлення;
    -   функція;
    -   зберігаєма процедура;
    -   обмеження;
    -   черга;
    -   синонім;
    -   статистика;
    -   статистичне обчислення.

Це нововведення дозволяє суттєво полегшити роботу адміністратору баз даних, оскільки надавши користувачу права на область, наприклад, на управління схемою, ви надаєте йому одразу права на користування всіма об'єктами цієї схеми.

Права на об'єкти бази роздаються за допомогою оператора GRANT. В ньому дуже багато опцій і повне знайомство з даним оператором виходить за межі нашого уроку. Ми ж спробуємо розглянути лише основні принципи його використання. Узагальнений синтаксис оператора GRANT виглядає наступним чином:

```html
GRANT{ALL [ PRIVILEGES ] }
           назва_привілею [ ( назва_поля [ ,...n ] ) ] [ ,...n ]
          [ ON [ клас_захищаємого_об'єкта :: ] захищаємий_об'єкт ]
            TO ім'я_облікового_запису [ ,...n ]
          [ WITH GRANT OPTION ]
          [ AS ім'я_облікового_запису ]
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Ключове слово ALL вказує на те, що користувачу необхідно надати всі права на вказаний об'єкт. Але в SQL Server 2008 воно не надає всі права. Більше того, ключове слово ALL являється застарівшим і існує лише для сумісності з попередніми версіями. В наступній версії даний параметр планується виключити, тому використовувати його не варто.

Ключове слово PRIVILEGES також являється застарівшим і було введено в попередніх версіях лише для відповідності стандарту SQL-92.

Якщо ключове слово ALL не використовується, тоді вказується список прав доступу. Після ключового слова ON розповідаємо на який саме об'єкт роздаються права та кому (TO). Отримувачем прав може бути користувач бази даних, ім'я входу (включаючи ім'я входу або групу Windows) або роль.

Опція WITH GRANT OPTION вказує на те, що користувачі, яким надаються права на об'єкт (-и) бази даних, можуть надавати їх іншим користувачам.

Якщо обліковий запис належить кільком ролям, тоді необхідно при роздачі прав вказати опцію AS. Після цього ключового слова задається список ролей, які конкретизують користувача: користувачу з якої саме ролі надати ті чи інші права.

Як видно з синтаксису, в SQL Server можна встановлювати права на рівні окремих полів. Але на практиці краще не користуватись такими правами через втрату продуктивності і ускладнення системи прав. Для таких цілей, тобто заборони доступу користувача або ролі до певних полів таблиці чи іншого об'єкта, краще використати представлення або зберігаєму процедуру, які будуть показувати лише необхідну інформацію.

Для прикладу, розберемо права, які найчастіше роздаються, тобто права на користування об'єктами бази даних. Отже, в SQL Server можна надавати наступні об'єктні права:

1.  SELECT, INSERT, UPDATE, DELETE на таблиці, представлення, табличні функції і на поля перелічених об'єктів, а також на синоніми.
2.  Право на запуск зберігаємих процедур та скалярних функцій — EXECUTE.
3.  Право
    -   REFERENCES
    -   право REFERENCES для таблиці необхідне для створення обмеження на зовнішній ключ (FOREIGN KEY), який ссилається на цю таблицю;
    -   право REFERENCES для представлення або табличної функції необхідне для сворення цих об'єктів з параметром WITH SCHEMABINDING.
4.  ALTER — можливість змінювати властивості об'єкта (по замовчуванню це право має лише його власник). На рівні бази даних можна налаштовувати права ALTER ANY об'єкт\_сервера\_або\_БД, які надають можливість вносити зміни в довільні об'єкти сервера або бази даних. Наприклад, ALTER ANY LOGIN надає право створювати, змінювати або видаляти довільне ім'я входу в екземплярі, а ALTER ANY TABLE надає можливість управляти таблицями бази даних.
    
    Слід також пам'ятати, що якщо ви встановите право ALTER на схему, це дозволить управляти всіма об'єтами, що входять до цієї схеми.
5.  CONTROL — надає повні права на об'єкт, включаючи інформацію в ньому. Крім того, користувачу, який має право CONTROL, дозволяється роздавати права на встановлений об'єкт іншим. Право CONTROL на певну область неявно включає право CONTROL на всі об'єкти, які знаходяться в її межах. Наприклад, привілей CONTROL на базу даних неявно надає всі права на базу даних, всі права на її збірки (_assembly_), на її схеми і об'єкти, які знаходяться в межах цих схем.
6.  TAKE OWNERSHIP — право на передачу прав власності на об'єкт. Таке право можна назначити для будь-яких об'єктів.
7.  VIEW DEFINITION — право на перегляд метаданих таблиць, представлень, процедур або функцій.
8.  VIEW CHANGE TRACKING — право на відслідковування змін в таблиці (або схемі), наприклад, буде надана інформація про те, які поля були змінені. Повний список операцій, які відслідковуються наступний:

-   DROP TABLE;
-   ALTER TABLE DROP CONSTRAINT;
-   ALTER TABLE DROP COLUMN;
-   ALTER TABLE ADD COLUMN;
-   ALTER TABLE ALTER COLUMN;
-   ALTER TABLE SWITCH;
-   DROP INDEX або ALTER INDEX DISABLE;
-   TRUNCATE TABLE.

9\. RECEIVE — право на роботу з чергами компонента Service Broker.

Щоб краще зрозуміти роботу оператора GRANT, розглянемо кілька прикладів:

1\. Надати права на вибірку даних з таблиці _book.Authors_ користувачу Verhiv:

```html
grant select
on book.Authors
to Verhiv;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

2\. Якщо необхідно надати права одразу кільком користувачам:

```html
grant select
on OBJECT::book.Authors
to Verhiv, Kovalenko;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

3\. Надати ролі _Management_ права на перегляд та зміну даних таблиці _sale.Sales_:

```html
grant select, update
on OBJECT::sale.Sales
to Management;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

4\. Якщо необхідно видати права на перегляд і вибірку даних таблиці _sale.Shops_ всім користувачам поточної бази даних, тоді можна використати роль PUBLIC, яке еквівалентне переліку всіх користувачів.

```html
grant select, insert
on OBJECT::sale.Shops
tо public;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

5\. Для обмеження прав на перегляд таблиці _sale.Sales_ лише кількома полями, необхідно написати наступний запит.

```html
grant selecton sale.Sales to public;

grant update
on sale.Sales(Price, Quantity)
to Kovalenko
with grant option;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

В результаті всі користувачі можуть лише переглядати таблицю _sale.Sales_, а користувач _Kovalenko_ має ще право змінювати в ній поля _Price_ та _Quantity_. Крім того, він має право передавати ці привілеї іншим користувачам.

6\. Надамо право на запуск зберігаємої процедури sp\_BestAuthors ролі Secretary:

```html
grant execute
on OBJECT::sp_Best Authors
to Secretary;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Оператор DENY дозволяє встановити заборону на використання об'єктів бази даних. Особливістю його використання є те, що він являється вищим по пріоритету за оператор GRANT, тому дозволяє відмінити права користувача, видані раніше. Але заборона (DENY) на рівні таблиці має меньший пріоритет, ніж дозвіл рівня поля, виданий оператором GRANT (!). Ця несумісність прав в SQL Server 2008 існує лише для забезпечення зворотної сумісності і в наступній версії вона буде усунена.

Повний синтаксис оператора DENY також доволі складний і дещо нагадує синтаксис оператора GRANT. Його узагальнений спрощений вигляд представлений нижче:

```html
DENY {ALL [ PRIVILEGES ] }
      | назва_привілею [ ( назва_поля [ ,...n ] ) ] [ ,...n ]
      [ ON [ клас_захищаємого_об'єкта :: ] захищаємий_об'єкт ]
      TO ім'я_облікового_запису [ ,...n ]
      [ CASCADE ]
      [ AS ім'я_облікового_запису ]
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Як бачите, майже всі параметри аналогічні оператору роздачі прав. Новим параметром є лише CASCADE, який виконує зворотну дію по відношенню до опції WITH GRANT OPTION інструкції GRANT. Він дозволяє заборонити права вказаному користувачу і всім іншим користувачам, яким вони були надані за допомогою опції WITH GRANT OPTION. При цьому, якщо забрати права у користувача, якому цей привілей був наданий за допомогою опції WITH GRANT OPTION, і не вказати аргумент CASCADE, SQL Server згенерує помилку.

Для прикладу, надамо всім користувачам, крім користувача _Verhiv_ право переглядати інформацію про магазини, які реалізують книги видавництва:

```html
grant select on book.Books to public; -- надаємо право select всім користувачам
deny select on book.Books to Verhiv;  -- відміняємо право select в користувача Verhiv
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Щоб забрати надані права у користувачів, використовується оператор REVOKE. По суті, даний оператор дозволяє відмінити дії, здійснені раніше оператором GRANT або DENY.

Формат даної команди схожий з форматом команди GRANT.

```html
REVOKE [ GRANT OPTION FOR ]
       {ALL [ PRIVILEGES ] | назва_привілею [ ( назва_поля [ ,...n ] ) ] [ ,...n ]
       }
       [ ON [ клас_захищаємого_об'єкта :: ] захищаємий_об'єкт ]
       { TO | FROM } ім'я_облікового_запису [ ,...n ]
       [ CASCADE ]
       [ AS ім'я_облікового_запису ]
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Опція GRANT OPTION FOR дозволяє забрати права на роздачу прав користувачем. При використанні параметра CASCADE дану опцію обов'язково слід вмикати.

Параметр CASCADE вказує на каскадну відміну прав, які надавались за допомогою параметра WITH GRANT OPTION оператора GRANT.

Наприклад, щоб забрати права на читання з таблиці _sale.Sales_ у користувача _Kovalenko_ потрібно написати наступне:

```html
revoke select
on sale.Sales
from Kovalenko;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Якщо необхідно забрати права в кількох користувачів, тоді їх слід перелічити через кому. А для анулювання прав у всіх користувачів вкажіть роль PUBLIC.

В наступному прикладі заберемо право на роздачу привілея _select_ на поля _Price_ та _Quantity_ таблиці _sale.Sale_ в користувача _Kovalenko_.

```html
revoke grant option for update
on sale.Sales(Price, Quantity)
from Kovalenko;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Для надання або видалення прав SSMS має також свій власний, доволі зручний у використанні, набір засобів. Наприклад, для того, щоб переглянути і змінити набір прав певного користувача або ролі бази даних, необхідно перейти до їх властивостей (Properties) та обрати вкладку Securables (_Захист_). Аналогічна вкладка існує при створенні окремо взятого користувача (або ролі бази даних). Виглядає вона так:

![Рисунок 15](https://fsx1.itstep.org/api/v1/files/MIqyy1InZj4pQgQ5hw8OFuiaj-nPGAKM)

Рисунок 15

Даний інструмент дозволяє переглянути, на які об'єкти бази даних має права користувач. У випадку необхідності, новий об'єкт можна додати за допомогою кнопки Search… (_Пошук_). В частині Permissions for (_Права доступу для_) детальніше представлено, які саме права має користувач на обраний об'єкт бази даних. На вкладці Explicit можна переглянути та налаштувати явні права для користувача. А на вкладці Effective — підсумкові права доступу для користувача або ролі бази даних (оскільки права від різних ролей бази даних, назначених цьому користувачу, сумуються).

Отримати інформацію про те, хто і які права має на окремо взятий об'єкт, можна за допомогою вкладки Permissions властивостей цього об'єкта. Наприклад, для таблиць вона матиме наступний вигляд:

![Рисунок 16](https://fsx1.itstep.org/api/v1/files/YSCzAGCpf1nYZC4deRWei5DQPg2QBIpU)

Рисунок 16

Список Users or roles (_Користувачі або ролі_) дозволяє легко переходити між користувачами або ролями бази даних, які мають права на цю таблицю. В частині Permissions for (_Права доступу для_) ви також можете більш детальніше ознайомитись з набором прав поточного (_виділеного_) користувача або ролі бази даних.

Насамкінець відмітимо, що на практиці використовується більше десятка таблиць і інших об'єктів бази даних, доступ до яких надавати кожному користувачу доволі незручно. Спростити цю задачу допомагає встановлення прав доступу на рівні схеми або всієї бази даних, а також використання фіксованих ролей рівня бази даних.

Також не забувайте про те, що доступ користувачів на пряму до таблиць організовувати не варто. Натомість зміну даних краще організувати за допомогою зберігаємих процедур, а для перегляду даних використати представлення або ті ж зберігаємі процедури.

### 5.3. Командні права доступу

В SQL Server користувач, крім об'єктних прав, може мати також набір командних прав, які дозволяють йому виконувати певний набір операторів (команд). Фактично — це набір прав на базу даних. В SQL Server 2008 список командних прав доволі великий і має наступний вигляд:

-   ALTER;
-   ALTER ANY APPLICATION ROLE;
-   ALTER ANY ASSEMBLY;
-   ALTER ANY ASYMMETRIC KEY;
-   ALTER ANY CERTIFICATE;
-   ALTER ANY CONTRACT;
-   ALTER ANY DATABASE AUDIT;
-   ALTER ANY DATABASE DDL TRIGGER;
-   ALTER ANY DATABASE EVENT NOTIFICATION;
-   ALTER ANY DATASPACE;
-   ALTER ANY FULLTEXT CATALOG;
-   ALTER ANY MESSAGE TYPE;
-   ALTER ANY REMOTE SERVICE BINDING;
-   ALTER ANY ROLE;
-   ALTER ANY ROUTE;
-   ALTER ANY SCHEMA;
-   ALTER ANY SERVICE;
-   ALTER ANY SYMMETRIC KEY;
-   ALTER ANY USER;
-   AUTHENTICATE;
-   BACKUP DATABASE;
-   BACKUP LOG;
-   CHECKPOINT;
-   CONNECT;
-   CONNECT REPLICATION;
-   CONTROL;
-   CREATE AGGREGATE;
-   CREATE ASSEMBLY;
-   CREATE ASYMMETRIC KEY;
-   CREATE CERTIFICATE;
-   CREATE CONTRACT;
-   CREATE DATABASE;
-   CREATE DATABASE DDL EVENT NOTIFICATION;
-   CREATE DEFAULT;
-   CREATE FULLTEXT CATALOG;
-   CREATE FUNCTION;
-   CREATE MESSAGE TYPE;
-   CREATE PROCEDURE;
-   CREATE QUEUE;
-   CREATE REMOTE SERVICE BINDING;
-   CREATE ROLE;
-   CREATE ROUTE;
-   CREATE RULE;
-   CREATE SCHEMA;
-   CREATE SERVICE;
-   CREATE SYMMETRIC KEY;
-   CREATE SYNONYM;
-   CREATE TABLE;
-   CREATE TYPE;
-   CREATE VIEW;
-   CREATE XML SCHEMA COLLECTION;
-   DELETE;
-   EXECUTE;
-   INSERT;
-   REFERENCES;
-   SELECT;
-   SHOWPLAN;
-   SUBSCRIBE QUERY NOTIFICATIONS;
-   TAKE OWNERSHIP;
-   UPDATE;
-   VIEW DATABASE STATE;
-   VIEW DEFINITION.

Управління командними правами нічим особливим від управління об'єктними не відрізняється. Для цього також використовуються оператори GRANT, DENY та REVOKE, але дещо в іншій формі.

```html
-- роздача прав
GRANT {ALL [ PRIVILEGES ] | назва_привілею [ ,...n ] }
       TO ім'я_облікового_запису [ ,...n ]
      [ WITH GRANT OPTION ]
      [ AS ім'я_облікового_запису ]

-- анулювати або забрати права
{ DENY | REVOKE} { ALL [ PRIVILEGES ] | назва_привілею [ ,...n ] }
       TO ім'я_облікового_запису [ ,...n ]
     [ CASCADE ]
     [ AS ім'я_облікового_запису ]
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Приведемо приклади управління такими правами:

```html
-- надамо права користувачу Kovalenko на створення таблиці
grant create table
to Kovalenko;

-- заберемо в ролі Management права на створення представлення
revoke create view
to Management;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Щоб налаштувати командні права доступу до бази даних за допомогою SSMS, необхідно обрати в контекстному меню бази даних пункт Properties (_Властивості_) та перейти на вкладку Permissions (_Права доступу_).

![Рисунок 17](https://fsx1.itstep.org/api/v1/files/Cjv5HB6bUEs9iGk9b2XzAEO9_9aVVD4Q)

Рисунок 17

Цей графічний інтерфейс дозволяє роздавати або анулювати обране право для поточного користувача чи ролі бази даних, шляхом простого роставляння або знімання галочок в частині Permissions for (_Права доступу для_).

### 5.4. Дані про права

Для отримання інформації про те, хто і які права має, крім вже розглянутих способів (з властивостей окремо взятого об'єкта), можна скористатись ще системною зберігаємою процедурою sp\_helprotect. Вона дозволяє переглянути інформацію про права доступу до об'єктів поточної бази даних.

```html
sp_helprotect [ [ @name = ] 'оператор_або_об'єкт_БД' ] -- інформацію про які права
                                                       -- відобразити
              [ , [ @username = ] 'ім'я_облікового_запису' ] -- права якого учасника перевіряються
              [ , [ @grantorname = ] 'ім'я_облікового_запису' ] -- яким користувачем були надані права
              [ , [ @permissionarea = ] 'тип' ] -- тип прав, які відображаються
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Як видно з синтаксису, аргументи зберігаємої процедури являються необов'язковими. Таким чином, якщо її запустити на виконання без аргументів, на екран буде виведений список всіх прав, які були надані або заборонені для поточної базі даних.

Зауваження щодо аргументів зберігаємої процедури:

1.  Якщо аргумент
    -   name
    -   CREATE DATABASE;
    -   CREATE DEFAULT;
    -   CREATE FUNCTION;
    -   CREATE PROCEDURE;
    -   CREATE RULE;
    -   CREATE TABLE;
    -   CREATE VIEW;
    -   BACKUP DATABASE;
    -   BACKUP LOG.
2.  Аргумент permissionarea вказує на те, які права будуть відображені: на об'єкти (символ «o»), оператори (символ «s») або на те і інше («os»; значення по замовчуванню). При використанні комбінацій типів, символи «o» і «s» розділяються комою або пропуском.
3.  Якщо необхідно вказати лише кілька аргументів, тоді замість пропущених слід вказувати значення NULL або використати іменовані аргументи. Наприклад, необхідно переглянути всі права, які має користувач _Kovalenko_:

```html
exec sp_helprotect NULL, Kovalenko
-- або
exec sp_helprotect @username = 'Kovalenko'
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 18](https://fsx1.itstep.org/api/v1/files/JH_tWGJQsahC2NlpExG2ww_BYHIBwU1A)

Рисунок 18

Дані в результуючій множині сортуються по категорії прав, власнику, об'єкту, отримувачу прав, участнику, який надав привілей, категорії типу захисту, типу захисту, дії і по полю ідентифікатора.

Приведемо ще один приклад використання зберігаємої процедури sp\_helprotect. Виведемо список прав на таблицю sale.Sales:

```html
exec sp_helprotect 'sale.Sales'
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 19](https://fsx1.itstep.org/api/v1/files/o0MWDHmaLyUWBOR65VUsnoFYde9vryZB)

Рисунок 19

Оскільки розглянута зберігаєма процедура не повертає інформацію про захищаємі об'єкти, які з'явились ще в SQL Server 2005, для таких цілей рекомендовано використовувати представлення sys.database\_permissions та функцію fn\_builtin\_permissions. Більш детальніше про них читайте в документації по SQL Server 2008.

## Домашнє завдання

Користувачі та права

1.  За допомогою операторів T-SQL створіть ім'я входу з іменем _AndreWadi_ та паролем «_mega_».
2.  За допомогою операторів T-SQL створіть ім'я входу з іменем _VladlenKopytych_, паролем «_superpassword_» та базою даних вашого видавництва по замовчуванню. Додати також можливість зміни пароля при першому підключення до SQL Server. Після цього ввімкніть явно дане ім'я входу.
3.  Змініть пароль імені входу _AndreWadi_ на наперед хешоване значення, базу даних по замовчуванню на базу даних _master_, а мову по замовчуванню встановіть англійську.
4.  Створіть для імені входу _VladlenKopytych_ двох користувачів бази даних: _Vladlen_ та _VladlenKopytych_, а для імені входу _AndreWadi_ користувача з аналогічним іменем. Для користувача VladlenKopytych встановити схему по замовчуванню sale.
    
    **Примітка!** _Користувачі створюються для бази даних вашого видавництва._
5.  Зробіть користувача _AndreWadi_ власником вашої бази даних видавництва, але встановіть заборону на управління даними таблиць і представлень.
6.  Користувачу
    -   Vladlen
    -   VladlenU
    -   book
    -   dbcreator
    -   всі права на таблицю _Books_ з правом передачі отриманих прав іншим користувачам;
    -   права на створення та модифікацію представлень;
    -   право REFERENCES на поле ID\_BOOK в представленні, яке відображає всю інформацію про роботу магазинів.
7.  Створити роль бази даних _SAdmin_, власником якої є користувач _VladlenKopytych_. Крім того, вона належить фіксованій ролі бази даних _db\_securityadmin_ та має права на перегляд метаданих таблиць, представлень, процедур або функцій.
8.  Визначіть права доступу до бази даних для продавців, бухгалтера, менеджера та директора, щоб вони могли виконувати свою роботу. При роздачі прав не забувайте також про наступні моменти:
    -   Продавцям необхідно надати набір прав, які дозволять їм не лише продавати книги, але і додавати та змінювати дані про книги, тематики та авторів.
    -   Бухгалтеру необхідно крім отримання повної інформації про книги та їх продаж за останній тиждень, надати всі необхідні права на зміну.
    -   Менеджер повинен бачити всю поточну картину у видавництві, яка стосується книг, тобто всю інформацію про них, а також мати можливість повністю нею управляти. Справи продажу книг його не стосуються.
    -   Директор повинен бачити всю інформацію про випуск книг за поточний тиждень, загальну суму отриманих грошей від продажу книг за поточний місяць та доступ на видалення магазинів.
        
        У випадку необхідності, створіть потребуємий набір представлень або зберігаємих процедур.
9.  Створити роль додатку
    -   Sales
    -   sale
    -   Sales
    -   право на запуск зберігаємої процедури, наприклад, sp\_ListAuthors;
    -   права UPDATE та DELETE на таблиці _book.Books_ та _sale.Shops_;
    -   право UPDATE на поля _Price_ та _Quantity_ таблиці _sale.Sales_.
10.  Виведіть на екран наступні звіти:
    -   звіт про всі права, які має користувач _VladlenU_ та створені вами ролі рівня бази даних (для продавців, бухгалтерів, менеджерів та директора);
    -   список прав лише на інструкції в поточній базі даних з використанням NULL в якості заповнювача пропущених параметрів;
    -   список всіх прав на поточний сервер

© STEP IT Academy, [itstep.org](https://itstep.org/)

All the copyrighted photos, audio, and video works, fragments of which are used in the material, are the property of their respective owners. Fragments of the works are used for illustrative purposes to the extent justified by the objective, within the educational process, and for educational purposes, in accordance with the Act of “On Copyright and Related Rights”. The scope and method of the cited works are in accordance with the adopted norms, without prejudice to the normal exploitation of copyright, and do not prejudice the legitimate interests of authors and right holders. At the time of use, the cited works fragments cannot be replaced by alternative, non-copyrighted counterparts and meet the criteria for fair use. All rights reserved. Any reproduction of the materials or its part is prohibited. Use of the works or their fragments must be agreed upon with authors and rights holders. Agreed material use is only possible with reference to the source. Responsibility for unauthorized copying and commercial use of the material is determined by the current legislation.