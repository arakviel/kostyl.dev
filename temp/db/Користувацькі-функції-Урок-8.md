Theory of databases. MS SQL Server (SHS) programming

Lessons

## Користувацькі функції

В SQL Server існує великий набір стандартних функцій, якими ви вже не раз користувались. Та цього набору для забезпечення функціональності бази даних інколи може бути недостатньо. Тому SQL Server надає можливість створювати свої власні користувацькі функції (user-defined functions).

Типи користувацьких функцій:

1.  Скалярні (_scalar functions_) — це функції, що повертають одне скалярне значення, тобто число, рядок тощо.
2.  Вбудовані однотабличні або підставляємі табличні (_inline table-valued functions_)— це функції, які повертають результат у вигляді таблиці. Повертаються вони одним оператором SELECT. Причому, якщо в результаті створюється таблиця, то імена її полів являються псевдонімами полів при вибірці даних.
3.  Багатооператорні функції (_multistatement table-valued functions_) — це функції, при визначенні якої задаються нові імена полів та типи.

Крім того функції розділяють по детермінізму. Детермінізм функції визначається постійністю її результатів. Функція є детермінованою (_deterministic function_), якщо при одному і тому ж заданому вхідному значенні вона завжди повертає один і той же результат. Наприклад, вбудована функція DATEADD() являється детермінованою, оскільки додавання трьох днів до дати 5 травня 2010 р. завжди дає дату 8 квітня 2010 р., або ж функція COS(), яка повертає косинус вказаного кута.

Функція є недетермінованою (_nondeterministic function_), якщо вона може повертати різні значення при одному і тому ж заданому вхідному значенні. Наприклад, вбудована функція GETDATE() являється недетермінованою, оскільки при кожному виклику вона повертає різні значення.

Детермінізм користувацької функції не залежить від того, являється вона скалярною чи табличною, — функції обох цих типів можуть бути як детермінованими, так і недетермінованими.

Від детермінованості функції залежить чи можна проіндексувати її результат, а також чи можна визначити кластеризований індекс на представлення, яке ссилається на цю функцію. Наприклад, недетерміновані функції не можуть бути використані для створення індексів або розрахункових полів. Щодо кластеризованого індекса, то він не може бути створений для представлення, якщо воно звертається до недетермінованої функції (незалежно від того, використовується вона в індексі чи ні).

Користувацькі функції мають ряд переваг, серед яких основним є підвищення продуктивності виконання, оскільки функції, як і зберігаємі процедури, кешують код і повторно використовують план виконання.

Отже, розглянемо типи функцій по порядку. Почнемо з скалярних. Синтаксис їх оголошення наступний:

```html
CREATE FUNCTION [ схема. ] ім'я_функції
                           ( [ @параметр [ AS ] [ схема. ] тип
                                         [ = значення_по_замовчуванню  default ]
                                         [ READONLY ]
                            ][,... n]
                           )
RETURNS тип_повертаємого_значення
[ WITH{  [ ENCRYPTION ]
        [ SCHEMABINDING ]
        [ RETURNS NULL ON NULL INPUT  CALLED ON NULL INPUT ]
        [ EXECUTE AS контекст_безпеки]
      }
      [ ,...n ]
]
[ AS ]
BEGIN
   тіло_функції
   RETURN (повертаєме_скалярне_значення)
END
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Як видно з синтаксису, після імені функції, необхідно в дужках перелічити необхідні вхідні параметри, якщо вони передбачаються. Оскільки всі параметри являються локальними змінними, то перед іменем необхідно ставити символ @, після чого вказується його тип (допускаються всі типи даних, включаючи типи даних CLR, крім timestamp (!)). У випадку необхідності можна задати значення по замовчуванню для кожного з вхідних параметрів або ж вказати ключове слово default. Якщо визначено значення default, тоді параметру присвоюється значення по замовчуванню для даного типу.

Ключове слово READONLY вказує на те, що параметр не може бути обновлений або змінений при визначенні функції. Відмітимо, що якщо тип параметра являється користувацьким табличним типом, тоді обов'язково вказати ключове слово READONLY.

Далі слід вказати тип повертаємого скалярного значення для функції (returns). Допускаються всі типи даних, крім нескалярних типів cursor і table, а також типи rowversion (_timestamp_), text, ntext або image. Їх краще замінити типами uniqueidentifier та binary(8).

Параметр WITH задає додаткові характеристики для вхідних аргументів. З ключовим словом ENCRIPTION, SCHEMABINDING та EXECUTE AS ви вже знайомі, тому на них зупинятись не будемо. Хоча тут є кілька зауважень:

-   параметр SCHEMABINDING не можна вказувати для функцій CLR і функцій, які ссилаються на псевдоніми типів даних;
-   параметр EXECUTE AS не можна вказувати для вбудованих користувацьких функцій.

Параметр RETURNS/CALLED може бути представлений одним з двох значень:

-   CALLED ON NULL INPUT (по замовчуванню) означає, що функція виконується і у випадках, якщо в якості аргумента передано значення NULL.
-   RETURNS NULL ON NULL INPUT вказаний для функцій CLR і означає, що функція може повернути NULL значення, якщо один з аргументів рівний NULL. При цьому код самої функції SQL Server не викликає.

Тіло функції розміщується в середині блоків BEGIN..END, який обов'язково повинен містити оператор RETURN для повернення результату. При написанні коду тіла функції слід пам'ятати, що тут існує ряд обмежень, основним з яких є заборона змінювати стан довільного об'єкта бази даних або саму базу даних.

Доречі, рекурсивні функції також підтримуються. Допускається до 32 рівнів вкладеності.

Викликати скалярну функцію можна одним з двох способів: за домомогою оператора select або execute.

```html
SELECT ім'я_функції (параметр1 [,... n])
EXEC[UTE] @змінна = ім'я_функції параметр1 [,... n]
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Напишемо функцію, яка повертає день тижня по вказаній в якості параметра даті.

```html
create function DayOfWeek (@day datetime)
returns nvarchar(15)
as
begin
    declare @wday nvarchar(15)
    if(datename(dw, @day)= 'Monday')
        set @wday ='понеділок'
    if(datename(dw, @day)= 'Friday')
        set @wday = 'пятниця'
    else
        set @wday = 'інший'
    return @wday
end;

-- виклик
select DayOfWeek(GETDATE()) as 'День тижня';
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 1](https://fsx1.itstep.org/api/v1/files/IFUMGOj6Y3tU8icONZir32Lz7fQweQPd)

Рисунок 1

Вбудовані табличні функції підпорядковуються тим же правилам, що і скалярні. Їх відмінність від останніх полягає у тому, що вони повертають результат у вигляді таблиці. Табличні функції являються непоганою альтернативою представленням та зберігаємим процедурам. Наприклад, недоліком представлень є те, що вони не можуть приймати параметри, які часом необхідно передати. Зберігаємі процедури в свою чергу можуть приймати параметри, але не можуть бути використані у виразі FROM оператора SELECT, що дещо ускладнює обробку результатів. Табличні функції вирішують вищеописані проблеми.

Отже, синтаксис однотабличної функції виглядає так:

```html
CREATE FUNCTION [ схема. ] ім'я_функції
                           ( [ @параметр [ AS ] [ схема. ] тип
                                         [ = значення_по_замовчуванню  default ]
                                         [ READONLY ]
                            ][,... n]
                           )
RETURNS TABLE
[ WITH {  [ ENCRYPTION ]
         [ SCHEMABINDING ]
         [ RETURNS NULL ON NULL INPUT  CALLED ON NULL INPUT ]
         [ EXECUTE AS контекст_безпеки]
       }
      [ ,...n ]
]
[ AS ]
BEGIN
    тіло_функції
    RETURN [ ( ] оператор SELECT[ ) ]
END
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Викликається таблична функція наступним чином:

```html
select * from ім'я_функції (параметр1 [,... n])
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Наприклад, напишемо функцію, яка виводить назви книг та кількість магазинів, що їх продають.

```html
create function countMagazines ()
returns table
as
return (select b.NameBook as 'Назва книги',
               count(sh.id_shop) as 'Кількість магазинів'
        from book.Books b, sale.Shops sh, sale.Sales s
        where b.id_book=s.id_book and s.id_shop=sh.id_shop
        groupby b.NameBook);

-- виклик
select * from countMagazines();
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 2](https://fsx1.itstep.org/api/v1/files/zQHywvh4FiET9Y8Wm82kFSCEuM-ncUp-)

Рисунок 2

Синтаксис багатооператорної функції:

```html
CREATE FUNCTION [ схема. ] ім'я_функції
                           ( [ @параметр [ AS ] [ схема. ] тип
                                         [ = значення_по_замовчуванню  default ]
                                         [ READONLY ]
                            ][,... n]
                           )
RETURNS @повертаєма_таблиця
        TABLE структура_таблиці
[ WITH{  [ ENCRYPTION ]
        [ SCHEMABINDING ]
        [ RETURNS NULL ON NULL INPUT  CALLED ON NULL INPUT ]
        [ EXECUTE AS контекст_безпеки]
      }
      [ ,...n ]
]
[ AS ]
BEGIN
    тіло_функції
    RETURN
END
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Відмітимо, що в багатооператорній функції повертаєма таблиця не обов'язково створюється оператором select. Звідси походить і назва функції. Тут можна, наприклад, виконувати попередню обробку даних і створювати тимчасову таблицю, після чого доопрацювати її і повернути нову таблицю у викликаючу програму.

Слід також бути уважним, оскільки блок тіла функції може містити кілька операторів SELECT. В такому випадку у виразі RETURNS потрібно явно визначити таблицю, яка буде повертатись. Крім того, оскільки оператор RETURN в багатооператорній табличній функції завжди повертає таблицю, яка задана в RETURNS, то він повинен виконуватись без аргументів. Наприклад, RETURN, а не RETURN @myTable.

Викликається багатооператорна таблична функція подібно вбудованій табличній, тобто за допомогою оператора SELECT:

```html
select * from ім'я_функції (параметр1 [,... n])
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

В якості прикладу напишемо багатооператорну табличну функцію, яка повертає назву магазину (-ів), який продав найбільшу кількість книг.

Даний процес можна поділити на два етапи:

-   перший — створимо тимчасову таблицю, що повертає назву книги і кількість магазинів, що їх продають;
-   другий — отримуємо магазин, що продав максимальну кількість книг.

```html
create function BestMagazine ()
returns @tableBestMagazine table ( nameM varchar(30) not null, countBooks int not null)
as
begin

-- створюємо тимчасову таблицю, що повертає назву книги і кількість магазинів, що її продають
    declare @tmpTable table (id_book int not null, numBooks int not null)
    insert @tmpTable
           select b.id_book as'Код', count(s.id_shop) as 'Кількість книг'
        from book.Books b, sale.Sales s
        where b.id_book = s.id_book
        groupby b.id_book

-- заповнюємо повертаєму таблицю за допомогою об'єднання тимчасової таблиці з іншою
    insert @tableBestMagazine
        select sh.NameShop as'Назва магазину', 'Кількість магазинів' = max(tt.numBooks)
        from @tmpTable tt, sale.Sales s, sale.Shops sh
        where tt.id_book = s.id_book and s.id_shop=sh.id_shop
        groupby sh.NameShop
    return
end;

-- виклик
select * from BestMagazine();
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 3](https://fsx1.itstep.org/api/v1/files/8I-_cD9wmO9Mvjgeg93smyVMmvgpBuIg)

Рисунок 3

Змінити існуючу функцію користувача можна за допомогою оператора ALTER FUNCTION:

```html
-- скалярна функція
ALTER FUNCTION [ схема. ] ім'я_функції
                          ( [ @параметр [ AS ] [ схема. ] тип
                                        [ = значення_по_замовчуванню  default ]
                                        [ READONLY ]
                           ][,... n]
                          )
RETURNS тип_повертаємого_значення
[ WITH {  [ ENCRYPTION ]
         [ SCHEMABINDING ]
         [ RETURNS NULL ON NULL INPUT  CALLED ON NULL INPUT ]
         [ EXECUTE AS контекст_безпеки]
      }
      [ ,...n ]
]
[ AS ]
BEGIN
    тіло_функції
    RETURN (повертаєме_скалярне_значення)
END

-- вбудована обнотаблична функція
ALTER FUNCTION [ схема. ] ім'я_функції
                          ( [ @параметр [ AS ] [ схема. ] тип
                                        [ = значення_по_замовчуванню  default ]
                                        [ READONLY ]
                           ][,... n]
                          )

RETURNS TABLE
[ WITH{ [ ENCRYPTION ]
          [ SCHEMABINDING ]
          [ RETURNS NULL ON NULL INPUT  CALLED ON NULL INPUT ]
          [ EXECUTE AS контекст_безпеки]
      }
     [ ,...n ]
]
[ AS ]
BEGIN
    тіло_функції
    RETURN [ ( ] оператор SELECT[ ) ]
END

-- багатооператорна функція
ALTER FUNCTION [ схема. ] ім'я_функції
                         ( [ @параметр [ AS ] [ схема. ] тип
                                       [ = значення_по_замовчуванню  default ]
                                       [ READONLY ]
                          ][,... n]
                         )
RETURNS @повертаєма_таблиця
        TABLE структура_таблиці

[ WITH {  [ ENCRYPTION ]
         [ SCHEMABINDING ]
         [ RETURNS NULL ON NULL INPUT  CALLED ON NULL INPUT ]
         [ EXECUTE AS контекст_безпеки]
     }
    [ ,...n ]
]
[ AS ]
BEGIN
    тіло_функції
    RETURN
END
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Не дивлячись на те, що за допомогою оператора ALTER FUNCTION можна змінити функцію практично повністю, використовувати даний оператор для перетворення скалярної функції в табличну чи навпаки заборонено. За допомогою ALTER FUNCTION також не можна перетворювати функцію T-SQL в функцію середовища CLR або навпаки.

Видалення користувацької функції здійснюється оператором DROP FUNCTION:

```html
DROPFUNCTION [ схема. ] ім'я_функції [ ,...n ]
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Отримати список користувацьких функцій можна з системного представлення sys.sql\_modules, а список параметрів кожної з них розміщується в представленні sys.parameters. Список користувацьких функцій CLR розміщується по іншій адресі, а саме в системному представленні sys. assembly\_modules.

© STEP IT Academy, [itstep.org](https://itstep.org/)

All the copyrighted photos, audio, and video works, fragments of which are used in the material, are the property of their respective owners. Fragments of the works are used for illustrative purposes to the extent justified by the objective, within the educational process, and for educational purposes, in accordance with the Act of “On Copyright and Related Rights”. The scope and method of the cited works are in accordance with the adopted norms, without prejudice to the normal exploitation of copyright, and do not prejudice the legitimate interests of authors and right holders. At the time of use, the cited works fragments cannot be replaced by alternative, non-copyrighted counterparts and meet the criteria for fair use. All rights reserved. Any reproduction of the materials or its part is prohibited. Use of the works or their fragments must be agreed upon with authors and rights holders. Agreed material use is only possible with reference to the source. Responsibility for unauthorized copying and commercial use of the material is determined by the current legislation.