## Об'єднання

## 1\. Оператори для використання у під-запитах

На минулому уроці ви вивчили під-запити та можливість їх використання при написанні SQL-запитів із застосуванням оператора IN. Проте, разом з під-запитами можна використовувати ще кілька логічних операторів, саме їх ми розглянемо у цьому розділі.

Для того, щоб продемонструвати вам приклади виконання SQL-запитів, ми будемо використовувати знайому вам з минулих занять базу даних University, часткова діаграма якої представлена на рисунку 1.

![Рисунок 1. Діаграма бази даних University (частково)](https://fsx1.itstep.org/api/v1/files/IEZ08_WsxtRTdAMRA_MWBeAkUWgXF827)

Рисунок 1. Діаграма бази даних University (частково)

### 1.1. Оператор EXISTS

Оператор EXISTS є унікальним, тому що він перевіряє рядки, а не порівнює значення стовпців і призначений для визначення наявності рядків, що повертаються під-запитом. Якщо під-запит містить хоча б один рядок, оператор EXISTS повертає істину і поточний запис поміщається в таблицю з результатами, інакше оператор повертає помилку і, відповідно, дані не записуються.

Як приклад, продемонструємо SQL-запит, який повертає нам інформацію про студентів, які отримували оцінки з предметів:

```html
SELECT FirstName, LastName, BirthDate, Email
FROM Students
WHERE EXISTS(SELECT*
             FROM Achievements
             WHERE Achievements.StudentId = Students.Id);
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Слід звернути увагу на ряд особливостей поточного запиту. По-перше, ви, напевно, помітили, що в даному SQL-запиті під-запит пов'язаний з основним запитом через унікальний ідентифікатор студента (Achievements.StudentId = Students.Id). По-друге, у під-запиті, після оператора SELECT, використовується символ \*. Такий запис характерний для будь-якого під-запиту з використанням оператора EXISTS, тому що він застосовується до рядків і стовпців, що повертаються, не мають жодного значення.

При виконанні поточного SQL-запиту оператор EXISTS поверне істину, якщо в таблиці Achievements існує хоча б один рядок, що містить унікальний ідентифікатор студента з основного запиту і саме інформація цього студента буде записана в таблицю результатів (Рисунок 2).

![Рисунок 2. Студенти, які отримали оцінки з предметів](https://fsx1.itstep.org/api/v1/files/RJBoX46oyK6k8JR344EU7HzFZ4jLFyxy)

Рисунок 2. Студенти, які отримали оцінки з предметів

Оператор EXISTS можна використовувати із оператором NOT для визначення даних, які не задовольняють умову. Наприклад, при написанні дуального SQL-запиту, який відобразить інформацію про студентів, які не отримали жодної оцінки з предметів:

```html
SELECT FirstName, LastName, BirthDate, Email
FROM Students
WHERE NOT EXISTS(SELECT*
                 FROM Achievements
                 WHERE Achievements.StudentId = Students.Id);
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

У наведеному прикладі під-запит також пов'язаний з основним запитом по ідентифікатору студента. Проте, в даному випадку використання оператора NOT призведе до того, що в результуючу таблицю буде записана інформація тільки про тих студентів, для яких оператор EXISTS поверне помилку. Тобто в тому випадку, якщо в таблиці Achievements немає жодного рядка, що містить унікальний ідентифікатор студента з основного запиту. Результат виконання поточного запиту рисунку 3.

![Рисунок 3. Студенти, які не отримали оцінки з предметів](https://fsx1.itstep.org/api/v1/files/lAN4hlnVyQ4LJrpBJpPgsV7axc9-4LT_)

Рисунок 3. Студенти, які не отримали оцінки з предметів

### 1.2. Оператор ANY/SOME

Оператори ANY і SOME є синонімами і виконують, як це не дивно, одну й ту саму дію — здійснюють перевірку виконання заданої умови порівняння хоча б для одного значення з тих, які повертає підзапит.

Наступний SQL-запит дозволить нам з'ясувати, чи існують у нашій базі даних University записи про студентів, які отримували оцінку 10:

```html
SELECT FirstName, LastName, BirthDate, Email
FROM Students
WHERE Id = ANY(SELECT StudentId
               FROM Achievements
               WHERE Assesment = 10);
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Слід звернути вашу увагу на особливість використання оператора ANY — оператор порівняння необхідно вказувати між порівнюваним значенням та оператором (WHERE Id =ANY ...).

У поточному запиті під-запит повертає унікальні ідентифікатори тих студентів, які отримали оцінку 10, і якщо ідентифікатор студента в записі з основного запиту збігається з будь-яким із них, цей запис буде додано до таблиці з результатами. Результат виконання цього запиту представлений на рисунку 4.

![Рисунок 4. Студенти, які отримували оцінку 10](https://fsx1.itstep.org/api/v1/files/SDi4Gpny6ZZNF09JsgXXUwObIQjO0lLu)

Рисунок 4. Студенти, які отримували оцінку 10

У тому випадку, якщо ви заміните в даному запиті оператор ANY на SOME, то ви отримаєте такий же результат, ми пропонуємо вам перевірити це самостійно.

Уважний студент може заперечити, що для отримання такого результату достатньо порівняти результати виконання під-запиту за допомогою оператора IN і буде абсолютно правим. Наступний SQL-запит поверне такий самий результат, як і на рисунку 4:

```html
SELECT FirstName, LastName, BirthDate, Email
FROM Students
WHERE Id IN(SELECT StudentId
            FROM Achievements
            WHERE Assesment = 10);
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Однак перевага операторів ANY/SOME полягає в тому, що їх можна використовувати не тільки з оператором порівняння на рівність (\=), як оператор IN, але і з операторами порівняння на нерівність (\>, <, \>=, <=, <>) .

Як приклад, наведемо SQL-запит, який дозволить нам визначити кількість студентів, які старші за будь-якого з викладачів:

```html
SELECTCOUNT(*)AS [Count]
FROM Students
WHERE BirthDate &lt; ANY(SELECT BirthDate
                      FROM Teachers);
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

У цьому запиті дата народження кожного студента порівнюється з кожною датою народження викладачів зі списку дат, який повертає нам під-запит. Якщо дата народження студента менша за будь-яку з дат народження викладачів, то такий студент старший за якогось викладача і функція агрегування COUNT(\*) дозволяє визначити їх кількість. Результат виконання поточного запиту на рисунку 5.

![Рисунок 5. Кількість студентів, які старші за будь-якого з викладачів](https://fsx1.itstep.org/api/v1/files/J0-ehvslIJibMPlEqIIqTe3nI2vCazp6)

Рисунок 5. Кількість студентів, які старші за будь-якого з викладачів

### 1.3. Оператор ALL

Оператор ALL використовується для порівняння результатів під-запиту, таким чином, щоб зазначеній умові задовольняли всі результати під-запиту без винятку.

Цей оператор, як і оператори ANY/SOME, може застосовуватися спільно з різними операторами порівняння. Наприклад, виконавши наступний SQL-запит, ми зможемо отримати список студентів, оцінки яких більші, ніж середні оцінки кожного студента, результат цього запиту представлений на рисунку 6.

```html
SELECT FirstName, LastName, Assesment
FROM Students AS S, Achievements AS A
WHERE StudentId = S.Id AND
Assesment &gt; ALL(SELECT AVG(Assesment)
                FROM Achievements
                GROUP BY StudentId);
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

![Рисунок 6. Студенти, оцінки яких більші, ніж середні оцінки кожного студента](https://fsx1.itstep.org/api/v1/files/oNwwp1W51u217AZkH4WPJPpb2KB2un-h)

Рисунок 6. Студенти, оцінки яких більші, ніж середні оцінки кожного студента

В даному випадку під-запит повертає список середніх оцінок усіх студентів, а в основному запиті здійснюється пошук студента, оцінка якого більша, ніж всі оцінки з цього списку.

Оператори ANY/SOME і ALL можуть застосовуватися, як спільно з оператором WHERE, що було показано в усіх попередніх прикладах, так і з оператором HAVING. Для того, щоб продемонструвати вам це ми, виключно в навчальних цілях, напишемо наступний SQL-запит, який повертає список студентів оцінки яких не рівні будь-якій оцінці студентів групи 30PR11:

```html
SELECT FirstName, LastName, Assesment
FROM Students AS S,
(SELECT StudentId, Assesment
FROM Achievements
GROUP BY StudentId, Assesment
HAVING Assesment &lt;&gt; ALL(SELECT Assesment
                        FROM Groups AS G, Students AS S, Achievements AS A
                        WHERE S.GroupId = G.Id AND A.StudentId = S.Id
                        AND GroupName = '30PR11')) AS SA
                        WHERE SA.StudentId = S.Id;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

У поточному SQL-запиті застосовуються два під-запити. Перший під-запит, з найбільшою вкладеністю, повертає список оцінок, отриманих студентами групи 30PR11. Результати цього під-запиту використовуються другим під-запитом для отримання унікального ідентифікатора студента та його оцінки за умови, що ця оцінка не дорівнює жодній з оцінок, повернутих першим під-запитом. Результати другого під-запиту формуються у вигляді таблиці із псевдонімом SA, яка з'єднується з таблицею основного запиту за ідентифікатором студента (SA.StudentId = S.Id) (Рисунок 7).

![Рисунок 7. Студенти, оцінки яких не дорівнюють оцінкам студентів групи 30PR11](https://fsx1.itstep.org/api/v1/files/R3OtnU6c_ejpPPpviH-pCmMJMv3fBp1c)

Рисунок 7. Студенти, оцінки яких не дорівнюють оцінкам студентів групи 30PR11

## 2\. Об'єднання результатів запиту

### 2.1. Принципи об'єднання

Об'єднання результатів запитів застосовується у разі, якщо необхідно отримати сукупність рядків двох і більше запитів, які виконуються незалежно один від одного.

Для того, щоб результати запитів можна було об'єднати, вони повинні відповідати певним умовам сумісності:

-   кількість стовпців у кожному запиті має бути однаковою;
-   типи даних відповідних стовпців у всіх запитах мають бути сумісні.

Також при об'єднанні запитів існує низка особливостей:

-   у результуючому наборі, отриманому при об'єднанні, будуть використовуватись імена стовпців, які були зазначені у першому запиті;
-   не можна сортувати кожен запит окремо, здійснити сортування можливо лише всього складового запиту, вказавши після його закінчення оператор ORDER BY.

Об'єднання результатів запитів забезпечується завдяки використанню ключових слів UNION та UNION ALL. Загальна форма запису SQL-запитів з використанням цих операторів виглядає наступним чином:

```html
SELECT columnName1, columnName2,...
FROM tableName
UNION [ALL]
SELECT columnName1, columnName2,...
FROM tableName;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

### 2.2. Ключове слово UNION

Ключове слово UNION дозволяє об'єднати результати запитів і застосовується в тому випадку, коли в результуючому наборі необхідно виключити рядки, що повторюються.

Продемонструємо використання ключового слова UNION на прикладі об'єднання двох запитів, в результаті якого нам необхідно отримати студентів та викладачів, що народилися влітку, при цьому результуючий набір буде відсортовано за їхньою датою народження:

```html
SELECT FirstName + ' ' + LastName AS FullName, BirthDate
FROM Students
WHERE MONTH(BirthDate) &gt; 5 AND MONTH(BirthDate) &lt; 9
UNION
SELECT FirstName + ' ' + LastName, BirthDate
FROM Teachers
WHERE MONTH(BirthDate) &gt; 5 AND MONTH(BirthDate) &lt; 9
ORDER BY BirthDate;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Даний SQL-запит буде виконуватися наступним чином: спочатку виконуються два запити, які повернуть повне ім'я та дату народження студентів та викладачів, що народилися влітку відповідно. Після цього результати запитів об'єднуються разом без повторюваних записівза допомогою ключового слова UNION, отриманий внаслідок цього набір результатів буде відсортований за зростанням дати народження з використанням оператора ORDER BY (Рисунок 8).

![Рисунок 8. Викладачі та студенти, що народилися влітку](https://fsx1.itstep.org/api/v1/files/xGMYH7v9Bw7vcKwHnOco-SzHpVdObZca)

Рисунок 8. Викладачі та студенти, що народилися влітку

### 2.3. Ключове слово UNION ALL

Ключове слово UNION ALL також дозволяє об'єднувати результати різних запитів, проте виконується швидше, ніж UNION, тому що не витрачає час на видалення дублюючих рядків в запитах, що об'єднуються.

Об'єднання результатів запитів можна також застосовувати, якщо необхідно отримати зведену інформацію з різних SQL-запитів, які пов'язані між собою певним критерієм. У наступному прикладі ми продемонструємо можливість отримання інформації про кількість студентів, які народилися в різні пори року:

```html
SELECT 'Spring' AS Seasons, COUNT(*) AS [Number of students]
FROM Students
WHERE MONTH(BirthDate) BETWEEN 3 AND 5
UNION ALL
SELECT 'Summer', COUNT(*)
FROM Students
WHERE MONTH(BirthDate) BETWEEN 6 AND 8
UNION ALL
SELECT 'Autumn', COUNT(*)
FROM Students
WHERE MONTH(BirthDate) BETWEEN 9 AND 11
UNION ALL
SELECT 'Winter', COUNT(*)
FROM Students
WHERE MONTH(BirthDate) IN (1, 2, 12);
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

В даному випадку кожен із SQL-запитів повертає кількість студентів, які народилися навесні, влітку, восени та взимку відповідно. Першим значенням кожного запиту вказано назву пори року у вигляді рядкового літералу, такий підхід спрацьовує, тому що використовується, по суті, однаковий тип даних. Отримані результати поєднуються за допомогою ключового слова UNION ALL, яке ще забезпечує необхідний порядок об'єднання, що не дозволяє зробити оператор UNION (Рисунок 9).

![Рисунок 9. Кількість студентів відповідно до пори року](https://fsx1.itstep.org/api/v1/files/tSofKq8CBReW4S7uEEoQnzC3cHPGfLji)

Рисунок 9. Кількість студентів відповідно до пори року

Ще один приклад продемонструє можливість використання об'єднання під час складання статистичних звітів. Наприклад, нам необхідно отримати окремо кількість студентів та викладачів, які народилися у другому кварталі, а також їх загальну кількість:

```html
SELECT 'Students' AS [Second quarter], COUNT(*) AS [Count]
FROM Students
WHERE MONTH(BirthDate) BETWEEN 5 AND 8
UNION ALL
SELECT 'Teachers', COUNT(*)
FROM Teachers
WHERE MONTH(BirthDate) BETWEEN 5 AND 8
UNION ALL
SELECT 'All', SUM(AllSum.AllCount)
FROM
(
    SELECT COUNT(*) AS AllCount
    FROM Students
    WHERE MONTH(BirthDate) BETWEEN 5 AND 8
    UNION ALL
    SELECT COUNT(*)
    FROM Teachers
    WHERE MONTH(BirthDate) BETWEEN 5 AND 8
) AS AllSum
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Даний SQL-запит аналогічний попередньому, тільки в цьому випадку два перші запити, що об'єднуються, повертають кількість студентів і викладачів, що народилися в другому кварталі відповідно, а в третьому запиті для підрахунку загальної кількості записів у таблиці з прототипом AllSum, яку ми отримали, як результат об'єднання двох запитів, використовується функція SUM(AllSum.AllCount). Результат виконання цього SQL-запиту наведено на рисунку 10.

![Рисунок 10. Кількість студентів та викладачів, у яких день народження у другому кварталі](https://fsx1.itstep.org/api/v1/files/UqiGoH-gKzqTEMWK5OHfKi4JLIkZdL-l)

Рисунок 10. Кількість студентів та викладачів, у яких день народження у другому кварталі

## 3\. Об'єднання JOIN

У минулому розділі ми вивчили можливість поєднання результатів запитів за допомогою ключового слова UNION, такий вид поєднання можна назвати поєднанням по вертикалі. У свою чергу, оператор JOIN дозволяє об'єднувати таблиці в межах одного SQL-запиту і може вважатися об'єднанням по горизонталі. Існують різні види об'єднань, які можна виконати за допомогою оператора JOIN: внутрішнє (INNER) та зовнішнє (LEFT, RIGHT, FULL).

У попередніх уроках під час написання SQL-запитів для об'єднання таблиць ми використовували синтаксис із застосуванням оператора WHERE, який відповідає стандарту ANSI SQL-89. Синтаксис з використанням оператора JOIN відповідає стандарту ANSI SQL-92, який крім інших покращень мови SQL забезпечує, на відміну від SQL-89, підтримку виконання зовнішніх запитів та покращує читабельність запиту, явно розділяючи об'єднання таблиць та фактичну фільтрацію даних.

В даний момент вам може здатися, що попередні ваші зусилля, витрачені на написання SQL-запитів за стандартом SQL-89, були марні, але ні. Справа в тому, що синтаксиси SQL-89 і SQL-92 часто застосовуються різними програмістами. Тому для того, щоб розуміти запити, написані іншими фахівцями, вам необхідно навчитися використовувати обидва синтаксиси.

Надалі ми рекомендуємо вам використовувати синтаксис з використанням оператора JOIN, який є більш сучасним підходом при написанні SQL-запитів і надає великі можливості, описані вище.

### 3.1. Поняття INNER JOIN

Внутрішнє об'єднання двох таблиць можливе за допомогою оператора INNER JOIN із зазначенням умови їхнього об'єднання (предикату) після ключового слова ON. Загальна форма запису SQL-запитів такого вигляду буде виглядати наступним чином:

```html
SELECT columnName1, columnName2,...
FROM tableName1 [INNER] JOIN tableName2
ON tableName1.columnName = tableName2.columnName;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

При виконанні оператора INNER JOIN кожен запис з першої таблиці зіставляється з кожним записом з другої таблиці за умовою, зазначеною після оператора ON, якщо умова виконується, тоді рядки записуються в результуючу таблицю, яка формується шляхом конкатенації рядків першої та другої таблиць.

Як перший приклад внутрішнього об'єднання, наведемо запит, за допомогою якого ми отримаємо всю інформацію про групи та студентів у цих групах:

```html
SELECT *
FROM Groups INNER JOIN Students
ON Groups.Id = Students.GroupId;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

У цьому SQL-запиті після оператора SELECT спеціально прописано символ \*, щоб ми змогли побачити всі отримані стовпці (Рисунок 11).

![Рисунок 11. Результат використання внутрішнього об'єднання у SQL-запиті](https://fsx1.itstep.org/api/v1/files/nbuvPGzaHXwdV2SYVsnKna-2eW45m1jH)

Рисунок 11. Результат використання внутрішнього об'єднання у SQL-запиті

Як ви можете помітити, ми отримали результуючу таблицю, яка фактично складається із значень двох таблиць Groups та Students, пов'язаних між собою унікальним ідентифікатором групи (Groups.Id).

Звичайно, що використовувати результати запиту в такому вигляді не має жодного сенсу, проте ми можемо вказати в операторі SELECT тільки необхідні нам стовпці, і в результуючій таблиці будуть саме їхні значення у послідовності:

```html
SELECT LastName, FirstName, Email, GroupName
FROM Groups INNER JOIN Students
ON Groups.Id = Students.GroupId;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат виконання поточного SQL-запиту представлено на рисунку 12.

![Рисунок 12. Інформація про студентів](https://fsx1.itstep.org/api/v1/files/dPLY8KiiKUBa119lYDaLhK3xlbCc6QoD)

Рисунок 12. Інформація про студентів

При використанні оператора INNER JOIN допускається не писати службове слово INNER, у цьому випадку JOIN буде розцінюватись, як внутрішнє об'єднання.

Як ви напевно здогадалися, за допомогою оператора INNER JOIN можна здійснювати об'єднання кількох таблиць. Продемонструємо це на наступному прикладі. Припустимо, нам необхідно отримати інформацію про успішність усіх студентів:

```html
SELECT FirstName, LastName, Name AS Subject, Assesment, GroupName
FROM Groups AS G JOIN Students AS S ON G.Id = S.GroupId
JOIN Achievements AS A ON S.Id = A.StudentId
JOIN Subjects AS Sb ON Sb.Id = A.SubjectId;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

При виконанні даного SQL-запиту нам потрібно об'єднати таблиці Groups і Students за ідентифікатором групи (G.Id = S.GroupId), Achievements і Students зв'язавши їх за ідентифікатором студента (S.Id = A.StudentId) та таблиці Subjects та Achievements за ідентифікатором предмета (Sb.Id = A.SubjectId) (Рисунок 13).

![Рисунок 13. Інформація про успішність студентів](https://fsx1.itstep.org/api/v1/files/B3gekMKz-zrMJvMx7CKIww_qIqVqHfQI)

Рисунок 13. Інформація про успішність студентів

При здійсненні внутрішнього об'єднання ви, як і раніше, можете використовувати всі оператори мови SQL. Наприклад, якщо потрібно отримати оцінки з предметів тільки у студентів 29 потоку та відсортувати отриману інформацію за прізвищами студентів, тоді нам достатньо застосувати оператори WHERE та ORDER BY до написаного раніше запиту (Рисунок 14):

```html
SELECT FirstName, LastName, Name AS Subject, Assesment, GroupName
FROM Groups AS G JOIN Students AS S ON G.Id = S.GroupId
JOIN Achievements AS A ON S.Id = A.StudentId
JOIN Subjects AS Sb ON Sb.Id = A.SubjectId
WHERE GroupName LIKE'29%'
ORDER BY LastName;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

![Рисунок 14. Успішність студентів 29 потоку](https://fsx1.itstep.org/api/v1/files/uP9BfWXTse4DcFWV61TvxTLbWNJHKAXX)

Рисунок 14. Успішність студентів 29 потоку

### 3.2. Необхідність використання зовнішнього об'єднання

При виконанні певного виду SQL-запитів, пов'язаних із отриманням повної інформації з таблиць, використання внутрішнього об'єднання не дасть бажаного результату. Наприклад, необхідно вивести інформацію про всіх студентів та оцінки, які вони отримали. Запит до бази даних University із застосуванням оператора INNER JOIN буде виглядати так:

```html
SELECT FirstName + ' ' + LastName AS FullName, Assesment
FROM Students AS S INNER JOIN Achievements AS A
ON S.Id = A.StudentId;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Як результат виконання даного запиту ми отримаємо наступний набір даних (Рисунок 15).

![Рисунок 15. Результат виконання внутрішнього об'єднання](https://fsx1.itstep.org/api/v1/files/LKGND2tABDTcfwyJEa_pElDXOIXILdeI)

Рисунок 15. Результат виконання внутрішнього об'єднання

Проте отриманий нами результат не задовольняє необхідної умови, адже нам необхідно було отримати дані про всіх студентів, а не лише про тих, хто отримав оцінки. Така поведінка характерна при використанні оператора INNER JOIN, тому що в результуючу таблицю будуть поміщені тільки ті записи, які задовольняють умову, зазначену після ключового слова ON, у нашому випадку відповідність унікального ідентифікатора студента (S.Id = A.StudentId).

Для того, щоб отримувати правильні результати при написанні подібних SQL-запитів, необхідно застосовувати зовнішні об'єднання (OUTER JOIN), які дозволяють отримати всі дані з однієї таблиці незалежно від того, чи існує для них збіг рядків в іншій таблиці. Існує три типи зовнішніх об'єднань: ліве (LEFT), праве (RIGHT) та повне (FULL). Загальна форма запису зовнішніх об'єднань виглядає так:

```html
SELECT columnName1, columnName2,...
FROM leftTable LEFT | RIGHT | FULL [OUTER] JOIN rightTable
ON tableName1.columnName = tableName2.columnName;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

При написанні запитів із використанням зовнішніх об'єднань ключове слово OUTER можна опустити, оскільки ключові слова LEFT, RIGHT і FULL однозначно визначать його тип.

### 3.3. Поняття LEFT JOIN

Оператор LEFT JOIN (LEFT OUTER JOIN) дозволяє створити так зване ліве зовнішнє об'єднання, при виконанні якого в результуючий набір крім рядків, що задовольняють умову після ключового слова ON, будуть записані навіть ті рядки з таблиці, розташованої зліва від оператора, які не задовольняють зазначену умову.

Спробуємо вирішити задачу про всіх студентів та їх оцінки поставлену в попередньому розділі за допомогою оператора LEFT JOIN та напишемо для цього відповідний SQL-запит:

```html
SELECT FirstName + ' ' + LastName AS FullName, Assesment
FROM Students AS S LEFT JOIN Achievements AS A
ON S.Id = A.StudentId;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

В даному випадку в результуючий набір потраплять необхідні дані про всіх студентів з таблиці Students, незалежно від того, отримували вони оцінки чи ні. У тому випадку, якщо в таблиці Achievements відсутня оцінка для відповідного студента, результат дорівнюватиме NULL (Рисунок 16).

![Рисунок 16. Результат виконання лівого зовнішнього об'єднання](https://fsx1.itstep.org/api/v1/files/OKdvd1E40ajMExTr4wyAW1VoTMcDjXkA)

Рисунок 16. Результат виконання лівого зовнішнього об'єднання

Для того, щоб остаточно переконати вас у корисності зовнішніх об'єднань, продемонструємо вам два варіанти вирішення ще одного завдання. Припустимо, нам необхідно отримати інформацію про студентів, які поки що не отримували оцінок.

Одним із варіантів отримання необхідних даних є SQL-запит із обов'язковим використанням під-запиту:

```html
SELECT FirstName + ' ' + LastName AS FullName
FROM Students
WHERE Id NOT IN(SELECT StudentId FROM Achievements);
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

У цьому випадку під-запит повертає унікальні ідентифікатори всіх студентів, які отримали оцінки, та інформація про які знаходиться в таблиці Achievements. В основному запиті виводяться дані лише про тих студентів, унікальний ідентифікатор яких відсутній у множині, сформованій під-запитом, тобто запис про них відсутній в таблиці Achievements, а отже вони ще не отримали жодної оцінки (Рисунок 17).

![Рисунок 17. Студенти, які не отримали оцінки](https://fsx1.itstep.org/api/v1/files/j_JQ_NeXKt9gCcZpDS5s8UC5igTGvCeD)

Рисунок 17. Студенти, які не отримали оцінки

Під час написання під-запитів багато студентів стикаються з проблемою розуміння їх виконання. Тому, більш витонченим рішенням поставленої задачі без використання під-запиту є можливість застосування в даному SQL-запиті оператора LEFT JOIN, який утворює більш зрозумілу синтаксичну конструкцію. До того ж, такий запит виконується швидше, тому що для кожного LEFT JOIN створюється окремий потік і його виконання відбувається паралельно, на відміну від під-запиту, виконання якого здійснюється послідовно з основним запитом в одному потоці.

Щоб зрозуміти, як вирішити поставлене завдання з допомогою зовнішнього об'єднання, вам необхідно уважно придивитися до результату виконання SQL-запиту на рисунку 16. Як ви помітили, у деяких студентів оцінка має невизначене значення (NULL), тобто якщо відфільтрувати записи за цією ознакою, ми отримаємо потрібний результат, який повністю збігається з результатом, отриманим при виконанні попереднього запиту (Рисунок 17):

```html
SELECT FirstName + ' ' + LastName AS FullName
FROM Students AS S LEFT JOIN Achievements AS A
ON S.Id = A.StudentId
WHERE Assesment IS NULL;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

### 3.4. Поняття RIGHT JOIN

За допомогою оператора RIGHT JOIN (RIGHT OUTER JOIN) можливо створити, так зване праве зовнішнє об'єднання, при виконанні якого в результуючий набір крім рядків, що задовольняють умову після ключового слова ON, будуть записані всі рядки з таблиці, розташованої праворуч від оператора, незалежно від того чи задовольняють вони зазначену умові чи ні.

Як перший приклад використання оператора RIGHT JOIN продемонструємо вам рішення вже відомого вам завдання — виведення інформації про всіх студентів та отримані ними оцінки:

```html
SELECT FirstName + ' ' + LastName AS FullName, Assesment
FROM Achievements AS A RIGHT JOIN Students AS S
ON S.Id = A.StudentId;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

У даному випадку ми поміняли місцями таблиці Achievements і Students та у результаті виконання цього запиту ми отримали результат ідентичний результату на рисунку 16. Таким чином, за допомогою правого зовнішнього об'єднання можна отримати результати аналогічні результатам лівого зовнішнього об'єднання, якщо змінити порядок слідування таблиць в SQL-запиті.

В наступному прикладі ми продемонструємо можливість спільного використання правого і лівого об'єднань. Припустимо, що нам необхідно отримати список усіх предметів та інформацію про викладачів, які їх читають. Нижче наведено можливий варіант запиту:

```html
SELECT [Name] AS [Subject], LastName, FirstName
FROM TeachersSubjects AS TS RIGHT JOIN Subjects AS S
ON S.Id = TS.SubjectId LEFTJOIN Teachers AS T
ON T.Id = TS.TeacherId
ORDER BY [Name];
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Таблиця TeachersSubjects містить інформацію про те, хто з викладачів якийсь предмет читає. У таблиці Subjects знаходиться список всіх предметів, тобто саме рядки з цієї таблиці нам необхідно отримати, незалежно від того, чи є відповідності в інших таблицях, пов'язаних з нею. Тому ми об'єднали таблиці TeachersSubjects і Subjects за допомогою правого зовнішнього з'єднання. Для того, щоб збереглися результати першого об'єднання, ми, за допомогою лівого зовнішнього об'єднання, пов'язуємо їх з таблицею Teachers, в якій міститься інформація про викладачів. З отриманого результату видно, що предмет Unity на даний момент не читає жоден із викладачів (Рисунок 18).

![Рисунок 18. Список всіх предметів та дані про викладачів, які їх читають](https://fsx1.itstep.org/api/v1/files/7GrSxY5xSfTID7jEZRMSJUTQyUY-mMh6)

Рисунок 18. Список всіх предметів та дані про викладачів, які їх читають

### 3.5. Поняття FULL JOIN

Оператор FULL JOIN (FULL OUTER JOIN) дозволяє створити повне зовнішнє об'єднання, при якому до результуючого набору включаються записи з лівої таблиці навіть у тому випадку, якщо для них відсутні відповідні записи в правій таблиці, а записи з правої таблиці будуть поміщені в результуючу таблицю навіть тоді, коли їм немає записів відповідності у лівій таблиці. Таким чином, повне зовнішнє з'єднання по суті є комбінацією лівого та правого зовнішніх об'єднань.

Наведемо приклад виконання повного зовнішнього об'єднання для отримання інформації про всіх студентів та груп:

```html
SELECT FirstName, LastName, GroupName
FROM Students AS S FULL JOIN Groups AS G
ON G.Id = S.GroupId
ORDER BY FirstName;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

В отриманій результуючій таблиці знаходяться всі записи таблиці Students і всі записи з таблиці Groups там, де відсутній відповідний запис з іншої таблиці, повертається невизначене значення (NULL). В даному випадку в групі 33GR12 немає жодного студента і студентка Charlotte Becker поки не зарахована до жодної групи (Рисунок 19).

![Рисунок 19. Інформація про всіх студентів та групи](https://fsx1.itstep.org/api/v1/files/j_Rr16R4b2HnARqHRb-l3kXWjNOKw1Ri)

Рисунок 19. Інформація про всіх студентів та групи

## 4\. Домашнє завдання

1.  Вам необхідно створити багатотабличну базу даних Airport, в якій має бути інформація, пов'язана з роботою аеропорту. У цій базі даних обов'язково мають бути такі таблиці: рейси літаків, квитки на рейси (бізнес та економ клас), пасажири.
2.  Використовуючи отримані в цьому уроці знання, вам необхідно написати до створеної бази
    -   Airport
    -   вивести всі рейси до певного міста на довільну дату, впорядкувавши їх за часом вильоту;
    -   вивести інформацію про рейс із найбільшою тривалістю польоту за часом;
    -   показати всі рейси, тривалість польоту яких перевищує дві години;
    -   отримати кількість рейсів у кожне місто;
    -   показати місто, в яке найчастіше здійснюються польоти;
    -   отримати інформацію про кількість рейсів у кожне місто та загальну кількість рейсів за певний місяць;
    -   вивести список рейсів, що вилітають сьогодні, на які є вільні місця у бізнес-класі;
    -   отримати інформацію про кількість проданих квитків на всі рейси за вказаний день та їхню загальну суму;
    -   вивести інформацію про попередній продаж квитків на певну дату із зазначенням усіх рейсів та кількості проданих на них квитків;
    -   вивести номери всіх рейсів та назви всіх міст, в які здійснюються польоти з аеропорту.

© STEP IT Academy, [itstep.org](https://itstep.org/)

All the copyrighted photos, audio, and video works, fragments of which are used in the material, are the property of their respective owners. Fragments of the works are used for illustrative purposes to the extent justified by the objective, within the educational process, and for educational purposes, in accordance with the Act of “On Copyright and Related Rights”. The scope and method of the cited works are in accordance with the adopted norms, without prejudice to the normal exploitation of copyright, and do not prejudice the legitimate interests of authors and right holders. At the time of use, the cited works fragments cannot be replaced by alternative, non-copyrighted counterparts and meet the criteria for fair use. All rights reserved. Any reproduction of the materials or its part is prohibited. Use of the works or their fragments must be agreed upon with authors and rights holders. Agreed material use is only possible with reference to the source. Responsibility for unauthorized copying and commercial use of the material is determined by the current legislation.