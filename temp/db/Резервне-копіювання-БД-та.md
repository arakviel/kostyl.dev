Database Theory. MS SQL Server Programming

Lessons

![](https://fsx1.itstep.org/api/v1/files/-rZfafbuJwi_OKr1n48i3WmSPYxI-KHo)

## Резервне копіювання БД та відновлення з резервної копії

## 1\. Основні поняття

От і підійшли ми до завершення курсу «SQL Server 2008». Створювати базу даних ми навчились, а також розібрались з організацією безпеки даних на сервері. Але це ще далеко не все. Після цього варто потурбуватись про оптимізацію її діяльності та безпеку даних у випадку виникнення непередбачуваних ситуацій, адже в процесі роботи всяке трапляється: пожежа, потоп, землетрус, різного роду збої в апаратній частині, помилки в роботі користувачів (наприклад, були випадково видалені або змінені дані) тощо. Для таких випадків дуже корисно мати під рукою копію даних, яку можна відновити у випадку втрати інформації. Здійснюється це за допомогою механізму резервного копіювання.

Резервне копіювання (_backup_) бази даних та відновлення з резервної копії (_restore_) — дві важливих та найбільш частих адміністративних процеси, які здійснюються розробниками і адміністраторами бази даних. В SQL Server 2008 для цього можна скористатись операторами T-SQL або використати набір інструментів SSMS.

Варто відзначити, що регулярне виконання _backup/restore_ бази даних та журналу транзакцій дозвляє уникнути втрати даних.

Всі типи резервного копіювання, які підтримуються SQL Server 2008, залежать від моделі відновлення бази даних (_recovery model_). Вони також визначають, як SQL Server буде працювати з журналом транзакцій, буде його реєструвати та очищати (точніше обрізати (_truncating_) журнал, тобто видаляти зафіксовані транзакції і вивільняти місця для реєстрації нових). SQL Server 2008 підтримує три моделі відновлення бази даних:

1.  **Модель повного відновлення** (_Full recovery model_) — в журналі транзакцій будуть реєструватись всі операції і очищення журналу відбуватись не буде. Дана модель дозволяє повністю відновити базу даних до стану на момент аварійного завершення її роботи.
2.  **Проста модель відновлення** (_Simple recovery model_) — реєструє мінімум даних про більшість транзакцій і виконує очищення журналу транзакцій після кожної контрольної точки. Таким чином, формується зручний і компактний журнал транзакцій, який забезпечує доволі високе підвищення продуктивності, але не буде пригодний для відновлення. В зв'язку з цим, дана модель не підтримує резервне копіювання і відновлення журналу транзакцій, а також не дозволяє відновлювати окремі сторінки.
3.  **Модель з неповним протоколюванням** (_Bulk-Logged recovery model_) — являється спрощеною моделлю повного відновлення, в якій про звичайні операції в журнал транзакції записується повна інформація, а от реєстрація інформації про масові операції (SELECT INTO та BULK INSERT) зводиться до мінімуму. Отже, якщо в резервній копії журналу транзакцій містяться які-небудь масові операції, базу даних можна відновити лише до стану, який відповідає кінцю резервної копії журналу, тобто не можна відновити на певний період часу. Ця модель відновлення використовується тільки для великих масових операцій.

На практиці, рекомендується використовувати модель повного відновлення бази даних, оскільки вона володіє найбільшими можливостями відновлення. Якщо ж ви використовуєте масові операції для імпорту даних, краще в такий період змінювати модель відновлення на модель з неповним протоколюванням, оскільки вона дозволяє підвищити продуктивність масових операцій.

Модель відновлення бази даних можна змінити засобами SSMS на сторінці Properties (_Властивості_) бази даних.

![Рисунок 1](https://fsx1.itstep.org/api/v1/files/QwU0jNMIca9x9CiR9vYVeEn9r-8AZOP6)

Рисунок 1

А також за допомогою інструкції ALTER DATABASE з наступним синтаксисом:

```html
-- синтаксис інструкції ALTER DATABASE для зміни моделі відновлення бази даних
ALTER DATABASE ім'я_бази_даних
SET RECORERY {FULL | SIMPLE | BULK_LOGGED}

-- наприклад, встановити повну модель відновлення бази даних
alter database Press
set recovery full;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Переглянути інформацію про поточну модель відновлення можна за допомогою системного представлення sys.databases:

```html
select name, recovery_model_desc
from sys.databases;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 2](https://fsx1.itstep.org/api/v1/files/hGls8tkSnvdi7OxlhcXalTFbut48P-3f)

Рисунок 2

## 2\. Резервне копіювання

### 2.1. Види резервного копіювання

Резервне копіювання бази даних — це процес зчитування всіх даних з бази даних і збереження їх у вигляді одного чи кількох файлів на диску або пристрої резервного копіювання. Резервні копії можна робити для цілої бази даних або її частини, набору файлів або файлових груп.

Важливо знати, що всі операції резервного копіювання виконуються в контексті безпеки облікового запису користувача, тому такому користувачу необхідно надати відповідні права. До необхідних прав слід віднести права на читання і запис в довільні каталоги або дискові накопичувачі, які будуть використовуватись для створення резервної копії, а також він повинен бути членом фіксованої ролі рівня бази даних _db\_backupoperator_.

Існують наступні види резервного копіювання:

1.  **Повне резервне копіювання бази даних** (_full database backup_) — дозволяє зберегти поточний стан всіх даних, які зберігаються в базі. Для цього механізм резервного копіювання витягує всі екстентибази даних, які виділені для об'єктів.
    
    (Екстент — це основна одиниця організації простору в SQL Server. Екстентявляє собою колекцію, яка складається з 8 фізичних неперервних сторінок (64 Кб). Сторінка — це основна одиниця джерела даних в SQL Server. Місце на диску, де розміщується файл бази даних, логічно розділяється на неперервні сторінки по 8 Кб з нумерацією від 0 до n. Всі дискові операції вводу-виводу виконуються на рівні сторінок. Всі сторінки зберігаються в екстентах.
    
    Файли журналу транзакцій не містять сторінок, в них розміщується послідовність записів журналу (!).)
2.  **Різничне резервне копіювання бази даних** (_differential database backup_) — зберігає всі екстенти, які були зміненіз моменту останнього повного резервного копіювання (!). Воно дозволяє зменшити кількість резервних копій журналу транзакцій, які необхідно відновити у випадку втрати даних.
3.  **Резервне копіювання журналу транзакцій** (_transaction log_) — дозволяє зберегти активний журнал (_active log_), тобто дані журналу, які починаються з номера транзакції (_LSN_), на якому закінчилось попереднє резервне копіювання журналу транзакцій. Після цього зберігаються всі наступні транзакції до тих пір, поки не будевиявленавідкрита транзакція.
4.  **Резервне копіювання файлових груп** (_filegroup backup_) — дозволяє створювати резервне копіювання окремих файлових груп бази даних.

Для виконання різничного резервного копіювання і резервного копіювання журналу транзакцій необхідно створити повну резервну копію. Але відбуваються вони окремо один від одного.

Підсумовуючи відмітимо також наступні моменти:

-   використання повних резервних копій разом з різничними і резервними копіями журналів транзакцій дозволяють зберегти всю базу даних, включаючи всі зміни, які відбулись з моменту останнього повного резервного копіювання;
-   для створення копій фрагментів бази даних краще всього використовувати резервне копіювання файлових груп разом з різничними резервними копіями і копіями журналу транзакцій.

### 2.2. Резервне копіювання бази даних

Механізм резервного копіювання бази даних записує на пристрій резервного копіювання сторінки бази даних, без врахування їх порядку. В зв'язку з цим дані можуть записуватись в кілька потоків, що робить операцію резервного копіювання досить швидкою. Швидкість резервного копіювання залежить лише від швидкості запису даних на пристрій.

Щоб на виході отримати непошкоджені дані (адже під час резервного копіювання до них можуть звертатись інші користувачі і виконувати при цьому вставку, модифікацію або видалення даних), SQL Server здійснює повне резервне копіюваннянаступним чином:

-   Спочатку блокується база даних і всі транзакції.
-   В журнал транзакцій додається маркер.
-   Знімається блокування бази даних.
-   Виконується резервне копіювання всіх сторінок бази даних.
-   Знову здійснюється блокування бази даних і всіх транзакцій.
-   В журнал транзакцій додається маркер.
-   Знімається блокування бази даних.
-   Витягуються всі транзакції між двома маркерами в журналі транзакцій і додаються в резервну копію.

Для резервного копіювання використовується також карта розміщення екстентів. Ця карта використовується для визначення екстентів, які повинні ввійти в резервну копію, і являє собою окрему сторінку даних в базі даних, кожен біт якої представляє один екстент. При повному резервному копіюванні всі біти зкидаються на 0. Після цього, якщо екстент змінюється, SQL Server змінює біт, який йому відповідає з 0 на 1. Таким чином, при різничному резервному копіюванні значення бітів карти аналізується і в резервну копію входять лише екстенти, які були змінені (тобто їх біт рівний 1).

Відмітимо, що для бази даних _master_ можна здійснювати лише повне резервне копіювання.

Ну і нарешті, резервне копіювання бази даних здійснюється за допомогою оператора BACKUP DATABASE:

```html
BACKUP DATABASE { база_даних | @змінна_з_іменем_БД } 
-- база даних або її частина
-- (об'єкт)

TO пристрій_резервного_копіювання [ ,...n ]
[ MIRROR TO пристрій_резервного_копіювання ,...n ]] 

-- дзеркало для основного пристрою резервного копіювання
-- параметри операцій створення резервної копії
[ WITH [ DIFFERENTIAL ] -- різнична резервна копія
       [ загальні_опції_WITH [ ,...n ] ]
]

-- пристрій_резервного_копіювання:
{ ім'я_логічного_пристрою_резервного_копіювання |   
   @змінна_імені_логічного_пристрою_резервного_копіювання } | 
   { DISK | TAPE } = { 'ім'я_фізичного_пристрою_резервного_копіювання' |  
   @змінна_імені_фізичного_пристрою_резервного_копіювання }
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Згідно вищеописаного синтаксису, спочатку необхідно вказати назву бази даних (або її частини), резервну копію якої необхідно зробити. Після ключового слова TO вказується пристрій резервного копіювання, на якому буде зберігатись резервна копія. Ним може бути як ім'я створеного логічного пристрою резервного копіювання, так і повний шлях на диску або стрічковому пристрої.

**ПРИМІТКА****!** _В_ _наступній версії_ _SQL Server_ _підтримка стрічкових пристроїв буде вилучена__._ _Тому варто уникати використання параметра_ _TAPE._

Параметр MIRROR TO служить для опису пристрою(-їв) резервного копіювання, який буде дзеркалом для основного пристрою резервного копіювання. Максимальна кількість пристроїв для дзеркального резервного копіювання — три. При цьому, вказана кількість пристроїв в параметрі MIRROR TO повинна мати той же тип і ту ж кількість, що і в параметрі TO.

Параметр WITH дозволяє задати додаткові необов'язкові параметри створення резервної копії, а також вказати необхідність створення різничної резервної копії бази даних (по замовчуванню створюється повна резервна копія). В якості загальних опцій параметра WITH можуть виступати:

1\. Параметри резервного набору даних, який створюється поточною операцією резервного копіювання.

-   COPY\_ONLY — резервна копія лише для копіювання. Якщо параметри DIFFERENTIAL і COPY\_ONLY використовуються разом, тоді параметр COPY\_ONLY ігнорується і створюється різнична резервна копія.
-   COMPRESSION | NO\_COMPRESSION — використовується компресія (_compression_) даної резервної копії.
-   DESCRIPTION = { 'текст' | @змінна\_тексту } — текстовий опис резервного набору даних, який може містити до 255 символів.
-   NAME = { 'ім'я' | @змінна\_імені } — ім'я резервного набору даних, яке не повинно перевищувати 128 символів. По замовчуванню ім'я відсутнє.
-   PASSWORD = { 'пароль' | @змінна\_пароля } — пароль на резервний набір даних. В наступній версії SQL Server ця опція буде видалена.
-   EXPIREDATE = { 'дата' | @змінна\_дати } и RETAINDAYS = { к-ть\_днів | @змінна\_к-ті\_днів } — час, який визначає, коли дану резервну копію можна перезаписати. Ці параметри можуть вказуватись разом, але в такому випадку RETAINDAYS має пріоритет над EXPIREDATE.
-   Якщо жоден з цих параметрів не заданий, тоді термін збереження визначається параметром конфігурації mediaretention.

Якщо вказані параметри задаються за допомогою змінної, тоді вони повинні мати один з наступних типів:

-   для
    -   EXPIREDATE
    -   рядковою константою;
    -   символьним рядком, крім типів даних ntext і text;
    -   smalldatetime;
    -   datetime.
-   для RETAINDAYS — цілим числом.

2\. Параметри набору носіїв, на які записуються резервні копії:

-   NOINIT | INIT — визначають чи буде операція резервного копіювання перезаписувати (INIT) резервні набори даних, які вже існують на носії резервної копії, чи дописувати (NOINIT) нові набори даних в кінець.
    
    По замовчуванню використовується опція NOINIT.
-   NOSKIP | SKIP — визначає чи буде операція резервного копіювання перевіряти (NOSKIP) дату ічас закінчення терміну резервної копії на носії перед їх перезаписом.
    
    Опція NOSKIP встановлена по замовчуванню.
-   NOFORMAT | FORMAT — повинен (FORMAT) чи ні (NOFORMAT) заголовок носія записуватись (або перезаписуватись) на томах, які використовуються поточною операцією резервного копіювання.
    
    В зв'язку з цим, опцію FORMAT слід використовувати дуже обережно, оскільки форматування будь-якого тому з набору носіїв пошкоджує всю резервну копію.
-   MEDIADESCRIPTION = { 'текст' | @змінна\_тексту } — текстовий опис набору носіїв, який не повинен перевищувати 255 символів.
-   MEDIANAME = { 'ім'я\_носія' | @змінна\_імені } — ім'я носія для всього набору носіїв резервних копій, яке не повинне бути більше 128 символів. Це ім'я повинно співпадати з вже заданим іменем носія, який існує в томах резервних копій.
    
    Якщо ім'я не вказане і вказаний параметр SKIP, тоді перевірки імені носія не буде.
-   MEDIAPASSWORD = { 'пароль' | @змінна\_пароля } — пароль на набір носіїв. В наступній версії SQL Server даний параметр буде відсутній.
-   BLOCKSIZE = { розмір | @змінна\_розміру } — розмір фізичного блоку в байтах, який може приймати одне з наступних значень: 512, 1 024, 2 048, 4 096, 8 192, 16 384, 32 768 і 65 536 байт. Значення по замовчуванню — 65536 для стрічкових пристроїв і 512 для інших.
-   На практиці, даний параметр майже не використовується, оскільки оператор BACKUP автоматично обирає розмір необхідного блоку.

3\. Параметри передачі даних:

-   BUFFERCOUNT = { к-ть\_буферів | @змінна\_к-ті\_буферів } — загальна кількість буферів вводу-виводу, які будуть використовуватись при резервному копіюванні. Відмітимо, що при великій кількості буферів операція резервного копіювання може бути дуже ресурсоємкою.
    
    Загальний простір, який використовується буферами визначається по наступній формулі: к-ть\_буферів \* об'єм\_пакета.
-   MAXTRANSFERSIZE = { об'єм\_пакета | @змінна\_об'єму\_пакета } — найбільший об'єм пакета даних в байтах для передачі між SQL Server і носієм резервного набору. Підтримуються значення, кратні 65 536 байтам (64 Кб) і до 4 194 304 байт (4 Мб).

4\. Параметри управління помилками:

-   NO\_CHECKSUM | CHECKSUM — дозволені (CHECKSUM) чи ні (NO\_CHECKSUM) контрольні суми. По замовчуванню контрольні суми відсутні, за виключенням зжатих резервних копій.
-   STOP\_ON\_ERROR | CONTINUE\_AFTER\_ERROR — чи буде операція резервного копіювання зупинена після виявлення помилки в контрольній сумі сторінки (STOP\_ON\_ERROR) чи продовжити роботу (CONTINUE\_AFTER\_ERROR).
    
    По замовчуванню встановлений STOP\_ON\_ERROR.

5\. Параметри сумісності представлені одним параметром RESTART, який нічого не робить і залишений лише для забезпечення зворотної сумісності.

6\. В параметрах спостереження існує також один представник — це параметр STATS \[ = відсотковий\_інтервал \]. Він дозволяє виводити повідомлення кожен раз по закінченні вказаного відсоткового інтервалу. По замовчуванню повідомлення виводиться після кожних 10 відсотків.

7\. Параметри стрічкових пристроїв:

-   REWIND | NOREWIND — вивільнити і перемотати стрічку (REWIND; значення по замовчуванню) або ж зберегти її відкритою після закінчення резервного копіювання (NOREWIND), що дозволяє суттєво покращити продуктивність при виконанні кількох операцій резервного копіювання на стрічку.
-   Параметр NOREWIND включає в себе параметр NOUNLOAD, тому разом їх вказувати в операторі BACKUP не дозволяється.
-   UNLOAD | NOUNLOAD
    -   UNLOAD | NOUNLOAD
    -   UNLOAD вказує на те, що стрічка повинна автоматично перемотуватись і вигружатись по завершенні операції backup.
    -   NOUNLOAD вказує на те, що стрічка буде зберігатися в стрічковому накопичувачі після операції backup.
-   **ПРИМІТКА!** _В символьних параметрах не дозволяється вказувати типи даних ntext і text. Крім того, оператор BACKUP заборонено використовувати в явних і неявних транзакціях._

Наведемо приклад створення повної резервної копії бази даних Press в файл на диску. При цьому всі резервні набори, які є на диску слід перезаписати:

```html
backup database Press
to disk = 'D:\Backups\Press.bak'
with init;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Файл резервної копії — це звичайний файл і тому достатньо просто прописати його назву з повним шляхом. При створенні резервної копії можна вказувати абсолютний або відносний шлях до файла, а також взагалі його упустити. В двох останніх випадках, буде використовуватись каталог по замовчуванню, яким являється «_C:_\\_Program Files_\\_Microsoft SQL Server_\\_MSSQL.n_\\_MSSQL_\\_Backup_», де n — номер екземпляра сервера. Каталог по замовчуванню можна змінити в розділі реєстру BackupDirectory, в гілці _HKEY\_LOCAL\_MACHINE_\\_SOFTWARE_\\_Microsoft_\\_Microsoft SQL Server_\\ _MSSQL.n_\\_MSSQLServer_.

![Рисунок 3](https://fsx1.itstep.org/api/v1/files/f44uNOO14Ep8JbLtZKc93eziNmBJNgIt)

Рисунок 3

Крім того, можна звертатись до віддаленого дискового файла. Щоб мати доступ до спільного мережевого ресурсу, необхідно, щоб цей диск був підключений як мережевий. Щоб вказати мережевий ресурс при резервному копіюванні, необхідно використовувати повне ім'я в форматі UNC, яке має наступну форму: \\\\_Ім'я\_системи_\\_Спільна\_папка_\\_Шлях_\\_Ім'я\_файла_. Наприклад:

```html
backup database Press
to disk = '\\BackupServer\Backups\Press.bak';
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Щодо логічних пристроїв резервного копіювання, то вони використовуються для неявного звернення до існуючих фізичних пристроїв резервного копіювання. Це дозволяє спростити процес вказування файла резервної копії, оскільки відпадає необхідність прописувати довгий повний шлях. Для їх створення використовується зберігаєма процедура sp\_addumpdevice, яка дозволяє зв'язати фізичний пристрій резервного копіювання з логічним.

```html
sp_addumpdevice [ @devtype = ] 'тип_пристрою_резервного_копіювання' -- disk або tape
              , [ @logicalname = ] 'ім'я_логічного_пристрою_резервного_копіювання'
              , [ @physicalname = ] 'ім'я_фізичного_пристрою_резервного_копіювання'

-- застарівші параметри, які існують для сумісності
[, { [ @cntrltype = ] тип_контролера | [ @devstatus = ] 'статус_пристрою'} ]
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Наприклад, запишемо резервну копію нашої бази даних Press на логічний пристрій резервного копіювання PressBack:

```html
-- створюємо логічний пристрій резервного копіювання
exec sp_addumpdevice 'disk', 'PressBack', 'D:\Backups\Press.bak';

-- створюємо резервну копію бази даних на логічний пристрій резервного копіювання
backup database Press
to PressBack;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Для видалення існуючого логічного пристрою резервного копіювання використовується системна зберігаєма процедура sp\_dropdevice:

```html
-- синтаксис
sp_dropdevice [ @logicalname = ] 'ім'я_логічного_пристрою_резервного_копіювання'
[ , [ @delfile = ] 'delfile' ] -- чи потрібно видаляти
                               -- фізичний пристрій резервного копіювання

-- наприклад, видалимо один з логічних пристроїв резервного копіювання,
-- разом з фізичним пристроєм, який йому відповідає
exec sp_dropdevice 'PressBack', 'delfile'
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Для перегляду імен існуючих логічних пристроїв, можна скористатись системним представленням sys.backup\_devices.

Для створення пристрою резервного копіювання засобами SSMS необхідно обрати в необхідному сервері, в папці _Server Objects_ або її підпапці _Backup Devices_ пункт контекстного меню New Backup Device… (_Новий пристрій резервного копіювання_).

![Рисунок 4](https://fsx1.itstep.org/api/v1/files/NSkQKLjy8jLKxpZkyCaPUCIeaIerts-p)

Рисунок 4

Після цього в діалоговому вікні Backup Device необхідно вказати ім'я та шлях до створюваного ресурсу.

А тепер розглянемо приклад створення дзеркальних наборів носіїв (media set), яке дозволяє створити кілька додаткових копій даних. Існування кількох резервних копій даних ще більше знижує ризик втрати даних у випадку виходу з ладу одного з пристроїв резервного копіювання. При використанні дзеркального резервного копіювання SQL Server зчитує сторінку з файла даних один раз, після чого створює кілька копій при запису сторінки на пристрій резервного копіювання (диск чи стрічку). Таким чином одна сторінка даних записується одночасно в кожне дзеркало.

Отже, збережемо резервну копію бази даних Press на носії, який складається з двох дисків, а також створимо при цьому два дзеркала резервної копії. При цьому резервна копія зберігається на локальний диск, а дзеркала на мережеві. За допомогою опції FORMAT запишемо також нові заголовки носіїв на всі набори носіїв, перезаписуючи попередні заголовки і форматуючи їх вміст. Відмітимо, що без цієї опції створення дзеркальних наборів неможливо. Це обов'язкова умова при дзеркальному резервному копіювання.

```html
BACKUP DATABASE Press
TO DISK = 'D:\Backups\Press1B.bak',DISK='D:\Backups\Press2B.bak'
MIRROR TO DISK = '\\BackupServer1\Backups\PressMirror1A.bak',
          DISK = '\\BackupServer\Backups\PressMirror1B.bak'
MIRROR TO DISK = '\\BackupServer2\Backups\PressMirror2A.bak',
          DISK = '\\BackupServer\Backups\PressMirror2B.bak'
WITH
    FORMAT, MEDIANAME = 'PressSet'
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Резервне копіювання бази даних можна зробити і засобами SSMS. Для цього, в контекстному меню необхідної бази даних необхідно обрати пункт Tasks->Back Up… В новому діалоговому вікні Back Up Database можна налаштувати майже всі необхідні параметри для здійснення резервного копіювання.

![Рисунок 5](https://fsx1.itstep.org/api/v1/files/SlB9ctk-Q4fwghqKmk3nLkceC8zjyK9t)

Рисунок 5

![Рисунок 6](https://fsx1.itstep.org/api/v1/files/E3aIgPdcLR97KSh4fflYJlWl5nEXH8Zl)

Рисунок 6

![Рисунок 7](https://fsx1.itstep.org/api/v1/files/EWX801Ph2bGfA6UF1WMuZMJSBc_lq6M_)

Рисунок 7

### 2.3. Резервне копіювання журналу транзакцій

Як вже було сказано, резервне копіювання журналу транзакцій (_transaction log_) дозволяє зберегти активний журнал (_active log_). Після цього зберігаються всі наступні транзакції до тих пір, поки не буде виявлена відкрита транзакція.

Резервне копіювання журналу транзакцій можна здійснювати лише для баз даних з моделлю повного відновлення або моделлю відновлення з неповним протоколюванням. Крім того, створення резервної копії журналу транзакцій можливе лише після виконання повного резервного копіювання бази даних.

Для резервного копіювання журналу транзакцій використовується інструкція BACKUP LOG:

```html
BACKUP LOG { база_даних | @змінна_імені_БД }
TO пристрій_резервного_копіювання [ ,...n ] -- див. оператор BACKUP для резервного
                                            -- копіювання бази даних
[ MIRROR TO пристрій_резервного_копіювання [ ,...n ] ]
[ WITH { загальні_опції_WITH | LOG_опції } ]
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Як видно з синтаксису, інструкція BACKUP LOG майже нічим не відрізняється від інструкції BACKUP DATABASE для створення резервної копії бази даних. Основна відмінність полягає в тому, що крім загальних параметрів створення резервної копії, можна вказувати ще ряд параметрів, які відносяться лише до операції резервного копіювання журналу транзакцій. Отже, до LOG параметрів відносять:

-   NORECOVERY | STANDBY = ім'я\_резервного\_файла — cтворюють резервну копію журналу транзакцій і залишають базу даних в стані RESTORING (NORECOVERY) або лише для читання і в стані STANDBY (STANDBY).
    
    Для найбільш ефективного створення резервної копії журналів, при якому не відбувається його урізання і база даних автоматично переходить в стан RESTORING, використовуйте одночасно параметр NORECOVERY з NO\_TRUNCATE.
    
    Використання параметра STANDBY рівносильно параметру BACKUP LOG WITH NORECOVERY, за яким йде RESTORE WITH STANDBY.
    
    При використанні режиму очікування необхідно вказати резервний файл, в якому містяться всі зміни, які пройшли відкат і повинні бути відновлені у випадку необхідності.
-   NO\_TRUNCATE — журнал транзакцій не урізається і резервне копіювання здійснюється не залежно від стану бази даних. В зв'язку з цим, резервна копія може мати неповні метадані. Як правило, даний параметр використовується при пошкодженні бази даних.
    
    Параметр NO\_TRUNCATE рівносильний одночасному використанню COPY\_ONLY і CONTINUE\_AFTER\_ERROR.
-   Варто відмітити, що резервні копії бази даних і журналу транзакційрекомендується зберігати на різних дисках. Це необхідно для забезпечення безпеки резервних копій у випадку пошкодження одного з дисків.

Наведемо невеличкий приклад створення повної резервної копії бази даних та журналу транзакцій. В якості пристроїв резервного копіювання використаємо логічні пристрої.

```html
-- створюємо логічні пристрої резервного копіювання
-- для збереження резервної копії бази даних
exec sp_addumpdevice 'disk', 'PressData', 'D:\Backups\PressData.bak';
go

-- для збереження резервної копії журналу транзакцій
exec sp_addumpdevice 'disk', 'PressLog', 'D:\Backups\PressLog.trn'; -- розширення довільне
go

-- робимо повну резервну копію бази даних
backup database Press
to PressData;
go

-- робимо резервну копію журналу транзакцій
backup log Press
to PressLog;
go
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

### 2.4. Резервне копіювання файлових груп та створення часткової резервної копії

В SQL Server 2008, крім створення повної резервної копії бази даних, існує можливість резервного копіювання окремих файлових груп (_filegroup backup_). Такий підхід дуже корисний, якщо через розмір бази даних її повне збереження або відновлення стає невиправданим.

Оскільки резервне копіювання файлових груп зберігає лише фрагменти бази даних, для його виконання необхідно, щоб для бази даних була встановлена модель повного відновлення або модель відновлення з неповним протоколюванням. Крім того, якщо необхідно відновити файлові групи з копій, зроблених у різний час, для їх согласованості на певний період часу, необхідна наявність журналу транзакцій.

Для резервного копіювання файлових груп бази даних використовується наступна форма інструкції BACKUP DATABASE, яка практично нічим не відрізняється від створення резервної копії бази даних:

```html
BACKUP DATABASE { ім'я_БД | @змінна_імені_БД }
{ FILE = { логічне_ім'я_файлу | @змінна_логічного_імені_файлу }
   FILEGROUP = { логічне_ім'я_файлової_групи | @ змінна_логічного_імені_файлової_групи }
} [ ,...n ]
TO пристрій_резервного_копіювання [ ,...n ] -- див.оператор BACKUP для резервного
                                            -- копіювання бази даних
[ MIRROR TO пристрій_резервного_копіювання [ ,...n ] ]
[ WITH { DIFFERENTIAL  загальні_опції_WITH [ ,...n ] } ]
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Наприклад, створимо різничну резервну копію кожного файла, які розміщуються в двох вторинних файлових групах.

```html
BACKUP DATABASE Press
       FILEGROUP = 'PressFilegroup1',
       FILEGROUP = 'PressFilegroup2'
TO DISK = 'D:\Backups\PressFilegroups.bak'
WITH DIFFERENTIAL
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Та існують випадки, коли в базі даних кілька файлових груп доступні лише для читання. В SQL Server 2008 такі файлові групи не будуть входити в резервну копію бази даних, якщо при її створенні встановити параметр READ\_WRITE\_FILEGROUPS. Але можна вказати і виняток. Для цього після параметра READ\_WRITE\_FILEGROUPS необхідно перелічити необхідні файлові групи для читання, які планується зберегти.

Якщо сама база даних доступна лише для читання, READ\_WRITE\_FILEGROUPS включає в резервну копію лише первинну файлову групу.

Така резервна копія буде частковою резервною копією бази даних і синтаксис її створення приведений нижче.

```html
BACKUP DATABASE { ім'я_БД | @змінна_імені_БД }
READ_WRITE_FILEGROUPS
[ , FILEGROUP = { логічне_ім'я_файлової_групи | 
                 @змінна_логічного_імені_файлової_групи [ ,...n ] ] -- файлова група
                                                                                                                               -- тільки для читання
TO пристрій_резервного_копіювання [ ,...n ] -- див.оператор BACKUP для резервного
                                            -- копіювання бази даних
[ MIRROR TO пристрій_резервного_копіювання [ ,...n ] ]
[ WITH { DIFFERENTIAL  загальні_опції_WITH [ ,...n ] } ]
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Наприклад:

```html
BACKUP DATABASE Press
READ_WRITE_FILEGROUPS
TO DISK = 'D:\Backups\PressRW.bak'
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

## 3\. Відновлення з резервної копії

Процес відновлення бази даних відбувається згідно обраної вами стратегії відновлення, але в більшості випадків вона розпочинається з повного відновлення бази даних, яка відновлює базу даних на певний період часу. Адже повна резервна копія містить всі дані бази. Після цього використовуються часткові (різничні) послідовні резервні копії, які дозволяють привести її до стану на пізніший період.

Сам процес відновлення з резервної копії довготривалий, адже, якщо база даних відновлюється з нуля, операція відновлення спочатку створює для бази даних всі файли і файлові групи, після чого по порядку відновлюються всі сторінки. Тому, радимо при можливості перед відновленням не видаляти базу даних, а перезаписати її.

Відновлення резервної копії виконується за допомогою оператора RESTORE, який дозволяє здійснювати наступні сценарії відновлення:

-   Повне відновлення — відновлює базу даних з повної резервної копії.
-   Часткове відновлення — відновлює частину базу даних з різничної резервної копії.
-   Відновлення файлів — відновлює в базі даних вказані файли або файлові групи.
-   Відновлення сторінок — відновлює вказані сторінки бази даних.
-   Відновлення журналу транзакцій — відновлює журнал транзакцій бази даних.
-   Відновлення по знімку — дозволяє повернути базу даних до моменту створення знімку (_snapshot_) бази даних.

При цьому, якщо відновлення резервних копій журналу транзакцій не потрібне, слід використовувати просту модель відновлення.

Приведемо синтаксис оператора RESTORE для перелічених вище випадків використання

```html
-- для повного відновлення бази даних
RESTORE DATABASE { ім'я_БД | @змінна_імені_БД }
[ FROM пристрій_резервного_копіювання [ ,...n ] ] -- див.оператор BACKUP для 
                                                  -- резервного копіювання БД
[ WITH
   { [ RECOVERY | NORECOVERY | STANDBY = 
     { standby_file_name | @standby_file_name_var } ] -- залишає БД в режимі відновлення,
                                                    -- тобто дозволяється здійснювати 
                                                    -- лише вибірку даних
       |, загальні_опції_WITH [ ,...n ]
       |, KEEP_REPLICATION -- опція_реплікації_WITH
       |, KEEP_CDC -- опції_WITH_відслідковування_змін_даних
       |, опції_WITH_service_broker
       |, опції_WITH_на_заданий_момент_часу
   } [ ,...n ]
]

-- для часткового відновлення бази даних
RESTORE DATABASE { ім'я_БД | @змінна_імені_БД }
{
   FILE = {логічне_ім'я_файлу | @змінна_логічного_імені_файлу}
    | FILEGROUP = {логічне_ім'я_файлової_групи 
    | @змінна_логічного_імені_файлової_групи}
    | READ_WRITE_FILEGROUPS
} [ ,...n ]
[ FROM пристрій_резервного_копіювання [ ,...n ] ]
WITH
      PARTIAL, -- відновити первинну і вказані вторинні файлові групи
      NORECOVERY
      [, загальні_опції_WITH | опції_WITH_на_заданий_момент_часу ] [ ,...n ]

-- для відновлення файлів та файлових груп
RESTORE DATABASE { ім'я_БД | @змінна_імені_БД }
{
    FILE = {логічне_ім'я_файлу | @змінна_логічного_імені_файлу}
     | FILEGROUP = {логічне_ім'я_файлової_групи | @змінна_логічного_імені_файлової_групи}
     | READ_WRITE_FILEGROUPS
    } [ ,...n ]
    [ FROM пристрій_резервного_копіювання [ ,...n ] ]
    WITH { [ RECOVERY | NORECOVERY ]
           [, загальні_опції_WITH [ ,...n ] ]
         } [ ,...n ]

-- для відновлення сторінок бази даних
RESTORE DATABASE { ім'я_БД | @змінна_імені_БД }
PAGE = 'Id_файла:Id_сторінки [ ,...n ]' -- список сторінок для відновлення
                                        -- (максимум 1000 сторінок)
[, { FILE = { логічне_ім'я_файлу | @змінна_логічного_імені_файлу }
   | FILEGROUP = { логічне_ім'я_файлової_групи | @змінна_логічного_імені_файлової_групи}
   | READ_WRITE_FILEGROUPS
   }
] [ ,...n ]
[ FROM пристрій_резервного_копіювання [ ,...n ] ]
  WITH NORECOVERY
     [, загальні_опції_WITH [ ,...n ] ]

-- для відновлення журналів транзакцій
RESTORE LOG { ім'я_БД | @змінна_імені_БД }
[ {FILE = { логічне_ім'я_файлу | @змінна_логічного_імені_файлу }
   | FILEGROUP = { логічне_ім'я_файлової_групи | @змінна_логічного_імені_файлової_групи}
   | READ_WRITE_FILEGROUPS
   | PAGE = 'Id_файла:Id_сторінки [ ,...n ]'
  } [ ,...n ]
]
[ FROM пристрій_резервного_копіювання [ ,...n ] ]
[ WITH 
  { 
    [ RECOVERY | NORECOVERY | STANDBY = {ім'я_standby_файла  
    | @змінна_імені_standby_файла } ]
    | , загальні_опції_WITH [ ,...n ]
    | , KEEP_REPLICATION -- опція_реплікації_WITH
    | , опції_WITH_на_заданий_момент_часу
  } [ ,...n ]
]

-- повернути базу даних на момент створення знімку (snapshot)
RESTORE DATABASE { ім'я_БД | @змінна_імені_БД }
FROM DATA BASE_SNAPSHOT = ім'я_знімка_БД
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Параметр WITH дозволяє задати додаткові необов'язкові параметри відновлення з резервної копії. Ряд загальних параметрів WITH збігається з параметрами WITH для операції BACKUP (див. п.6.2.2. «Резервне копіювання бази даних»). До них відносять:

-   Параметри набору носіїв (_Media Set Options_);
-   Параметри передачі даних (_Data Transfer Options_);
-   Параметри управління помилками (_Error Management Options_);
-   Параметри спостереження (_Monitoring Options_);
-   Параметристрічкових пристроїв (_Tape Options_).

В SQL Server 2008 параметр PARTIAL запускає початковий етап поетапного відновлення, яке дозволяє відкласти відновлення файлових груп, які залишились, тобто не були вказані при відновленні.

Ще кілька загальних параметрів WITH приведено нижче:

-   MOVE 'логічне\_ім'я\_в\_backup' TO 'ім'я\_файла\_з\_шляхом' \[ ,...n \] — вказує на те, що файл даних або журнал транзакцій, який вказаний після MOVE, необхідно відновити з копії і перемістити по адресі, заданій в параметрі TO.
-   REPLACE — якщо при відновленні з резервної копії база даних (або журнал транзакцій) з аналогічним іменем вже існує, тоді необхідно її перезаписати.
    
    Якщо даний параметр не вказаний і при відновленні з резервної копії на сервері вже існує база даних (або журнал транзакцій) з аналогічним іменем, тоді операція відновлення буде відмінена.
-   RESTART — перезапустити перервану операцію відновлення з точки переривання.
-   RESTRICTED\_USER — обмежити доступ до створеної бази даних для членів ролей _db\_owner_, _dbcreator_ і _sysadmin_. Параметр RESTRICTED\_USER являється альтернативою параметра DBO\_ONLY ранніх версій SQL Server.

Крім того, даний параметр слід використовувати з параметром RECOVERY.

#### Параметри резервного набору даних (Backup Set Options)

-   FILE = { номер\_резервного\_набору | @змінна\_номеру\_резервного\_набору} — вказує на резервний набір даних для відновлення. Наприклад, значення 1 вказує на те, що буде використовуватись перший резервний набір даних на носії даних резервних копій, значення 2 вказує на другий набір даних і т.д.
    
    Перелік резервних наборів даних можна отримати за допомогою інструкції RESTORE HEADERONLY. По замовчуванню приймається значення -1.
-   PASSWORD = { 'пароль' | @змінна\_пароля } — пароль на резервний набір даних. В наступній версії SQL Server ця опція буде видалена (!).
    
    Якщо під час створення резервної копії проводилась реплікація бази даних, тоді при відновленні варто вказати параметр реплікації KEEP\_REPLICATION. Він запобігає видаленню параметрів реплікації, якщо резервна копія бази даних або журналу транзакцій відновлюється на сервері «гарячого» резервування і база даних відтворюється. При цьому, забороняється використовувати даний параметр разом з параметром NORECOVERY.
    
    Якщо при створенні резервної копії в базі даних била ввімкнена система відслідковування змін даних, тоді при відновленні слід вказати ключове слово KEEP\_CDC. В такому разі SQL Server запобігає видаленню налаштувань системи відслідковування змін даних. Даний параметр також забороняється використовувати разом з параметром NORECOVERY.
    
    Якщо при створенні резервної копії для бази даних був активований компонент Service Broker, при відновленні ви можете скористатись набором опцій WITH для даного компонента.
-   ENABLE\_BROKER — після закінчення процесу відновлення ввімкнути доставку повідомлень компонента Service Broker. По замовчуванню при відновленні доставка повідомлень вимкнена. При цьому існуючий ідентифікатор компонента Service Broker зберігається в базі даних.
-   ERROR\_BROKER\_CONVERSATIONS — завершує всі діалоги, які знаходяться в стані помилки і були або приєднані до бази даних, або відновлені. Це дозволяє додаткам виконувати регулярне очищення існуючих сеансів зв'язку.
    
    Доставка повідомлень компонента Service Broker до завершення даної операції вимикається, а потім знову вмикається. При цьому існуючий ідентифікатор компонента Service Broker зберігається в базі даних.
-   NEW\_BROKER — назначає базі даних новий ідентифікатор компонента Service Broker. При цьому всі існуючі сеанси зв'язку в базі даних будуть негайно видалені, без видачі діалогових вікон при завершенні. В зв'язку з цим, всі маршрути, які ссилаються на попередній ідентифікатор компонента Service Broker, потрібно перестворити.

**Опції WITH на заданий момент часу**_дозволяють відновити базу даних на певний момент часу або до певної транзакції, вказавши при цьому необхідну точку відновлення в інструкції STOPAT, STOPATMARK або STOPBEFOREMARK._

_Для відновлення на певний момент часу спочатку потрібно відновити повну резервну копію бази даних, кінцева точка якої розміщується раніше цільової точки відновлення. Щоб спростити цей процес, можна ще при створенні резервної копії, в операторі RESTORE DATABASE вказати інструкцію WITH STOPAT, STOPATMARK або STOPBEFOREMARK._

_Параметри WITH на заданий момент часу для інструкцій RESTORE\_DATABASE і RESTORE\_LOG однакові, за виключенням значення параметра STOPATMARK._

-   STOPAT = { 'дата\_і\_час' @змінна\_дати\_і\_часу } — відновити базу даних або журнал транзакцій до вказаного періоду часу. При цьому до бази даних застосовуються лише ті записи журналу транзакцій, які були зроблені до вказаної дати і часу. Тип даних змінної повинен бути varchar, char, smalldatetime або datetime.
    
    **(!)** _Якщо вказаний час назначений після створення останньої резервної копії журналів, база данных залишається у невідновленому стані. Це рівносильно інструкції_ _RESTORE LOG_ _з параметром_ _NORECOVERY__._

Для RESTORE DATABASE:

```html
STOPATMARK = { 'lsn:lsn_номер' } 
[ AFTER 'дата_і_час' ]
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Для RESTORE LOG:

```html
STOPATMARK = { 'точка_транзакції' | 'lsn:lsn_номер' }
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

\[ AFTER 'дата\_і\_час' \] — відновлення до вказаної точки відновлення. Вказана транзакція включається в відновлення, але фіксується лише у випадку, якщо вона була з самого початку зафіксована в ході формування транзакції.

Параметр lsn\_номер визначає реєстраційний номер транзакції в журналі.

Якщо в інструкції RESTORE LOG не заданий параметр AFTER, тоді відновлення відбувається до першої точкизвказаним іменем. Інакше відновлення відбувається до першої точки з вказаним іменем перед або після вказаної дати і часу.

(!) Якщо вказана точка збереження транзакції, номер LSN або час назначені після створення останньої резервної копії журналів, база даних залишається у невідновленому стані. Це рівносильно інструкції RESTORE LOG з параметром NORECOVERY.

Для RESTORE DATABASE:

```html
STOPBEFOREMARK = { 'lsn: lsn_номер' }
[ AFTER 'дата_і_час' ]
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Для RESTORE LOG:

```html
STOPBEFOREMARK = { 'точка_транзакції' | 'lsn:lsn_номер' }
[ AFTER 'дата_і_час' ]
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Відновлення до вказаної точки відновлення. Задана транзакція не включається у відновлення, оскільки після використання параметра WITH RECOVERY відбувається її відкат.

Параметр lsn\_номер визначає реєстраційний номер транзакції в журналі.

Якщо в інструкції RESTORE LOG не заданий параметр AFTER, тоді відновлення відбувається до першої точки з вказаним іменем. Інакше відновлення відбувається до першої точки з вказаним іменем перед або після вказаної дати і часу.

(!) _Відновлення на заданий момент часу не буде виконуватись, якщо послідовність часткового відновлення включає файлові групи FILESTREAM. Але існує можливість примусово продовжити послідовність відновлення. Для цього необхідно вказати параметр CONTINUE\_AFTER\_ERROR разом з параметром STOPAT, STOPATMARK або STOPBEFOREMARK. Це дозволить виконати послідовність часткового відновлення, але файлова група FILESTREAM при цьому не відновиться._

В SQL Server 2008 існує можливість повернути базу даних до зробленого знімка бази даних (_snapshot_). Для цього необхідно задати ім'я необхідного знімка в параметрі DATABASE\_SNAPSHOT при відновленні з резервної копії. Але, слід пам'ятати:

-   аргумент DATABASE\_SNAPSHOT доступний лише для повного відновлення бази даних;
-   при такому відновленні будуть видалені всі повнотекстові каталоги;
-   максимальний розмір знімка бази даних рівний розміру самої бази даних;
-   розширення файла знімка бази даних може використовуватись довільне.

Приведемо кілька прикладів відновлення:

1\. Відновлення бази даних з повної резервної копії:

```html
restore database Press
from disk = 'D:\Backups\Press.bak'

-- якщо після відновлення її потрібно перемістити, тоді використаємо наступний запит:
restore database Press
from disk = 'D:\Backups\Press.bak'
with
move 'Press_Data'
to 'C:\Program Files\Microsoft SQL Server\MSSQL10.MSSQLSERVER\MSSQL\Data\Press.mdf',
move 'Press_Log'
to 'C:\Program Files\Microsoft SQL Server\MSSQL10.MSSQLSERVER\MSSQL\Data\Press.ldf'
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

2\. Створимо знімок бази даних _Press_ з іменем _Press\_sn_, після чого спробуємо здійснити повне відновлення бази даних з зробленого знімка.

Нагадаємо, що наша база даних тепер складається з двох файлів: _Press_ та _PressFile2_. У відповідності до синтаксису, при створенні знімку необхідно вказати кожен файл первинної бази даних. Файлові групи не вказуються.

![Рисунок 8](https://fsx1.itstep.org/api/v1/files/tw-YieMzw-Cc62pd3IGLG-VreenGsqBu)

Рисунок 8

```html
-- синтаксис для створення моментального знімка бази даних
CREATE DATABASE ім'я_знімка_БД
ON

-- список файлів в основній базі даних
( NAME = логічне_ім'я_файла, FILENAME = 'місцерозташування_файла' ) [ ,...n ]
AS SNAPSHOT OF ім'я_основної_БД

-- створюємо знімок бази даних
create database Press_sn
on
( name = Press, filename = 'C:\Program Files\Microsoft SQL Server\
                            MSSQL10.MSSQLSERVER\MSSQL\Data\Pressdat1_sn.ss'),
( name = PressFile2, filename = 'C:\Program Files\Microsoft SQL Server\
                            MSSQL10.MSSQLSERVER\MSSQL\Data\Pressdat2_sn.ss')
as snap shot of Press;
go

-- відновлюємо базу даних з знімку
restore database Press
from database_snapshot = 'Press_sn';
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

3\. Відновимо журнал транзакцій до певної мітки, тобто точки збереження в транзакції PointRestore.

```html
-- відмічаємо транзакцію, до якої буде відновлений журнал транзакцій
begin transaction PointRestore
with mark 'Deleting old books'; -- вказує на те, що транзакція відмічена в журналі
go
delete
from sale.Sales
where ID_BOOK in
    (select ID_BOOK
     from book.Books
     where DATEPART(YEAR, DateOfPublish) &lt; 2000)
go
delete
from book.Books
where DATEPART(YEAR, DateOfPublish) &lt; 2000
go
commit transaction PointRestore;
go

-- здійснюємо резервне копіювання бази даних та журналу транзакцій
use master;
go
backup database Press
to disk = 'D:\Backups\Press.bak'
with init;
go
backup log Press
to disk = 'D:\Backups\PressLog.trn';
go

-- відновлюємо базу даних та журнал тразакцій
restore database Press
from disk = 'D:\Backups\Press.bak'
with norecovery;
go
restore log Press
from disk = 'D:\Backups\Press.bak'
with recovery,
    stopatmark = 'PointRestore';
go
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Засобами SSMS операція відновлення дуже схожа з операцією резервного копіювання. Тобто потрібно перейти до бази даних, яку необхідно відновити, і в її контекстному меню обрати пункт Tasks->Restore, після чого вказати, що саме потребує відновлення: база даних, журнал транзакцій, файли чи файлові групи. Наприклад, для бази даних, вікно Restore буде мати наступний вигляд:

![Рисунок 9](https://fsx1.itstep.org/api/v1/files/wyJxWxOhD4vRPefUwR4eGEnL9LGAOPIu)

Рисунок 9

![Рисунок 10](https://fsx1.itstep.org/api/v1/files/NOriFYP218SAPinb8LHyb835kY-V8DMT)

Рисунок 10

## 4\. Перевірка резервної копії

Вміти створити резервну копію, нажаль, не достатньо. Адже, резервна копія може пошкодитись або ще в процесі створення, або з часом. В такому разі вона буде не придатна для роботи. Отже, ви повинні також знати як перевірити роботоздатність резервної копії. З однієї сторони, тут нічого складного немає: достатньо просто її відновити і перевірити всі дані. Але цей процес може бути довготривалим, а отже непрактичним. SQL Server 2008 має простіший спосіб вирішення даної проблеми — це інструкція RESTORE VERIFYONLY, яка має наступний синтаксис

```html
RESTORE VERIFYONLY
FROM пристрій_резервного_копіювання [ ,...n ] -- див.оператор BACKUP для резервного
                                              -- копіювання БД
[ WITH
{
    LOADHISTORY -- завантажувати дані в журнальні таблиці резервного копіювання і
                -- відновлення БД msdb

    -- Параметри операції відновлення
    | MOVE 'логічне_імя_backup_файла' TO 'місце розташування' [ ,...n ]

    -- Параметри резервного набору даних
    | FILE = { номер_резервного_набору | @змінна_номеру_резервного_набору }
    | PASSWORD = { пароль | @змінна_пароля }

    -- Параметри набору носіїв
    | MEDIANAME = {'ім'я_носія' | @змінна_імені }
    | MEDIAPASSWORD = {'пароль' | @змінна_пароля }

    -- Параметри управління помилками
    | {CHECKSUM | NO_CHECKSUM}
    | {STOP_ON_ERROR | CONTINUE_AFTER_ERROR}

    -- Параметри спостереження
    | STATS [ = відсотковий_інтервал ]

    -- Параметри стрічкових пристроїв
    | {REWIND | NOREWIND}
    | {UNLOAD | NOUNLOAD}
} [ ,...n ]
]
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Щоб впевнитись в тому, що носій не пошкоджений, дана інструкція перевіряє спочатку його заголовок, потім контрольну суму резервної копії. Після цього зчитується внутрішня послідовність сторінок і перераховується контрольна сума резервної копії для порівняння. Також проводяться різноманітні тести для перевірки цілісності резервної копії, але структура її даних при цьому не зачіпається.

## 7\. Домашнє завдання

#### Резервне копіювання та відновлення з резервної копії:

1.  Засобами T-SQL встановіть явно для вашої бази даних модель відновлення з неповним протоколюванням. Після цього створіть та протестуйте стратегію резервного копіювання вашої бази даних, яка включає в себе повне резервне копіюваня, різничне резервне копіювання та резервне копіювання журналу транзакцій. При цьому скористайтесь набором логічних пристроїв резервного копіювання. Після цього перевірте створені резервні копії, відновивши їх.
2.  Створіть та протестуйте стратегію резервного копіювання вашої бази даних, яка включає в себе резервне копіювання файлових груп, різничне резервне копіювання та резервне копіювання журналу транзакцій. Після цього перевірте створені резервні копії, відновивши їх.
3.  Створіть базу даних, яка містить файлові групи лише для читання і для читання та запису. Виконайте резервне копіювання лише файлових груп для читання і запису.
4.  Створіть дзеркальний набір носіїв, який складається з одного диска та чотирьох дзеркал. Після цього напишіть сценарій, який буде здійснювати резервне копіювання бази даних та зберігатись на створеному наборі носіїв.
5.  Написати сценарій, який дозволить відновити базу даних до моменту на 9:00 10 листопада 2010 р. Перевірте чи ваша базаних не пошкоджена і доступна для роботи.
6.  Створіть для бази даних знімок (_snapshot_), після чого внесіть до неї ряд змін. Відновіть базу даних, використовуючи створений раніше знімок і перевірте чи існують в ній внесені зміни.
7.  Змоделюйте ситуацію, в якій необхідно відновити пошкоджену сторінку. Відновіть в базу даних необхідну сторінку.
8.  Припустимо, що у вашій базі даних необхідно провести певне обновлення даних:
    -   збільшити ціну продажу всіх книг, які продаються магазинами Англії, на 15%;
    -   списати ряд книг, шляхом видалення їх з бази даних, а саме книги, тематики «Детективи», оскільки ваше видавництво більше не буде займатись друком та розповсюдженням таких книг.

Розробіть та протестуйте стратегію резервного копіювання вашої бази даних, яка забезпечить у випадку необхідності відновлення з резервної копії бази даних до внесення вищеописаних змін. Після цього перевірте створену резервну копію, відновивши її.

© STEP IT Academy, [itstep.org](https://itstep.org/)

All the copyrighted photos, audio, and video works, fragments of which are used in the material, are the property of their respective owners. Fragments of the works are used for illustrative purposes to the extent justified by the objective, within the educational process, and for educational purposes, in accordance with the Act of “On Copyright and Related Rights”. The scope and method of the cited works are in accordance with the adopted norms, without prejudice to the normal exploitation of copyright, and do not prejudice the legitimate interests of authors and right holders. At the time of use, the cited works fragments cannot be replaced by alternative, non-copyrighted counterparts and meet the criteria for fair use. All rights reserved. Any reproduction of the materials or its part is prohibited. Use of the works or their fragments must be agreed upon with authors and rights holders. Agreed material use is only possible with reference to the source. Responsibility for unauthorized copying and commercial use of the material is determined by the current legislation.