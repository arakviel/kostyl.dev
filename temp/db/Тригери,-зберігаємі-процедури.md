## Тригери, зберігаємі процедури

## 1\. Тригери

Тригер — це спеціалізована процедура, яка автоматично викликається SQL Server при виникненні подій в базі даних. В SQL Server з версії SQL Server 2005 підтримуються два типи тригерів:

1.  **DML-тригери** — виконуються при виникненні DML (_Data Manipulation Language_ — Мова Маніпулювання Даними) подій: додаванні (INSERT), видаленні (DELETE) або обновленні (UPDATE) записів таблиць або представлень. Такі тригери завжди прив'язані до певної таблиці або представлення і можуть перехвачувати дані лише її/його.
2.  **DDL-тригери** — виконуються при виникненні DDL (_Data Definition Language_ — Мова Визначення Даних) подій: створення (CREATE), зміна (ALTER) або видалення (DROP) об'єктів. Окрему підгрупу утворюють тригери входу, які спрацьовують на подію LOGON, яка виникає при встановленні сеансу користовувача. DDL-тригери використовуються для адміністрування бази даних, наприклад, для аудиту і управління доступом до об'єкта.

Тригери можуть бути створені як за допомогою інструкцій Transact-SQL, так і за допомогою методів збірок, створених в середовищі CLR платформи .NET Framework та передані екземпляру SQL Server.Всі тригери не мають параметрів і не виконуються явно. При виникненні події, до якої прив'язаний тригер, SQL Server автоматично його запускає.

Отже, розпочнемо наше знайомство, а почнемо ми з DML-тригерів. Синтаксис створення такого тригера має наступний вигляд:

```html
CREATE TRIGGER [схема.] ім'я_тригера
    ON { таблиця представлення } -- для кого створюється тригер
    [ WITH ENCRYPTION            -- зашифрувати вхідний код тригера
        [, EXECUTE AS умова ]    -- контекст виконання
    ]
{ FOR  AFTER           -- після зміни даних
       INSTEAD OF }    -- замість SQL команди, для якої вони оголошені
{ [ INSERT ] [ , ] [ UPDATE ] [ , ] [ DELETE ] } -- на яку дію з даними
[ WITH APPEND ]         -- додати тригер існуючого типу
[ NOT FOR REPLICATION ] -- тригер не виконається, якщо в ході реплікації буде змінена
                        -- таблиця, на яку він вказує
AS
    { тіло_тригера  EXTERNAL NAME збірка.клас.метод}
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Після вказання імені тригера в інструкції ON необхідно вказати назву таблиці або представлення, для якого створюється тригер.

За допомогою інструкції WITH можна ввімкнути шифрування коду тригера (ENCRIPTION) або вказати контекст виконання (EXECUTE AS), в якому буде працювати тригер. Параметр EXECUTE AS в основному використовується для перевірки привілеїв (прав доступу) на об'єкти бази даних, на які ссилається тригер.

Як видно з синтаксису, DML-тригери можна запускати в двох режимах: AFTER та INSTEAD OF. Тригера BEFORE, який наявний в багатьох СУБД, в MS SQL Server не існує.

Тригер INSTEAD OF може породжувати подію (команду), для якої він оголошений. Причому ця подія буде виконуватись так, ніби тригера INSTEAD OF не існувало. Наприклад, якщо ви хочете перевірити певну умову до виконання команди INSERT, ви можете оголосити тригер INSTEAD OF INSERT. Тригер INSTEAD OF буде виконувати перевірку, а потім виконувати команду INSERT для таблиці. Оператор INSERT буде виконуватись звичним чином, не породжуючи рекурсивних викликів тригера INSTEAD OF.

Слід також пам'ятати, що по замовчуванню всі тригери активні та виконуються після здійсненої дії, тобто мають встановлений параметр AFTER.

Зауваження щодо побудови тригерів:

1.  Якщо при оголошенні тригера, вказати єдине ключове слово FOR, то аргумент AFTER використовується по замовчуванню.
2.  Не можна створювати тригери INSTEAD OF для модифікованих представлень.
3.  Тригери AFTER використовуються лише для таблиць.
4.  Параметр WITH ENCRYPTION не може бути вказаний для тригерів CLR.
5.  Аргумент WITH APPEND встановлений лише для сумісності з попередніми версіями (на рівні 65). При цьому він може використовуватись лише при вказанні параметра FOR без INSTEAD OF і не може вказуватись для тригерів CLR. В зв'язку з тим, що в наступній версії SQL Server аргумент WITH APPEND планується повністю вилучити, рекомендується його уникати.

Існує також ряд правил, яких слід дотримуватись при створенні тригерів:

-   НЕ МОЖНА створювати тригери для тимчасових таблиць, але вони можуть звертатись до них;
-   НЕ МОЖНА створювати, змінювати, видаляти резервні копії або відновлювати з резервної копії бази даних;
-   тригери можуть використовувати для забезпечення цілісності даних, але їх не слід використовувати замість оголошення цілісності шляхом встановлення обмеження FOREIGN KEY;
-   тригери не можуть повертати результуючі набори, тому при використанні оператора select в тілі тригера слід бути дуже уважним. При цьому в багатьох випадках, разом з оператором select використовується директива IF EXISTS;
-   підтримуються рекурсивні AFTER тригери, за умови встановлення параметра бази даних RECURSIVE\_TRIGGERS в значення ON;
-   можна створювати вкладені тригери (підтримується до 32 рівнів вкладеності), які фактично являються неявною рекурсією. Для їх підтримки необхідно встановити параметр NESTED TRIGGERS;
-   в тілі DML-тригера НЕ МОЖНА використовувати оператори:
    -   всі операції CREATE/ALTER/DROP;
    -   TRUNCATE TABLE;
    -   RECONFIGURE;
    -   LOAD DATABASE або TRANSACTION;
    -   GRANT і REVOKE;
    -   SELECT INTO;
    -   UPDATE STATISTICS.

Тригери також являються об'єктами БД і в SQL Management Studio вони розміщуються в папці «_Triggers_» таблиці, на яку встановлений той чи інший тригер. Наприклад:

![Рисунок 1](https://fsx1.itstep.org/api/v1/files/FnxcivF5DK05GlBD1bzALlJDPcLL8mqw)

Рисунок 1

В MS SQL Server в межах DML-тригерів використовують довідкові таблиці INSERTED і DELETED, які мають ту ж структуру, що і базові таблиці тригера. Вони розміщуються в оперативній пам'яті, оскільки являються логічними таблицями. Працюють вони наступним чином:

-   Коли в базову таблицю додаються нові дані (новий запис), то ці ж дані додаються спочатку в базову таблицю, а потім в таблицю inserted. Їх наявність в таблиці inserted позбавляє необхідності створювати спеціальні змінні для доступу до цієї інформації.
-   Коли рядок видаляється з таблиці, то він записується в таблицю deleted, а потім видаляється з базової таблиці.
-   Коли рядок обновлюється, то старе значення запису записується в таблицю deleted і видаляється з базової таблиці, потім обновлений запис записується в базову таблицю, а далі в таблицю inserted.

Тобто ми можемо використовувати таблицю DELETED для отримання значень записів, які видаляються з таблиці, а таблицю INSERTED для отримання нових записів перед їх фактичною вставкою. В інших серверних СУБД такі задачі виконують схожі механізми, наприклад, в InterBase/Firebird та Oracle — це контекстні змінні OLD і NEW.

Для кращого розуміння роботи з тригерами напишемо кілька прикладів.

1\. Класичний тригер, який буде спрацьовувати при кожній вставці даних в таблицю Authors і повертає повідомлення про кількість змінених рядків. В цій нелегкій на перший погляд справі нам допоможе глобальна змінна @@rowcount, що містить дані про кількість модифікованих рядків, в результаті роботи тригера.

```html
create trigger addAuthor
on book.Authors
for insert, update
as
    raiserror('%d рядків було додано або модифіковано', 0, 1, @@rowcount)
    return
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Додаємо нового автора в нашу БД:

```html
insert into book.Authors(FirstName, LastName, id_country)
    values('Artur', 'Liliput', 1)
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 2](https://fsx1.itstep.org/api/v1/files/Y4i7rI5mreinxiQZYrZWoZhaKFl_hWyH)

Рисунок 2

2\. Тригер, який при додаванні нових даних про книгу, дата видавництва якої більше місяця, буде викидати повідомлення про помилку.

```html
create trigger CheckDateTrigger
on book.Books
for insert
as
begin
    declare @InsDate smalldatetime

-- отримуємо дату видавництва книги, яка додається
    select @InsDate = DateOfPublish
    from inserted

-- перевіряємо скільки пройшло днів з дня її видання
    if(@InsDate &lt;=getdate()-30)
    begin
        raiserror('Це стара книга і дані про неї додані не будуть',0,1)
        rollback transaction
    end
    else
        PRINT('Дані додані успішно')
End
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Додамо нову книгу:

```html
insertinto book.Books(NameBook, id_theme, id_author, Price, DrawingOfBook,
                      DateOfPublish, Pages)
values('Адміністрування MS SQL Server 2005', 21, 1, 125.0, 3500,'2007.09.01', 726)
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 3](https://fsx1.itstep.org/api/v1/files/yPTw40AFmQUH8eTSdZD9EWYx4PKlXW6S)

Рисунок 3

3\. Тригер, що забороняє видалення книги, якщо вона найбільше продається, тобто є лідером продаж.

```html
create trigger CheckBookDelete
on book.Books
for delete
as
begin
    declare @NameBook varchar(25), @BestBook varchar(25)

-- Отримуємо назву видаляємої книги
    select @NameBook = deleted.NameBook
    from deleted
    declare @Zvit table(nameB varchar(25), quantity int)

-- Отримуємо інформацію про назви книг та їх кількості продажу (популярність)
    insert @Zvit
        select b.NameBook, count(s.id_book)
        from book.Books b, sale.Sales s
        where b.id_book = s.id_book
        groupby b.NameBook

-- знаходимо саму продаваєму книгу
    select @BestBook = z.nameB
    from @Zvit z
    where z.quantity = (select max(quantity)
                          from @Zvit)

-- перевіряємо чи назви співпали
    if(@BestBook = @NameBook)
    begin
        raiserror('Ви не можете видалити дану книгу', 0, 1)
        rollback transaction
    end
    else
    begin
        print('Книга видалена успішно')
    end
end
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

4\. Тригер, який при видаленні книги тематики «Програмування» викидає повідомлення про помилку.

```html
create trigger NotProgrammingDelete
on book.Books
instead of delete
as
begin
    declare @ProgID int

-- отримуємо ідентифікатор тематики "Програмування"
    select @ProgID = id_theme
    from book.Themes
    where NameTheme = 'Програмування'

-- перевіряємо чи співпадають ідентифікатори в книгах тематики, які видаляються
    if exists(select*
              from deleted
              where id_theme = @ProgID)
    raiserror('Книгу не можна видалити, 0, 1)
end
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Як вже було сказано вище, для DDL-операцій, таких як CREATE, ALTER, DROP, GRANT, DENY, REVOKE та UPDATE STATISTICS, використовуються DDL-тригери. Крім контролю і моніторингу даних операцій, DDL-тригери дозволяють обмежувати їх виконання, навіть якщо користувач має відповідні права. Наприклад, можна заборонити користувачам певних груп змінювати і видаляти таблиці. Для цього достатньо створити DDL-тригер для подій DROP TABLE та ALTER TABLE, який буде робити відкат цих операцій та видавати відповідне повідомлення про помилку.

Синтаксис створення DDL-тригера має наступний вигляд:

```html
CREATE TRIGGER ім'я_тригера
    ON { ALL SERVER  DATABASE } -- область дії тригера
    [ WITH ENCRYPTION [, EXECUTE AS умова ] ]
{ FOR  AFTER } { ім'я_події  група_подій } [ ,...n ]
AS
{ тіло_тригера  EXTERNAL NAME збірка.клас.метод}
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Як видно з синтаксису, після інструкції ON необхідно вказати область дії тригера:

-   ALL SERVER — поточний сервер. Тригер буде спрацьовувати при виникненні визначених подій в будь-якому місці в рамках поточного сервера. Наприклад, CREATE\_DATABASE, ALTER\_LOGIN, ALTER\_INSTANCE тощо.
-   DATABASE — поточна база даних. Тригер буде спрацьовувати при виникненні визначених подій на рівні поточної бази даних або нижчих рівнях. Наприклад, CREATE\_TABLE, DROP\_DEFAULT, ALTER\_USER тощо.

Для зручності адміністрування можна використовувати групи подій, наприклад, група подій DDL\_TABLE\_EVENTS включає в себе події, які стосуються таблиці: CREATE\_TABLE, ALTER\_TABLE і DROP\_TABLE. Групи подій мають ієрархічну структуру. Наприклад, група подій DDL\_TABLE\_VIEW\_EVENTS охоплює всі інструкції T-SQL в групах DDL\_TABLE\_EVENTS, DDL\_VIEW\_EVENTS, DDL\_INDEX\_EVENTS та DDL\_STATISTICS\_EVENTS.

Детальний список назв подій приведений в розділі «DDL-події» електронної документації по SQL Server 2008, а груп подій у розділі «Групи DDL-подій».

Проілюструємо код вищенаведеного прикладу використання DDL-тригера, тобто на заборону зміни і видалення таблиць:

```html
create trigger NotAlterDropTable
on DATABASE
for DROP_TABLE, ALTER_TABLE
as
begin
    print 'Модифікація та видалення таблиць заборонені. Зверніться до адміністратора.'
    rollback
end
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Варто відмітити, що DDL-тригери не викликаються на подій, які впливають на тимчасові таблиці і зберігаємі процедури. DDL-тригери також не обмежені областю схеми і після створення тригери рівня бази даних знаходяться в папці «_Programmability/Database Triggers_», а тригери рівня сервера — в папці «Triggers» папки «_Server Objects_» (об'єкти сервера).

![Рисунок 4](https://fsx1.itstep.org/api/v1/files/88k1yg0IVopIYuvnUWVTt8Jxy7WmHMVV)

Рисунок 4

Окрему підгрупу DDL-тригерів становлять тригери входу (logon trigger):

```html
CREATE TRIGGER ім'я_тригера
    ON ALL SERVER
    [ WITH ENCRYPTION [, EXECUTE AS умова ] ]
{ FOR  AFTER } LOGON
AS
{ тіло_тригера  EXTERNAL NAME збірка.клас.метод }
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Такі тригери виконуються у відповідь на подію LOGON, яка викликається при встановленні користувацького сеансу з екземпляром сервера. Тригери входу спрацьовують після завершення етапу аутентифікації при вході, але перед тим, як сеанс користувача реально встановлюється. Отже, всі повідомлення про помилку функції raiserror або інструкції PRINT, які викликаються в тригері, перенаправляються в журнал помилок SQL Server. Якщо ж користувач ввів невірний логін чи пароль, то тригер входу не спрацьовує.

Відмітимо, що в тригерах входу не підтримуються розприділені транзакції. Тригери входу можуть створюватись з будь-якої бази даних, але належать вони базі даних master.

В наступному прикладі заборонимо користувачу з логіном 'vasja\_pupkin' підключення до SQL Server.

```html
use master;
go
create trigger TriggerConnection
on ALL SERVER
with execute as 'vasja_pupkin'
for logon
as
begin
    if ORIGINAL_LOGIN() = 'vasja_pupkin'
    begin
        print 'Такий логін заборонений на сервері. Зверніться до адміністратора.'
        rollback
    end
end
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Тригери можна змінювати, тимчасово відключити або видалити.

Модифікувати тригер можна за допомогою інструкції ALTER TRIGGER:

```html
-- для DML-тригера
ALTER TRIGGER [схема.] ім'я_тригера
    ON { таблиця  представлення }
    [ WITH ENCRYPTION [, EXECUTE AS умова ] ]
{ FOR  AFTER  INSTEAD OF }
{ [ INSERT ] [ , ] [ UPDATE ] [ , ] [ DELETE ] }
[ NOT FOR REPLICATION ]
AS
{ тіло_тригера  EXTERNAL NAME збірка.клас.метод}

-- для DDL-тригера
ALTER TRIGGER ім'я_тригера
    ON { ALL SERVER  DATABASE }
    [ WITH ENCRYPTION [, EXECUTE AS умова ] ]
{ FOR  AFTER } { ім'я_події  група_подій } [ ,...n ]
AS
{ тіло_тригера  EXTERNAL NAME збірка.клас.метод}

-- для тригера входу
ALTER TRIGGER ім'я_тригера
    ON ALL SERVER
    [ WITH ENCRYPTION [, EXECUTE AS умова ] ]
{ FOR  AFTER } LOGON
AS
    { тіло_тригера  EXTERNAL NAME збірка.клас.метод}
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Відключити або включити тригер можна за допомогою інструкції ALTER TABLE або за допомогою наступних інструкцій:

```html
-- включити тригер
ENABLE TRIGGER{ [ схема. ] ім'я_тригера [ ,...n ]  ALL}
ON { таблиця  представлення  DATABASE  ALL SERVER}

-- вимкнути тригер
DISABLE TRIGGER{ [ схема. ] ім'я_тригера [ ,...n ]  ALL}
ON { таблиця  представлення  DATABASE  ALL SERVER}
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Опція ALL вказує на те, що всі тригери в області дії значення параметра ON будуть включені або вимкнені.

Опції DATABASE та ALL SERVER вказує на те, що інструкція стосується DDL-тригера рівня бази даних або сервера (включаючи тригер входу) відповідно.

Видалення тригера здійснюється оператором DROP TRIGGER:

```html
-- для DML-тригера
DROP TRIGGER [схема.] ім'я_тригера [ ,...n ] [ ; ]

-- для DDL-тригера
DROP TRIGGER ім'я_тригера [ ,...n ]
ON {DATABASE  ALL SERVER}

-- для тригера входу
DROP TRIGGER ім'я_тригера [ ,...n ]
   ON ALL SERVER
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Імена всіх тригерів зберігаються в системній таблиці sysobjects та системному представленні sys.objects. Метадані DDL- та DML-тригерів рівня бази даних можна переглянути за допомогою нового представлення sys.triggers. Якщо поле parent\_class\_desc даного представлення має значення «DATABASE», тоді це DDL-тригер і його областю дії є база даних. Тіло тригера можна отримати з представлення sys.sql\_modules (зв'язавши його з sys.triggers по полю object\_id), а код створення — з системної таблиці syscomments. Метадані CLR-тригерів доступні з представлення sys.assembly\_modules, яке також слід зв'язати з sys.triggers по полю.

Інформація про DDL-тригери рівня сервера, включаючи тригери входу зберігається в системному представленні sys.server\_triggers. Тіло тригера рівня сервера можна отримати з представлення sys.server\_sql\_modules, а метадані CLR-тригера серверного рівня — з представлення sys.server\_assembly\_modules.

На завершення відмітимо, що SQL Server надає інформацію про події, які він відловлює, у вигляді XML. Вони доступні через нову вбудовану функцію EVENTDATA(), яка повертає XML-дані. Ця можливість дозволяє застосовувати DDL-тригери для аудиту DDL-операцій в базі даних.

Для цього, наприклад, можна створити таблицю аудиту з полем, яке містить XML-дані. Потім створюємо DDL-тригер з параметром EXECUTE AS SELF для DDL-подій або груп подій, які вас цікавлять. Тіло такого DDL-тригера може просто виконувати вставку (INSERT) XML-даних, які повертаються EVENTDATA(), в таблицю аудиту.

## 2\. Поняття Transact-SQL та його розширення

**Transact-SQL (T-SQL)** — це розширення мови запитів ANSI SQL, який був розроблений компаніями Microsoft (для Microsoft SQL Server) і Sybase (для Sybase ASE). Одним з основних призначень мови T-SQL — дозволити розробникам баз даних з легкістю створювати запити, повертаючи при цьому дані множиною способів.

Стандарт ANSI SQL був розширений набором елементів та операторів, які часто використовуються в тригерах, транзакціях, зберігаємих процедурах та функціях. Розглянемо ряд розширень мови T-SQL:

1\. Оператори BEGIN..END, які обмежують кілька операторів певного блоку.

2\. Змінні, які служать для збереження довільних даних. Для того, щоб створити змінну, потрібно її задекларувати:

```html
declare{@імя_локальної_змінної  @@імя_глобальної_змінної} [ AS ] тип [ = value ]
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Як видно з синтаксису при створенні змінної її можна проініціалізувати певним значенням. Присвоїти ж значення вже створеній змінній можна двома способами: за допомогою оператора select та за допомогою оператора set:

```html
-- ініціалізація змінної
declare @find varchar(10) = 'Boo%';

-- присвоєння значення за допомогою оператора select
select змінна1 = значення1 [, зміннаN = значенняN ]

-- наприклад
declare @var int, @a char(5)
select @var = 5, @a = 'Hello'

-- присвоєння значення за допомогою оператора set
set змінна = значення

-- наприклад
declare @var int, @a char(5)
set @var = 5
set @a = 'Hello'
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Самий простий спосіб виведення значення з змінної - це скористатись допомогою вже знайомого оператора select, який має здатність виводити літерали та значення переданих полів.

```html
select 'Значення змінної @var = '+convert(char(10), @var)
select 'Рядок: ' + @a + ' '+convert(char(10), @var)
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 5](https://fsx1.itstep.org/api/v1/files/_aOVU3C1RD3jEH3mCevew7usq6L4ST9k)

Рисунок 5

За допомогою T-SQL можна створювати також змінні табличного типу. Для прикладу створимо табличну змінну @MyTable та заповнимо її значеннями з таблиці Books.

```html
-- створюємо змінну табличного типу
declare @MyTable table( Id int NOT NULL,
                        number int);

-- заповнюємо змінну даними
insert @MyTable
       select top (5) ID_BOOK, Pages
       from book.Books

-- виводимо на екран дані з змінної типу таблиці
select Id, number
from @MyTable;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 6](https://fsx1.itstep.org/api/v1/files/fPULjCkQGk88teGDsG2XqUT5_udR3Ly9)

Рисунок 6

3\. Оператор PRINT дозволяє вивести рядок в форматі ASCII, змінну символьного типу або вираз, результатом якого також є рядок. Синтаксис оператора має наступний вигляд:

```html
PRINT{'рядок_ASCII' @локальна_рядкова_змінна вираз_який_повертає_рядок }
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Наприклад:

```html
PRINT 'Hello World'
DECLARE @msg nvarchar(50);
SET @msg = N'Сьогодні ' + CAST(GETDATE() AS nvarchar(30)) + N'.';
PRINT @msg;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 7](https://fsx1.itstep.org/api/v1/files/aussQuDe2Yjw8dlma6Huii_FViCFiK2E)

Рисунок 7

Слід відмітити, що в даному операторі не можна використовувати оператор конкатенації, а тому він не підходить для виведення форматованого рядка. Щоб вийти з такої ситуації, слід зберегти відформатований рядок в змінній, а тоді вивести її за допомогою оператора PRINT.

4\. Функція Raiserror виводить повідомлення про помилку. Це повідомлення являється рядком (не більше 2 047 символів), а тому його можна відформатувати довільним чином. Синтаксис функції Raiserror дуже схожий на синтаксис функції printf бібліотеки мови С і виглядає так:

```html
Raiserror( { 'рядок_з_специфікаторами'  ідентифікатор_помилки  @змінна },
              ступінь_важливості_помилки,
              стан_помилки_на_момент_виклику,
              підставляємі_змінні);
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

В якості першого параметра може використовуватись:

-   **Рядок**, який містить повідомлення про помилку у відформатованому вигляді;
-   **Змінна**, яка повинна мати тип char або varchar, і містити відформатований рядок про помилку;
-   **Номер** (ідентифікатор) повідомлення про помилку, який визначений користувачем і збережений в системному представленні sys.messages за допомогою процедури sp\_addmessage. Номер користувацького повідомлення повинен бути більше 50 000.

Рядок з повідомленням про помилку для форматування може містити специфікації перетворення наступного формату:

```html
% [[flag] [width] [. precision] [{h l}]] type
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

-   flag — це код, який дозволяє визначити вирівнювання або проміжок підставляємого значення (\-, +, 0, #, '').
-   width — мінімальна ширина поля, в яке поміщається значення аргумента. Символ (\*) означає, що ширина визначається одним з аргументів в функції raiserror.
-   precision — точність (максимальна кількість символів рядка). Символ (\*) означає, що точність визначається одним з аргументів в функції raiserror.
-   type
    -   type
    -   %d або %і — ціле число з знаком (_signed int_);
    -   %s — рядок символів (_string_);
    -   %u — беззнакове ціле (_unsigned int_);
    -   %o — беззнакове число в вісімковій системі числення (_unsigned octal_);
    -   %x або %X — беззнакове число в 16-значній системі числення (_unsigned hexdecimal_);
    -   Дійсні числа не підтримуються.

Другий параметр — це ступінь важливості помилки, який вказується в межах від 0 до 25.

-   Від 0 до 18 — можуть вказуватись користувачами.
-   Від 19 до 25 — критичні помилки, які можуть вказувати лише члени серверної ролі sysadmin і користувачами з правами ALTER TRACE.

Вважається, що помилки від 20 до 25 неможливо усунути. У випадку таких помилок з'єднання клієнта з сервером розривається і реєструється повідомлення про помилку в журналах додатку та помилок.

**Стан помилки на момент виклик**у повинно бути цілим числом в діапазоні від 0 до 255. По замовчуванню це значення рівне 1. Якщо одна і та ж користувацька помилка виникає в кількох місцях, то за допомогою цього унікального значення для кожного місцярозташування можна визначити, де була згенерована помилка.

**Підставляємі змінн****і** — це змінні, які повинні бути підставлені на місці специфікаторів.

Наприклад:

```html
RAISERROR (N'This is message %s %d.', 10, 1, /*аргументи: */ 'number', 5);
go
RAISERROR (N'&lt;&lt;%*.*s&gt;&gt;', 10, 1,
           7,-- перший аргумент використовується для ширини поля
           3,-- другий аргумент використовується для точності (кількість символів)
           N'abcde');-- третій аргумент - сам рядок
go
RAISERROR ('&lt;&lt;%7.3s&gt;&gt;', 10, 1, 'abcde');
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 8](https://fsx1.itstep.org/api/v1/files/ToWm6gxUe6BP81MtJkaSTznfoctr3el9)

Рисунок 8

І ще маленький приклад коду, в якому ми спробуємо скористатись власним номером помилки. Повідомлення, якому ми хочемо присвоїти номер, слід додати в системне представлення sys.messages за допомогою системної зберігаємої процедури sp\_addmessage:

```html
sp_addmessage @msgnum = 50005, @severity = 10, @msgtext = '"%7.3s"';
go
RAISERROR (50005, -- ідентифікатор повідомлення
           10, 1, 'Hello');
go
sp_dropmessage @msgnum = 50005;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 9](https://fsx1.itstep.org/api/v1/files/AKoBCPVFjD_MdXyXS8zypaTL_L2rvAXd)

Рисунок 9

5\. Умовний оператор if..else, який використовується для перевірки умови та має наступний синтаксис:

```html
if [(]булевий_вираз[)]
    дія
[else [булевий_вираз]
    дія
]
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Наприклад, нам необхідно визначити поточний день тиждня. Якщо день тиждня «Понеділок», тоді виводимо на екран значення «Поточний день тижня», інакше вказати на невірний результат.

```html
if (datename (dw, GetDate())) = 'Monday'
begin
    PRINT 'Сьогодні понеділок'
end
else
    PRINT 'Сьогодні не понеділок'
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 10](https://fsx1.itstep.org/api/v1/files/7wyJIdM_1jTToo7_ZO5EAnkV0j7vqAE0)

Рисунок 10

Для отримання назви тижня ми скористались функцією datename:

```html
DATENAME (datepart, date )
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Параметр datepart вказує на те, що саме ви хочете отримати з дати:

**Таблиця 1**

**Datepart**

**Абревіатура**

**Datepart**

**Абревіатура**

year

yy, yyyy

weekday

dw

quarter

qq, q

hour

hh

month

mm, m

minute

mi, n

dayofyear

dy, y

second

ss, s

day

dd, d

millisecond

ms

week

wk, ww

Булевий вираз біля if може містити оператор SELECT, який потрібно ОБОВ'ЯЗКОВО заключити в дужки. Якщо SELECT повертає одне значення, тоді його можна використати для порівняння з іншим значенням і побудовою булевого умовного виразу. Наприклад, визначимо ціну книг і, якщо отримана ціна буде більше 50 грн., тоді виведемо відповідне повідомлення:

```html
if(selectavg(price)
    from book.Books)&gt; 50
begin
    PRINT 'Існують книги, середня ціна яких більше 50 грн.'
End
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 11](https://fsx1.itstep.org/api/v1/files/s6RyNv5RkCA02A69BPGlPFR-aasDm6-5)

Рисунок 11

Якщо SELECT повертає більше одного значення, то в умовному виразі if використовується ключове слово EXISTS, який повертає true, якщо SELECT повернув хоча б один запис, інакше — false. Синтаксис оператора if разом з exists буде мати наступний вигляд:

```html
if exists (оператор SELECT)
    дія
[else [булевий_вираз]
    дія
]
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Наприклад, виведемо всю інформацію при кожну книгу, дата видавництва якої знаходиться в проміжку від 01.01.2006 до сьогоднішнього дня:

```html
if exists (select*
           from book.Books
           where DateOfPublish between '2006.01.01' and current_timestamp)
begin
    PRINT 'Інформація про книги'
    select*
    from book.Books
    where DateOfPublish between '01.01.2006' and current_timestamp
    return
end
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 12](https://fsx1.itstep.org/api/v1/files/NMIiAlu47yjJv9l2Tw3sZXHsf9C_vKHX)

Рисунок 12

6\. Оператор розгалуження CASE, який дозволить повернути різні значення в залежності від певного контролюючого значення або умови. Оператори, які включають в себе структуру CASE, можуть використовувати одну з двух синтаксичних форм, в залежності від того, чи буде змінюватись оцінюваний вираз:

-   Проста, в якій результуюче значення повертається лише у випадку, якщо вираз після WHEN логічно рівний вказаному значенню. Ви можете використовувати довільну кількість інструкцій WHEN. Інструкція ELSE необов'язкова і виконується лише, якщо всі інструкції WHEN оцінюються як FALSE.

```html
case умовний_вираз
when вираз_константа1 then результуюче_значення1
when вираз_константа2 then результуюче_значення2
[,... n]
[else результуюче_значенняN]
End
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

-   З пошуком. В цій формі CASE можна вказати умовний вираз при кожній інструкції WHEN.

```html
case
when умовний_вираз1 then результуюче значення1
when умовний_вираз2 then результуюче значення2
[,... n]
[else результуюче_значенняN]
End
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

**Примітка!** _В SQL Server CASE являється функцією, а не командою. В зв'язку з цим CASE може використовуватись лише як частина оператора SELECT або UPDATE, на відміну від оператора IF, який працює самостійно._

А тепер напишемо кілька прикладів:

-   Напишемо запит, який буде виводити на екран назву книги та її тематику в розширеному вигляді:

```html
select 'Назва книги' = b.NameBook,
       'Тематика' = case t.NameTheme
                      when 'C &amp; C++' then 'ТематикаС &amp; C++'
                      when 'WEB' then 'Все про Web'
                      else 'Невідома тематика'
                      end
from book.Books b, book.Themes t
where b.id_theme = t.id_theme
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 13](https://fsx1.itstep.org/api/v1/files/U9W7CA0g2gzG2nqprRY0MR3ZHEVer5yA)

Рисунок 13

-   Запит, в якому потрібно перевірити ціну книги. В результуючий запит повертається значення, яке відповідає першій умові true:

```html
select 'Назва книги' = b.NameBook,
       'Ціна книги' = case
                        when price &lt; 100 then'Ціна &lt; 100'
                        when price between 100 and 500 then'Ціна в діапазоні 100..500'
                        else 'Ціна &gt; 500' 
                        end
from book.Books b
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 14](https://fsx1.itstep.org/api/v1/files/qrdykNz9XQf4z_N7g-o3rsbzGBAIrVH3)

Рисунок 14

Інколи виникає ситуація, коли необхідно використати оператор CASE для перевірки на IS NOT NULL. В результаті структура case набуває вигляду:

```html
case
when значення1 IS NOT NULL then вираз1
when значення2 IS NOT NULL then вираз2
[,... n]
[else результуюче_значенняN]
End
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

У такому випадку рекумендується використовувати функцію COALESCE, яка служить для отримання значень не рівних NULL.

Наприклад, в таблиці Books замість одного поля ціни в нас існує два поля: оптова та роздрібна ціна. Нам необхідно взнати вартість кожної книги:

```html
-- з оператором case
select 'Назва книги' = NameBook,
       'Вартість' = case
                  when TradePrice IS NOT NULL then TradePrice * Quantity
                  when RetailPrice IS NOT NULL then RetailPrice * Quantity
                  end
from book.Books;

-- з використанням функції coalesce
select 'Назва книги' = NameBook,
       'Вартість' = coalesce(TradePrice * Quantity, RetailPrice * Quantity)
from book.Books;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Йдемо далі. Оператор case може повернути NULL, якщо порівнювані вирази являються однаковими, інакше він повертає перше значення. У такому випадку структура даного оператора набуває наступного вигляду:

```html
case
when значення1 = значенняХ then NULL
when значення2 = значенняY then NULL
[,... n]
[else результуюче_значенняN]
End
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Щоб спростити роботу слід скористатись функцією NULLIF. Припустимо, що нам необхідно вивести на екран назви книг та їх тираж. Якщо значення тиражу відсутнє (тобто рівне нулю), тоді виводимо NULL.

```html
-- з оператором case
select 'Книги' = NameBook,
       'Тираж' = case
                 when DrawingOfBook = 0 then NULL
                 else DrawingOfBook
                 end
from book.Books;

-- з використанням функції nullif
select 'Книги' = NameBook, 'Тираж' = NULLIF(DrawingOfBook, 0)
from book.Books;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 15](https://fsx1.itstep.org/api/v1/files/r6ieRalwXIv-81q8FR2M6Lo75Id2Qdzi)

Рисунок 15

А тепер підрахуємо скільки книг мають значення тиражу.

```html
select 'Кількість книг без тиражу' = count (NULLIF(DrawingOfBook, 0))
from book.Books;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 16](https://fsx1.itstep.org/api/v1/files/z7eVghz8EKQt3zFHxyd8pFfT9MB0i_15)

Рисунок 16

7\. Оператор безумовного переходу GOTO. Даний оператор передає виконання оператору, який йде після мітки, що на нього вказує. В SQL Server мітки являються невиконуваними операторами та мають наступний синтаксис:

```html
ім'я_мітки:
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Сама команда GOTO має простий синтаксис:

```html
GOTO імя_мітки
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

GOTO як завжди являється небажаною для використання командою, оскільки код з його застосуванням стає важким для сприйняття і аналізу. Напишемо приклад використання оператора GOTO для обробки помилок.

```html
PRINT 'Дія виконується'
GOTO label
PRINT 'Дія не виконується'

label:
PRINT 'Після виконання'
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 17](https://fsx1.itstep.org/api/v1/files/8hPv7pIfi0-io1IHGsVzoE1N4Ca0isGV)

Рисунок 17

Та не слід забувати, що в даному випадку набагато гнучкіше буде застосувати інструкцію try..catch або ж використати механізм обробки транзакцій (про це пізніше).

8\. T-SQL також підтримує цикли, які являються послідовністю дій, що можуть виконуватись кілька разів поспіль. Цикли представляються за допомогою єдиного оператора циклу з передумовою WHILE:

```html
while [(] умова [)]
оператори;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

В циклах також дозволяэться використання операторів break та continue. Оператор BREAK призводить до виходу з циклу. Після цього виконання продовжується за оператором, який є наступним після оператора END (вказує на кінець блоку цикла). Оператор CONTINUE використовується, якщо необхідно перейти на початок циклу, і почати всю роботу спочатку. Доречі, в більшості випадків ці два оператори використовуються в межах умовного оператора if.

Напишемо кілька прикладів використання цикла:

```html
-- створюємо змінну
declare @i int
set @i = 1

-- запускаємо цикл
while @i&lt;10
begin
    print @i
    set @i = @i + 1
    if @i &gt; 5
        break
end
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 18](https://fsx1.itstep.org/api/v1/files/FYZagvMHyO8spgeL6pxHg-arwW7ihFE9)

Рисунок 18

А тепер обрахуємо середню ціну всіх книг. Якщо вона менше 200 грн., то всі ціни підвищити на 10% до тих пір, поки середня ціна не стане більше 200 грн.

```html
while(select avg(price)
    from book.Books) &lt; 200
begin
    update book.Books
    set price = price* 1.1
end
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

9\. Загальні табличні вирази (_Common Table Expressions_, CTE) дозволяють задавати тимчасовий іменований набір даних, функціонально схожий на представлення та доступний в межах пакету. В зв'язку з цим їх ще називають віртуальними представленнями. Синтаксис їх створення:

```html
WITH ім'я_представлення [ ( назва_поля [ ,...n ] ) ]
     AS ( підзапит)
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

При цьому список полів при оголошенні віртуального представлення повинен відповідати кількості полів в підзапиті. В підзапиті CTE не можуть використовуватись оператори:

-   COMPUTE або COMPUTE BY;
-   ORDER BY (за виключенням випадків, коли використовується інструкція TOP);
-   INTO;
-   FOR XML;
-   FOR BROWSE.

Наведемо приклад. Необхідно вибрати всі книги, ціна яких більша середньої ціни на всі книги окремого автора.

```html
-- з використанням віртуального представлення
with AvgPrice(ID_AUTHOR, NameAuthor, Price)
as
    ( select a.ID_AUTHOR, a.LastName + ' ' + a.FirstName, avg(book.Price)
      from book.Books book, book.Authors a
      where book.ID_AUTHOR = a.ID_AUTHOR
      groupby a.ID_AUTHOR, a.LastName + ' ' + a.FirstName
    )

select book.NameBook, book.Price
from book.Books as book, AvgPrice as p
where book.ID_AUTHOR = p.ID_AUTHOR and book.Price &gt; p.Price

-- з підзапитом
select book.NameBook, book.Price
from book.Books as book,
    ( select a.ID_AUTHOR as ID_AUTHOR,
             a.LastName + ' ' + a.FirstName as NameAuthor,
             avg(book.Price) as Price
      from book.Books book, book.Authors a
      where book.ID_AUTHOR = a.ID_AUTHOR
      group by a.ID_AUTHOR, a.LastName + ' ' + a.FirstName
    ) as p
where book.ID_AUTHOR = p.ID_AUTHOR and book.Price &gt; p.Price
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 19](https://fsx1.itstep.org/api/v1/files/b3s0anN0Ja7qtCMS6deQmjQE5lsSrZ5K)

Рисунок 19

Як видно з прикладу, віртуальні представлення та вкладені запити працюють однаково і дають аналогічний результат. Але у випадку повторного використання такого запиту, наприклад, в зберігаємій процедурі, зменшити кількість SQL коду допоможе саме віртуальне представлення.

Розглянемо ще один приклад. Напишемо віртуальне представлення, яке відображає інформацію про кількість книг окремого автора.

```html
with CountBooks(NameAuthor, Count_)
as
    ( select a.LastName + ' ' + a.FirstName, count(ID_BOOK)
      from book.Books b, book.Authors a
      where b.ID_AUTHOR = a.ID_AUTHOR
      groupby a.LastName + ' ' + a.FirstName
    ) ;

select*
from CountBooks
    order by 2 desc;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Одним з основних переваг віртуальних представлень, являється використання рекурсивних виразів. Використання таких представлень дуже корисне, якщо необхідно відобразити дані у вигляді ієрархії. Наприклад, можна показати спорідненість дочірних компаній або ж залежність працівників від їх керівників тощо. Загальний принцип побудови рекурсивних віртуальних представлень наступний:

```html
WITH ім'я_представлення [ ( назва_поля [ ,...n ] ) ]
AS
(
    SELECT... -- Початкова вибірка
    UNION ALL -- Обєднання результатів
    SELECT... -- Вибірка, яка визначає крок рекурсії
    INNER JOIN CTE.ID = Таблиця.ID -- Співставлення таблиць
)
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

В рекурсивних віртуальних представленнях забороняється використання наступних операторів:

-   SELECT DISTINCT;
-   GROUP BY;
-   HAVING;
-   Функції агрегування;
-   TOP;
-   LEFT, RIGHT, OUTER JOIN (INNER JOIN допускається);
-   Вкладені запити.

Наприклад, виведемо у вигляді ієрархічного списку перелік тематик та книг, які їм належать та видаються видавництвом.

```html
WITH Reports (ID_THEME, ID_BOOK, Level_) AS
(
    SELECT ID_THEME, ID_BOOK, 1 AS Level_
    FROM book.Books
    WHERE ID_THEME IS NULL
    UNION ALL
    SELECT b.ID_THEME, b.ID_BOOK, Level_ + 1
    FROM book.Books b INNER JOIN Reports r
        ON b.ID_THEME = r.ID_BOOK
)

select*
from Reports
order by 1
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат нажаль не буде досить наглядний, оскільки в нас не існує принципу підпорядкованості тематик. Тому рівень у всіх книг буде рівний одиниці.

Без використання віртуального представлення, для досягнення аналогічного результату доведеться написати набагато складніший запит. Крім того, рекурсивні віртуальні представлення продуктивніші, ніж тимчасові таблиці.

## 3\. Транзакції в MSSQLServer

Всі дані, які зберігаються в базі даних повинні бути коректними і задача розробників це забезпечити. Основним механізмом, який забезпечує таку узгодженість даних на програмному рівні, являються транзакції.Транзакція — це група послідовних операцій, які логічно виконуються як одне ціле. Фактично будь-яка послідовність операторів або оператор, що виконується в базі даних розглядається як транзакція та реєструється в журналі транзакцій. Транзакції можуть бути дуже корисними при тестуванні коду, який вносить зміни в базу даних.

Давайте розглянемо більш детальніше дане визначення. Операції, про які йде мова — це INSERT/UPDATE/DELETE, SELECT тощо. Якщо транзакція об'єднує які-небудь операції в єдиний блок, то говорять що ці дії виконуються в контексті даної транзакції. Слід також відмітити, що після запуску транзакції всі внесені зміни будуть по замовчуванню видимі лише у вашому з'єднанні. Для користувачів, які переглядають дані у інших з'єднаннях, ці зміни будуть невидимі. Далі ви або підтверджуєте транзакцію, зберігаючи всі зміни в базі даних, або робите відкат транзакції, повертаючи цим самим всі дані до їх попереднього стану (до початку транзакції).

Кожна транзакція повинна володіти наступними 4 властивостями:

1.  **Atomicity** (атомарності). Гарантує, що жодна транзакція не буде зафіксована в системі частково. Тобто оператори, які входять до транзакції можуть бути або виконані всі і повністю або не виконаний жоден з них. Часткове виконання транзацій не допускається.
2.  **Consistency** (узгодженості або послідовності) вказує на те, що система знаходиться в узгодженому стані як до початку транзакції, так і після її завершення, а це в свою чергу не порушує бізнес-логіку та відношення між об'єктами бази даних. Ця властивість дуже важлива при розробці клієнт-серверних додатків, оскільки в базі даних відбувається велика кількість транзакцій для різних об'єктів бази від різних клієнтів.І якщо хоча б одна з транзакцій порушує цілісність даних, то всі інші можуть видати невірні результати.
3.  **Isolation** (ізольованості), тобто транзакція не взаємодіє і не конфліктує з іншими транзакціями в базі даних. Це включає і те, що під час виконання транзакції інші процеси не повинні бачити дані в проміжному стані.
4.  **Durability** (довгочасності або надійності) вказує на гарантованість виконання всіх дій, незалежно від зовнішніх подій (збій в системі, «падіння» сервера тощо).

В MS SQL Server виділяють наступні типи транзакцій:

-   явні;
-   неявні;
-   автоматичні.

Явні транзакції — це транзакції, які оголошуються в програмі напряму. Для визначення початку і кінця транзакції використовуються такі оператори:

-   BEGIN TRAN\[SACTION\] \[ім'я\_транзакції\] — визначає початок транзакції.
-   COMMIT TRAN\[SACTION\] \[ім'я\_транзакції\] — повідомляє сервер, що транзакція закінчилась і потрібно зберегти (зафіксувати) всі зміни. Можна вказувати ім'я транзакції для підтвердження лише її дій.
-   COMMIT WORK — аналогічно попередньому оператору, але ім'я транзакції не вказується.
-   ROLLBACK TRAN\[SACTION\] \[ім'я\_транзакції ім'я\_точки\_збереження\] — відміна всіх дій поточної транзакції, або транзакції з певним іменем, або ДО точки збереження. Якщо в програмі існує точка збереження, то всі зміни, що зроблені в базі даних ЛИШЕ до цієї точки, можна відмінити.
-   ROLLBACK WORK — аналогічно попередньому оператору, але ім'я транзакції не вказується.
-   SAVE TRAN\[SACTION\] \[ім'я\_точки\_збереження\] — дозволяє встановити точку збереження.

Розглянемо все по порядку. Припустимо в нас існує три дії, які ми хочемо об'єднати в одну транзакцію, причому визначити її потрібно явно. В такому випадку код буде мати наступний вигляд:

```html
begin transaction        -- початок транзакції

-- 1
select distinct FirstName
from book.Authors;

-- 2
insert into book.Themes(NameTheme)
values ('MFC')

-- 3
update book.Authors
set id_country = (select id_country
                         for global.Country
                         where NameCountry = 'Україна')
commit transaction      -- підтвердити виконання транзакції
-- rollback transaction -- відмінити виконання транзакції
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Оператори Rollback існують для відміни виконання дій, визначених в межах транзакції. Тобто будь-які зміни, зроблені в базі даних до даного оператора, відміняються. Причому існує можливість створення точки збереження, і тоді можна відмінити лише ті дії, які були здійснені після неї. Точка збереження створюється за допомогою оператора SaveTransaction. В межах однієї транзакції може існувати кілька точок збереження, а також допускається наявність кількох точок з однаковими іменами. У випадку існування точок з однаковими іменами, відміна операцій здійснюється до останньої точки (від початку транзакції), тобто точки з аналогічними іменами, розміщені вище будуть ігноруватись.

Наприклад:

```html
begin transaction -- початок транзакції

-- 1
select distinct FirstName
from book.Authors;
save transaction pt1 -- перша точка збереження

-- 2
insert into book.Themes(NameTheme)
values('MFC')
save transaction pt2 -- друга точка збереження

-- 3
update book.Authors
set id_country = (select id_country
                  for global.Country
                  where NameCountry = 'Україна')

rollback transaction pt2   -- відмінити виконання транзакціїдо точки pt2 (до update)
--rollback transaction pt1 -- відмінити виконання транзакціїдо точки pt1 (до insert)
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Або:

```html
begin transaction -- початок транзакції

-- 1
select distinct FirstName
from book.Authors;
save transaction pt1 -- перша точка збереження

-- 2
insert into book.Themes(NameTheme)
values('MFC')
save transaction pt1 -- друга точка збереження (з аналогічним іменем)

-- 3
update book.Authors
set id_country = (select id_country
                  for global.Country
                  where NameCountry = 'Україна')
rollback transaction pt1 -- відмінити виконання транзакціїдо точки pt1.
                         -- Відміна відбудеться до оператора update
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

В SQL Server існує ряд глобальних системних змінниих, серед яких є і корисні в роботі з транзакціями. Найчастіше використовуваними є:

-   Глобальна системна змінна @@error, яка містить результат виконная транзакції. Якщо транзакція завершилась успішно, то вона містить 0, інакше — код помилки.
-   Глобальна системна змінна
    -   @@trancount
    -   При виклику оператора begin transaction значення цієї змінної збільшується на 1.
    -   Оператор save transaction на її значення не впливає
    -   Оператор rollback transaction впливає двояко. Якщо ім'я транзакції не вказано, то значення змінної обнуляється, інакше значення зменшується на 1.

Приведемо маленький приклад того, як ми можемо маніпулювати транзакціями, використовуючи значення першої глобальної системної змінної.

```html
begin ransaction -- початок транзакції

-- 1
select distinct FirstName
from book.Authors;
save transaction pt1 -- перша точка збереження

-- 2
insert into book.Themes(NameTheme)
values ('MFC')
save transaction pt2 -- друга точка збереження

-- 3
update book.Authors
set id_country = (select id_country
                  for global.Country
                  where NameCountry = 'Україна')

-- вибір дії в залежності від поточного стану помилки
if(@@error &gt;= 1 and @@error &lt;= 10)
begin
    print 'Значення помилки 1..10'
    rollback transaction pt2
end
else if(@@error &gt; 10)
    rollback transaction
else
    commit transaction
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Для більш гнучкої обробки помилок в T-SQL можна використовувати інструкцію try…catch. В блоці try (захищений блок) розміщується код, який може генерувати виключення (помилки). У випадку виникнення помилки, обробка негайно призупиняється, всі інструкції try-блоку, які залишились, ігноруються і управління передається catch-блоку, який йде за ним. Отже, в catch-блок передається управління, якщо буде згенероване виключення.

Синтаксис інструкції try…catch має наступний вигляд:

```html
begin try
    -- блок коду, який перевіряється на помилки
end try
begin catch
    -- обробник виключення
end catch
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Після попадання в блок catch, ви можете за допомогою системних функцій виявити причину помилки або отримати детальну інформацію про неї. Найпошиніші функції:

-   ERROR\_NUMBER — номер помилки;
-   ERROR\_MESSAGE — текст повідомлення про помилку;
-   ERROR\_LINE — номер рядка, в якому міститься помилка;
-   ERROR\_SEVERITY — важливість повідомлення про помилку;
-   ERROR\_STATE — номер стану про помилку.

В явних транзакціях забороняється одночасно використовувати наступні оператори:

-   ALTER, DROP, RESTORE i CREATE DATABASE;
-   BACKUP i RESTORE LOG;
-   RECONFIGURE;
-   UPDATE STATISTICS.

Неявні транзакції включені в T-SQL для сумісності з стандартом ANSI. Коли вмикається режим неявних транзакцій, автоматично виконується оператор begin transaction. Завершити транзакцію можна лише шляхом явного виклику оператора commit або rollback transaction.

Ввімкнути цей режим можна за допомогою оператор аset implicit\_transaction:

```html
set implicit_transaction [on -- ввімкнути
                          off] -- вимкнути
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

При цьому до кінця сеансу наступні операції повинні обов'язково бути зафіксовані або відмінені:

-   ALTER, TRUNCATE TABLE;
-   всі операції CREATE та DROP;
-   SELECT;
-   GRANT та REVOKE;
-   INSERT, DELETE, UPDATE;
-   FETCH;
-   OPEN.

Наприклад:

```html
set implicit_transaction on

select distinct FirstName
from book.Authors;

commit transaction
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Слід також пам'ятати, що використання неявних транзакцій не рекомендується, оскільки кожну транзакцію потрібно завершити або відмінити явно. Якщо цього не зробити, то транзакція буде відкрита і дані будуть надовго заблоковані.

**Автоматичні транзакції** — це транзакції, які виконуються, якщо навіть оператори для роботи з транзакціями не прописані в програмному коді явно. Тобто будь-які зміни даних сервером розцінюються як транзакція. Простіше кажучи, автоматичні транзакції здійснюються без явних рамок і з використанням оператора GO, які посилають пакет даних для обробки на сервер.

## 4\. Зберігаємі процедури

**Зберігаємі процедури (_stored procedures_)** — це послідовність компільованих операторів, що зберігаються в базі даних. Слід відмітити, що код зберігаємих процедур компілюється при першому запуску і далі зберігається у відкомпільованому вигляді, тому їх ефективність набагато вища, ніж у звичайних запитів. Зберігаємі процедури являються основним інтерфейсом, який повинен використовуватись прикладними додатками для звернення до довільних даних в базі даних. Крім управління доступом до бази даних, вони також дозволяють ізолювати код бази даних. Тепер не потрібно писати SQL команди для здійснення певних змін, а також це гарантує безпеку між користувачами і таблицями в базі.

В SQL Server існує набір системних зберігаємих процедур, які починаються з префікса sp\_xxx (_stored procedure_), а також можна створювати свої власні користувацькі зберігаємі процедури. Користувацькі зберігаємі процедури створюються за допомогою оператора CREATE PROCEDURE і вони можуть містити майже довільні команди.

```html
CREATE PROC[EDURE] [схема.] ім'я_процедури [;число]
[@параметр [схема.] тип
                    [VARYING] /*для управління курсором*/
                    [ =значення_по_замовчуваннюNULL]
                    [OUT  OUTPUT] /*вказує на те, що даний параметр є повертаємим*/
                    [READONLY] /*тільки для читання. Для табличних типів*/
]
[,...n]
[WITH {RECOMPILE  ENCRYPTION  RECOMPILE, ENCRYPTION
        EXECUTE AS { CALLER  SELF  OWNER 'логін_користувача' } } ]
[FOR REPLICATION] /*приймає участь в реплікації*/
AS
{
    [BEGIN]
        тіло_процедури з оператором SELECT
    [END]
        EXTERNAL NAME збірка.клас.метод
}
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Зберігаємі процедури можуть як приймати дані (_input parameters_), так і повертати (output parameters). В процедурі також дозволяється використання локальних змінних. З параметром ENCRYPTION ви вже знайомі. Він використовується для створення шифрованих зберігаємих процедур. Якщо вказати параметр RECOMPILE SQL Server перекомпілює процедуру при кожному її запуску. Більш детальніше з цим параметром ми познайомимось пізніше. Параметр EXECUTE AS визначає контекст безпеки для зберігаємої процедури:

-   CALLER (по замовчуванню) — вказує, що інструкції, які містяться в процедурі, виконуються в контексті користувача, який її викликав.
-   'логін\_користувача' — вказується який саме користувач може змінювати зберігаєму процедуру.
-   SELF — інструкції виконуються в контексті користувача, який створив зберігаєму процедуру або може її змінювати.
-   OWNER — всі інструкції виконуються в контексті поточного власника цієї зберігаємої процедури. Якщо власник процедури не вказаний, тоді мають на увазі власника схеми.

Параметр EXTERNAL NAME вказує на збірку .NET Framework, на яку повинна посилатись зберігаєма процедура CLR. При цьому слід вказати назву класу в цій збірці і необхідний метод (повинен бути статичний). Якщо ім'я класу включає в себе назву простору імен, відділену крапками ( . ), тоді його слід відмежовувати квадратними дужками ( \[ \] ) або подвійними лапками ( " " ).

Викликати процедуру можна за допомогою оператора execute, спрощений синтаксис якого наступний:

```html
exec[ute] ім'я_процедури [;число] [список_параметрів] [WITH RECOMPILE]
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Більш детальніше кожен з параметрів розглянемо на практиці, але для початку ще трішки теорії.

Отже, при створенні зберігаємої процедури слід дотримуватись наступних правил:

-   в зберігаємих процедурах не можна використовувати оператори:
    -   CREATE RULE,
    -   CREATE DEFAULT,
    -   CREATE PROCEDURE,
    -   CREATE TRIGGER,
    -   CREATE VIEW,
    -   USE база\_даних,
    -   SET SHOWPLAN\_TEXT,
    -   SET SHOWPLAN\_ALL;
-   під час виконання процедури всі об'єкти, на які вона ссилається, повинні бути присутні в БД. Спеціальна властивість процедури (пізнє зв'язування імені) дозволяє під час компіляції ссилатись на неіснуючий об'єкт. Завдяки цьому зберігаєма процедура при створенні може генерувати тимчасові об'єкти, а потім ссилатись на них при запуску;
-   в процедурі не можна створювати об'єкт, а потім видалити його або створювати заново під одним і тим же іменем;
-   процедура не може мати більше 1024 параметрів;
-   можна створювати вкладені процедури (підтримується до 32 рівнів вкладеності);
-   як і у випадку представлень, якщо в процедурі використовується оператор SELECT \* і в базову таблицю додаються поля після створення процедури, то при її виконанні ці нові поля використовувати неможна. Для цього потрібно за допомогою оператора ALTER PROCEDURE змінити зберігаєму процедуру.

Процес виконання зберігаємих процедур проходить 5 етапів:

-   Лексикографічний аналізатор виразів розбиває процедуру на окремі компоненти.
-   Компоненти, які ссилаються на об'єкти БД (таблиці, представлення тощо), співставляються з цими об'єктами (вже перевіреними на існування). Цей процес називається розширенням посилань.
-   Зберігаєма процедура реєструється, тобто в sysobjects записується її назва, а в syscomments — код створення.
-   Створюється попередній план виконання запиту, тобто дерево запиту, який зберігається в системній таблиці sysprocedures.
-   Зчитується дерево запиту та процедура виконується.

Серед переваг зберігаємих процедур можна виділити те, що план процедури збергається в процедурному кеші після її першого виконання і вже надалі звідти просто зчитується. Тобто процедура компілюється один раз, при першому її виклику. Це призводить до підвищення продуктивності та швидкості виконання зберігаємих процедур. Крім того, існує можливість автоматичного виконання процедур при запуску SQL Server.

Перейдемо до практики. Для початку напишемо просту процедуру, яка дозволяє переглянути список авторів та кількість їх книг:

```html
create procedure sp_authors
as
select a.firstname + ' ' + a.lastname, count(b.id_book) as countBooks
from book.Authors a, book.Books b
where b.id_author = a.id_author
group by a.firstname + ' ' + a.lastname;
go
exec sp_authors;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 20](https://fsx1.itstep.org/api/v1/files/X5PvbH0XWilkxoF5ErR_oAXmYk5UVYkH)

Рисунок 20

А тепер розглянемо як використовується параметр «число» при створенні процедури. Як правило, він служить для створення групи зберігаємих процедур. Це може стати у нагоді, коли необхідно, щоб кілька процедур виконувались як одна, тобто одночасно. Для прикладу, напишемо групу з двох процедур, які отримують різну інформацію про авторів:

```html
create proc sp_grAuthors;1
as
select *
from book.Authors;
go

create proc sp_grAuthors;2
as
select a.firstname + ' ' + a.lastname, count(b.id_book) as countBooks
from book.Authors a, book.Books b
where b.id_author = a.id_author
group by a.firstname + ' ' + a.lastname
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Навіть фізично група запитів зберігається як одна:

![Рисунок 21](https://fsx1.itstep.org/api/v1/files/oPUMI4F3jT5ZTgpFdDccmVBGaiSa-Y-V)

Рисунок 21

Запускаємо:

```html
exec sp_grAuthors;1   -- запускає перший запит з групи (по номеру)
    exec sp_grAuthors -- запускає перший запит з групи
exec sp_grAuthors;2   -- запускає другий запит з групи
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 22](https://fsx1.itstep.org/api/v1/files/pchFcS95Qi900CAmrkPrFpTaIkkJt9s7)

Рисунок 22

Для видалення зберігаємої процедури використовується оператор DROP PROCEDURE, а у випадку групи процедур — видаляється ціла група. Видалення окремої зберігаємої процедури з групи неможливо. Синтаксис даного оператора типовий, тому розглядати детально його ми не будемо.

Розглянемо приклад передачі переметрів в зберігаєму процедуру. Для цього напишемо зберігаєму процедуру, яка додає два числа, переданих в якості параметрів, а результат записує у вихідний (_output_) параметр:

```html
create procedure sp_summa
@a int,
@b int,
@res intoutput
as
set @res = @a + @b
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Передавати при виклику параметри в зберігаєму процедуру можна двома способами: явно і по позиції.

```html
declare @summ int  -- оголошуємо змінну, яка буде містити результат
execute sp_summa @a = 5, @b = 25, @res = @summ output -- явна передача параметрів
execute sp_summa 5, 25, @summ output -- передача параметрів по позиції
select '5 + 25 = ', @summ -- виводимо результат
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 23](https://fsx1.itstep.org/api/v1/files/749u_rLZlMmd1_fsoLoAc9nuodkfxzCR)

Рисунок 23

Повертати значення з процедури можна використовуючи оператор return. Для цього перепишемо нашу процедуру наступним чином:

```html
create procedure sp_summa2
@a int,
@b int
as
declare @res int
set @res = @a + @b
return @res
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Виклик такої зберігаємої процедури буде наступним:

```html
declare @summ int -- оголошуємо змінну, яка буде містити результат
execute @summ = sp_summa2 @a = 5, @b = 25 -- явна передача параметрів
execute @summ = sp_summa2 5, 25 -- передача параметрів по позиції
select '5 + 25 = ', @summ -- виводимо результат
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Розглянемо більш складніший приклад. Напишемо процедуру, яка повертає список авторів, які живуть в Україні:

```html
create proc sp_ListAuthors
@name varchar(25) output,
@surname varchar(25) output
as
select @name = a.firstname, @surname = a.lastname
from book.Authors a, global.Country c
where a.id_country = c.id_country and c.NameCountry = 'Україна'
go

declare @name varchar(25), @surname varchar(25)
exec sp_ListAuthors @name output, @surname output
select'List authors name: ', @name + ' ' + @surname
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 24](https://fsx1.itstep.org/api/v1/files/q8T0qFUlobdbom8JLknkIN1ahZuHDSZg)

Рисунок 24

Залишилось розглянути опцію RECOMPILE. При її використанні SQL Server буде ігнорувати існуючий план виконання зберігаємої процедури і при кожному її виконанні створювати новий. На практиці перекомпіляція зберігаємої процедури використовується дуже рідко, але вона стате у нагоді, наприклад, при додаванні нового індекса, який покращує роботу зберігаємої процедури. Опцію RECOMPILE можна використовувати у двох випадках:

1\. В операторі CREATE PROC, тобто при створенні процедури. В такому випадку план виконання процедури не повинен зберігатись в процедурному кеші і при виконанні вона буде заново перекомпільовуватись. Це корисно для процедур з поточними параметрами. Наприклад:

```html
createproc sp_themes
with recompile
as
select*
from book.Themes
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

2\. В операторі EXEC PROC — при виклику процедури. В такому випадку перекомпіляція здійснюється в поточному сеансі виконання процедури. Новий план зберігається в кеші і потім може ще використовуватись:

```html
exec sp_themes with recompile
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Щоб перекомпілювати всі зберігаємі процедури і тригери використовується системна процедура sp\_recompile, а для автоматичного виконання зберігаємої процедури при запуску сервера слід виконати процедуру sp\_procoption.

Для того, щоб переглянути інформацію про зберігаєму процедуру, тобто код її створення, потрібно викликати системну процеруду sp\_helptext:

```html
exec sp_helptext sp_addtype
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат:

![Рисунок 25](https://fsx1.itstep.org/api/v1/files/slaNVSHCoQYW4iZo7EZwrsg1rDQHq0id)

Рисунок 25

Щоб переглянути список зв'язаних з процедурою об'єктів, слід скористатись системною процедурою sp\_depends:

```html
exec sp_dependsім'я_процедури
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

## 5\. Домашнє завдання

Написати наступні тригери:

1.  Тригер, який при продажу книги автоматично змінює кількість книг в таблиці Books. (**Примітка!** _Додати до таблиці Books необхідне поле кількості наявних книжок QuantityBooks_).
2.  Тригер на перевірку, щоб кількість продажу книг не перевищила наявну.
3.  Тригер, який при видаленні книги, копіює дані про неї в окрему таблицю «DeletedBooks».
4.  Тригер, який слідкує, щоб ціна продажу книги не була меньше основної ціни книги з таблиці Books.
5.  Тригер, що забороняє додавання нової книги, для якої не вказана дата випуску та викидає відповідне повідомлення про помилку.
6.  Тригер або набір тригерів, які забороняють видалення об'єктів будь-якої бази даних на сервері (таблиць, значень по замовчуванню тощо).
7.  Додайте до бази даних тригер, який виконує аудит змін даних в таблиці Books.

© STEP IT Academy, [itstep.org](https://itstep.org/)

All the copyrighted photos, audio, and video works, fragments of which are used in the material, are the property of their respective owners. Fragments of the works are used for illustrative purposes to the extent justified by the objective, within the educational process, and for educational purposes, in accordance with the Act of “On Copyright and Related Rights”. The scope and method of the cited works are in accordance with the adopted norms, without prejudice to the normal exploitation of copyright, and do not prejudice the legitimate interests of authors and right holders. At the time of use, the cited works fragments cannot be replaced by alternative, non-copyrighted counterparts and meet the criteria for fair use. All rights reserved. Any reproduction of the materials or its part is prohibited. Use of the works or their fragments must be agreed upon with authors and rights holders. Agreed material use is only possible with reference to the source. Responsibility for unauthorized copying and commercial use of the material is determined by the current legislation.