## Функції агрегування

## 1\. Функції агрегування

Як ви знаєте, основним призначенням баз даних є впорядковане зберігання різної інформації, яка може бути вилучена зручним способом у разі потреби. Проте, є ще одне важливе застосування баз даних — статистичний аналіз збереженої інформації. Для того, щоб отримати статистичні дані в цифровому вигляді використовуються функції агрегування, які призначені для отримання узагальнюючого значення із певної кількості стовпців, тобто результатом виконання будь-якої функції буде єдине значення.

У мові T-SQL існує п'ять функцій агрегування: COUNT(), AVG(), SUM(), MIN() і MAX(). Перш ніж приступити до їх детального розгляду, слід відзначити важливу особливість — функції AVG() і SUM() можуть застосовуватися тільки до стовпців цифрових типів даних, а функції COUNT(), MIN() і MAX() як до цифрових полів, так і символьного типу даних.

Для того, щоб продемонструвати практичне застосування функцій агрегування, ми скористаємось таблицею Students, відомою вам із попереднього уроку (Рисунок 1).

![Рисунок 1. Таблиця Students](https://fsx1.itstep.org/api/v1/files/440uYhm_-YQssdkczeOKrXH41Y5E9PWS)

Рисунок 1. Таблиця Students

### 1.1. Функція COUNT

Функція COUNT() дозволяє визначити кількість записів у певному стовпці чи у всій таблиці.

Якщо викликати функцію COUNT() і передати як параметр символ \* (зірочка):

```html
SELECT COUNT(*) AS [Number of records]
FROM Students;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

То в результаті ви отримаєте загальну кількість записів у таблиці, включаючи як повторювані, так і невизначені значення (NULL-значення) (Рисунок 2).

![Рисунок 2. Визначення загальної кількості записів у таблиці](https://fsx1.itstep.org/api/v1/files/6i5SWlnz0eR4-SLyd_e4__aGGftIoJ3g)

Рисунок 2. Визначення загальної кількості записів у таблиці

Щоб отримати кількість записів у конкретному стовпці таблиці, під час виклику функції COUNT() необхідно передати як параметр назву стовпця. При використанні функції у такому вигляді не враховуються записи, що мають невизначене значення у цьому стовпці. Наприклад, SQL-запит, який повертає кількість записів у стовпці Grants, буде виглядати наступним чином:

```html
SELECT COUNT(Grants) AS [Number of grands]
FROM Students;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат, отриманий при виконанні цього SQL-запиту, відрізняється від результату, представленого на рисунку 2, так як у стовпці Grants є значення NULL (Рисунок 3).

![Рисунок 3. Кількість записів у стовпці Grants](https://fsx1.itstep.org/api/v1/files/YzQt0m07ZYj3cqkjlaT2DZABwyPrDcb5)

Рисунок 3. Кількість записів у стовпці Grants

Якщо вам потрібно визначити кількість унікальних записів у певному стовпці, тоді при виклику функції COUNT() необхідно вказати ключове слово DISTINCT перед ім'ям стовпця. Внесемо зміни до попереднього прикладу:

```html
SELECT COUNT(DISTINCT Grants) AS [Unique of grands]
FROM Students;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

В результаті виконання цього SQL-запиту ми отримаємо кількість записів у стовпці Grants без повторень (Рисунок 4).

![Рисунок 4. Кількість записів у стовпці Grants без повторень](https://fsx1.itstep.org/api/v1/files/eJX0sJ3siUOSoQSi1giV9l6WZkwHLK4_)

Рисунок 4. Кількість записів у стовпці Grants без повторень

### 1.2. Функція AVG

Функція AVG() дозволяє отримати середнє арифметичне значення певного стовпця.

Використання функції AVG() розглянемо на простому прикладі знаходження розміру середньої стипендії студентів,відповідний SQL-запит виглядатиме наступним чином:

```html
SELECT AVG(Grants) AS [Average grant]
FROM Students;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат виконання цього запиту представлений на рисунку 5.

![Рисунок 5. Середня стипендія студентів](https://fsx1.itstep.org/api/v1/files/0PbVy8HjU3PSxyypq9PB_XbLFhFAJUR5)

Рисунок 5. Середня стипендія студентів

Наступний приклад буде трохи складнішим, припустимо, нам необхідно визначити середній вік студентів, тоді ми можемо написати наступний SQL-запит:

```html
SELECT AVG(DATEDIFF(dd, BirthDate, GETDATE())/365.25) AS [Average age]
FROM Students;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Для того, щоб визначити вік студентів ми використовуємо функцію DATEDIFF(), отримуючи різницю в днях між поточною датою та датою народження студента, роблячи поділ отриманого результату на 365.25 ми отримуємо більш точні значення (Рисунок 6).

![Рисунок 6. Середній вік студентів](https://fsx1.itstep.org/api/v1/files/pmwItxn1M07lNhISSAd8_fuXbIkoTFPI)

Рисунок 6. Середній вік студентів

### 1.3. Функція SUM

Функція SUM() дає змогу обчислити суму значень заданого стовпця.

Наприклад, виконавши наступний SQL-запит, ми можемо дізнатися, скільки грошей виплачується студентам щомісяця у вигляді стипендії, результат представлений на рисунку 7.

```html
SELECT SUM(Grants) AS [Sum grants]
FROM Students;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

![Рисунок 7. Сума стипендій студентів](https://fsx1.itstep.org/api/v1/files/z6TSIYVFwEnTkm24las8FZxpDkhFBwuF)

Рисунок 7. Сума стипендій студентів

### 1.4. Функція MIN

Використання функції MIN() забезпечує отримання найменшого значення у певному стовпці таблиці.

Для того, щоб визначити найменшу дату народження студентів, необхідно виконати наступний запит, результат якого представлений на рисунку 8:

```html
SELECT MIN(BirthDate) AS [Min date of birth]
FROM Students;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

![Рисунок 8. Мінімальна дата народження студентів](https://fsx1.itstep.org/api/v1/files/ZuBGH2uXC8YTaHSxYV3L2B4VlIecWvsk)

Рисунок 8. Мінімальна дата народження студентів

### 1.5. Функція MAX

Функція MAX() дозволяє визначити найбільше значення у вказаному стовпці.

Як говорилося раніше, функції MIN() і MAX() можуть використовуватися під час роботи зі стовпцями символьного типу, у цьому разі будуть порівнюватися цифрові коди відповідних символів. Наприклад, нам необхідно визначити максимальне значення із прізвищ студентів, тобто знайти прізвище, у якого значення символів найбільше. Адже насправді послідовно порівнюватимуться не самі символи, а їх числові значення в кодуванні Unicode, тому що в нашому випадку стовпець LastName має тип даних nvarchar. Для того, щоб вирішити це завдання можна написати наступний SQL-запит:

```html
SELECT MAX(LastName) AS [Maximum last name]
FROM Students;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат цього запиту наведено нижче (Рисунок 9).

![Рисунок 9. Максимальне прізвище зі списку студентів](https://fsx1.itstep.org/api/v1/files/WJUHxfe5-6ZOKgf7ZeFcZVcvkF8vIRIu)

Рисунок 9. Максимальне прізвище зі списку студентів

При написанні SQL-запитів з використанням функцій агрегування, при необхідності, можна здійснювати обмеження результату за умовою, наприклад, нам потрібно отримати кількість студентів, ім'я яких починається на літеру J. Виконавши наступний запит, ви отримаєте потрібний результат (Рисунок 10):

```html
SELECT COUNT(*) AS [Number of students]
FROM Students
WHERE FirstName LIKE 'J%';
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

![Рисунок 10. Кількість студентів, ім'я яких починається на букву J](https://fsx1.itstep.org/api/v1/files/uCul15ZnZlodo4laXRm9oWaFyjXtpQQq)

Рисунок 10. Кількість студентів, ім'я яких починається на букву J

Для того, щоб у вас не склалося враження, що функції агрегування застосовуються тільки в простих запитах, ми, на закінчення поточного розділу, продемонструємо приклад багатотабличного SQL-запиту. Для того, щоб освіжити вашу пам'ять, ми наведемо частину діаграми бази даних з минулого уроку (Рисунок 11).

![Рисунок 11. Зв'язок між таблицями Students та Groups](https://fsx1.itstep.org/api/v1/files/5o4g5WpOZH24KDszo9e_1irGGuUS7F9b)

Рисунок 11. Зв'язок між таблицями Students та Groups

Припустимо, нам необхідно дізнатися кількість студентів, які навчаються на 32 потоці:

```html
SELECT COUNT(*) AS [Count of students]
FROM Students AS S, Groups AS G
WHERE G.Id = S.GroupId AND G.GroupName LIKE '32%';
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

У поточному запиті для того, щоб отримати з бази даних потрібну інформацію, необхідно встановити зв'язок між таблицями Students і Groups по первинному/зовнішньому ключу (G.Id = S.GroupId) і залишити тільки ті записи, які починаються на 32 (G.GroupName LIKE '32%'), після чого отримати їхню кількість за допомогою функції COUNT(). Результат цього запиту представлений на рисунку 12.

![Рисунок 12. Кількість студентів 32-го потоку](https://fsx1.itstep.org/api/v1/files/1zns1Ujo6gdtQYxJEedcEOcy2XgHNary)

Рисунок 12. Кількість студентів 32-го потоку

## 2\. Поняття груповання. Ключове слово GROUP BY

Всі приклади попереднього розділу повертали як результати SQL-запитів лише значення функцій агрегування. А що станеться, якщо нам потрібна буде додаткова інформація? Наприклад, необхідно дізнатися, скільки студентів навчається в кожній групі.

«Що тут складного? — скажете ви. — Потрібно додати до оператора SELECT назву групи». Спробуємо написати відповідний запит, виконання якого завершиться помилкою (Рисунок 13).

![Рисунок 13. Помилка: не можна використовувати стовпець GroupName у списку вибору](https://fsx1.itstep.org/api/v1/files/uMbrAySSD1DV6HorqqWDYPJo9f5I9h1m)

Рисунок 13. Помилка: не можна використовувати стовпець GroupName у списку вибору

Помилка відбулася тому, що будь-яка функція агрегування (в даному випадку COUNT()) завжди повертає одне єдине значення, а звернення до стовпця GroupName в операторі SELECT повертає безліч значень рядків і така ситуація не може бути коректно оброблена оператором SELECT. Якщо уявити неможливий результат виконання цього SQL-запиту, то він виглядав би наступним чином (Рисунок 14).

![Рисунок 14. Неможливий результат використання функцій агрегування](https://fsx1.itstep.org/api/v1/files/9wNIUp4k_T-TV_6fXN821pqZ00Gc4RNu)

Рисунок 14. Неможливий результат використання функцій агрегування

Як ви можете помітити, декільком назвам групи відповідає одне значення функції агрегування, а це впринципі неможливо.

Для того, щоб даний SQL-запит виконався правильно, необхідно зробити так, щоб назва групи теж була в однині, тобто якимось чином згрупувати значення в стовпці GroupName (Рисунок 15).

![Рисунок 15. Необхідний результат виконання запиту](https://fsx1.itstep.org/api/v1/files/qjwcV5Qb-9Pfv24Wz0HGkYmaG_xsvtGB)

Рисунок 15. Необхідний результат виконання запиту

Натяк на вирішення цієї проблеми зроблено в тексті, який описує помилку — необхідно використовувати оператор GROUP BY, який дозволяє групувати результуючі рядки за вказаним стовпцем:

```html
SELECT GroupName, COUNT(S.GroupId) AS [Number of students]
FROM Groups AS G, Students AS S
WHERE G.Id = S.GroupId
GROUP BY GroupName;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Використання оператора GROUP BY у попередньому запиті дозволило створити групи рядків, по одному для кожного унікального значення у стовпці GroupName. Після чого, за допомогою функції COUNT() було отримано кількість записів у кожній групі рядків і вже підсумкові рядки були включені до результуючої таблиці. Результат виконання цього SQL-запиту збігається з очікуваним (Рисунок 15).

При необхідності ви можете групувати рядки на основі кількох стовпців, однак у цьому випадку групування буде здійснюватися, ґрунтуючись на унікальному поєднанні даних у всіх стовпцях, що беруть участь у групуванні.

Наприклад, якщо нам знадобиться отримати кількість студентів з однаковою стипендією за групами з відображенням цих стипендій, то у групуванні даних крім назв груп братимуть участь ще й значення стипендій:

```html
SELECT GroupName, Grants, COUNT(S.GroupId) AS [Number of students]
FROM Groups AS G, Students AS S
WHERE G.Id = S.GroupId
GROUP BY GroupName, Grants;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

В результаті виконання даного SQL-запиту ми отримаємо кількість студентів у групі більше одного лише тоді, коли розмір стипендії збігатиметься у кількох студентів у цій групі. У нашому випадку у групі 30PR11 два студенти не отримують стипендії, тим самим формуючи для запиту однакове значення — NULL, це відбувається тому, що функція GROUP BY інтерпретує всі значення NULL, як рівні. У решті груп значення стипендій у студентів не збігається (Рисунок 16).

![Рисунок 16. Кількість студентів у кожній із груп з однаковою стипендією](https://fsx1.itstep.org/api/v1/files/leREPCWDUm744WAiKEwamESEysi9dCOP)

Рисунок 16. Кількість студентів у кожній із груп з однаковою стипендією

## 3\. Ключове слово HAVING

При використанні функцій агрегування існує необхідність накладати обмеження на результати, що повертаються ними, саме це є одним з призначень оператора HAVING. Ще одна можливість застосування цього оператора — фільтрація результатів групування рядків на підставі значень стовпців, вказаних після оператора GROUP BY.

### 3.1. Принципи використання HAVING

Оператор HAVING синтаксично прописується після оператора GROUP BY, але до оператора ORDER BY:

```html
SELECT columnName1, columnName2, ...
FROM tableName
[WHERE condition]
[GROUP BY columnName1, columnName2, ...]
HAVING condition
[ORDER BY columnName1 ASC | DESC, ...];
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Насправді наявність операторів WHERE, GROUP BY і ORDER BY не є обов'язковим.

Наведемо кілька прикладів використання оператора HAVING. У першому з них запит поверне лише студентів, середня стипендія яких не перевищує 1200, при цьому результат буде відсортований за їх прізвищами:

```html
SELECT LastName, Grants
FROM Students
GROUP BY LastName, Grants
HAVING AVG(Grants) &lt;= 1200
ORDER BY LastName;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Даний SQL-запит буде виконуватися таким чином: всі записи з таблиці Students будуть згруповані за прізвищами та стипендіями студентів (оператор GROUP BY), потім отримані групи фільтруються за умовою в операторі HAVING і після цього отримані результати сортуються за прізвищами (Рисунок 17).

![Рисунок 17. Студенти із середньою стипендією менше 1200](https://fsx1.itstep.org/api/v1/files/ZSWg7Svr9MYVnBTvGUUzZJf4cnoj5Mz2)

Рисунок 17. Студенти із середньою стипендією менше 1200

За допомогою наступного SQL-запиту ми зможемо визначити назву груп, кількість студентів у яких перевищує 2 особи:

```html
SELECT GroupName, COUNT(*) AS [Number of students]
FROM Groups AS G, Students AS S
WHERE G.Id = S.GroupId
GROUP BY GroupName
HAVING COUNT(S.GroupId) &gt; 2;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

У цьому запиті з'єднуємо таблиці Students і Groups за первинним/зовнішнім ключем (G.Id = S.GroupId), групуємо отримані рядки за назвою групи, після чого обмежуємо кількість записів за умовою в операторі HAVING, порівнюючи кількість ідентифікаторів груп у студентів (COUNT(S.GroupId)>2). Результат цього запиту представлений на рисунку 18.

![Рисунок 18. Групи, в яких навчаються понад 2 особи](https://fsx1.itstep.org/api/v1/files/r4PoY0siRLfvXLrb8CJopRYZzyOw28u0)

Рисунок 18. Групи, в яких навчаються понад 2 особи

Ще один SQL-запит демонструє можливість перевірки в операторі HAVING значень одного зі стовпців, за якими групуються дані. Припустимо нам необхідно вивести імена та прізвища студентів із певного списку:

```html
SELECT FirstName, LastName
FROM Students
GROUP BY LastName, FirstName
HAVING LastName IN('Moore', 'Thomas', 'Doe');
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

У поточному запиті записи групуються за прізвищем та ім'ям, потім залишаються лише ті рядки, у яких прізвища збігаються із заданим в операторі HAVING списком і лише ця інформація потрапляє до результуючої таблиці. (Рисунок 19).

![Рисунок 19. Інформація щодо студентів з певними прізвищами](https://fsx1.itstep.org/api/v1/files/lLQFHKeIdENIEAcvMuk25yyna90ryita)

Рисунок 19. Інформація щодо студентів з певними прізвищами

Останній запит демонструє можливість використання оператора HAVING за відсутності оператора GROUP BY. Виведемо мінімальні значення прізвищ студентів, якщо середня стипендія перевищує 1100:

```html
SELECT MIN(LastName) AS [Minimum last name]
FROM Students
HAVING AVG(Grants) &gt; 1100;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

В операторі SELECT попереднього SQL-запиту ми можемо викликати лише функції агрегування, якщо спробувати вказати назву будь-якого стовпця, то буде згенерована помилка з вимогою використовувати оператор GROUP BY. Результат виконання цього запиту на рисунку 20.

![Рисунок 20. Використання оператора HAVING без GROUP BY](https://fsx1.itstep.org/api/v1/files/KNPtO0nTCkZj1nO7mrDUoo6I6MwtAomS)

Рисунок 20. Використання оператора HAVING без GROUP BY

Якщо в операторі HAVING змінити умову — збільшити порівнюване значення, наприклад, до 1400, ми отримаємо порожній результуючий набір, тому що таких середніх значень у таблиці Students немає.

### 3.2. Порівняльний аналіз HAVING та WHERE

Оператори WHERE та HAVING схожі за способом їх використання і той, і інший містить умови фільтрації даних, проте ці оператори відрізняються своїм призначенням. Умови після оператора WHERE визначають, яким чином з'єднувати таблиці, що використовуються, і фільтрують окремі рядки даних, тим самим обмежуючикількість записів, що виводяться в результуючій таблиці. У свою чергу оператор HAVING призначений для фільтрації згрупованих даних або виконання умов для функцій агрегування, саме тому використання оператора WHERE в даних ситуаціях неможливо. Наприклад, якщо ми напишемо SQL-запит з використання оператора WHERE для того, щоб отримати інформацію про студентів, середня стипендія яких не перевищує 1200, його виконання призведе до помилки (Рисунок 21).

![Рисунок 21. Помилка: неможливо використовувати агрегатну функцію](https://fsx1.itstep.org/api/v1/files/4rPtdkYy8iwgTdxnNU7rqvpcCCxKyuIN)

Рисунок 21. Помилка: неможливо використовувати агрегатну функцію

## 4\. Підзапити

У мові SQL реалізована можливість створення підзапитів або іншими словами вкладених запитів, тобто можливість створення такого запиту, який буде розміщено всередині іншого запиту. Існують ситуації, коли без такого підходу отримати потрібну інформацію буде дуже складно чи взагалі неможливо.

### 4.1. Необхідність створення та використання підзапитів

Обговоримо необхідність використання підзапитів на простому прикладі, припустимо, нам необхідно вивести прізвище, ім'я та номер групи студентів, які отримують максимальну стипендію. Здавалося б, що написати такий SQL-запит не складе особливих труднощів, наприклад, так:

```html
SELECT LastName, FirstName, GroupName, Grants
FROM Students AS S, Groups AS G
WHERE G.Id = S.GroupId
GROUP BY LastName, FirstName, GroupName, Grants
HAVING Grants = MAX(Grants);
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Однак, отриманий результат буде далеким від очікуваного, в даному випадку ми отримали максимальне значення стипендії для кожної групи даних (Рисунок 22).

![Рисунок 22. Результат неправильно написаного SQL-запиту](https://fsx1.itstep.org/api/v1/files/Y33C8iMwVPFf6VK6P3JPQUco6srUx7Rt)

Рисунок 22. Результат неправильно написаного SQL-запиту

Такий результат виконання SQL-запиту легко можна пояснити. В даному випадку дані згруповані таким чином, що формують унікальні групи на підставі прізвища та імені студента, назві групи та стипендії, а в операторі HAVING порівнюється значення стипендії для кожної групи даних з максимальним значенням стипендії тієї ж групи, тобто саме з собою, тим самим повертаючи істину. Групи, у яких максимальна стипендія має невизначене значення (Grants =NULL) відкидаються, оскільки порівняння на значення NULL можливе тільки з використанням ключового слова IS NULL.

Для того, щоб наш SQL-запит повернув необхідні результати, необхідно порівнювати стипендії студентів з максимальним значенням стипендії (у нашому випадку воно дорівнює 1256). Однак, як ви знаєте з попереднього розділу, використання функцій агрегування в операторі WHERE заборонено, тому запит можна написати наступним чином:

```html
SELECT LastName, FirstName, GroupName, Grants
FROM Students AS S, Groups AS G
WHERE G.Id = S.GroupId AND Grants = 1256;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат цього запиту представлений на рисунку 23.

![Рисунок 23. Студенти, які отримують максимальну стипендію](https://fsx1.itstep.org/api/v1/files/VGi_2uhzCk3tDTjRferhaG4zIgedgxPL)

Рисунок 23. Студенти, які отримують максимальну стипендію

Незважаючи на те, що в результаті виконання цього SQL-запиту ми отримали правильний результуючий набір, такий підхід не витримує жодної критики, адже максимальне значення стипендії може змінюватися, що в свою чергу призведе до зміни «магічного числа».

Тому, для отримання максимального значення стипендії доцільно використовувати відповідний підзапит (SELECT MAX(Grants) FROM Students). Отримане в результаті виконання підзапиту значення буде порівнюватися зі стипендією в кожному записі студентів і в разі збігу значень, саме цей запис буде додаватися в результуючу таблицю. Перепишемо попередній SQL-запит з використанням підзапиту, результат виконання буде таким же, як на рисунку 23:

```html
SELECT LastName, FirstName, GroupName, Grants
FROM Students AS S, Groups AS G
WHERE G.Id = S.GroupId
AND Grants = (SELECT MAX(Grants) FROM Students);
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Доповнюючи коментарі до цього запиту, слід додати, що відповідно до синтаксису мови SQL підзапити необхідно поміщати у круглі дужки.

У попередньому прикладі ми використовували підзапит, який повертав скалярне значення, як результат виконання функції агрегування MAX(). Однак SQL-запити в основному повертають безліч рядків і в цьому випадку при використанні їх в якості підзапитів існує своя особливість. Наприклад, нам необхідно отримати інформацію про всіх студентів, які навчаються в групах з номером 11, при цьому нам неважливо на якому потоці. У цьому випадку підзапит виконається правильно і поверне невизначену кількість значень одного стовпця (Id), але неправильне порівняння результатів, що повертаються ним, призведе до помилки на рисунку 24.

![](https://fsx1.itstep.org/api/v1/files/CnQapj2Xl1ca4M9HA4F2mveBygpBpsXU)

Дана помилка пов'язана з тим, що наш запит повертає унікальні ідентифікатори кількох груп, які відповідають заданій умові (GroupName LIKE '%11'), а в операторі WHERE повернуті результати порівнюються з єдиним значенням стовпця GroupId, що в принципі неможливо (подібна ситуація вже описувалася в поточному уроці при використанні функцій агрегування). Тому у всіх випадках, коли запит може повернути кілька значень, для їх порівняння замість логічних операторів слід використовувати ключове слово IN:

```html
SELECT LastName, FirstName, GroupId
FROM Students
WHERE GroupId IN(SELECT Id FROM Groups WHERE GroupName LIKE '%11');
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Результат виконання поточного запиту на рисунку 25.

![Рисунок 25. Студенти, які навчаються у групах з номером 11](https://fsx1.itstep.org/api/v1/files/csjUZmgAbGE2RPlRIx0OyPtsZRvZsCcD)

Рисунок 25. Студенти, які навчаються у групах з номером 11

### 4.2. Порівняння підзапитів та багатотабличних запитів

Як багатотабличні запити, так і підзапити можна віднести до категорії «складних» запитів. Однак, якщо багатотабличні запити повертають дані, отримані в результаті з'єднання кількох реально існуючих таблиць, то підзапити формують віртуальні значення, які використовуються для порівняння з реально існуючими даними. Підзапити дозволяють забезпечити значну гнучкість при виконанні запитів, тому що їх можна використовувати не тільки в операторі WHERE (що вже було продемонстровано), але і в операторах SELECT, FROM і HAVING.

Як приклад, ми напишемо підзапит, який поверне дані (у вигляді віртуальної таблиці), на підставі яких ми виведемо інформацію основного запиту. Таке використання підзапитів в операторі FROM може бути можливим лише, якщо для результатів виконання підзапиту буде вказано псевдонім з використанням ключового слова AS.

Для того, щоб вам було легше зрозуміти наступний SQL-запит, ми наведемо частину діаграми бази даних University з минулого уроку. (Рисунок 26).

![Рисунок 26. Діаграма бази даних University (частково)](https://fsx1.itstep.org/api/v1/files/7cBr6PqO3lSyEwm4KOCt7Rh0VGrE8Nsh)

Рисунок 26. Діаграма бази даних University (частково)

Припустимо, нам необхідно вивести прізвища викладачів, які читають предмети, по яких студенти отримують відмінні оцінки, для цього виконаємо наступний запит:

```html
SELECT T.LastName, M.SubjectName
FROM Teachers AS T, TeachersSubjects AS TS,
(SELECT S.Id AS SubId, S.NameAS SubjectName
FROM Subjects AS S, Achievements AS A
WHERE S.Id = A.SubjectId
GROUPBY S.Name, S.Id
HAVING MAX(A.Assesment) &gt;= 10)AS M
WHERE T.Id = TS.TeacherId AND TS.SubjectId = M.SubId;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

В даному випадку наш підзапит формує віртуальну таблицю, яка повертає унікальний ідентифікатор та назви предметів, за якими студенти отримують лише відмінні оцінки (MAX(A.Assesment) >= 10). Для цієї таблиці вказано псевдонім (AS M), завдяки чому основний запит може отримувати доступ до значень її стовпців: здійснювати з'єднання (TS.SubjectId = M.SubId) та виводити дані (M.SubjectName). Результат виконання цього запиту представлений на рисунку 27.

![Рисунок 27. Викладачі та предмети, з яких студенти отримують відмінні оцінки](https://fsx1.itstep.org/api/v1/files/svdteVEd9fzVtGhGBpYcPH_oey04qkju)

Рисунок 27. Викладачі та предмети, з яких студенти отримують відмінні оцінки

У наступному SQL-запиті ми продемонструємо можливість використання підзапитів в операторі HAVING. За допомогою цього запиту ми отримаємо список викладачів, середнє значення місяця народження яких більше за середнє значення місяця народження студентів:

```html
SELECT LastName, FirstName
FROM Teachers
GROUP BY LastName, FirstName
HAVING AVG(MONTH(BirthDate)) &gt;
(SELECT AVG(MONTH(BirthDate)) FROM Students);
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

У цьому випадку підзапит повертає середнє значення місяців народження студентів, яке в операторі HAVING порівнюється із середнім значенням місяця народження кожного викладача. Результат виконання цього запиту представлений на рисунку 28.

![Рисунок 28. Використання підзапиту в операторі HAVING](https://fsx1.itstep.org/api/v1/files/fzbcEt0TQfrIYNpPNXZO2uirSYIVMz-9)

Рисунок 28. Використання підзапиту в операторі HAVING

### 4.3. Принцип роботи підзапитів

У разі, якщо в SQL-запиті застосовуються підзапити, то виконання SQL-операторів насамперед відбувається у підзапиті, а уже потім отримані результати використовуються в основному запиті. В одному SQL-запиті може бути кілька підзапитів, при цьому вони можуть бути вкладені один в одного, в цьому випадку виконання починається з підзапиту, який має найглибше вкладення.

Продемонструємо це за допомогою наступного SQL-запиту, який виведе назву груп, студенти яких отримують максимальну стипендію:

```html
SELECT GroupName
FROM Groups
WHERE Id IN(SELECT GroupId
FROM Students
WHERE Grants = (SELECT MAX(Grants) FROM Students));
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

У цьому випадку першим виконається підзапит (SELECT MAX(Grants) FROM Students), який поверне розмір максимальної стипендії. Потім його результати будуть використані в підзапиті (SELECT GroupId FROM Students WHERE Grants = (...)) для визначення унікальних ідентифікаторів груп, отримані результати будуть використовуватися при виконанні основного SQL-запиту (Рисунок 29).

![Рисунок 29. Групи, у яких студенти отримують максимальну стипендію](https://fsx1.itstep.org/api/v1/files/Vmqwc_QEx8jhesmDWgDj2E2P_-t_h_i9)

Рисунок 29. Групи, у яких студенти отримують максимальну стипендію

Слід зазначити, що є ще один вид підзапитів, які називаються пов'язанимичи корельованими підзапитами. Особливістю виконання таких підзапитів є їхня залежність від значень в основному запиті і тому вони не можуть бути оброблені раніше, ніж основний запит, для кращого розуміння принципу їх використання наведемо приклад. Припустимо, нам необхідно вивести максимальну оцінку, отриману студентами з кожного предмета. Таку інформацію можна отримати, написавши SQL-запит і по-іншому, але ми вирішили продемонструвати використання зв'язаного підзапиту в операторі SELECT. Необхідно зауважити, що обов'язковою умовою такого використання є повернення підзапитом одного значення, для цих цілей ідеально підходять функції агрегування:

```html
SELECT Subjects.Name,(SELECT MAX(A.Assesment)
FROM Achievements AS A
WHERE Subjects.Id = A.SubjectId) AS Maximum
FROM Subjects;
```

![](https://materials.itstep.org/img/copy-svgrepo-com.svg)

Виконання поточного зв'язаного підзапиту залежить від порівняння унікального ідентифікатора предмету (Subjects.Id = A.SubjectId), значення якого змінюється в міру рядкового читання записів у таблиці Subjects, тому кількість рядків в отриманій віртуальній таблиці відповідає кількості записів у таблиці Subjects (Рисунок 30).

![Рисунок 30. Максимальні оцінки студентів з кожного предмету](https://fsx1.itstep.org/api/v1/files/9sRQf_TwcXSxIZxsEGNFdTAsYnY8U9Mh)

Рисунок 30. Максимальні оцінки студентів з кожного предмету

1.  Вам необхідно створити багатотабличну базу даних, що містить інформацію про вигаданий фітнес клуб, яка повинна містити такі таблиці: інструктори, секції, відвідувачі тощо.
2.  Використовуючи отримані в цьому уроці знання, написати до створеної бази даних наступні SQL-запити:
    -   вивести кількість інструкторів з кожної секції;
    -   показати кількість людей, які повинні займатися у певний момент часу в кожній секції;
    -   вивести кількість відвідувачів фітнес клубу, які користуються послугами певного мобільного оператора;
    -   отримати кількість відвідувачів, у яких прізвище збігається із прізвищами з певного списку;
    -   показати кількість людей з однаковими іменами, які займаються у певного інструктора;
    -   отримати інформацію про людей, які відвідали фітнесзал мінімальну кількість разів;
    -   вивести кількість відвідувачів, які займалися у певній секції за першу половину поточного року;
    -   визначити загальну кількість людей, які відвідали фітнес-зал за минулий рік.

© STEP IT Academy, [itstep.org](https://itstep.org/)

All the copyrighted photos, audio, and video works, fragments of which are used in the material, are the property of their respective owners. Fragments of the works are used for illustrative purposes to the extent justified by the objective, within the educational process, and for educational purposes, in accordance with the Act of “On Copyright and Related Rights”. The scope and method of the cited works are in accordance with the adopted norms, without prejudice to the normal exploitation of copyright, and do not prejudice the legitimate interests of authors and right holders. At the time of use, the cited works fragments cannot be replaced by alternative, non-copyrighted counterparts and meet the criteria for fair use. All rights reserved. Any reproduction of the materials or its part is prohibited. Use of the works or their fragments must be agreed upon with authors and rights holders. Agreed material use is only possible with reference to the source. Responsibility for unauthorized copying and commercial use of the material is determined by the current legislation.